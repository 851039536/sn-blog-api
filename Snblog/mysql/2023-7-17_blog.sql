-- MySqlBackup.NET 2.3.5
-- Dump Time: 2023-07-17 16:38:35
-- --------------------------------------
-- Server version 8.0.33 MySQL Community Server - GPL


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb3 */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


-- 
-- Definition of article_tag
-- 

DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE IF NOT EXISTS `article_tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标签名称',
  `description` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标签描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table article_tag
-- 

/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
INSERT INTO `article_tag`(`id`,`name`,`description`) VALUES
(1,'windowsApi','0'),
(2,'winfrom','0'),
(3,'dll','dll'),
(4,'文章','文章'),
(5,'axios','axios'),
(6,'刷新','刷新'),
(7,'vuex','vuex'),
(8,'委托','委托'),
(9,'jwt','jwt'),
(30,'mysql',''),
(31,'scroll','scroll'),
(32,'csharp','csharp'),
(33,'process','process'),
(34,'swagger','swagger'),
(35,'异常','异常'),
(36,'工具','工具'),
(37,'语法','语法'),
(38,'wpf','wpf'),
(39,'api','api'),
(40,'跨域','跨域'),
(41,'orm',''),
(42,'依赖注入','依赖注入'),
(43,'插件','插件'),
(44,'语法高亮','语法高亮'),
(45,'登录',''),
(46,'爬虫',''),
(47,'ini','ini'),
(48,'数据映射',''),
(49,'缓存',''),
(50,'部署','');
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;

-- 
-- Definition of article_type
-- 

DROP TABLE IF EXISTS `article_type`;
CREATE TABLE IF NOT EXISTS `article_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '分类名称',
  `description` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin COMMENT '分类描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=109 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table article_type
-- 

/*!40000 ALTER TABLE `article_type` DISABLE KEYS */;
INSERT INTO `article_type`(`id`,`name`,`description`) VALUES
(1,'vue','vue'),
(2,'axios','axios'),
(3,'netcore','netcore'),
(103,'mysql',''),
(104,'csharp',''),
(105,'windows','windows'),
(106,'markdown','markdown'),
(107,'sqlsugar','sqlsugar'),
(108,'工具','');
/*!40000 ALTER TABLE `article_type` ENABLE KEYS */;

-- 
-- Definition of diary_type
-- 

DROP TABLE IF EXISTS `diary_type`;
CREATE TABLE IF NOT EXISTS `diary_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='日记分类';

-- 
-- Dumping data for table diary_type
-- 

/*!40000 ALTER TABLE `diary_type` DISABLE KEYS */;
INSERT INTO `diary_type`(`id`,`name`) VALUES
(4,'舔狗日记'),
(5,'毒鸡汤');
/*!40000 ALTER TABLE `diary_type` ENABLE KEYS */;

-- 
-- Definition of interface_type
-- 

DROP TABLE IF EXISTS `interface_type`;
CREATE TABLE IF NOT EXISTS `interface_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table interface_type
-- 

/*!40000 ALTER TABLE `interface_type` DISABLE KEYS */;
INSERT INTO `interface_type`(`id`,`name`) VALUES
(1,'header'),
(2,'sidebar');
/*!40000 ALTER TABLE `interface_type` ENABLE KEYS */;

-- 
-- Definition of interface
-- 

DROP TABLE IF EXISTS `interface`;
CREATE TABLE IF NOT EXISTS `interface` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `path` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '路径',
  `type_id` int NOT NULL COMMENT '类别',
  `user_id` int NOT NULL COMMENT '用户',
  `identity` tinyint(1) NOT NULL COMMENT '显示隐藏',
  PRIMARY KEY (`id`),
  KEY `type_id` (`type_id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `interface_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`),
  CONSTRAINT `type` FOREIGN KEY (`type_id`) REFERENCES `interface_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=136 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table interface
-- 

/*!40000 ALTER TABLE `interface` DISABLE KEYS */;
INSERT INTO `interface`(`id`,`name`,`path`,`type_id`,`user_id`,`identity`) VALUES
(1,'主页','/article/column',2,4,1),
(2,'博客','/qarticle',2,4,1),
(9,'日记','/diary',2,4,1),
(10,'哔哔视频','/video',2,4,1),
(11,'网站导航','/favorite',2,4,1),
(12,'博客导航','/BlogCircles',2,4,1),
(13,'我的书单','/book',2,4,1),
(14,'聚合搜索','/ListContent',2,4,1),
(17,'图册','/Photo',1,4,1),
(18,'代码块','code',1,4,0),
(19,'后台管理','/Login',2,4,1),
(128,'博客导航','/BlogCircles',2,1,1),
(131,'网站导航','/favorite',2,1,1),
(134,'博客','/qarticle',2,1,1),
(135,'主页','/article/column',2,1,1);
/*!40000 ALTER TABLE `interface` ENABLE KEYS */;

-- 
-- Definition of sn_comments
-- 

DROP TABLE IF EXISTS `sn_comments`;
CREATE TABLE IF NOT EXISTS `sn_comments` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '评论主键',
  `user_id` int NOT NULL COMMENT '用户id',
  `give` int NOT NULL COMMENT '点赞数',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `time_create` datetime NOT NULL COMMENT '评论日期',
  `time_modified` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_comments
-- 

/*!40000 ALTER TABLE `sn_comments` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_comments` ENABLE KEYS */;

-- 
-- Definition of sn_navigation_type
-- 

DROP TABLE IF EXISTS `sn_navigation_type`;
CREATE TABLE IF NOT EXISTS `sn_navigation_type` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_navigation_type
-- 

/*!40000 ALTER TABLE `sn_navigation_type` DISABLE KEYS */;
INSERT INTO `sn_navigation_type`(`id`,`title`) VALUES
(1,'npm'),
(2,'网站'),
(3,'vue'),
(4,'net'),
(5,'JavaScript'),
(7,'收藏'),
(8,'博客圈'),
(9,'css'),
(10,'论坛'),
(11,'导航'),
(13,'文档'),
(14,'工具'),
(15,'学习'),
(16,'mysql'),
(17,'在线刷题'),
(18,'图库'),
(19,'前端框架'),
(20,'markdown'),
(21,'uniapp'),
(22,'efcore'),
(23,'docker'),
(24,'vue组件库'),
(26,'vite'),
(27,'常用工具'),
(28,'wpf'),
(29,'orm'),
(30,'cdn');
/*!40000 ALTER TABLE `sn_navigation_type` ENABLE KEYS */;

-- 
-- Definition of sn_picture_type
-- 

DROP TABLE IF EXISTS `sn_picture_type`;
CREATE TABLE IF NOT EXISTS `sn_picture_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_picture_type
-- 

/*!40000 ALTER TABLE `sn_picture_type` DISABLE KEYS */;
INSERT INTO `sn_picture_type`(`id`,`name`) VALUES
(1,'article'),
(2,'User'),
(3,'Video');
/*!40000 ALTER TABLE `sn_picture_type` ENABLE KEYS */;

-- 
-- Definition of sn_picture
-- 

DROP TABLE IF EXISTS `sn_picture`;
CREATE TABLE IF NOT EXISTS `sn_picture` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图床名',
  `img_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片地址',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `prcture_type_id` (`type_id`),
  KEY `pivture_user_id` (`user_id`),
  CONSTRAINT `pivture_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`),
  CONSTRAINT `prcture_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_picture_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_picture
-- 

/*!40000 ALTER TABLE `sn_picture` DISABLE KEYS */;
INSERT INTO `sn_picture`(`id`,`name`,`img_url`,`type_id`,`user_id`) VALUES
(2,'blog','/img/blog/1.jpg',1,4),
(3,'blog','/img/blog/2.jpg',1,4),
(4,'blog','/img/blog/3.jpg',1,4),
(6,'blog','/img/blog/4.jpg',1,4),
(7,'blog','/img/blog/5.jpg',1,4);
/*!40000 ALTER TABLE `sn_picture` ENABLE KEYS */;

-- 
-- Definition of sn_setblog_type
-- 

DROP TABLE IF EXISTS `sn_setblog_type`;
CREATE TABLE IF NOT EXISTS `sn_setblog_type` (
  `id` int NOT NULL,
  `name` varchar(50) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_setblog_type
-- 

/*!40000 ALTER TABLE `sn_setblog_type` DISABLE KEYS */;
INSERT INTO `sn_setblog_type`(`id`,`name`) VALUES
(0,'后台设置'),
(1,'主页设置');
/*!40000 ALTER TABLE `sn_setblog_type` ENABLE KEYS */;

-- 
-- Definition of sn_software_type
-- 

DROP TABLE IF EXISTS `sn_software_type`;
CREATE TABLE IF NOT EXISTS `sn_software_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_software_type
-- 

/*!40000 ALTER TABLE `sn_software_type` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_software_type` ENABLE KEYS */;

-- 
-- Definition of sn_software
-- 

DROP TABLE IF EXISTS `sn_software`;
CREATE TABLE IF NOT EXISTS `sn_software` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '标题',
  `img` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '图片路径',
  `type_id` int DEFAULT NULL COMMENT '分类',
  `comment_id` int DEFAULT NULL COMMENT '评论',
  `time_create` datetime DEFAULT NULL COMMENT '时间',
  `time_modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `software_type_id` (`type_id`),
  CONSTRAINT `software_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_software_type` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_software
-- 

/*!40000 ALTER TABLE `sn_software` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_software` ENABLE KEYS */;

-- 
-- Definition of sn_talk_type
-- 

DROP TABLE IF EXISTS `sn_talk_type`;
CREATE TABLE IF NOT EXISTS `sn_talk_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_talk_type
-- 

/*!40000 ALTER TABLE `sn_talk_type` DISABLE KEYS */;
INSERT INTO `sn_talk_type`(`id`,`name`) VALUES
(3,'版本更新'),
(4,'测试'),
(5,'生活');
/*!40000 ALTER TABLE `sn_talk_type` ENABLE KEYS */;

-- 
-- Definition of sn_talk
-- 

DROP TABLE IF EXISTS `sn_talk`;
CREATE TABLE IF NOT EXISTS `sn_talk` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `describe` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '简介',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `read` int NOT NULL COMMENT '阅读量',
  `give` int NOT NULL COMMENT '点赞',
  `comment_id` int NOT NULL COMMENT '评论',
  `user_id` int NOT NULL COMMENT '用户',
  `type_id` int NOT NULL,
  `time_create` datetime NOT NULL COMMENT '发表时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `sn_talk_typeId` (`type_id`),
  CONSTRAINT `lalk_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`),
  CONSTRAINT `talk_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_talk_type` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_talk
-- 

/*!40000 ALTER TABLE `sn_talk` DISABLE KEYS */;
INSERT INTO `sn_talk`(`id`,`title`,`describe`,`text`,`read`,`give`,`comment_id`,`user_id`,`type_id`,`time_create`,`time_modified`) VALUES
(3,'Blog-12.18更新','favorite,博客页面样式更新样式更新,内容页面,时间线页面动态加载组件数据提示框更新为骨架框','<h3>1.样式更新</h3><p><span style=\"color: rgb(68, 68, 68);\">favorite</span>,<span style=\"color: rgb(68, 68, 68);\">博客页面样式更新样式更新</span></p><h3>2.内容页改动</h3><p><span style=\"color: rgb(68, 68, 68);\">内容页面,时间线页面动态加载组件数据提示框更新为骨架框</span></p><h3>3.时间线改动</h3><p><span style=\"color: rgb(68, 68, 68);\">增加one日记动态数据时间线增加跳转到页面详情</span></p>',0,0,0,4,3,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(17,'Blog-12.21更新','','<h3>1.增加页面</h3><p>增加日志详情页面-TalkText.vue, OneSidebar.vue 文章侧边栏界面</p><h3>2.Talk页面改动</h3><p>增加页面跳转至TalkText.vue</p><p>About关于界面增加功能跳转</p><p>One文章页面增加 OneSidebar文章侧边栏</p>',0,0,0,4,3,'2020-12-21 00:00:00','2020-12-18 00:00:00'),
(18,'Blog-12.23更新','优化了Indexs,Talk及侧边栏等页面字体样式及抗齿轮,one页面增加点击弹出详情框及更新了css样式','<h3>1.页面优化</h3><ul><li>优化了Indexs,Talk及侧边栏等页面字体样式及抗齿轮</li><li>one页面增加点击弹出详情框及更新了css样式</li><li>OneSidebar侧边栏时间字段格式优化,增加点击弹出详情页</li><li>Snvodeo视频页面及详情页增加时间字段格式优化</li><li>TalkTest页面头部组件更新</li><li>TimeLine时间组件动态字段更新增加(分类,标签,文章,阅读,字段数)</li><li>Sidebarsn css样式更新</li><li>IndexSidebar 站点信息增加动态更新</li></ul><h3>2.新增</h3><ul><li>增加nprogress顶部加载组件</li><li>增加store状态管理</li><li>增加Transfer文章中转站页面</li></ul><p><br></p><h3>3.页面重构</h3><ul><li>app页面js更改为ts方式重写</li></ul><h3>4.其他优化</h3><ul><li>修复Indextext2页面跳转当前页面不刷新</li><li>封装了内容详情(blogs)css样式</li><li>增加视频图片</li></ul>',0,0,0,4,3,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(19,'Blog-12.25更新','','<h3>1.页面改动</h3><p>app.vue 删除背景颜色设定</p><p>com.scss 封装line-ome index.css</p><p>增加响应式设定</p><p>导航页面css调整</p><p>收藏页面增加动态数据分类框(之前是静态)</p><p>one侧边栏动态增加字段,文章数量,阅读显示</p><p>删除日志Talk页面顶部信息框,删除侧边栏图标框 Headers.vue 样式调整</p><h3>2.新增内容</h3><p>增加新字体 font.css并应用页面</p><p>增加响应式断点主页面已完成响应式设定</p><p>新增字体文件 新增移动端状态下显示底部导航框bootom</p>',0,0,0,4,3,'2020-12-25 00:00:00','2020-12-18 00:00:00'),
(20,'展望','','<p>是佛挡杀佛的范德萨发</p>',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00'),
(21,'青春真的结束了吗','','',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00'),
(22,'Blog正式投入使用','','<p>经过接近一个月时间的项目重构(vue2--&gt;vue3+ts),主要部分功能已经完善。</p><p><strong>以下已完成功能</strong></p><p>主页技术方面的文章阅读</p><p>标签页面方面查找对应的文章进行阅读</p><p>时间线</p><p>导航站</p><p>日志-&gt;只做个人文章展示</p><p><strong>娱乐项</strong></p><p>短文仅供一乐(舔狗日志)</p><p>收藏,博客页面分享各路大神技术博客</p><p><strong>待进行功能</strong></p><p>书单--准备进行</p><p>后台-- 后台系统大部分功能已近完善,基本可以投入生产,但是还有很多细节方面没弄好暂不上线</p><p>留言-- 前端已完成,后台api已完成待导入接口</p><p><strong>待优化功能项</strong></p><p>额!!!!!!! 好像都需要优化</p><p>后续增加一个新页面来追踪自己要做什么,做到什么进度。就叫个人项目进度追踪应该也算是新功能了</p><p><strong>项目架构</strong></p><p>前端项目使用到的技术</p><p><span style=\"color: rgb(136, 136, 136);\">VUE3 -- TS -- Router -- Axios -- Store -- AntDesignVue -- TaiwindCss -- animate.css -- marked</span></p><p>后端项目</p><p>NetCore3.1webApi</p><p><strong>本次更新</strong></p><p>1.增加导航侧边栏 FavSidebar.vue</p><p>2.增加书单页面 Book.vue</p><p>3.增加图片视频展示</p><p>4.删除字体(太大了)</p><p>5.Talk.vue 页面进行重构(想好看点)</p><p><br></p>',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00');
/*!40000 ALTER TABLE `sn_talk` ENABLE KEYS */;

-- 
-- Definition of sn_user_friends
-- 

DROP TABLE IF EXISTS `sn_user_friends`;
CREATE TABLE IF NOT EXISTS `sn_user_friends` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL COMMENT '用户id',
  `user_friends_id` int DEFAULT NULL COMMENT '好友id',
  `user_note` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '好友备注',
  `user_status` varchar(20) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '好友状态',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_user_friends
-- 

/*!40000 ALTER TABLE `sn_user_friends` DISABLE KEYS */;
INSERT INTO `sn_user_friends`(`id`,`user_id`,`user_friends_id`,`user_note`,`user_status`) VALUES
(1,1,2,'小张','在线');
/*!40000 ALTER TABLE `sn_user_friends` ENABLE KEYS */;

-- 
-- Definition of sn_video_type
-- 

DROP TABLE IF EXISTS `sn_video_type`;
CREATE TABLE IF NOT EXISTS `sn_video_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_video_type
-- 

/*!40000 ALTER TABLE `sn_video_type` DISABLE KEYS */;
INSERT INTO `sn_video_type`(`id`,`name`) VALUES
(1,'火影'),
(2,'LOL');
/*!40000 ALTER TABLE `sn_video_type` ENABLE KEYS */;

-- 
-- Definition of snippet_label
-- 

DROP TABLE IF EXISTS `snippet_label`;
CREATE TABLE IF NOT EXISTS `snippet_label` (
  `id` int NOT NULL,
  `name` varchar(30) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table snippet_label
-- 

/*!40000 ALTER TABLE `snippet_label` DISABLE KEYS */;
INSERT INTO `snippet_label`(`id`,`name`) VALUES
(22,'KeepAlive'),
(19,'Map'),
(27,'Props'),
(23,'Teleport'),
(5,'code'),
(4,'component'),
(6,'scroll'),
(3,'slot'),
(2,'transition'),
(24,'事件'),
(25,'侦听器'),
(11,'判断'),
(26,'动态绑定'),
(10,'字符串'),
(14,'对象'),
(12,'循环'),
(7,'数组'),
(15,'整数'),
(13,'方法'),
(9,'日期处理'),
(20,'模块化'),
(1,'测试'),
(17,'浏览器'),
(21,'组件'),
(8,'运算符'),
(18,'集合'),
(16,'颜色');
/*!40000 ALTER TABLE `snippet_label` ENABLE KEYS */;

-- 
-- Definition of snippet_tag
-- 

DROP TABLE IF EXISTS `snippet_tag`;
CREATE TABLE IF NOT EXISTS `snippet_tag` (
  `id` int NOT NULL,
  `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table snippet_tag
-- 

/*!40000 ALTER TABLE `snippet_tag` DISABLE KEYS */;
INSERT INTO `snippet_tag`(`id`,`name`) VALUES
(1,'插件'),
(2,'基础教程'),
(3,'语法片段'),
(4,'异常解决'),
(6,'编码规范'),
(7,'指令'),
(8,'命名规范');
/*!40000 ALTER TABLE `snippet_tag` ENABLE KEYS */;

-- 
-- Definition of snippet_type
-- 

DROP TABLE IF EXISTS `snippet_type`;
CREATE TABLE IF NOT EXISTS `snippet_type` (
  `id` int NOT NULL,
  `name` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table snippet_type
-- 

/*!40000 ALTER TABLE `snippet_type` DISABLE KEYS */;
INSERT INTO `snippet_type`(`id`,`name`) VALUES
(1,'csharp'),
(2,'vue'),
(3,'axios'),
(5,'typescript'),
(6,'javascript'),
(8,'css'),
(9,'vite'),
(10,'scss'),
(11,'eslint'),
(12,'mysql'),
(13,'vscode'),
(14,'windicss'),
(15,'vue-router'),
(16,'ES6');
/*!40000 ALTER TABLE `snippet_type` ENABLE KEYS */;

-- 
-- Definition of user
-- 

DROP TABLE IF EXISTS `user`;
CREATE TABLE IF NOT EXISTS `user` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `ip` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT 'ip地址',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '账号',
  `email` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '邮箱',
  `pwd` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '密码',
  `photo` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '头像',
  `time_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `time_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '称呼',
  `brief` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '简介',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table user
-- 

/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user`(`id`,`ip`,`name`,`email`,`pwd`,`photo`,`nickname`,`brief`) VALUES
(1,'ip','1','81929392@qq.con','1','','测试号','哈哈'),
(4,'ip','kai','851039536@qq.com','woshishui','..','少年','人生有梦,各自精彩'),
(18,'1','12312','23213','213','131232','3213','213123');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;

-- 
-- Definition of article
-- 

DROP TABLE IF EXISTS `article`;
CREATE TABLE IF NOT EXISTS `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题 ',
  `sketch` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容简述',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '博客内容',
  `read` smallint NOT NULL COMMENT '阅读次数',
  `give` smallint NOT NULL COMMENT '点赞',
  `img` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `comment_id` smallint NOT NULL COMMENT '评论',
  `tag_id` int NOT NULL COMMENT '标签外键',
  `type_id` int NOT NULL COMMENT '分类外键',
  `user_id` int NOT NULL COMMENT '用户外键id',
  `time_create` datetime NOT NULL COMMENT '发表时间',
  `time_modified` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`),
  KEY `user_id` (`user_id`),
  KEY `article_labelsId` (`tag_id`),
  KEY `article_sortId` (`type_id`),
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `article_tag` (`id`),
  CONSTRAINT `tyoeId` FOREIGN KEY (`type_id`) REFERENCES `article_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `userId` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=437 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table article
-- 

/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article`(`id`,`name`,`sketch`,`text`,`read`,`give`,`img`,`comment_id`,`tag_id`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(368,'c#使用mysql进行备份还原','数据备份是数据安全的最后一道防线，对于任何数据丢失的场景，备份虽然不一定能恢复百分之百的数据(取决于备份周期)，但至少能将损失降到最低。','> 数据备份是数据安全的最后一道防线，对于任何数据丢失的场景，备份虽然不一定能恢复百分之百的数据(取决于备份周期)，但至少能将损失降到最低。\n\n###  引用dll\n\n使用nuget安装dll程序包\n\n```\nnuget > MySql.Data.dll\nnuget > MySqlbackup.dll\n```\n\n\n\n### 连接静态类\n\n新建一个连接字符串静态类\n\n```csharp\npublic static class mysql\n{\npublic static string constr = \"database=test;Password=密码;user ID=root;server=ip地址\";\npublic static MySqlConnection conn = new MySqlConnection(constr);\n}\n```\n\n\n\n### 数据备份\n\n```csharp\nDialogResult result = MessageBox.Show(\"备份路径默认在当前程序下\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Question);\nif(result == DialogResult.Yes)\n{\n    string time1 = System.DateTime.Now.ToString(\"d\").Replace(\"/\", \"-\");\n    string file = \".//mysql/\" + time1 + \"_test.sql\";\n    using(MySqlCommand cmd = new MySqlCommand())\n    {\n        using(MySqlBackup mb = new MySqlBackup(cmd))\n        {\n            cmd.Connection = mysql.conn;\n            mysql.conn.Open();\n            mb.ExportToFile(file);\n            mysql.conn.Close();\n            MessageBox.Show(\"已备份\");\n        }\n    }\n}\n```\n\n### 备份还原\n\n```csharp\nstring file = textBox1.Text;\nif(file == \"\")\n{\n    MessageBox.Show(\"不能为空\");\n    return;\n}\nDialogResult result = MessageBox.Show(\"确定还原吗？\", \"还原\", MessageBoxButtons.YesNo, MessageBoxIcon.Question);\nif(result == DialogResult.Yes)\n{\n    try\n    {\n        using(MySqlCommand cmd = new MySqlCommand())\n        {\n            using(MySqlBackup mb = new MySqlBackup(cmd))\n            {\n                cmd.Connection = mysql.conn;\n                mysql.conn.Open();\n                mb.ImportFromFile(file);\n                mysql.conn.Close();\n                MessageBox.Show(\"已还原\");\n            }\n        }\n    }\n    catch(Exception ex)\n    {\n        MessageBox.Show(ex.Message);\n    }\n}\n```\n\n### 定时备份\n\n```csharp\n//winform\ntimer1.Interval = 1000; //代表一秒运行一次\ntimer1.Enabled = true; //启动\n```\n\n利用winform窗体 timer定时器控件\n\n```csharp\nprivate void timer1_Tick(object sender, EventArgs e)\n{\n    if(booql)\n    {\n        booql = false;\n        if(DateTime.Now.Hour == 10 && DateTime.Now.Minute == 00) //时间10点 \n        {\n            string time1 = System.DateTime.Now.ToString(\"d\").Replace(\"/\", \"-\");\n            string file = \".//mysql/\" + time1 + \"_test.sql\";\n            using(MySqlCommand cmd = new MySqlCommand())\n            {\n                using(MySqlBackup mb = new MySqlBackup(cmd))\n                {\n                    cmd.Connection = mysql.conn;\n                    mysql.conn.Open();\n                    mb.ExportToFile(file);\n                    mysql.conn.Close();\n                    MessageBox.Show(\"数据库已自动备份本地\");\n                }\n            }\n        }\n    }\n}\n```\n',91,0,'blog/2.jpg',0,30,104,4,'2022-12-07 16:09:17','2022-12-07 16:09:17'),
(369,'c#中使用ShellExecute','WinApi 中 ShellExecute 的功能是运行一个外部程序（或者是打开一个已注册的文件、打开一个目录、打印一个文件等等），并对外部程序有一定的控制','API手册：http://www.office-cn.net/t/api/api_content.htm\n\nWinApi 中 ShellExecute 的功能是运行一个外部程序（或者是打开一个已注册的文件、打开一个目录、打印一个文件等等），并对外部程序有一定的控制。函数如下：\n\n若ShellExecute函数调用成功，则返回值为被执行程序的实例句柄。若返回值小于32，则表示出现错误。\n\n### API\n\n```csharp\n /// <summary>\n /// ShellExecute\n /// </summary>\n /// <param name=\"hwnd\">指定父窗口句柄:ntPtr.Zero</param>\n /// <param name=\"lpszOp\">指定要进行的操作:Open</param>\n /// <param name=\"lpszFile\">指定要打开的文件名|路径</param>\n /// <param name=\"lpszParams\">指定命令行参数: 0 | \"\"</param>\n /// <param name=\"lpszDir\">用于指定默认目录:0 | \"\"</param>\n /// <param name=\"FsShowCmd\">显示模式: 0:隐藏 1~11</param>\n /// <returns></returns>\n [DllImport(\"shell32.dll\")]\n private static extern int ShellExecute(IntPtr hwnd, StringBuilder lpszOp, StringBuilder lpszFile, StringBuilder lpszParams, StringBuilder lpszDir, int FsShowCmd);\n```\n\n### 函数使用\n\n```csharp\n /// <summary>\n /// 打开程序/文件夹\n /// </summary>\n /// <param name=\"path\">路径</param>\n /// <param name=\"FsShow\">显示模式 默认1</param>\n public static void OpenFile(string path, int FsShow = 1)\n {\n     ShellExecute(IntPtr.Zero, new StringBuilder(\"Open\"), new StringBuilder(@path), new StringBuilder(\"\"), new StringBuilder(\"\"), FsShow);\n }\n```\n\n',69,0,'blog/10.jpg',0,1,104,4,'2022-12-08 13:51:05','2022-12-15 15:18:14'),
(370,'dataGridView读写文本','DataGridView控件是数据表格控件，属于很常用的控件。','DataGridView控件是数据表格控件，属于很常用的控件。\n\nDataGridView 控件具有极高的可配置性和可扩展性，它提供有大量的属性、方法和事件，可以用来对该控件的外观和行为进行自定义。当需要在 Windows 窗体应用程序中显示表格数据时，请首先考虑使用 DataGridView 控件，然后再考虑使用其他控件（例如 DataGrid）。\n\n\n### 读取文本\n\n```csharp\nconstant con = new constant();\nprivate void GetGrView()\n{\n  dataGridView1.ColumnCount = 1;\n  string z;\n  if(File.Exists(\".//allitems.txt\"))\n  {\n    FileStream fs = new FileStream(\".//allitems.txt\", System.IO.FileMode.Open, System.IO.FileAccess.Read);\n    StreamReader sr = new StreamReader(fs, System.Text.Encoding.GetEncoding(\"utf-8\"));\n    try\n    {\n      while(true)\n      {\n        z = sr.ReadLine();\n        if(z == null) break;\n        dataGridView1.Rows.Add(z);\n      }\n    }\n    finally\n    {\n      sr.Close();\n      fs.Dispose();\n      fs.Close();\n    }\n  }\n}\n```\n\n### 写入文本\n\n```csharp\nstring st = \"\";\n//写入\nprivate void WriteGrView()\n{\n  if(File.Exists(\".//allitems.txt\"))\n  {\n    FileStream fs = new FileStream(\".//allitems.txt\", System.IO.FileMode.Open, System.IO.FileAccess.Write);\n    StreamWriter sr = new StreamWriter(fs, System.Text.Encoding.GetEncoding(\"utf-8\"));\n    try\n    {\n      for(int i = 0; i < 22; i++)\n      {\n        for(int j = 0; j < 1; j++)\n        {\n          st = st + dataGridView1.Rows[i].Cells[j].Value;\n        }\n        sr.WriteLine(st);\n        st = \"\";\n      }\n    }\n    finally\n    {\n      sr.Close();\n      fs.Dispose();\n      fs.Close();\n    }\n  }\n}\n```\n\n',28,0,'blog/1.jpg',0,2,104,4,'2022-12-08 14:54:09','2022-12-15 15:25:59'),
(371,'c#中读取文件目录下的文件信息','应用程序可能只允许用户选择文佳夹而非文件，，在添加时，只要选择添加这个文佳夹，就是只选择了文佳夹，而不是文件，这就要用到FloderBrowertDIalog控件对话框','应用程序可能只允许用户选择文佳夹而非文件，在添加时，只要选择添加这个文佳夹，就是只选择了文佳夹，而不是文件，这就要用到FloderBrowertDIalog控件对话框\n\n**FolderBrowserDialog对话框的常用属性**\n\nDescription　在对话框中提供描述性的消息\n\nRootFloder  指定对话框开始浏览的根文件夹\n\nSelectedPath  指定用户所选的文件夹\n\nShowNewFloderButton  指定新建文件夹按钮是否显示在对话框中\n\n```csharp\nprivate void button1_Click(object sender, System.EventArgs e) \n{\n	//浏览文件夹\n	this.folderBrowserDialog1.ShowDialog();\n	if(this.folderBrowserDialog1.SelectedPath.Trim()!=\"\")\n	this.textBox1.Text=this.folderBrowserDialog1.SelectedPath.Trim();\n}\nprivate void button2_Click(object sender, System.EventArgs e) \n{\n	//显示指定文件夹下的文件\n	if(this.textBox1.Text.Trim()==\"\")\n	return;\n	this.listBox1.Items.Clear();\n	string[] MyFiles=System.IO.Directory.GetFiles(this.textBox1.Text);\n	this.listBox1.Items.AddRange(MyFiles);\n}\n```\n\n',32,0,'blog/1.jpg',0,2,104,4,'2022-12-08 16:44:19','2022-12-15 15:37:49'),
(372,'winfrom导出CSV数据','.csv是一种逗号分隔值文件格式，其文件以纯文本形式存储表格数据（数字和文本）','.csv是一种逗号分隔值文件格式，其文件以纯文本形式存储表格数据（数字和文本）。CSV文件由任意数目的记录组成，记录间以某种换行符分隔；每条记录由字段组成，字段间的分隔符是其它字符或字符串，最常见的是逗号或制表符。通常，所有记录都有完全相同的字段序列。通常都是纯文本文件。\n\n### 数据导出\n\n```csharp\n/// <summary>\n/// 数据导出\n/// </summary>\n/// <param name=\"dataGridView\"></param>\n/// <returns></returns>\nprivate bool dataGridViewToCSV(DataGridView dataGridView)\n{\n    if(dataGridView.Rows.Count == 0)\n    {\n        MessageBox.Show(\"没有数据可导出!\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Information);\n        return false;\n    }\n    SaveFileDialog saveFileDialog = new SaveFileDialog();\n    saveFileDialog.Filter = \"CSV files (*.csv)|*.csv\";\n    saveFileDialog.FilterIndex = 0;\n    saveFileDialog.RestoreDirectory = true;\n    saveFileDialog.CreatePrompt = true;\n    saveFileDialog.FileName = null;\n    saveFileDialog.Title = \"保存\";\n    DateTime now = DateTime.Now;\n    saveFileDialog.FileName = now.Year.ToString().PadLeft(2) + now.Month.ToString().PadLeft(2, ''0'') + now.Day.ToString().PadLeft(2, ''0'') + \"-\" + now.Hour.ToString().PadLeft(2, ''0'') + now.Minute.ToString().PadLeft(2, ''0'') + now.Second.ToString().PadLeft(2, ''0'');\n    if(saveFileDialog.ShowDialog() == DialogResult.OK)\n    {\n        Stream stream = saveFileDialog.OpenFile();\n        StreamWriter sw = new StreamWriter(stream, System.Text.Encoding.GetEncoding(-0));\n        string strLine = \"\";\n        try\n        {\n            //表头\n            for(int i = 0; i < dataGridView.ColumnCount; i++)\n            {\n                if(i > 0) strLine += \",\";\n                strLine += dataGridView.Columns[i].HeaderText;\n            }\n            strLine.Remove(strLine.Length - 1);\n            sw.WriteLine(strLine);\n            strLine = \"\";\n            //表的内容\n            for(int j = 0; j < dataGridView.Rows.Count; j++)\n            {\n                strLine = \"\";\n                int colCount = dataGridView.Columns.Count;\n                for(int k = 0; k < colCount; k++)\n                {\n                    if(k > 0 && k < colCount) strLine += \",\";\n                    if(dataGridView.Rows[j].Cells[k].Value == null) strLine += \"\";\n                    else\n                    {\n                        string cell = dataGridView.Rows[j].Cells[k].Value.ToString().Trim();\n                        //防止里面含有特殊符号\n                        cell = cell.Replace(\"\\\"\", \"\\\"\\\"\");\n                        cell = \"\\\"\" + cell + \"\\\"\";\n                        strLine += cell;\n                    }\n                }\n                sw.WriteLine(strLine);\n            }\n            sw.Close();\n            stream.Close();\n            MessageBox.Show(\"数据被导出到：\" + saveFileDialog.FileName.ToString(), \"导出完毕\", MessageBoxButtons.OK, MessageBoxIcon.Information);\n        }\n        catch(Exception ex)\n        {\n            MessageBox.Show(ex.Message, \"导出错误\", MessageBoxButtons.OK, MessageBoxIcon.Information);\n            return false;\n        }\n    }\n    return true;\n}\n```',8,0,'blog/4.jpg',0,2,104,4,'2022-12-15 15:56:00','2022-12-15 15:56:00'),
(373,'c#使用NAudio录音','NAudio功能强大，且其入门容易。\n强大在于：它支持许多音频操作，可实现多种API播放与录制、多种不同音频格式、音频格式转换（重采样、位深、声道等）、音频编码、多通道播放、音频效果处理等等（详细介绍可以看Github readme）。','在网上找了很多类似录音教程效果都不好，或根本不能录音，代码由网上借鉴修改（完整实现录音播放功能）\n\n### NAudio\n\nNAudio为.NET平台下的开源库，采用ML-PL协议，开源地址：https://github.com/naudio/NAudio。\n\nNAudio功能强大，且其入门容易。\n强大在于：它支持许多音频操作，可实现多种API播放与录制、多种不同音频格式、音频格式转换（重采样、位深、声道等）、音频编码、多通道播放、音频效果处理等等（详细介绍可以看Github readme）。\n\n###  新建RecordController\n\nRecordController.cs\n\n```js\npublic class RecordController\n{\n    public WaveIn mWavIn;\n    public WaveFileWriter mWavWriter;\n    /// <summary>\n    /// 开始录音\n    /// </summary>\n    /// <param name=\"filePath\"></param>\n    public void StartRecord(string filePath)\n        {\n            mWavIn = new WaveIn();\n            mWavIn.DataAvailable += MWavIn_DataAvailable;\n            // mWavIn.RecordingStopped += MWavIn_RecordingStopped; 有冲突\n            mWavWriter = new WaveFileWriter(filePath, mWavIn.WaveFormat);\n            mWavIn.StartRecording();\n        }\n        /// <summary>\n        /// 停止录音\n        /// </summary>\n    public void StopRecord()\n        {\n            mWavIn ? .StopRecording();\n            mWavIn ? .Dispose();\n            mWavIn = null;\n            mWavWriter ? .Close();\n            mWavWriter = null;\n        }\n        //这个方法在调用关闭时会有冲突\n    private void MWavIn_RecordingStopped(object sender, StoppedEventArgs e)\n    {\n        //mWavIn?.Dispose();\n        //mWavIn = null;\n        //mWavWriter?.Close();\n        //mWavWriter = null;\n    }\n    private void MWavIn_DataAvailable(object sender, WaveInEventArgs e)\n    {\n        mWavWriter.Write(e.Buffer, 0, e.BytesRecorded);\n        int secondsRecorded = (int) mWavWriter.Length / mWavWriter.WaveFormat.AverageBytesPerSecond;\n    }\n}\n```\n\n### 方法调用\n\nRecordController record = new RecordController();\n\n```js\n/// <summary>\n/// 耳机sidetone测试\n/// </summary>\n/// <param name=\"i\"></param>\npublic void Sidetone(int i)\n{\n    string[] row = getlistviewitem(i);\n    record.StartRecord(\"e:\\rec.wav\");\n    if(MessageBox.Show(\"正在录音，点击是播放录音\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.No)\n    {\n        record.StopRecord();\n        ErrorFlag = false;\n        row[6] = \"FAIL\";\n    }\n    else\n    {\n        record.StopRecord();\n        string path = \"e:\\rec.wav\";\n        //.wav音频文件路径\n        System.Media.SoundPlayer player = new System.Media.SoundPlayer(path);\n        player.Play();\n        if(MessageBox.Show(\"是否有录音\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.No)\n        {\n            ErrorFlag = false;\n            row[6] = \"FAIL\";\n        }\n        else\n        {\n            ErrorFlag = true;\n            row[5] = \"OK\";\n            row[6] = \"PASS\";\n        }\n    }\n    listupdate(row, i);\n}\n```\n\n',8,0,'blog/3.jpg',0,3,104,4,'2022-12-15 16:05:02','2022-12-15 16:05:02'),
(374,'c#使用SoundPlayer','System.Media名称空间下的类`SoundPlayer` 可以让我们很方便的播放wav波形声音文件。`SoundPlayer`类其实就是对winmm.dll文件中API函数的封装。','System.Media名称空间下的类`SoundPlayer` 可以让我们很方便的播放wav波形声音文件。`SoundPlayer`类其实就是对winmm.dll文件中API函数的封装。\n\n### SoundPlayer\n\n`SoundPlayer`类的使用很简单。如下：\n\n```csharp\nSoundPlayer player = new SoundPlayer();\nplayer.SoundLocation = \"音乐文件名\";\nplayer.Load();\nplayer.Play();\n```\n\n其中Play方法是异步方法，会在另一个线程中播放。如果我们有时候需要等声音播放完毕之后再进行下一步操作。即声音播放需要阻塞当前线程。就可以使用PlaySync()\n\n- SoundPlayer类的缺点：只能播放wav文件；在winxp下播放文件比较大或位率比较高的情况，PlaySync同步播放会有播放不完全的问题。\n\n- 这个问题的产生是由于winmm.dll的版本问题引起的。在xp下winmm.dll的版本是5。在win7下是6。win7下就没有问题。如果要解决在\n\n- xp下播放不完全的问题。可以使用xp下的录音机打开声音文件，把声音文件另存为7kbit/s的位率格式，但这样声音效果就很差了。\n\n### 方法调用\n\n引用System.Media名称空间下的类SoundPlayer \n\n```js\nSoundPlayer player = new SoundPlayer();\n\npublic void Play()\n{\n    player.SoundLocation = @\".x0pbk-swz4q.wav\";\n    //读取音频文件\n    player.Load(); //同步模式\n    player.Play();\n    if(MessageBox.Show(\"播放音樂中，通过旋转耳机上的旋钮测试音量,若聲音播放正常则选是，反之否\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.No)\n    {\n        DisplaylistboxMSG(\"Headset測試結果為異常\");\n    }\n    else\n    {\n        DisplaylistboxMSG(\"Headset測試結果為正常\");\n    }\n    player.Stop();\n    //停止播放\n    player.Dispose();\n}\n```\n\n ',6,0,'blog/5.jpg',0,3,104,4,'2022-12-15 16:17:21','2022-12-15 16:17:21'),
(375,'后端开发术语大全','后端开发术语大全','## 系统开发\n\n### 高内聚/低耦合\n\n高内聚指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。模块的内聚反映模块内部联系的紧密程度。\n\n模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。一个完整的系统，模块与模块之间，尽可能的使其独立存在。通常程序结构中各模块的内聚程度越高，模块间的耦合程度就越低。\n\n###  过度设计\n\n过度设计就是进行了过多的面向未来的设计或者说把相对简单的事情想复杂了，过度追求模块化、可扩展性、设计模式等，为系统增加了不必要的复杂度。\n\n###  过早优化\n\n过早指的不是在开发过程的早期，而是在还没弄清楚需求未来的变化的走向的时候。你的优化不仅可能导致你无法很好地实现新的需求，而且你对优化的预期的猜测有可能还是错的，导致实际上你除了把代码变复杂以外什么都没得到。\n\n正确的方法是，先有质量地实现你的需求，写够testcase，然后做profile去找到性能的瓶颈，这个时候才做优化。\n\n###  重构 (Refactoring)\n\n重构（Refactoring）就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。\n\n### 破窗效应\n\n又称破窗理论，破窗效应（Broken windows theory）是犯罪学的一个理论。此理论认为环境中的不良现象如果被放任存在，会诱使人们仿效，甚至变本加厉。一幢有少许破窗的建筑为例，如果那些窗不被修理好，可能将会有破坏者破坏更多的窗户。最终他们甚至会闯入建筑内，如果发现无人居住，也许就在那里定居或者纵火。\n\n应用在软件工程上就是，一定不能让系统代码或者架构设计的隐患有冒头的机会，否则随着时间的推移，隐患会越来越重。反之，一个本身优质的系统，会让人不由自主的写出优质的代码。\n\n### 互不信任原则\n\n指在程序运行上下游的整个链路中，每个点都是不能保证绝对可靠的，任何一个点都可能随时发生故障或者不可预知的行为，包括机器网络、服务本身、依赖环境、输入和请求等，因此要处处设防。\n\n### 持久化 (Persistence)\n\n持久化是将程序数据在临时状态和持久状态间转换的机制。通俗的讲，就是临时数据（比如内存中的数据，是不能永久保存的）持久化为持久数据（比如持久化至数据库或者本地磁盘中，能够长久保存）。\n\n### 临界区\n\n临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用，但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。\n\n### 阻塞/非阻塞\n\n阻塞和非阻塞通常形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。而非阻塞允许多个线程同时进入临界区。\n\n###  同步/异步\n\n通常同步和异步是指函数/方法调用方面。\n\n同步就是在发出一个函数调用时，在没有得到结果之前，该调用就不返回。异步调用会瞬间返回，但是异步调用瞬间返回并不代表你的任务就完成了，他会在后台起个线程继续进行任务，等任务执行完毕后通过回调callback或其他方式通知调用方。\n\n### 并发/并行\n\n并行(parallel)指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。\n\n并发(concurrency)指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。\n\n##   架构设计\n\n###  高并发 (High Concurrency)\n\n由于分布式系统的问世，高并发（High Concurrency）通常是指通过设计保证系统能够同时并行处理很多请求。通俗来讲，高并发是指在同一个时间点，有很多用户同时的访问同一 API 接口或者 Url 地址。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。\n\n###  高可用 (High Availability)\n\n高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，一个系统经过专门的设计，以减少停工时间，而保持其服务的高度可用性。\n\n### 读写分离\n\n为了确保数据库产品的稳定性，很多数据库拥有双机热备功能。也就是，第一台数据库服务器，是对外提供增删改业务的生产服务器；第二台数据库服务器，主要进行读的操作。\n\n###  冷备/热备\n\n冷备：两个服务器，一台运行，一台不运行做为备份。这样一旦运行的服务器宕机，就把备份的服务器运行起来。冷备的方案比较容易实现，但冷备的缺点是主机出现故障时备机不会自动接管，需要主动切换服务。\n\n热备：即是通常所说的active/standby方式，服务器数据包括数据库数据同时往两台或多台服务器写。当active服务器出现故障的时候，通过软件诊测（一般是通过心跳诊断）将standby机器激活，保证应用在短时间内完全恢复正常使用。当一台服务器宕机后，自动切换到另一台备用机使用。\n\n###  异地多活\n\n异地多活一般是指在不同城市建立独立的数据中心，“活”是相对于冷备份而言的，冷备份是备份全量数据，平时不支撑业务需求，只有在主机房出现故障的时候才会切换到备用机房，而多活，是指这些机房在日常的业务中也需要走流量，做业务支撑。\n\n### 负载均衡 (Load Balance)\n\n负载均衡，是对多台服务器进行流量分发的负载均衡服务。可在多个实例间自动分配应用程序的对外服务能力，通过消除单点故障提升应用系统的可用性，让您实现更高水平的应用程序容错能力，从而无缝提供分配应用程序流量所需的负载均衡容量，为您提供高效、稳定、安全的服务。\n\n ### 动静分离\n\n动静分离是指在web服务器架构中，将静态页面与动态页面或者静态内容接口和动态内容接口分开不同系统访问的架构设计方法，进而提升整个服务访问性能和可维护性。\n\n### 集群\n\n单台服务器的并发承载能力总是有限的，当单台服务器处理能力达到性能瓶颈的时，将多台服务器组合起来提供服务，这种组合方式称之为集群，集群中每台服务器就叫做这个集群的一个“节点”，每个节点都能提供相同的服务，从而成倍的提升整个系统的并发处理能力。\n\n### 分布式\n\n分布式系统就是将一个完整的系统按照业务功能拆分成很多独立的子系统，每个子系统就被称为“服务”，分布式系统将请求分拣和分发到不同的子系统，让不同的服务来处理不同的请求。在分布式系统中，子系统独立运行，它们之间通过网络通信连接起来实现数据互通和组合服务。\n\n### CAP理论\n\nCAP理论，指的是在一个分布式系统中，Consistency(一致性)、Availability(可用性)、Partition Tolerance(分区容错性)，不能同时成立。\n一致性：它要求在同一时刻点，分布式系统中的所有数据备份都相同或者都处于同一状态。\n\n可用性：在系统集群的一部分节点宕机后，系统依然能够正确的响应用户的请求。\n\n分区容错性：系统能够容忍节点之间的网络通信的故障。\n\n\n简单的来说，在一个分布式系统中，最多能支持上面的两种属性。但显然既然是分布式注定我们是必然要进行分区，既然分区，我们就无法百分百避免分区的错误。因此，我们只能在一致性和可用性去作出选择。\n\n在分布式系统中，我们往往追求的是可用性，它的重要性比一致性要高，那么如何实现高可用，这里又有一个理论，就是 BASE 理论，它给 CAP 理论做了进一步的扩充。\n\n### BASE理论\n\nBASE 理论指出：\nBasically Available（基本可用）\n\nSoft state（软状态）\n\nEventually consistent（最终一致性）\n\n\nBASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 水平扩展/垂直扩展\n\n水平扩展 Scale Out通过增加更多的服务器或者程序实例来分散负载，从而提升存储能力和计算能力。\n\n垂直扩展 Scale Up 提升单机处理能力。\n\n垂直扩展的方式又有两种：\n（1）增强单机硬件性能，例如：增加CPU核数如32核，升级更好的网卡如万兆，升级更好的硬盘如SSD，扩充硬盘容量如2T，扩充系统内存如128G;\n（2）提升单机软件或者架构性能，例如：使用Cache来减少IO次数，使用异步来增加单服务吞吐量，使用无锁数据结构来减少响应时间；\n\n### 平行扩容\n\n与水平扩展类似。集群服务器中的节点均为平行对等节点，当需要扩容时，可以通过添加更多节点以提高集群的服务能力。一般来说服务器中关键路径（如服务器中的登录、支付、核心业务逻辑等）都需要支持运行时动态平行扩容。\n\n### 弹性扩容\n\n指对部署的集群进行动态在线扩容。弹性扩容系统可以根据实际业务环境按照一定策略自动地添加更多的节点（包括存储节点、计算节点、网络节点）来增加系统容量、提高系统性能或者增强系统可靠性，或者同时完成这三个目标。\n\n### 状态同步/帧同步\n\n状态同步：状态同步是指服务器负责计算全部的游戏逻辑，并且广播这些计算的结果，客户端仅仅负责发送玩家的操作，以及表现收到的游戏结果。\n\n特征：状态同步安全性高，逻辑更新方便，断线重连快，但是开发效率较低，网络流量随游戏复杂度增加，服务器需要承载更大压力。\n帧同步：服务端只转发消息，不做任何逻辑处理，各客户端每秒帧数一致，在每一帧都处理同样的输入数据。\n\n特征：帧同步需要保证系统在相同的输入下，要有相同的输出。帧同步开发效率高，流量消耗低而且稳定，对服务器的压力非常小。但是网络要求高，断线重连时间长，客户端计算压力大。\n\n## 网络通信\n\n### 连接池\n\n预先建立一个连接缓冲池，并提供一套连接使用、分配、管理策略，使得该连接池中的连接可以得到高效、安全的复用，避免了连接频繁建立、关闭的开销。\n\n### 断线重连\n\n由于网络波动造成用户间歇性的断开与服务器的连接，待网络恢复之后服务器尝试将用户连接到上次断开时的状态和数据。\n\n### 会话保持\n\n会话保持是指在负载均衡器上的一种机制，可以识别客户端与服务器之间交互过程的关连性，在作负载均衡的同时还保证一系列相关连的访问请求都会分配到一台机器上。用人话来表述就是：在一次会话过程中发起的多个请求都会落到同一台机器上。\n\n### 长连接/短连接\n\n通常是指TCP的长连接和短连接。长连接就是建立TCP连接后，一直保持这个连接，一般会中间彼此发送心跳来确认对应的存在，中间会做多次业务数据传输，一般不会主动断开连接。短连接一般指建立连接后，执行一次事务后（如：http请求），然后就关掉这个连接。\n\n### 流量控制/拥塞控制\n\n流量控制防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理。\n\n拥塞控制防止发送方发的太快，使得网络来不及处理产生拥塞，进而引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿。\n\n### 惊群效应\n\n惊群效应也有人叫做雷鸣群体效应，不过叫什么，简言之，惊群现象就是多进程（多线程）在同时阻塞等待同一个事件的时候（休眠状态），如果等待的这个事件发生，那么他就会唤醒等待的所有进程（或者线程），但是最终却只可能有一个进程（线程）获得这个时间的“控制权”，对该事件进行处理，而其他进程（线程）获取“控制权”失败，只能重新进入休眠状态，这种现象和性能浪费就叫做惊群。\n\n###  NAT\n\nNAT（Network Address Translation，网络地址转换），就是替换IP报文头部的地址信息。NAT通常部署在一个组织的网络出口位置，通过将内部网络IP地址替换为出口的IP地址提供公网可达性和上层协议的连接能力。\n\n## 故障异常\n\n###  宕机\n\n宕机，一般情况下指的就是计算机主机出现意外故障而死机。其次，一些服务器例如数据库死锁也可以称为宕机，一些服务器的某些服务挂掉了，就可以这么说。\n\n### coredump\n\n当程序出错而异常中断时，OS会把程序工作的当前状态存储成一个coredunmp文件。通常情况下coredump文件包含了程序运行时的内存，寄存器状态，堆栈指针，内存管理信息等。\n\n### 缓存穿透/击穿/雪崩\n\n缓存穿透：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。\n\n缓存击穿：缓存击穿是指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。\n\n缓存雪崩：缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。\n\n与缓存击穿不同的是：存击穿是热点key失效，缓存雪崩是大量的key同时失效。\n\n### 500/501/502/503/504/505\n\n500 Internal Server Error：内部服务错误，一般是服务器遇到意外情况，而无法完成请求。可能原因: 1、程序错误，例如：ASP或者PHP语法错误；2、高并发导致，系统资源限制不能打开过多的文件所致。\n\n501Not implemented：服务器不理解或不支持请求的HTTP请求。\n\n502Bad Gateway：WEB服务器故障，可能是由于程序进程不够，请求的php-fpm已经执行，但是由于某种原因而没有执行完毕，最终导致php-fpm进程终止。可能原因：1、Nginx服务器，php-cgi进程数不够用；2、PHP执行时间过长；3、php-cgi进程死掉；\n\n503Service Unavailable：服务器目前无法使用。系统维护服务器暂时的无法处理客户端的请求，这只是暂时状态。可以联系下服务器提供商。\n\n504Gateway Timeout：服务器504错误表示超时，是指客户端所发出的请求没有到达网关，请求没有到可以执行的php-fpm，一般是与nginx.conf的配置有关。\n\n505HTTP Version Not Supported：服务器不支持请求中所用的 HTTP 协议版本。（HTTP 版本不受支持）\n\n除了500错误可能是程序语言错误，其余的报错，都大概可以理解为服务器或者服务器配置出现问题。\n\n### 内存溢出/内存泄漏\n\n内存溢出：内存溢出（Out Of Memory）指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。\n\n内存泄漏：内存泄漏（Memory Leak）指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n\n### 句柄泄漏\n\n句柄泄漏是进程在调用系统文件之后，没有释放已经打开的文件句柄。一般句柄泄漏后的现象是，机器变慢，CPU飙升，出现句柄泄漏的cgi或server的CPU使用率增加。\n\n### 死锁\n\n死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都抑制处于阻塞状态并无法进行下去，此时称系统处于死锁状态或系统产生了死锁。\n\n###  软中断/硬中断\n\n硬中断：我们通常所说的中断指的是硬中断(hardirq)。\n\n由与系统相连的外设(比如网卡、硬盘)自动产生的。\n\n主要是用来通知操作系统系统外设状态的变化。\n\n软中断：1、通常是硬中断服务程序对内核的中断；2、为了满足实时系统的要求，中断处理应该是越快越好。\n\nlinux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。\n\n### 毛刺\n\n在短暂的某一刻，服务器性能指标（如流量、磁盘IO、CPU使用率等）远大于该时刻前后时间段。毛刺的出现代表这服务器资源利用不均匀，不充分，容易诱发其他更严重的问题。\n\n###  重放攻击\n\n攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。它是一种攻击类型，这种攻击会不断恶意或欺诈性地重复一个有效的数据传输，重放攻击可以由发起者，也可以由拦截并重发该数据的敌方进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。\n\n### 网络孤岛\n\n网络孤岛指集群环境中，部分机器与整个集群失去网络连接，分裂为一个小集群并且发生数据不一致的状况。\n\n### 数据倾斜\n\n对于集群系统，一般缓存是分布式的，即不同节点负责一定范围的缓存数据。我们把缓存数据分散度不够，导致大量的缓存数据集中到了一台或者几台服务节点上，称为数据倾斜。一般来说数据倾斜是由于负载均衡实施的效果不好引起的。\n\n###  脑裂\n\n脑裂是指在集群系统中，部分节点之间网络不可达而引起的系统分裂，不同分裂的小集群会按照各自的状态提供服务，原本的集群会同时存在不一致的反应，造成节点之间互相争抢资源，系统混乱，数据损坏。\n\n## 监控告警\n\n### 服务监控\n\n服务监控主要目的在服务出现问题或者快要出现问题时能够准确快速地发现以减小影响范围。服务监控一般有多种手段，按层次可划分为：\n\n系统层（CPU、网络状态、IO、机器负载等）\n\n应用层（进程状态、错误日志、吞吐量等）\n\n业务层（服务/接口的错误码、响应时间）\n\n用户层（用户行为、舆情监控、前端埋点）\n\n###  全链路监控\n\n服务拨测：服务拨测是探测服务（应用）可用性的监控方式，通过拨测节点对目标服务进行周期性探测，主要通过可用性和响应时间来度量，拨测节点通常有异地多个。\n节点探测：节点探测是用来发现和追踪不同的机房（数据中心）节点之间网络可用性和通畅性的监控方式，主要通过响应时间、丢包率、跳数来度量，探测方法一般是ping、mtr或其他私有协议。\n告警过滤：对某些可预知的告警进行过滤，不进入告警统计的数据，如少量爬虫访问导致的http响应500错误，业务系统自定义异常信息等。\n告警去重：当一个告警通知负责人后，在这个告警恢复之前，不会继续收到相同的告警。\n告警抑制：为了减少由于系统抖动带来的干扰，还需要实现抑制，例如服务器瞬间高负载，可能是正常的，只有持续一段时间的高负载才需要得到重视。\n告警恢复：开发/运维人员不仅需要收到告警通知，还需要收到故障消除告警恢复正常的通知。\n告警合并：对同一时刻产生的多条相同告警进行合并，如某个微服务集群同一时刻出现多个子服务负载过高的告警，需要合并成为一条告警。\n告警收敛：有时某个告警产生时，往往会伴随着其它告警。这时可以只对根本原因产生告警，其它告警收敛为子告警一并发送通知。如云服务器出现CPU负载告警时往往伴随其搭载的所有系统的可用性告警。\n故障自愈：实时发现告警，预诊断分析，自动恢复故障，并打通周边系统实现整个流程的闭环。\n\n## 服务治理\n\n###  微服务\n\n微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间相互协调、互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务和服务之间采用轻量级的通信机制相互沟通（通常是基于HTTP的Restful API).每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境、类生产环境等。\n\n### 服务发现\n\n服务发现是指使用一个注册中心来记录分布式系统中的全部服务的信息，以便其他服务能够快速的找到这些已注册的服务。服务发现是支撑大规模 SOA 和微服务架构的核心模块，它应该尽量做到高可用。\n\n###  流量削峰\n\n如果观看抽奖或秒杀系统的请求监控曲线，你就会发现这类系统在活动开放的时间段内会出现一个波峰，而在活动未开放时，系统的请求量、机器负载一般都是比较平稳的。为了节省机器资源，我们不可能时时都提供最大化的资源能力来支持短时间的高峰请求。所以需要使用一些技术手段，来削弱瞬时的请求高峰，让系统吞吐量在高峰请求下保持可控。削峰也可用于消除毛刺，使服务器资源利用更加均衡和充分。常见的削峰策略有队列，限频，分层过滤，多级缓存等。\n\n### 版本兼容\n\n在升级版本的过程中，需要考虑升级版本后，新的数据结构是否能够理解和解析旧数据，新修改的协议是否能够理解旧的协议以及做出预期内合适的处理。这就需要在服务设计过程中做好版本兼容。\n\n### 过载保护\n\n过载是指当前负载已经超过了系统的最大处理能力，过载的出现，会导致部分服务不可用，如果处置不当，极有可能引起服务完全不可用，乃至雪崩。过载保护正是针对这种异常情况做的措施，防止出现服务完全不可用的现象。\n\n### 服务熔断\n\n服务熔断的作用类似于我们家用的保险丝，当某服务出现不可用或响应超时的情况时，为了防止整个系统出现雪崩，暂时停止对该服务的调用。\n\n### 服务降级\n\n服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。\n\n根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。\n\n根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。\n\n总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。\n\n### 熔断VS降级\n\n相同点：目标一致，都是从可用性和可靠性出发，为了防止系统崩溃；用户体验类似，最终都让用户体验到的是某些功能暂时不可用；\n\n不同点：触发原因不同，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；\n\n###  服务限流\n\n限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。\n\n###  故障屏蔽\n\n将故障机器从集群剔除，以保证新的请求不会分发到故障机器。\n\n## 测试方法\n\n###  黑盒/白盒测试\n\n黑盒测试不考虑程序内部结构和逻辑结构，主要是用来测试系统的功能是否满足需求规格说明书。一般会有一个输入值，一个输入值，和期望值做比较。\n\n白盒测试主要应用在单元测试阶段，主要是对代码级的测试，针对程序内部逻辑结构，测试手段有：语句覆盖、判定覆盖、条件覆盖、路径覆盖、条件组合覆盖\n\n### 单元/集成/系统/验收测试\n\n软件测试一般分为4个阶段：单元测试、集成测试、系统测试、验收测试。\n\n单元测试：单元测试是对软件中的最小可验证单元进行检查和验证，如一个模块、一个过程、一个方法等。单元测试粒度最小，一般由开发小组采用白盒方式来测试，主要测试单元是否符合“设计”。\n\n集成测试：集成测试也叫做组装测试，通常在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。集成测试界于单元测试和系统测试之间，起到“桥梁作用”，一般由开发小组采用白盒加黑盒的方式来测试，既验证“设计”，又验证“需求”。\n\n系统测试：系统测试时将经过集成测试的软件，作为计算机系统的一部分，与系统中其他部分结合起来，在实际运行环境下进行一系列严格有效的测试，以发现软件潜在的问题，保证系统的正常运行。系统测试的粒度最大，一般由独立测试小组采用黑盒方式来测试，主要测试系统是否符合“需求规格说明书”。\n\n验收测试：验收测试也称交付测试，是针对用户需求、业务流程进行的正式的测试，以确定系统是否满足验收标准，由用户、客户或其他授权机构决定是否接受系统。验收测试与系统测试相似，主要区别是测试人员不同，验收测试由用户执行。\n\n### 回归测试\n\n当发现并修改缺陷后，或在软件中添加新的功能后，重新测试。用来检查被发现的缺陷是否被改正，并且所做的修改没有引发新的问题。\n\n### 冒烟测试\n\n这一术语源自硬件行业。对一个硬件或硬件组件进行更改或修复后，直接给设备加电。如果没有冒烟，则该组件就通过了测试。在软件中，“冒烟测试”这一术语描述的是在将代码更改嵌入到产品的源树中之前对这些更改进行验证的过程。\n\n冒烟测试是在软件开发过程中的一种针对软件版本包的快速基本功能验证策略，是对软件基本功能进行确认验证的手段，并非对软件版本包的深入测试。\n\n比如：对于一个登录系统的冒烟测试，我们只需测试输入正确的用户名、密码，验证登录这一个核心功能点，至于输入框、特殊字符等，可以在冒烟测试之后进行。\n\n###  性能测试\n\n性能测试是通过自动化的测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试。负载测试和压力测试都属于性能测试，两者可以结合进行。\n\n通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。\n\n压力测试是通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。\n\n###  基准测试\n\n基准测试（Benchmark）也是一种性能测试方式，用来测量机器的硬件最高实际运行性能，以及软件优化的性能提升效果, 同时也可以用来识别某段代码的CPU或者内存效率问题. 许多开发人员会用基准测试来测试不同的并发模式, 或者用基准测试来辅助配置工作池的数量, 以保证能最大化系统的吞吐量.\n\n### A/B测试\n\nA/B测试，是用两组及以上随机分配的、数量相似的样本进行对比，如果实验组和对比组的实验结果相比，在目标指标上具有统计显著性，那就可以说明实验组的功能可以导致你想要的结果，从而帮你验证假设或者做出产品决定。\n\n### 代码覆盖测试\n\n代码覆盖（Code coverage）是软件测试中的一种度量，描述程式中源代码被测试的比例和程度，所得比例称为代码覆盖率。在做单元测试时，代码覆盖率常常被拿来作为衡量测试好坏的指标，甚至，用代码覆盖率来考核测试任务完成情况，比如，代码覆盖率必须达到80%或 90%。于是乎，测试人员费尽心思设计案例覆盖代码。\n\n## 发布部署\n\n#### DEV/PRO/FAT/UAT\n\nDEV（Development environment）：开发环境，用于开发人员调试使用，版本变化较大。\n\nFAT（Feature Acceptance Test environment）：功能验收测试环境，用于软件测试人员测试使用。\n\nUAT（User Acceptance Test environment）：用户验收测试环境，用于生产环境下的功能验证，可作为预发布环境。\n\nPRO（Production environment）：生产环境，正式线上环境。\n\n###  灰度发布\n\n灰度发布是指在升级版本过程中，通过分区控制，白名单控制等方式对一部分用户先升级产品特性，而其余用户则保持不变，当一段时间后升级产品特性的用户没有反馈问题，就逐步扩大范围，最终向所有用户开放新版本特性，灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、修改问题，以保证其影响度。\n\n###  回滚 (Rollback)\n\n指的是程序或数据处理错误时，将程序或数据恢复到上一次正确状态(或者是上一个稳定版本)的行为。',6,0,'blog/7.jpg',0,4,104,4,'2022-12-15 16:50:05','2022-12-15 16:50:16'),
(376,'vue3中使用axios','使用npm安装\n\n```\n$ npm install axios\n```','### 安装\n\n使用npm安装\n\n```\n$ npm install axios\n```\n\n### 封装axios\n\n```js\nimport axios from ''axios'';\nimport qs from \"qs\";\nimport store from \"@/store/index\";\nimport router from ''@/router/index'';\nimport { dataList } from ''@/components/aspin/data'';\nimport { message } from ''ant-design-vue'';\nimport { storage } from ''../storage/storage'';\n\n//数据请求字符\naxios.defaults.baseURL = process.env.VUE_APP_API_URL,\n  // 如果请求超过 `timeout` 的时间，请求将被中断\n  axios.defaults.timeout = 5000;\n// 表示跨域请求时是否需要使用凭证\naxios.defaults.withCredentials = false;\n// axios.defaults.headers.common[''token''] =  AUTH_TOKEN\naxios.defaults.headers.post[''Content-Type''] = ''application/json;charset=UTF-8'';\n// 允许跨域\naxios.defaults.headers.post[\"Access-Control-Allow-Origin-Type\"] = \"*\";\n// 请求拦截器\naxios.interceptors.request.use(function (config) {\n  if (\n    config.method === \"post\" ||\n    config.method === \"put\" ||\n    config.method === \"delete\"\n  ) {\n    // qs序列化\n    config.data = qs.parse(config.data);\n  }\n  // 若是有做鉴权token , 就给头部带上token\n  if (storage.get(store.state.Roles)) {\n    store.state.Roles\n    config.headers.Authorization = storage.get(store.state.Roles);\n  }\n  return config;\n}, error => {\n  message.error(error.data.error.message);\n  return Promise.reject(error.data.error.message);\n})\n\n// 响应拦截器\naxios.interceptors.response.use(function (config) {\n  dataList.show = true\n  if (config.status === 200 || config.status === 204) {\n    setTimeout(() => {\n      dataList.show = false\n    }, 400)\n    return Promise.resolve(config);\n  } else {\n    return Promise.reject(config);\n  }\n},\n  function (error) {\n    if (error.response.status) {\n      switch (error.response.status) {\n        case 400:\n          message.error(\"发出的请求有错误，服务器没有进行新建或修改数据的操作==>\" + error.response.status)\n          break;\n        // 401: 未登录\n        // 未登录则跳转登录页面，并携带当前页面的路径\n        // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n        case 401: //重定向\n          message.error(\"token:登录失效==>\" + error.response.status + \":\" + store.state.Roles)\n          storage.remove(store.state.Roles)\n          storage.get(store.state.Roles)\n          router.replace({\n            path: ''/Login'',\n          });\n          break;\n        // 403 token过期\n        // 登录过期对用户进行提示\n        // 清除本地token和清空vuex中token对象\n        // 跳转登录页面                \n        case 403:\n          message.error(\"用户得到授权，但是访问是被禁止的==>\" + error.response.status)\n          break;\n        case 404:\n          message.error(\"网络请求不存在==>\" + error.response.status)\n          break;\n        case 406:\n          message.error(\"请求的格式不可得==>\" + error.response.status)\n          break;\n        case 410:\n          message.error(\"请求的资源被永久删除，且不会再得到的==>\" + error.response.status)\n          break;\n        case 422:\n          message.error(\"当创建一个对象时，发生一个验证错误==>\" + error.response.status)\n          break;\n        case 500:\n          message.error(\"服务器发生错误，请检查服务器==>\" + error.response.status)\n          break;\n        case 502:\n          message.error(\"网关错误==>\" + error.response.status)\n          break;\n        case 503:\n          message.error(\"服务不可用，服务器暂时过载或维护==>\" + error.response.status)\n          break;\n        case 504:\n          message.error(\"网关超时==>\" + error.response.status)\n          break;\n        default:\n          message.error(\"其他错误错误==>\" + error.response.status)\n      }\n      return Promise.reject(error.response);\n    } else {\n      // 处理断网的情况\n      // eg:请求超时或断网时，更新state的network状态\n      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\n      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明\n      store.commit(''changeNetwork'', false);\n    }\n  }\n)\nexport default axios\n```\n\n### main.ts\n\n全局使用\n\n```js\nimport axios from ''./utils/http/axios''\n// 全局ctx(this) 上挂载 $axios\napp.config.globalProperties.$api = axios\n```\n\n ### 封装使用\n\n```js\nimport request from ''@/utils/http/axios''\nimport { IntArticle } from \"@/api/data/interData\";\n\nexport class article\n\n  /**\n   * @description: 主键查询\n   * @param {number} id\n   * @param {boolean} cache\n   * @return {*}\n   */\n  static async GetByIdAsync(id: any, cache: boolean): Promise<any> {\n    return await request({\n      url: \"/api/SnArticle/GetByIdAsync?id=\" + id + \"&cache=\" + cache,\n      method: ''get'',\n    })\n  }\n\n  /**\n   * @description: 新增数据\n   * @param {any} resultData\n   */\n  static async AddAsync(resultData: IntArticle) {\n    return await\n      request({\n        url: \"/api/SnArticle/AddAsync\",\n        method: \"post\",\n        data: resultData,\n      })\n  }\n  /**\n   * @description: 更新数据\n   * @param {IntArticle} resultData\n   */\n  static async UpdateAsync(resultData: IntArticle) {\n    return await\n      request({\n        url: \"/api/SnArticle/UpdateAsync\",\n        method: \"put\",\n        data: resultData,\n      })\n  }\n  /**\n   * @description: 删除\n   * @param {number} id\n   * @return {*}\n   */\n  static async DeleteAsync(id: number) {\n    return await\n      request({\n        url: \"/api/SnArticle/DeleteAsync?id=\" + id,\n        method: \"delete\",\n      })\n  }\n}\n```\n\n### 并发请求\n\n处理并发请求的助手函数\n\n axios.all(iterable)\n\n axios.spread(callback)\n\n```js\n//示例:\nimport { article } from ''@/api/index'';\nimport { blogsList } from \"./components/data\";\nimport axios from ''@/utils/http/axios''\nclass methods {\n  static async GetFySortTitle() {\n    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize, true).then((res: any) => {\n      blogsList.dataResult = res.data;\n    });\n  }\n  static async ConutSort() {\n    await article.ConutSort(7).then((result: any) => {\n      blogsList.count = result.data;\n    });\n  }\n}\nasync function QueryAll() {\n  // axios.all([await methods.ConutSort(), await methods.GetFySortTitle()]).then(axios.spread((Fy, co: any) => {\n  //   blogsList.count = co.data;\n  //   blogsList.dataResult = Fy.data;\n  // }))\n  axios.all([await methods.ConutSort(), await methods.GetFySortTitle()])\n}\n\nexport {\n  methods,\n  QueryAll\n}\n```\n\n\n\n\n\n \n\n ',4,0,'blog/9.jpg',0,5,1,4,'2022-12-15 17:08:39','2022-12-15 17:08:39'),
(378,'vue2使用vuex','vuex 是一个专门为vue.js应用程序开发的状态管理模式。','### vuex\n\nvuex 是一个专门为vue.js应用程序开发的状态管理模式。\n\nvuex中，有默认的五种基本的对象：\n\n- **state**：存储状态（变量）\n- **getters**：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()\n- **mutations**：修改状态，并且是同步的。在组件中使用$store.commit('''',params)。这个和我们组件中的自定义事件类似。\n- **actions**：异步操作。在组件中使用是$store.dispath('''')\n- **modules**：store的子模块，为了开发大型项目，方便状态管理而使用的。这里我们就不解释了，用起来和上面的一样。\n\n### 安装使用\n\n安装vuex\n\n```\nnpm install vuex --save\n```\n\n### store.js\n\n新建store/store.js文件，引入vuex\n\n```js\nimport Vue from ''vue''\nimport Vuex from ''vuex''\nVue.use(Vuex)\nconst state = {\n  count: 1\n}\nconst mutations = {\n  increment (state) {\n    state.count++\n  }\n}\nexport default new Vuex.Store({\n  state,\n  mutations\n})\n```\n\n### main.js\n\n引入store\n\n```js\nimport store from ''./store/store''\nnew Vue({\n  el: ''#app'',\n  router,\n  store,\n  components: { App },\n  template: ''<App/>''\n})\n```\n\n页面调用count状态\n\n```js\n{{ $store.state.count }}\n```\n\n用mutations和actions 继续操作store状态\n\n```js\n<button @click=\"add()\">add</button>\nmethods: {\n    add () {\n     this.$store.commit(''increment'') //普通提交封装\n    }\n  }\n```\n\n###  mutations携带参数\n\n```js\n<button @click=\"add(10)\">add</button>\n methods: {\n    add (count) {\n    //  this.$store.commit(''increment'',count)\n       this.$store.commit({ //对象提交封装\n       type:''increment'',\n       count\n     })\n    }\n  }\nstore.js文件:\nconst mutations = {\n  increment (state,count) {\n    state.counter+=count\n  }\n}\n //对象提交count更改 payload\n   increment (state) {\n   state.counter+=payload.count\n}\n```\n\n### actions异步操作\n\n```js\nconst actions = { // 异步操作\n  acincrement (context) {\n    state.count++\n  }\n```\n\n使用dispath来触发\n\n```js\n this.$store.dispatch(''acincrement'')\n```\n\n### getters\n\n```js\nconst getters = {\n  getterCount(state, n = 0) {\n    return (state.count += n)\n  }\n}\nexport default new Vuex.Store({\n  state,\n  mutations,\n  actions,\n  getters\n})\n```\n\n属性调用：\n\n```\n{{ $store.getters.getterCount }}\n```\n\n### getters传参：\n\n```js\n{ $store.getters.getterid(10) }}\ngetterid(state){\n\nreturn age = >{\nreturn //需要判断的数值\n}\n}\n```\n\n ',5,0,'blog/1.jpg',0,7,1,4,'2022-12-15 17:21:49','2022-12-15 17:21:49'),
(379,'axios基础封装','新建文件夹 network 在文件新建 request.js','### request.js\n\n新建文件夹 network 在文件新建 request.js\n\n```js\nimport axios from ''axios''\nexport function request (config) {\n  // 创建axios实例\n  const intstance = axios.create({\n    baseURL: ''https://localhost:44314'',\n    timeout: 5000\n    // contentType: ''application/json;charset=UTF-8'',\n    // dataType: ''json''\n  })\n  // axios拦截器\n  intstance.interceptors.request.use(config => {\n    return config\n  }, er => {})\n  // axios响应拦截拦截\n  intstance.interceptors.response.use(res => {\n    return res\n  }, er => {\n  })\n  return intstance(config)\n}\nexport default request //导出\n```\n\n### main.挂载配置\n\n```js\nimport request from ''@/network/request''\n\nnew Vue({\n  el: ''#app'',\n  router,\n  store,\n  request, // 封装的axios\n  components: { App },\n  template: ''<App/>''\n\n})\n```\n\n### 组件中调用\n\n在需要使用axios的组件中调用\n\n```js\nimport request from ''@/network/request''\n\n request({ // 查询所有\n        url: ''/api/Gj''\n      }).then(res => {\n        this.tableData = res.data\n      })\n\n request({ // 添加\n        url: ''/api/Gj'',\n        method: ''POST'',\n        data: {\n          ''id'': 0,\n          ''method'': this.method,\n          ''text'': this.content,\n          ''type'': this.value\n        }\n      }).then(res => {\n        console.log(res)\n        if (res.status === 201) {\n          this.open1()\n          console.log(''成功'')\n        } else {\n          this.open4()\n          console.log(''失败'')\n        }\n      }).catch(console.error.bind(console)) // 异常\n\n  request({// 更新\n        url: ''/api/Gj/'' + this.id,\n        method: ''put'',\n        data: {\n          ''id'': this.newinfo.id,\n          ''method'': this.newinfo.method,\n          ''text'': this.newinfo.text,\n          ''type'': this.newinfo.type\n       }\n      }).then(res => {\n        if (res.status === 204) {\n          this.open1()\n          console.log(''成功'')\n        } else {\n          this.open4()\n          console.log(''失败'')\n        }\n      }).catch(console.error.bind(console)) // 异常\n```\n\n ',7,0,'blog/1.jpg',0,5,2,4,'2022-12-15 17:29:04','2022-12-15 17:29:04'),
(380,'C#使用委托事件进行窗体间的传值','在窗体中先获取到要接受值窗体。然后通过.得到某个空间或者属性，直接赋值，这个需要接收放的窗体属性或者空间必须是public ，是极不安全的一种方式','在窗体中先获取到要接受值窗体。然后通过.得到某个空间或者属性，直接赋值，这个需要接收放的窗体属性或者空间必须是public ，是极不安全的一种方式\n\n**委托（Delegate）** 是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。\n\n委托（Delegate）特别用于实现事件和回调方法。所有的委托（Delegate）都派生自 **System.Delegate** 类。\n\n### 定义委托\n\n委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法\n\n 定义了一个参数是string ，无返回值的委托，名为 SendMessageToChildForms。\n\n```c#\n public delegate void SendMessageToChildForms(string s);\n```\n\n### 委托实例化\n\n一旦声明了委托类型，委托对象必须使用 **new** 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 **new** 语句的参数就像方法调用一样书写，但是不带有参数。\n\n本质就是实例化了一个事件event\n\n```c#\npublic event SendMessageToChildForms smtcf_event;\n```\n\n###   执行的方法\n\n```c#\npublic void ToShowGetMessage(string s)\n{\n     this.lb_收到内容.Text=s;\n}\n```\n\n### 绑定方法\n\n在一实例化的一个委托事件上绑定子窗体的具体方法\n\n```c#\n Parameter frm_child = new Parameter();\n            smtcf_event += frm_child.ToShowGetMessage; \n            frm_child.Show();\n```\n\n### 触发委托\n\n```c#\n        if (smtcf_event != null) //判断委托事件是否为空，如果委托不为空才执行\n        {\n            smtcf_event.Invoke(\"12212\");// 可以省略Invoke 简写为smtcf(this.textBox1.Text.Trim());\n        }\n```\n\n',6,0,'blog/7.jpg',0,8,104,4,'2022-12-15 17:52:43','2022-12-15 17:52:51'),
(381,'netcore3.1使用Jwt','（Authentication）和授权（Authorization）的区别，以免混淆了。认证是确认的过程中你是谁，而授权围绕是你被允许做什么，即权限。显然，在确认允许用户做什么之前，你需要知道他们是谁，因此，在需要授权时，还必须以某种方式对用户进行身份验证。','### 认证授权区别\n\n（Authentication）和授权（Authorization）的区别，以免混淆了。认证是确认的过程中你是谁，而授权围绕是你被允许做什么，即权限。显然，在确认允许用户做什么之前，你需要知道他们是谁，因此，在需要授权时，还必须以某种方式对用户进行身份验证。 \n\n### 什么是JWT\n\n根据维基百科的定义，JSON WEB Token（JWT），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成：头信息（header），消息体（payload）和签名（signature）。\n\n头信息指定了该JWT使用的签名算法:\n\n```c#\nheader = ''{\"alg\":\"HS256\",\"typ\":\"JWT\"}''\n```\n\n`HS256`表示使用了HMAC-SHA256来生成签名。\n\n消息体包含了JWT的意图：\n\n```c#\npayload = ''{\"loggedInAs\":\"admin\",\"iat\":1422779638}''//iat表示令牌生成的时间\n```\n\n未签名的令牌由`base64url`编码的头信息和消息体拼接而成（使用\".\"分隔），签名则通过私有的key计算而成：\n\n```c#\nkey = ''secretkey''  \nunsignedToken = encodeBase64(header) + ''.'' + encodeBase64(payload)  \nsignature = HMAC-SHA256(key, unsignedToken)\n```\n\n最后在未签名的令牌尾部拼接上`base64url`编码的签名（同样使用\".\"分隔）就是JWT了：\n\n```c#\ntoken = encodeBase64(header) + ''.'' + encodeBase64(payload) + ''.'' + encodeBase64(signature)\n\n# token看起来像这样: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJsb2dnZWRJbkFzIjoiYWRtaW4iLCJpYXQiOjE0MjI3Nzk2Mzh9.gzSraSYS8EXBxLN_oWnFSRgCzcmJmMjLiuyu5CSpyHI\n```\n\nJWT常常被用作保护服务端的资源（resource），客户端通常将JWT通过HTTP的`Authorization` header发送给服务端，服务端使用自己保存的key计算、验证签名以判断该JWT是否可信：\n\n```c#\nAuthorization: Bearer eyJhbGci*...<snip>...*yu5CSpyHI\n```\n\n### 准备工作\n\n使用vs2019创建webapi项目，并且安装nuget包\n\n```c#\nMicrosoft.AspNetCore.Authentication.JwtBearer\n```\n\n### Startup类\n\nConfigureServices 添加认证服务\n\n```csharp\nservices.AddAuthentication(options =>\n{\n    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;\n    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;\n}).AddJwtBearer(options =>\n{\n    options.SaveToken = true;\n    options.RequireHttpsMetadata = false;\n    options.TokenValidationParameters = new TokenValidationParameters()\n    {\n        ValidateIssuer = true, ValidateAudience = true, ValidAudience = \"https://xx\", ValidIssuer = \"https://xx\", IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"SecureKeySecureKeySecureKeySecureKeySecureKeySecureKey\"))\n    };\n});\n```\n\nConfigure 配置认证中间件\n\n```csharp\napp.UseAuthentication();//认证中间件\n```\n\n### 创建token\n\n添加一个登录model命名为LoginInput\n\n```c#\npublic class LoginInput\n{\n    public string Username\n    {\n        get;\n        set;\n    }\n    public string Password\n    {\n        get;\n        set;\n    }\n}\n```\n\n添加一个认证,控制器命名为AuthenticateController\n\n```c#\n[Route(\"api/[controller]\")]\npublic class AuthenticateController: Controller\n{\n    [HttpPost]\n    [Route(\"login\")]\n    public IActionResult Login([FromBody] LoginInput input)\n    {\n        //从数据库验证用户名，密码 \n        //验证通过 否则 返回Unauthorized\n        //创建claim\n        var authClaims = new []\n        {\n            new Claim(JwtRegisteredClaimNames.Sub, input.Username), new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString())\n        };\n        IdentityModelEventSource.ShowPII = true;\n        //签名秘钥 可以放到json文件中\n        var authSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\"SecureKeySecureKeySecureKeySecureKeySecureKeySecureKey\"));\n        var token = new JwtSecurityToken(issuer: \"https://xx\", audience: \"https://xx\", expires: DateTime.Now.AddHours(2), claims: authClaims, signingCredentials: new SigningCredentials(authSigningKey, SecurityAlgorithms.HmacSha256));\n        //返回token和过期时间\n        return Ok(new\n        {\n            token = new JwtSecurityTokenHandler().WriteToken(token), expiration = token.ValidTo\n        });\n    }\n}\n```\n\n### 添加api资源\n\n利用控制器 WeatherForecastController\n\n添加个Authorize标签\n\n路由调整为：[Route(\"api/[controller]\")] 代码如下\n\n```c#\n[Authorize]\n[ApiController]\n[Route(\"api/[controller]\")]\npublic class WeatherForecastController: ControllerBase\n```\n\n### 运行测试\n\n使用postman进行模拟\n\n1. 发现返回时401未认证，下面获取token\n2. 通过用户和密码获取token\n3. 如果我们的凭证正确，将会返回一个token和过期日期，然后利用该令牌进行访问\n4. 利用token进行请求\n5. 现请求状态200！\n\n',11,0,'blog/10.jpg',0,9,3,4,'2022-12-15 17:59:49','2022-12-15 17:59:49'),
(382,'c#上传下载实现','### 安装SqlSugar\n\nModel文件下新建 DbContext 类\n\n```c#\npublic class DbContext \n{\n	public DbContext() \n	{','### 安装SqlSugar\n\nModel文件下新建 DbContext 类\n\n```c#\npublic class DbContext \n{\n	public DbContext() \n	{\n		Db = new SqlSugarClient(new ConnectionConfig() public class DbContext\n{\n    public DbContext()\n        {\n            Db = new SqlSugarClient(new ConnectionConfig()\n            {\n                ConnectionString = \"server=localhost;uid=root;pwd=woshishui;database=test\",\n                    DbType = DbType.MySql,\n                    InitKeyType = InitKeyType.Attribute, //从特性读取主键和自增列信息\n                    IsAutoCloseConnection = true, //开启自动释放模式和EF原理一样我就不多解释了\n            });\n            //调式代码 用来打印SQL \n            Db.Aop.OnLogExecuting = (sql, pars) =>\n            {\n                Console.WriteLine(sql + \"rn\" + Db.Utilities.SerializeObject(pars.ToDictionary(it => it.ParameterName, it => it.Value)));\n                Console.WriteLine();\n            };\n        }\n        //注意：不能写成静态的，不能写成静态的\n    public SqlSugarClient Db; //用来处理事务多表查询和复杂的操作\n    public SimpleClient < uploading > uploadingdb\n        {\n            get\n            {\n                return new SimpleClient < uploading > (Db);\n            }\n        } //用来处理Student表的常用操作\n}\n		{\n			ConnectionString = \"server=localhost;uid=root;pwd=woshishui;database=test\",\n			                DbType = DbType.MySql,\n			                InitKeyType = InitKeyType.Attribute,//从特性读取主键和自增列信息\n			IsAutoCloseConnection = true,//开启自动释放模式和EF原理一样我就不多解释了\n			});\n			//调式代码 用来打印SQL \n			Db.Aop.OnLogExecuting = (sql, pars) =>\n			            {\n			                Console.WriteLine(sql + \"rn\" +\n                                  Db.Utilities.SerializeObject(pars.ToDictionary(it => it.ParameterName, it => it.Value)));\n                Console.WriteLine();\n            };\n        }\n        //注意：不能写成静态的，不能写成静态的\n        public SqlSugarClient Db;//用来处理事务多表查询和复杂的操作\n        public SimpleClient<uploading> uploadingdb { get { return new SimpleClient<uploading>(Db); } }//用来处理Student表的常用操作\n    }\n```\n\n### 实体类\n\n```c#\n[SugarTable(\"uploading\")]\npublic class uploading\n{\n    //指定主键和自增列，当然数据库中也要设置主键和自增列才会有效\n    [SugarColumn(IsPrimaryKey = true, IsIdentity = true)]\n    public int id\n    {\n        get;\n        set;\n    }\n    public string name\n    {\n        get;\n        set;\n    }\n    public string path\n    {\n        get;\n        set;\n    }\n}\n```\n\n### UploadingManager\n\n```c#\n class UploadingManager: DbContext\n {\n     public List < uploading > Query()\n     {\n         try\n         {\n             List < uploading > data = Db.Queryable < uploading > ().Select(f => new uploading\n             {\n                 name = f.name,\n                     path = f.path\n             }).ToList();\n             return data;\n         }\n         catch(Exception e)\n         {\n             Console.WriteLine(e);\n             throw;\n         }\n     }\n     public List < string > GetName(string name)\n     {\n         List < string > data = Db.Queryable < uploading > ().Where(w => w.name == name).Select(f => f.path).ToList();\n         return data;\n     }\n }\n```\n\n\n\n### 窗体加载\n\n 读取到数据库字段name并赋值\n\n```csharp\n private void Form1_Load(object sender, EventArgs e)\n {\n     List < uploading > data = uploading.Query();\n     foreach(var data1 in data)\n     {\n         comboBox1.Items.Add(data1.name);\n     }\n     comboBox1.SelectedIndex = 0;\n }\n```\n\n comboBox事件触发条件查询到上传的path\n\n```csharp\n private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)\n {\n     List < string > data = uploading.GetName(comboBox1.Text);\n     for(int i = 0; i < data.Count; i++)\n     {\n         textBox1.Text = data[0];\n     }\n }\n```\n\n### 上传事件\n\n```c#\n  private void Button1_Click(object sender, EventArgs e)\n  {\n      string path = textBox1.Text;\n      CopyDirs(textBox3.Text, path);\n  }\n```\n\n```c#\n private void CopyDirs(string srcPath, string aimPath)\n {\n     try\n     {\n         // 检查目标目录是否以目录分割字符结束如果不是则添加\n         if(aimPath[aimPath.Length - 1] != System.IO.Path.DirectorySeparatorChar)\n         {\n             aimPath += System.IO.Path.DirectorySeparatorChar;\n         }\n         // 判断目标目录是否存在如果不存在则新建\n         if(!System.IO.Directory.Exists(aimPath))\n         {\n             System.IO.Directory.CreateDirectory(aimPath);\n         }\n         // 得到源目录的文件列表，该里面是包含文件以及目录路径的一个数组\n         // 如果你指向copy目标文件下面的文件而不包含目录请使用下面的方法\n         // string[] fileList = Directory.GetFiles（srcPath）；\n         string[] fileList = System.IO.Directory.GetFileSystemEntries(srcPath);\n         // 遍历所有的文件和目录\n         foreach(string file in fileList)\n         {\n             // 先当作目录处理如果存在这个目录就递归Copy该目录下面的文件\n             if(System.IO.Directory.Exists(file))\n             {\n                 CopyDir(file, aimPath + System.IO.Path.GetFileName(file));\n                 DisplaylistboxMsg(\"上传成功\");\n             }\n             // 否则直接Copy文件\n             else\n             {\n                 System.IO.File.Copy(file, aimPath + System.IO.Path.GetFileName(file), true);\n                 DisplaylistboxMsg(\"上传成功\");\n             }\n         }\n     }\n     catch(Exception e)\n     {\n         DisplaylistboxMsg(\"上传失败\" + e.Message);\n     }\n }\n```\n\n### 下载事件\n\n```c#\nprivate void Button2_Click(object sender, EventArgs e)\n    {\n        CopyDir(@\"\\\\10.55.2.3\\mech_production_line_sharing\\Test\\\" + textBox2.Text, textBox4.Text);\n        }\n        private void CopyDir(string srcPath, string aimPath)\n        {\n            // 检查目标目录是否以目录分割字符结束如果不是则添加\n            if(aimPath[aimPath.Length - 1] != System.IO.Path.DirectorySeparatorChar)\n            {\n                aimPath += System.IO.Path.DirectorySeparatorChar;\n            }\n            // 判断目标目录是否存在如果不存在则新建\n            if(!System.IO.Directory.Exists(aimPath))\n            {\n                System.IO.Directory.CreateDirectory(aimPath);\n            }\n            // 得到源目录的文件列表，该里面是包含文件以及目录路径的一个数组\n            // 如果你指向copy目标文件下面的文件而不包含目录请使用下面的方法\n            // string[] fileList = Directory.GetFiles（srcPath）；\n            string[] fileList = System.IO.Directory.GetFileSystemEntries(srcPath);\n            // 遍历所有的文件和目录\n            foreach(string file in fileList)\n            {\n                // 先当作目录处理如果存在这个目录就递归Copy该目录下面的文件\n                if(System.IO.Directory.Exists(file))\n                {\n                    CopyDir(file, aimPath + System.IO.Path.GetFileName(file));\n                    DisplaylistboxMsg(\"下载成功\");\n                }\n                // 否则直接Copy文件\n                else\n                {\n                    System.IO.File.Copy(file, aimPath + System.IO.Path.GetFileName(file), true);\n                    DisplaylistboxMsg(\"下载成功\");\n                }\n            }\n        }\n```\n\n',7,0,'blog/4.jpg',0,32,104,4,'2022-12-16 09:22:12','2022-12-16 12:12:03'),
(386,'vue3自定义无限滚动','最初使用的vue3-infinite-scroll-better插件进行滚动加载,打包部署后插件滚动功能失效了也不报错很难查找问题出现在哪部分,只好自己写一个相对简单的功能','最初使用的vue3-infinite-scroll-better插件进行滚动加载,打包部署后插件滚动功能失效了也不报错很难查找问题出现在哪部分,只好自己写一个相对简单的功能\n\n### 监控窗体的滚动值\n\n使用的vueuse\n\n```tsx\nimport { useWindowScroll } from ''@vueuse/core''\n//他是响应式的\nconst { y } = useWindowScroll()\n```\n\n### 定义监听\n\n```tsx\nconst scDisabled = computed(() => {\n  //数据长度小于等于总数返回true\n  return rArticle.value.length <= state.count\n})\n//默认50触发加载内容\nconst cheight = ref(50)\n//对窗体高度进行监听\nwatch(\n  () => {\n    return [y] \n  },\n  async () => {\n    if (scDisabled.value) {\n      if (y.value > cheight.value) {\n        console.log(''触发加载'')\n        cheight.value += 400 //高度\n        state.pagesize += 3 //每次加载3行数据\n        await GetFy() //加载数据\n      }\n    }\n  },\n  { deep: true }\n)\n```\n\n当窗体高度大于cheight字段就加载数据内容\n\n',7,0,'blog/11.jpg',0,31,1,4,'2022-12-16 11:52:14','2022-12-16 12:11:23'),
(387,'c#解压缩的使用','### ZipDirectory\n\n压缩用的库函数ZipDirectory\n\n#### 创建压缩方法','### ZipDirectory\n\n压缩用的库函数ZipDirectory\n\n#### 创建压缩方法\n\n```js\n/// <summary>\n/// 压缩文件夹\n/// </summary>\n/// <param name=\"folderToZip\">需要压缩的文件夹</param>\n/// <param name=\"zipedFileName\">压缩后的Zip完整文件名</param>\npublic static void ZipDirectory(string folderToZip, string zipedFileName)\n    {\n        ZipDirectory(folderToZip, zipedFileName, string.Empty, true, string.Empty, string.Empty, true);\n    }\n    /// <summary>\n    /// 压缩文件夹\n    /// </summary>\n    /// <param name=\"folderToZip\">需要压缩的文件夹</param>\n    /// <param name=\"zipedFileName\">压缩后的Zip完整文件名（如D:\\test.zip）</param>\n    /// <param name=\"isRecurse\">如果文件夹下有子文件夹，是否递归压缩</param>\n    /// <param name=\"password\">解压时需要提供的密码</param>\n    /// <param name=\"fileRegexFilter\">文件过滤正则表达式</param>\n    /// <param name=\"directoryRegexFilter\">文件夹过滤正则表达式</param>\n    /// <param name=\"isCreateEmptyDirectories\">是否压缩文件中的空文件夹</param>\npublic static void ZipDirectory(string folderToZip, string zipedFileName, string password, bool isRecurse, string fileRegexFilter, string directoryRegexFilter, bool isCreateEmptyDirectories)\n{\n    FastZip fastZip = new FastZip();\n    fastZip.CreateEmptyDirectories = isCreateEmptyDirectories;\n    fastZip.Password = password;\n    fastZip.CreateZip(zipedFileName, folderToZip, isRecurse, fileRegexFilter, directoryRegexFilter);\n}\n```\n\n#### 方法调用\n\n```csharp\nprivate void skinButton1_Click(object sender, EventArgs e)\n{\n    FilesUploadFor.ZipDirectory(foldertozip.Text, zipedfilename.Text);\n    filesUploadFor.DisplaylistboxMsg(\"压缩完成\");\n}\n```\n\n### UnZip\n\n解压用的库函数UnZip\n\n#### 创建解压方法\n\n```js\n/// <summary>  \n/// 功能：解压zip格式的文件。  \n/// </summary>  \n/// <param name=\"zipFilePath\">压缩文件路径</param>  \n/// <param name=\"unZipDir\">解压文件存放路径,为空时默认与压缩文件同一级目录下，跟压缩文件同名的文件夹</param>  \n/// <returns>解压是否成功</returns>  \npublic void UnZip(string zipFilePath, string unZipDir)\n{\n    if(zipFilePath == string.Empty)\n    {\n        throw new Exception(\"压缩文件不能为空！\");\n    }\n    if(!File.Exists(zipFilePath))\n    {\n        throw new FileNotFoundException(\"压缩文件不存在！\");\n    }\n    //解压文件夹为空时默认与压缩文件同一级目录下，跟压缩文件同名的文件夹  \n    if(unZipDir == string.Empty) unZipDir = zipFilePath.Replace(Path.GetFileName(zipFilePath), Path.GetFileNameWithoutExtension(zipFilePath));\n    if(!unZipDir.EndsWith(\"/\")) unZipDir += \"/\";\n    if(!Directory.Exists(unZipDir)) Directory.CreateDirectory(unZipDir);\n    using(var s = new ZipInputStream(File.OpenRead(zipFilePath)))\n    {\n        ZipEntry theEntry;\n        while((theEntry = s.GetNextEntry()) != null)\n        {\n            string directoryName = Path.GetDirectoryName(theEntry.Name);\n            string fileName = Path.GetFileName(theEntry.Name);\n            if(!string.IsNullOrEmpty(directoryName))\n            {\n                Directory.CreateDirectory(unZipDir + directoryName);\n            }\n            if(directoryName != null && !directoryName.EndsWith(\"/\"))\n            {}\n            if(fileName != String.Empty)\n            {\n                using(FileStream streamWriter = File.Create(unZipDir + theEntry.Name))\n                {\n                    int size;\n                    byte[] data = new byte[2048];\n                    while(true)\n                    {\n                        size = s.Read(data, 0, data.Length);\n                        if(size > 0)\n                        {\n                            streamWriter.Write(data, 0, size);\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n#### 方法调用\n\n```csharp\nprivate void skinButton2_Click(object sender, EventArgs e)\n{\n    filesUploadFor.UnZip(zipedfilename.Text, \"\");\n    filesUploadFor.DisplaylistboxMsg(\"解压缩完成\");\n}\n```\n',2,0,'blog/14.jpg',0,3,104,4,'2022-12-16 13:57:18','2022-12-16 13:57:18'),
(388,'c#使用Proceess进行windows登录','Process基本属性和方法Id //进程的Id\nProcessName  //进程的名称\nPriorityClass //进程的优先级\n\nHandleCount //进程句柄数\n','### Process基本属性和方法\n\nId //进程的Id\n\nProcessName  //进程的名称\n\nPriorityClass //进程的优先级\n\nHandleCount //进程句柄数\n\nPrivateMemorySize64 //关联的进程分配的专用内存量\n\nWorkingSet64 //工作集，关联的进程分配的物理内存量\n\nStartInfo //进程启动的相关属性\n\nGetProcesses()  //获取当前系统的所有进程\n\nStart()  //启动进程\n\nKill(); //强行杀死进程\n\n### 登录代码\n\n```c#\n/// <summary>\n/// 登录权限\n/// </summary>\n/// <param name=\"path\"></param>\n/// <param name=\"userName\"></param>\n/// <param name=\"passWord\"></param>\n/// <returns></returns>\npublic bool ConnectState(string path, string userName, string passWord)\n{\n    bool Flag = false;\n    //创建一个进程\n    Process proc = new Process();\n    try\n    {\n        proc.StartInfo.FileName = \"cmd.exe\";\n        proc.StartInfo.UseShellExecute = false;\n        proc.StartInfo.RedirectStandardInput = true;\n        proc.StartInfo.RedirectStandardOutput = true;\n        proc.StartInfo.RedirectStandardError = true;\n        proc.StartInfo.CreateNoWindow = true;\n        proc.Start();\n        string dosLine = \"net use \" + path + \" \" + passWord + \" /user:\" + userName;\n        proc.StandardInput.WriteLine(dosLine);\n        proc.StandardInput.WriteLine(\"exit\");\n        while(!proc.HasExited)\n        {\n            proc.WaitForExit(1000);\n        }\n        string errormsg = proc.StandardError.ReadToEnd();\n        proc.StandardError.Close();\n        if(string.IsNullOrEmpty(errormsg))\n        {\n            Flag = true;\n        }\n        else\n        {\n            throw new Exception(errormsg);\n        }\n    }\n    catch(Exception ex)\n    {\n        DisplaylistboxMsg(ex.Message);\n    }\n    finally\n    {\n        proc.Close();\n        proc.Dispose();\n    }\n    return Flag;\n}\n```\n\n### 执行登录\n\n```c#\n private void 登录_Click(object sender, EventArgs e)\n {\n     bool userbool = ConnectState(@\"\\\\10.xx.xx.x\", User, Pwd);\n     if(userbool)\n     {\n        //成功\n     }\n     else\n     {\n        //失败\n     }\n }\n```\n\n',5,0,'blog/5.jpg',0,1,1,4,'2022-12-16 14:20:07','2022-12-16 14:20:07'),
(389,'netcore3.1Swagger中的配置','将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的 服务集合中：','### 配置中间件\n\n将 Swagger 生成器添加到 Startup.ConfigureServices 方法中的 服务集合中：\n\n**ConfigureServices**\n\n```c#\n//注册Swagger生成器，定义一个和多个Swagger 文档\nservices.AddSwaggerGen(c =>\n{\n    c.SwaggerDoc(\"1.0\", new OpenApiInfo\n    {\n        Title = \" KaiOuYang\", //标题  \n            Version = \"1.0.1\", //版本\n            Description = \"A simple example ASP.NET Core Web API\"\n    , });\n    var xmlFile = $ \"{Assembly.GetExecutingAssembly().GetName().Name}.xml\";\n    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);\n    c.IncludeXmlComments(xmlPath, true);\n});\n```\n\n### 启用中间件\n\n在 Startup.Configure 方法中启用中间件为生成的 JSON 文档和 Swagger UI 提供服务：\n\n```c#\n//启用中间件服务生成Swagger作为JSON终结点\napp.UseSwagger();\n//启用中间件服务对swagger-ui，指定Swagger JSON终结点\napp.UseSwaggerUI(c =>\n{\n    c.SwaggerEndpoint(\"/swagger/1.0/swagger.json\", \"TE后台管理\");\n    c.RoutePrefix = string.Empty;\n});\n```\n\n### 启用XML注释\n\n可使用以下方法启用 XML 注释：\n\n- 右键单击“解决方案资源管理器”中的项目，然后选择“属性”\n- 查看“生成”选项卡的“输出”部分下的“XML 文档文件”框\n\n启用 XML 注释后会为未记录的公共类型和成员提供调试信息。如果出现很多警告信息 例如，以下消息指示违反警告代码 1591：\n\n`warning CS1591: Missing XML comment for publicly visible type or member ''TodoController.GetAll()''`\n\n### 显示注释代码\n\nSwagger UI 显示上述注释代码的 \n\n```c#\n /// <summary>\n /// 这是一个带参数的get请求\n /// </summary>\n /// <remarks>\n /// 例子:\n /// Get api/Values/1\n /// </remarks>\n /// <param name=\"id\">主键</param>\n /// <returns>测试字符串</returns>          \n```\n\n### 描述响应类型\n\n```c#\n /// <summary>\n /// 这是一个带参数的get请求\n /// </summary>\n /// <remarks>\n /// 例子:\n /// Get api/Values/1\n /// </remarks>\n /// <param name=\"id\">主键</param>\n /// <returns>测试字符串</returns> \n /// <response code=\"201\">返回value字符串</response>\n/// <response code=\"400\">如果id为空</response>  \n // GET api/values/2\n[HttpGet(\"{id}\")]\n[ProducesResponseType(201)]\n[ProducesResponseType(400)]\npublic ActionResult<string> Get(int id)\n{\n     return $\"你请求的 id 是 {id}\";\n}\n```\n\n',2,0,'blog/8.jpg',0,34,3,4,'2022-12-16 16:20:25','2022-12-16 16:20:25'),
(390,'netcore跨域Cors找不到\"Access-Control-Allow-Origin\"','netcore跨域Cors找不到\"Access-Control-Allow-Origin\"','原文:[net core 3.1 跨域 Cors 找不到 “Access-Control-Allow-Origin”](https://www.cnblogs.com/xiaotimor/p/12068984.html)\n\n### ConfigureServices\n\n```c#\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddCors(options =>\n    {\n        options.AddPolicy(\"any\", builder =>\n        {\n            //builder.AllowAnyOrigin() //允许任何来源的主机访问\n            builder.WithOrigins(\"http://*.*.*.*\") //.SetIsOriginAllowedToAllowWildcardSubdomains()//设置允许访问的域\n                .AllowAnyMethod().AllowAnyHeader().AllowCredentials(); //\n        });\n    });\n    services.AddControllers();\n}\n```\n\n### 新增CorsMiddleware类\n\n```c#\npublic class CorsMiddleware\n{\n    private readonly RequestDelegate _next;\n    public CorsMiddleware(RequestDelegate next)\n    {\n        _next = next;\n    }\n    public async Task Invoke(HttpContext context)\n    {\n        if(!context.Response.Headers.ContainsKey(\"Access-Control-Allow-Origin\"))\n        {\n            context.Response.Headers.Add(\"Access-Control-Allow-Origin\", \"*\");\n        }\n        await _next(context);\n    }\n}\n```\n\n### Configure中使用中间件\n\n```csharp\n app.UseMiddleware<CorsMiddleware>();\n```',21,0,'blog/6.jpg',0,35,3,4,'2022-12-16 16:26:25','2022-12-16 16:26:51'),
(391,'效率工具AutoHotKey','AutoHotkey 是一款 windows 平台下的热键脚本语言程序。可以实现诸如窗口置顶、快速输入、快捷操作等丰富多彩的功能。','# 效率工具AutoHotKey\n\nAutoHotkey 是一款 windows 平台下的热键脚本语言程序。可以实现诸如窗口置顶、快速输入、快捷操作等丰富多彩的功能。\n\n能够通过自定义脚本实现很多快捷、自动化操作，乃至创建图形界面程序，而且占用资源极小，是一个能够高度自定义、可用性极高的工具。\n\n###  下载安装\n\n[AutoHotkey —— 官网](https://www.autohotkey.com/)\n\n[AutoHotkey中文指南](https://www.autoahk.com/help/autohotkey/zh-cn/docs/Tutorial.htm)\n\n### 创建项目\n\n1. 右键点桌面空白处.\n2. 点击 \"新建\" 菜单.\n3. 点击里面的 \"AutoHotkey Script\" 新建一个脚本.\n4. 给脚本命名. 备注: 文件名必须带 .ahk 后缀, 例如 **MyScript.ahk**\n5. 找到刚刚新建的脚本并右键点击它.\n6. 点击 \"Edit Script\".\n7. 一个新窗口被弹出, 也许是记事本. 如果是这样就成功了!\n8. 新建一个文本文件，修改文件后缀名为 **.ahk** 格式也行\n\n\n\n###  快捷键定义\n\n```ruby\n;#代表win，\n\n+代表shift，^代表Ctrl，\n\n！代表Alt ;\n\n 如果要注释，可以用分号 也可以用//\n```\n\n### 热键标记\n\n`!`：是热键标记，这里的感叹号代表键盘上的 alt 键。\n`!n`：即对应键盘热键 alt + n。\n\n常用热键标记对应关系：\n\n- `#` ：win 键\n- `!` ：alt\n- `^` ：ctrl\n- `+` ：shift\n- `&` ：用于连接两个按键(含鼠标按键) 合并成一个自定义热键.\n\n###  连接\n\n符号 `::` 意味着每次按下前面的热键时，随后的命令将会被执行。这里用来连接热键标记和 Run 命令。\n\n### Run 命令\n\nRun 命令：用来启动一个程序、文档、URL 网址或者快捷方式。如：\n\n```ruby\nRun Notepad\nRun C:\\My Documents\\Address List.doc\nRun www.yahoo.com\nRun mailto:someone@somedomain.com\n```\n\n把上面 3 部分组合起来即可实现自定义快捷键。\n\n|                        |              |                               |\n| ---------------------- | ------------ | ----------------------------- |\n| Ctrl                   | ^            | ^                             |\n| Shift                  | +            | +                             |\n| Alt                    | !            | !                             |\n| Windows键              | #            | #                             |\n| #、^、+、!等           | 一般不用     | {#}、{^}、{+}、{!}等          |\n|                        |              |                               |\n| 左Ctrl、左Shift、左Alt | <^   <+   <! |                               |\n| 右Ctrl、右Shift、右Alt | >^   >+   >! |                               |\n| Enter                  |              | {enter}                       |\n| Tab                    |              | {Tab}                         |\n| F1、F12等              | F1、F12等    | {F1}、{F12}等                 |\n| Esc                    |              | {Esc}或{Escape}               |\n| 空格                   |              | {Space}                       |\n| Backspace              |              | {Backspace}或{BS}             |\n| Delete                 |              | {Delete} or {Del}             |\n| Insert                 |              | {Insert} or {Ins}             |\n| ↑、↓、←、→             |              | {Up}、{Down}、{Left}、{Right} |\n| Home键                 |              | {Home}                        |\n| End键                  |              | {End}                         |\n| PageUp键               |              | {PgUp}                        |\n| PageDown键             |              | {PgDn}                        |\n| CapsLock键             |              | {CapsLock}                    |\n\n### 常用操作\n\n####  替换字符\n\n\n一个简单的例子：输入 chinar 自动替换为 `http://www.chinar.xin`\n\n记事本中输入：\n\n第一种写法：\n\n```ruby\n::oyk::http://oykperson.xyz/\n```\n\n第二种写法：\n\n```ruby\n::oyk::\nSend http://oykperson.xyz/\nreturn\n::bky::\nSend https://www.cnblogs.com/\nreturn\n```\n\nAHK语法中： Send 是发送命令， return 是结束\n\n保存后，右键文件 →→ Run Script 运行脚本\n\n然后，当我们输入文本`chinar` 按下 空格键 / 回车键 / tab 键时，会自动帮我们替换为`http://www.chinar.xin`\n\n#### 极速打开网页\n\nWin+0\n\n```ruby\n#0::Run https://tinypng.com/\n```\n\n####  自定义快捷键\n\n打开文件或网址\n\nAlt+n 或+c启动程序\n\n```ruby\n!n::run notepad\n```\n\n```ruby\n!c::run, D:\\SoftwareKit\\_jade_new_soft\\cmd_markdown_win64\\Cmd Markdown.exe\n```\n\n#### 一键拷贝文件路径\n\n只需要**Ctrl+shift+c**即可拷贝文件路径\n\n```ruby\n^+c::\n; null= \nsend ^c\nsleep,200\nclipboard=%clipboard% ;%null%\ntooltip,%clipboard%\nsleep,500\ntooltip,\nreturn\n```\n\n#### 缩写快速打出常用语\n\n键入`/jeff` 后，再加**空格**、或 **tab**、或**回车**\n\n```ruby\n::/mail::gmail@gmail.com\n::/jeff::http://www.jeffjade.com/\n::/con::console.log();\n::/js::javascript:;\n::/fk::轩先生这会子肯定在忙，请骚后。thx。祝君：天天开心，日日欣悦。\n```\n\n#### 激活/打开/隐藏程序\n\n快捷键：Win+C\n\n```ruby\n#c::\nIfWinNotExist ahk_class Chrome_WidgetWin_1\n{\n    Run \"C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe\"\n    WinActivate\n}\nElse IfWinNotActive ahk_class Chrome_WidgetWin_1\n{\n    WinActivate\n}\nElse\n{\n    WinMinimize\n}\nReturn\n```\n\n#### 音量随心所欲\n\n```ruby\n;最钟爱代码之音量随心所欲\n;=========================================================\n~lbutton & enter:: ;鼠标放在任务栏，滚动滚轮实现音量的加减\nexitapp  \n~WheelUp::  \nif (existclass(\"ahk_class Shell_TrayWnd\")=1)  \nSend,{Volume_Up}  \nReturn  \n~WheelDown::  \nif (existclass(\"ahk_class Shell_TrayWnd\")=1)  \nSend,{Volume_Down}  \nReturn  \n~MButton::  \nif (existclass(\"ahk_class Shell_TrayWnd\")=1)  \nSend,{Volume_Mute}  \nReturn  \n\nExistclass(class)  \n{  \nMouseGetPos,,,win  \nWinGet,winid,id,%class%  \nif win = %winid%  \nReturn,1  \nElse  \nReturn,0  \n}\n;=========================================================\n```\n\n#### 得到当前选中文件的路径\n\n```ruby\n;=========================================================\n#+c:: ;用快捷键得到当前选中文件的路径\nsend ^c\nsleep,200\nclipboard=%clipboard% ;windows 复制的时候，剪贴板保存的是“路径”。只是路径不是字符串，只要转换成字符串就可以粘贴出来了\ntooltip,%clipboard% ;提示文本\nsleep,500\ntooltip,\nreturn\n;=========================================================\n```\n\n\n\n#### 开机自启\n\n把需要开机启动的脚本，放入 “启动” 文件夹即可。\n\n**目录：**{C:\\Users\\username\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup}\n\n### 避免和系统快捷键冲突\n\n系统的常用快捷键都是使用Ctrl+XX和Alt+XX来组合的,而Win+XX的很少，所以我们应该尽量使用Win+XX来组合\n\n```ruby\n/*温馨提示*/\n;Windows系统默认的Win快捷键:\n;Win + E：打开资源管理器;\n;Win + D：显示桌面;\n;Win + F：打开查找对话框;\n;Win + R：打开运行对话框;\n;Win + L：锁定电脑;\n;Win + PauseBreak：打开系统属性对话框;\n;Win + Q: 本地文件 / 网页等搜索;\n;Win + U: 打开控制面板－轻松使用设置中心;\n```',1,0,'blog/14.jpg',0,36,105,4,'2022-12-16 17:17:09','2022-12-16 17:17:09'),
(392,'Markdown使用','Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。','## 简介\n\nMarkdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\nMarkdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。\n\nMarkdown 编写的文档后缀为 **.md**, **.markdown**。\n\n## 标题\n\n### 使用 = 和 - 标记一级和二级标题\n\n```markdown\n展示一级标题\n=================\n展示二级标题\n-----------------\n```\n\n###  #号标记\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n## 段落\n\n* 段落的换行是使用两个以上空格加上回车\n\n* 段落没有特殊的格式，直接编写文字就好\n\n## 字体\n\n```markdown\n*斜体文本*\n_斜体文本_\n**粗体文本**\n__粗体文本__\n***粗斜体文本***\n___粗斜体文本___\n```\n\n## 分隔线\n\n使用三个或以上的 `-` 或者 `*` 表示，且这一行只有符号，**注意不要被识别为二级标题即可**，例如中间或者前面可以加空格。\n\n```markdown\n***\n* * *\n*****\n- - -\n----------\n```\n\n## 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 **~~** 即可，实例如下：\n\n```markdown\nRUNOOB.COM\nGOOGLE.COM\n~~BAIDU.COM~~\n```\n\n## 下划线\n\n下划线可以通过 HTML 的  标签来实现：\n\n```markdown\n<u>带下划线文本</u>\n```\n\n## 文字引用\n\n使用 `>` 表示，可以有多个 `>`，表示层级更深，例如\n\n> 一层\n>\n> > > 二层\n> > >\n> > > > > > 三层\n\n```markdown\n> 1\n>> 2\n>>> 3\n```\n\n\n\n## 脚注\n\n脚注是对文本的补充说明。\n\nMarkdown 脚注的格式如下:\n\n```markdown\n[^要注明的文本]\n```\n\n## 列表\n\n列表分两种方式\n\n### 无序列表\n\n无序列表使用星号(*****)、加号(**+**)或是减号(**-**)作为列表标记：\n\n```markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n\n### 有序列表\n\n有序列表使用数字并加上 **.** 号来表示，如：\n\n```markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n\n使用 `1.` （点号后面有个空格）表示有序列表，可嵌套。\n\n1. 第一项\n2. 2323\n3. 233\n\n### 列表嵌套\n\n列表嵌套只需在子列表中的选项添加四个空格即可：\n\n```markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n1. 第一项：\n   - 1232133123\n   - 2132133123\n   - 23213213\n   - 3123\n2. 第二项：\n   - 第二项嵌套的第一个元素\n   - 第二项嵌套的第二个元素\n\n## 区块\n\nMarkdown 区块引用是在段落开头使用 **>** 符号 ，然后后面紧跟一个**空格**符号：\n\n```markdown\n> 区块引用\n> 菜鸟教程\n> 学的不仅是技术更是梦想\n```\n\n另外区块是可以嵌套的，一个 **>** 符号是最外层，两个 **>** 符号是第一层嵌套，以此类推：\n\n```markdown\n> 最外层\n> > 第一层嵌套\n> > > 第二层嵌套\n```\n\n### 区块中使用列表\n\n区块中使用列表实例如下：\n\n```markdown\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> + 第一项\n> + 第二项\n> + 第三项\n```\n\n### 列表中使用区块\n\n如果要在列表项目内放进区块，那么就需要在 **>** 前添加四个空格的缩进。\n\n区块中使用列表实例如下：\n\n```markdown\n* 第一项\n    > 菜鸟教程\n    > 学的不仅是技术更是梦想\n* 第二项\n```\n\n\n\n* 第一项\n\n  > 12323213213213\n  > 学的不仅是技术更是梦想\n\n## 代码\n\n### 行内代码块\n\n如果是段落上的一个函数或片段的代码可以用反引号把它包起来（**`**），例如：\n\n```markdown\n`printf()` 函数\n```\n\n`printf()`函数\n\n`Name=”yukaizhao”`\n\n### 代码区块\n\n代码区块使用 **4 个空格**或者一个**制表符（Tab 键）**。\n\n你也可以用 **```** 包裹一段代码，并指定一种语言（也可以不指定）：\n\n````markdown\n$(document).ready(function () {\n    alert(''RUNOOB'');\n});\n````\n\n## 链接\n\n链接使用方法如下：\n\n```markdown\n[文字描述](链接地址)\n或者\n<链接地址>\n```\n\n例如：\n\n```markdown\n这是一个链接 [菜鸟教程](https://www.runoob.com)\n```\n\n直接使用链接地址：\n\n```markdown\n<https://www.runoob.com>\n```\n\n### 高级链接\n\n我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：\n\n```markdown\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 runoob 作为网址变量 [Runoob][runoob]\n然后在文档的结尾为变量赋值（网址）\n\n  [1]: http://www.google.com/\n  [runoob]: http://www.runoob.com/\n```\n\n[1]: http://www.google.com/\n[runoob]: http://www.runoob.com/\n\n\n\n## 图片\n\nMarkdown 图片语法格式如下：\n\n```markdown\n![alt 属性文本](图片地址)\n![alt 属性文本](图片地址 \"可选标题\")\n```\n\n- 开头一个感叹号 !\n- 接着一个方括号，里面放上图片的替代文字\n- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ''title'' 属性的文字。\n\n使用实例：\n\n```markdown\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\n```\n\n![123](http://static.runoob.com/images/runoob-logo.png)\n\n![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png \"RUNOOB\")\n\n![image-20221101165524031](C:\\Users\\ch190006\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221101165524031.png)\n\n\n\n当然，你也可以像网址那样对图片网址使用变量:\n\n```markdown\n这个链接用 1 作为网址变量 [RUNOOB][1].\n然后在文档的结尾为变量赋值（网址）\n[1]: http://static.runoob.com/images/runoob-logo.png\n```\n\nMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 <img> 标签。\n\n```markdown\n<img src=\"http://static.runoob.com/images/runoob-logo.png\" width=\"50%\">\n```\n\n## 表格\n\n表格使用 **|** 来分隔不同的单元格，使用 **-** 来分隔表头和其他行。\n\n语法格式如下：\n\n```markdown\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n```\n\n| 标题 | 描述 |\n| ---- | ---- |\n\n| 标题 | 描述 |\n| ---- | ---- |\n| 1    |      |\n\n\n\n对齐方式\n\n**我们可以设置表格的对齐方式：**\n\n- **-:** 设置内容和标题栏居右对齐。\n- **:-** 设置内容和标题栏居左对齐。\n- **:-:** 设置内容和标题栏居中对齐。\n\n实例如下：\n\n```markdown\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n```\n\n\n\n## 高级技巧\n\n### 支持的 HTML 元素\n\n不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：`       `等 ，如：\n\n```markdown\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n```\n\n### 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n\n```markdown\n**文本加粗** \n\\*\\* 正常显示星号 \\*\\*\n```\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n```markdown\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n```\n\n### 数学公式\n\n使用 `$` 表示，其中一个 $ 表示在行内，两个 $ 表示独占一行。\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n```markdown\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n```\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix} \n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n${$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n\n### ypora 画流程图、时序图(顺序图)、甘特图\n\n[更多流程图语法]: http://flowchart.js.org/\n\n主要的语法为 `name=>type: describe`，其中 type 主要有以下几种：\n\n1.开始和结束：`start` `end`\n2.输入输出：`inputoutput`\n3.操作：`operation`\n4.条件：`condition`\n5.子程序：`subroutine`\n\n**1、横向流程图源码格式：**\n\n````markdown\n```mermaid\ngraph LR\nA[方形] -->B(圆角)\n    B --> C{条件a}\n    C -->|a=1| D[结果1]\n    C -->|a=2| E[结果2]\n    F[横向流程图]\n```\n````\n\n\n\n```mermaid\ngraph LR\nA[方形] -->B(圆角)\n    B --> C{条件a}\n    C -->|a=1| D[结果1]\n    C -->|a=2| E[结果2]\n    F[横向流程图]\n```\n\n\n\n**2、竖向流程图源码格式：**\n\n````markdown\n```mermaid\ngraph TD\nA[方形] --> B(圆角)\n    B --> C{条件a}\n    C --> |a=1| D[结果1]\n    C --> |a=2| E[结果2]\n    F[竖向流程图]\n```\n````\n\n```mermaid\ngraph TD\nA[方形] --> B(圆角)\n    B --> C{条件a}\n    C --> |a=1| D[结果1]\n    C --> |a=2| E[结果2]\n    F[竖向流程图]\n```\n\n**3、标准流程图源码格式：**\n\n````markdown\n```flow\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst->op->cond\ncond(yes)->io->e\ncond(no)->sub1(right)->op\n```\n````\n\n```flow\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst->op->cond\ncond(yes)->io->e\ncond(no)->sub1(right)->op\n```\n\n**4、标准流程图源码格式（横向）：**\n\n````markdown\n```flow\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst(right)->op(right)->cond\ncond(yes)->io(bottom)->e\ncond(no)->sub1(right)->op\n```\n````\n\n```flow\nst=>start: 开始框\nop=>operation: 处理框\ncond=>condition: 判断框(是或否?)\nsub1=>subroutine: 子流程\nio=>inputoutput: 输入输出框\ne=>end: 结束框\nst(right)->op(right)->cond\ncond(yes)->io(bottom)->e\ncond(no)->sub1(right)->op\n```\n\n**5、UML时序图源码样例：**\n\n````markdown\n```sequence\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象A->对象B: 你真的好吗？\n```\n````\n\n```sequence\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象A->对象B: 你真的好吗？\n```\n\n\n\n**6、UML时序图源码复杂样例：**\n\n````markdown\n```sequence\nTitle: 标题：复杂使用\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象B->小三: 你好吗\n小三-->>对象A: 对象B找我了\n对象A->对象B: 你真的好吗？\nNote over 小三,对象B: 我们是朋友\nparticipant C\nNote right of C: 没人陪我玩\n```\n````\n\n```sequence\nTitle: 标题：复杂使用\n对象A->对象B: 对象B你好吗?（请求）\nNote right of 对象B: 对象B的描述\nNote left of 对象A: 对象A的描述(提示)\n对象B-->对象A: 我很好(响应)\n对象B->小三: 你好吗\n小三-->>对象A: 对象B找我了\n对象A->对象B: 你真的好吗？\nNote over 小三,对象B: 我们是朋友\nparticipant C\nNote right of C: 没人陪我玩\n```\n\n\n\n**7、UML标准时序图样例：**\n\n````markdown\n```mermaid\n%% 时序图例子,-> 直线，-->虚线，->>实线箭头\n  sequenceDiagram\n    participant 张三\n    participant 李四\n    张三->王五: 王五你好吗？\n    loop 健康检查\n        王五->王五: 与疾病战斗\n    end\n    Note right of 王五: 合理 食物 <br/>看医生...\n    李四-->>张三: 很好!\n    王五->李四: 你怎么样?\n    李四-->王五: 很好!\n```\n````\n\n```mermaid\n%% 时序图例子,-> 直线，-->虚线，->>实线箭头\n  sequenceDiagram\n    participant 张三\n    participant 李四\n    张三->王五: 王五你好吗？\n    loop 健康检查\n        王五->王五: 与疾病战斗\n    end\n    Note right of 王五: 合理 食物 <br/>看医生...\n    李四-->>张三: 很好!\n    王五->李四: 你怎么样?\n    李四-->王五: 很好!\n```\n\n\n\n**8、甘特图样例：**\n\n````markdown\n```mermaid\n%% 语法示例\n        gantt\n        dateFormat  YYYY-MM-DD\n        title 软件开发甘特图\n        section 设计\n        需求                      :done,    des1, 2014-01-06,2014-01-08\n        原型                      :active,  des2, 2014-01-09, 3d\n        UI设计                     :         des3, after des2, 5d\n    未来任务                     :         des4, after des3, 5d\n        section 开发\n        学习准备理解需求                      :crit, done, 2014-01-06,24h\n        设计框架                             :crit, done, after des2, 2d\n        开发                                 :crit, active, 3d\n        未来任务                              :crit, 5d\n        耍                                   :2d\n        section 测试\n        功能测试                              :active, a1, after des3, 3d\n        压力测试                               :after a1  , 20h\n        测试报告                               : 48h\n```\n````\n\n```mermaid\n%% 语法示例\n        gantt\n        dateFormat  YYYY-MM-DD\n        title 软件开发甘特图\n        section 设计\n        需求                      :done,    des1, 2014-01-06,2014-01-08\n        原型                      :active,  des2, 2014-01-09, 3d\n        UI设计                     :         des3, after des2, 5d\n    未来任务                     :         des4, after des3, 5d\n        section 开发\n        学习准备理解需求                      :crit, done, 2014-01-06,24h\n        设计框架                             :crit, done, after des2, 2d\n        开发                                 :crit, active, 3d\n        未来任务                              :crit, 5d\n        耍                                   :2d\n        section 测试\n        功能测试                              :active, a1, after des3, 3d\n        压力测试                               :after a1  , 20h\n        测试报告                               : 48h\n```',4,0,'blog/2.jpg',0,37,106,4,'2022-12-16 17:40:10','2022-12-16 17:40:10'),
(393,'WPF控件库MaterialDesignInXamlToolkit','添加 NuGet 包\n\n　　在解决方案管理器视图中的目标项目上右键 -> 管理 NuGet 程序包\n\n或在控制台输入','### 安装控件库\n\n引用 MaterialDesignThemes.Wpf.dll\n\n添加 NuGet 包\n\n　　在解决方案管理器视图中的目标项目上右键 -> 管理 NuGet 程序包\n\n或在控制台输入\n\n```ruby\nInstall-Package MaterialDesignThemes\n```\n\n### 配置App.xaml\n\n配置App.xaml\n\n你需要合并一个主题（Dark或者Light）到你的资源字典，你只需要添如下代码到你的资源字典就能完成此步骤\n\nLight theme：\n\n```xml\n<ResourceDictionary Source=\"pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml\" />\n```\n\n Dark theme:\n\n```xml\n<ResourceDictionary Source=\"pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Dark.xaml\" />\n```\n\n**添加色彩**\n\n```xaml\n<ResourceDictionary Source=\"pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.COLOR_NAME.xaml\" />\n<ResourceDictionary Source=\"pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.COLOR_NAME.xaml\" />\n```\n\n**App.xaml文件**\n\n```xaml\n<Application x:Class=\"MaterialTest.App\"\n             xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n             xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n             StartupUri=\"MainWindow.xaml\">\n    <Application.Resources>\n        <ResourceDictionary>\n            <ResourceDictionary.MergedDictionaries>\n\n                <ResourceDictionary Source=\"pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Light.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MaterialDesignThemes.Wpf;component/Themes/MaterialDesignTheme.Defaults.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Primary/MaterialDesignColor.DeepPurple.xaml\" />\n                <ResourceDictionary Source=\"pack://application:,,,/MaterialDesignColors;component/Themes/Recommended/Accent/MaterialDesignColor.Lime.xaml\" />\n\n            </ResourceDictionary.MergedDictionaries>            \n        </ResourceDictionary>\n    </Application.Resources>\n</Application>\n```\n\n### 配置主窗口文件\n\n```xaml\n<Window [...]\n        TextElement.Foreground=\"{DynamicResource MaterialDesignBody}\"\n        Background=\"{DynamicResource MaterialDesignPaper}\"\n        TextElement.FontWeight=\"Medium\"\n        TextElement.FontSize=\"14\"\n        FontFamily=\"pack://application:,,,/MaterialDesignThemes.Wpf;component/Resources/Roboto/#Roboto\"\n        [...] >\n```\n\n### 控件效果和代码\n\nGitHub 上下载的 MaterialDesignDemo.exe 查看控件效果和代码。\n\nDemo 下载地址：https://github.com/ButchersBoy/MaterialDesignInXamlToolkit/releases\n\nGitHub 地址：[https://github.com/MaterialDesignInXAML/MaterialDesignInXamlToolkit](https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FMaterialDesignInXAML%2FMaterialDesignInXamlToolkit)',1,0,'blog/9.jpg',0,38,104,4,'2022-12-16 17:52:44','2022-12-16 17:52:44'),
(394,'c#中的Path类','Path.GetFullPath(file) 取全路径\nPath.GetFileName(file) 取文件名，包含扩展名','Path类是static类型\n\n### 常用方法\n\n```ruby\nPath.GetFullPath(file) 取全路径\nPath.GetFileName(file) 取文件名，包含扩展名\nPath.GetFileNameWithoutExtension(file) 取文件名，不包含扩展名\nPath.GetExtension(file) 取扩展名\nPath.GetDirectoryName(file) 取路径名\nPath.GetPathRoot(file)  取盘符\nPath.Combine(file1，file2) 合并2个路径\n```\n\n### 常用实现\n\n```c#\nstring str = @\"C:\\Users\\Administrator\\Desktop\\ceshi.txt\";\n//获得文件名\nConsole.WriteLine(Path.GetFileName(str));\n//获得不包含扩展名的文件名\nConsole.WriteLine(Path.GetFileNameWithoutExtension(str));\n//获得文件所在文件夹的名称\nConsole.WriteLine(Path.GetDirectoryName(str));\n//获得文件所在的全路径\nConsole.WriteLine(Path.GetFullPath(str));\n//拼接路径字符串\nConsole.WriteLine(Path.Combine(@\"D:\\a\\b\\\",\"\n            c.txt \"));\n            Console.ReadKey();\n```\n\n### 属性方法\n\n| 属性或方法                                            | 作用                                     |\n| ----------------------------------------------------- | ---------------------------------------- |\n| string ChangeExtension(string path, string extension) | 更改路径字符串的扩展名                   |\n| string Combine(params string[] paths)                 | 将字符串数组组合成一个路径               |\n| string Combine(string path1, string path2)            | 将两个字符串组合成一个路径               |\n| string GetDirectoryName(string path)                  | 返回指定路径字符串的目录信息             |\n| string GetExtension(string path)                      | 返回指定路径字符串的扩展名               |\n| string GetFileName(string path)                       | 返回指定路径字符串的文件名和扩展名       |\n| string GetFileNameWithoutExtension(string path)       | 返回不具有扩展名的指定路径字符串的文件名 |\n| string GetFullPath(string path)                       | 返回指定路径字符串的绝对路径             |\n| char[] GetInvalidFileNameChars()                      | 获取包含不允许在文件名中使用的字符的数组 |\n| char[] GetInvalidPathChars()                          | 获取包含不允许在路径名中使用的字符的数组 |\n| string GetPathRoot(string path)                       | 获取指定路径的根目录信息                 |\n| string GetRandomFileName()                            | 返回随机文件夹名或文件名                 |\n| string GetTempPath()                                  | 返回当前用户的临时文件夹的路径           |\n| bool HasExtension(string path)                        | 返回路径是否包含文件的扩展名             |\n| bool IsPathRooted(string path)                        | 返回路径字符串是否包含根                 |',0,0,'blog/19.jpg',0,37,104,4,'2022-12-17 14:05:37','2022-12-17 14:05:37'),
(395,'C#File文件类','File 类中获取或设置文件信息的常用方法如下表所示。','C# 语言中 File 类同样可以完成与 FileInfo 类相似的功能，但 File 类中也提供了一些不同的方法。\n\nFile 类中获取或设置文件信息的常用方法如下表所示。\n\n| 属性或方法                                                   | 作用                                   |\n| ------------------------------------------------------------ | -------------------------------------- |\n| DateTime GetCreationTime(string path)                        | 返回指定文件或目录的创建日期和时间     |\n| DateTime GetLastAccessTime(string path)                      | 返回上次访问指定文件或目录的日期和时间 |\n| DateTime GetLastWriteTime(string path)                       | 返回上次写入指定文件或目录的日期和时间 |\n| void SetCreationTime(string path, DateTime creationTime)     | 设置创建该文件的日期和时间             |\n| void SetLastAccessTime(string path, DateTime lastAccessTime) | 设置上次访问指定文件的日期和时间       |\n| void SetLastWriteTime(string path, DateTime lastWriteTime)   | 设置上次写入指定文件的日期和时间       |\n\n### File类的方法\n\n​        创建文件：File.Create(@\"文件路径\");\n​        删除文件（彻底删除）：File.Delete(@\"文件路径\");\n​        复制文件内容：File.Copy(被复制文件路径,新文件路径);\n​        剪切文件：File.Move(被剪切文件路径,新文件路径);\n\n以字节形式读取文件：返回字节数组（可以读取任何文件）\n\n\n```c#\nbyte[] buffer = File.ReadAllBytes(@\"文件路径\");  //返回值为字节数组\n//将字节解码，先确定编码方式，再解码字节数组\nstring s = Encoding.GetEncoding(\"编码方式\").GetString(buffer);\nConsole.WriteLine(s); \n```\n\n以字节形式写入文件：\n\n```c#\nstring s = \"今天生活美滋滋\";  //需要写入文件的字符串\n//把字符串用编码转成字节数组\nbyte[] buffer = Encoding.GetEncoding(\"编码方式\").GetByte(s);\nFile.WriteAllBytes(@\"文件路径\",buffer);\n```\n\n以行的形式读取文件内容：返回字符串数组（只能读文本文件，不能读取音乐文件或其他多媒体文件）\n\n```c#\nstring[] str = File.ReadAllLines(@\"文件路径\",Encoding.GetEncoding(\"编码方式\"));\nforeach(string s in str){\n	Console.WriteLine(s);  //一次输出一行\n}\n```\n\n以字符串形式读取文件内容：返回字符串（只能读文本文件，不能读取音乐文件或其他多媒体文件）\n\n```c#\nstring s = File.ReadAllText(@\"文件路径\",字符串,Encoding.GetEncoding(\"编码方式\"));\n```\n\n以行形式写入文件：\n\n```c#\nFile.WriteAllLines(@\"文件路径\",字符串数组,Encoding.GetEncoding(\"编码方式\"));\n```\n\n以字符串形式写入文件内容：\n\n```c#\nFile.WriteAllText(@\"文件路径\",Encoding.GetEncoding(\"编码方式\"));\n```\n\n',2,0,'blog/4.jpg',0,37,104,4,'2022-12-17 14:09:39','2022-12-17 14:10:03'),
(396,'C#FileStream类','文件读写流使用 FileStream 类来表示，FileStream 类主要用于文件的读写，不仅能读写普通的文本文件，还可以读取图像文件、声音文件等不同格式的文件。区别于File类的是它对文件可进行分步读写，减小内存压力，缺点是我们需要手动的关闭和释放资源，','文件读写流使用 FileStream 类来表示，FileStream 类主要用于文件的读写，不仅能读写普通的文本文件，还可以读取图像文件、声音文件等不同格式的文件。区别于File类的是它对文件可进行分步读写，减小内存压力，缺点是我们需要手动的关闭和释放资源，\n\n## FileAccess \n\nFileAccess 枚举类型主要用于设置文件的访问方式，具体的枚举值如下。\n\n- Read：以只读方式打开文件。\n- Write：以写方式打开文件。\n- ReadWrite：以读写方式打开文件。\n\n## FileMode \n\nFileMode 枚举类型主要用于设置文件打开或创建的方式，具体的枚举值如下。\n\n- CreateNew：创建新文件，如果文件已经存在，则会抛出异常。\n- Create：创建文件，如果文件不存在，则删除原来的文件，重新创建文件。\n- Open：打开已经存在的文件，如果文件不存在，则会抛出异常。\n- OpenOrCreate：打开已经存在的文件，如果文件不存在，则创建文件。\n- Truncate：打开已经存在的文件，并清除文件中的内容，保留文件的创建日期。如果文件不存在，则会抛出异常。\n- Append：打开文件，用于向文件中追加内容，如果文件不存在，则创建一个新文件。\n\n## FileShare \n\nFileShare 枚举类型主要用于设置多个对象同时访问同一个文件时的访问控制，具体的枚举值如下。\n\n- None：谢绝共享当前的文件。\n- Read：允许随后打开文件读取信息。\n- ReadWrite：允许随后打开文件读写信息。\n- Write：允许随后打开文件写入信息。\n- Delete：允许随后删除文件。\n- Inheritable：使文件句柄可由子进程继承。\n\n## FileOptions \n\nFileOptions 枚举类型用于设置文件的高级选项，包括文件是否加密、访问后是否删除等，具体的枚举值如下。\n\n- WriteThrough：指示系统应通过任何中间缓存、直接写入磁盘。\n- None：指示在生成 System.IO.FileStream 对象时不应使用其他选项。\n- Encrypted：指示文件是加密的，只能通过用于加密的同一用户账户来解密。\n- DeleteOnClose：指示当不再使用某个文件时自动删除该文件。\n- SequentialScan：指示按从头到尾的顺序访问文件。\n- RandomAccess：指示随机访问文件。\n- Asynchronous：指示文件可用于异步读取和写入。\n\n\nFileStream 类的构造方法有很多，这里介绍一些常用的构造方法，如下表所示。\n\n| 构造方法                                                     | 说明                                                         |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| FileStream(string path, FileMode mode)                       | 使用指定路径的文件、文件模式创建 FileStream 类的实例         |\n| FileStream(string path, FileMode mode, FileAccess access)    | 使用指定路径的文件、文件打开模式、文件访问模式创建 FileStream 类的实例 |\n| FileStream(string path, FileMode mode, FileAccess access, FileShare share) | 使用指定的路径、创建模式、读写权限和共享权限创建 FileStream 类的一个新实例 |\n| FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options) | 使用指定的路径、创建模式、读写权限和共享权限、其他 文件选项创建 FileStream 类的实例 |\n\n##  FileStream\n\n| 属性或方法                                      | 作用                                                         |\n| ----------------------------------------------- | ------------------------------------------------------------ |\n| bool CanRead                                    | 只读属性，获取一个值，该值指示当前流是否支持读取             |\n| bool CanSeek                                    | 只读属性，获取一个值，该值指示当前流是否支持查找             |\n| bool CanWrite                                   | 只读属性，获取一个值，该值指示当前流是否支持写入             |\n| bool IsAsync                                    | 只读属性，获取一个值，该值指示 FileStream 是异步还 是同步打开的 |\n| long Length                                     | 只读属性，获取用字节表示的流长度                             |\n| string Name                                     | 只读属性，获取传递给构造方法的 FileStream 的名称             |\n| long Position                                   | 属性，获取或设置此流的当前位置                               |\n| int Read(byte[] array, int offset, int count)   | 从流中读取字节块并将该数据写入给定缓冲区中                   |\n| int ReadByte()                                  | 从文件中读取一个字节，并将读取位置提升一个字节               |\n| long Seek(lorig offset, SeekOrigin origin)      | 将该流的当前位置设置为给定值                                 |\n| void Lock(long position, long length)           | 防止其他进程读取或写入 System.IO.FileStream                  |\n| void Unlock(long position, long length)         | 允许其他进程访问以前锁定的某个文件的全部或部分               |\n| void Write(byte[] array, int offset, int count) | 将字节块写入文件流                                           |\n| void WriteByte(byte value)                      | 将一个字节写入文件流中的当前位置                             |\n\n## File和FileStream的区别\n\nFile是一个静态类；FileStream是一个非静态类。\n\nFile：是一个**文件**的类，对文件进行操作。其内部封装了对文件的各种操作(MSDN:提供用于创建、复制、删除、移动和打开单一文件的静态方法，并协助创建FileStream对象)。\n\n　　FileStream:**文件流**的类。对txt，xml，avi等文件进行内容写入、读取、复制...时候需要使用的一个工具。\n\n## 创建实例\n\n```c#\nstring path = \"D:\\\\test.txt\";\nFileStream fileStream1 = new FileStream(path, FileMode.Open);\nFileStream fileStream2 = new FileStream(path, FileMode.Open, FileAccess.Read);\nFileStream fileStream3 = new FileStream(path, FileMode.Open, FileAccess.ReadWrite, FileShare.Read);\nFileStream fileStream4 = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.Read, 10, FileOptions.None);\n```\n\n```c#\n//定义文件路径\nstring path = @\"D:\\\\code\\\\test.txt\";\n//创建 FileStream 类的实例\nFileStream fileStream = new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.ReadWrite);\n//定义属性\nstring msg = \"11111\";\n//将字符串转换为字节数组\nbyte[] bytes = Encoding.UTF8.GetBytes(msg);\n//向文件中写入字节数组\nfileStream.Write(bytes, 0, bytes.Length);\n//刷新缓冲区\nfileStream.Flush();\n//关闭流\nfileStream.Close();\n```\n\n```c#\nclass Program\n{\n    static void Main(string[] args)\n    {\n        //定义文件路径\n        string path = @\"D:\\\\code\\\\test.txt\";\n        //判断是否含有指定文件\n        if(File.Exists(path))\n        {\n            FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.Read);\n            //定义存放文件信息的字节数组\n            byte[] bytes = new byte[fileStream.Length];\n            //读取文件信息\n            fileStream.Read(bytes, 0, bytes.Length);\n            //将得到的字节型数组重写编码为字符型数组\n            char[] c = Encoding.UTF8.GetChars(bytes);\n            //输出\n            Console.WriteLine(c);\n            //关闭流\n            fileStream.Close();\n        }\n        else\n        {\n            Console.WriteLine(\"不存在！\");\n        }\n    }\n}\n```\n\n\n\n## 文件复制\n\n```c#\n public class FileSreamTest\n {\n     public static void CopyFile(string source, string target)\n     {\n         //读取文件流\n         using(FileStream fsRead = new FileStream(source, FileMode.Open, FileAccess.Read))\n         {\n             //写入流\n             using(FileStream fsWrite = new FileStream(target, FileMode.OpenOrCreate, FileAccess.Write))\n             {\n                 byte[] buffer = new byte[1024 * 1024 * 5];\n                 while(true)\n                 {\n                     //返回读取字节数\n                     int r = fsRead.Read(buffer, 0, buffer.Length);\n                     if(r == 0)\n                     {\n                         break;\n                     }\n                     //写入\n                     fsWrite.Write(buffer, 0, r);\n                 }\n             }\n         }\n     }\n }\n static void Main(string[] args)\n {\n     string source = @\"E:\\功能流程.7z\";\n     string target = @\"C:\\Users\\CH190006\\Desktop\\Test\\功能流程.7z\";\n     FileSreamTest.CopyFile(source, target);\n     Console.ReadKey();\n }\n```\n\n',0,0,'blog/12.jpg',0,32,104,4,'2022-12-17 14:15:41','2022-12-17 14:15:41'),
(397,'WebAPI约定','约定能做什么？约定在控制器生成前运行，我们可以修改默认的约定，如我们可以向控制器统一添加路由前缀','约定能做什么？约定在控制器生成前运行，我们可以修改默认的约定，如我们可以向控制器统一添加路由前缀\n\n## 默认约定\n\n集将应用于 ContactsConventionController 中的所有操作：\n\n```c#\n[ApiController]\n[ApiConventionType(typeof(DefaultApiConventions))]\n[Route(\"api/[controller]\")]\npublic class ContactsConventionController : ControllerBase\n{\n```\n\n默认的约定集将应用于程序集中的所有操作：\n\n```c#\n[assembly: ApiConventionType(typeof(DefaultApiConventions))]\nnamespace ApiConventions\n{\n    public class Startup\n    {\n```\n\n## 创建API约定\n\n如果默认 API 约定不能满足需要，请创建自己的约定。 约定是：\n\n- 带有方法的静态类型。\n- 能够对操作定义[响应类型](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/advanced/conventions?view=aspnetcore-3.1#response-types)和[命名要求](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/advanced/conventions?view=aspnetcore-3.1#naming-requirements)。\n\n### 响应类型\n\n这些方法使用 `[ProducesResponseType]` 或 `[ProducesDefaultResponseType]` 属性进行批注。 例如：\n\n```csharp\npublic static class MyAppConventions\n{\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public static void Find(int id)\n    {\n    }\n}\n```\n\n如果没有更具体的元数据属性，则将此约定应用于程序集可强制实现以下内容：\n\n- 该约定方法应用于所有名为 `Find` 的操作。\n- `id` 操作上存在名为 `Find` 的参数。\n\n### 命名要求\n\n`[ApiConventionNameMatch]` 和 `[ApiConventionTypeMatch]` 属性可应用于约定方法，确定它们所要应用的操作。 例如：\n\n```csharp\n[ProducesResponseType(StatusCodes.Status200OK)]\n[ProducesResponseType(StatusCodes.Status404NotFound)]\n[ApiConventionNameMatch(ApiConventionNameMatchBehavior.Prefix)]\npublic static void Find(\n    [ApiConventionNameMatch(ApiConventionNameMatchBehavior.Suffix)]\n    int id)\n{ }\n```\n\n在上面的示例中：\n\n- 应用于该方法的 `Microsoft.AspNetCore.Mvc.ApiExplorer.ApiConventionNameMatchBehavior.Prefix` 选项表示该约定可匹配前缀是“Find”的任何操作。 匹配的操作可以是 `Find`、`FindPet` 和 `FindById`。\n- 应用于该参数的 `Microsoft.AspNetCore.Mvc.ApiExplorer.ApiConventionNameMatchBehavior.Suffix` 表示该约定可匹配带有唯一以标识符作为后缀结尾的参数的方法。 示例包括 `id` 或 `petId` 等参数。 与此类似，可将 `ApiConventionTypeMatch` 应用于类型，以约束参数类型。 `params[]` 参数指示无需显式匹配的剩余参数。',2,0,'blog/15.jpg',0,39,104,4,'2022-12-17 14:26:33','2022-12-17 14:26:33'),
(398,'netcore响应状态码','','| 解释说明                                                     | HTTP 状态码 | 涵义                  |\n| :----------------------------------------------------------- | :---------- | :-------------------- |\n| 用于一般性的成功返回，不可用于请求错误返回                   | 200         | OK                    |\n| 资源被创建                                                   | 201         | Created               |\n| 用于资源异步处理的返回，仅表示请求已经收到。对于耗时比较久的处理，一般用异步处理来完成 | 202         | Accepted              |\n| 此状态可能会出现在 PUT、POST、DELETE 的请求中，一般表示资源存在，但消息体中不会返回任何资源相关的状态或信息 | 204         | No Content            |\n| 用于客户端一般性错误信息返回, 在其它 4xx 错误以外的错误，也可以使用，错误信息一般置于 body 中 | 400         | Bad Request           |\n| 接口需要授权访问，为通过授权验证                             | 401         | Unauthorized          |\n| 当前的资源被禁止访问                                         | 403         | Forbidden             |\n| 找不到对应的信息                                             | 404         | Not Found             |\n| 服务器内部错误                                               | 500         | Internal Server Error |\n\n## HTTP 共有四个谓词方法\n\n| HTTP 谓词方法 | 解释说明           |\n| :------------ | :----------------- |\n| GET           | 获取资源信息       |\n| POST          | 提交新的资源信息   |\n| PUT           | 更新已有的资源信息 |\n| DELETE        | 删除资源           |',1,0,'blog/18.jpg',0,39,3,4,'2022-12-17 14:35:20','2022-12-17 14:35:20'),
(399,'netcore3.1api + efcore + DI 封装','IconcardContext.cs\nIRepositoryFactory.cs\nIRepositorys.cs','## 框架结构\n\n实体层： **Typecho.Enties** \n\n仓储层：\n\n**Typecho.IRepository** \n\n```csharp\nIconcardContext.cs\nIRepositoryFactory.cs\nIRepositorys.cs\n```\n\n**Typecho.Repository** \n\n```\nRepositoryFactory.cs\nRepositorys.cs\ntypechoContext.cs\n```\n\n业务层：\n\n**Typecho.IService**\n\n```\nIBaseService.cs\nITypechoTestService.cs\n```\n\n**Typecho.Service**\n\n```\nBaseService.cs\nTypechoService.cs\n```\n\nUI层（api）：\n\n**TypechoCore**\n\n```\nTestController.cs\n```\n\n##   EF从数据库生成实体类到Enties\n\n### 安装依赖包\n\n```ruby\nInstall-Package MySql.Data.EntityFrameworkCore -Pre\nInstall-Package Pomelo.EntityFrameworkCore.MySql\nInstall-Package Microsoft.EntityFrameworkCore.Tools\nInstall-Package Microsoft.VisualStudio.Web.CodeGeneration.Design\n```\n\n### 管理器控制台\n\n输入以下代码\n\n```csharp\nScaffold-DbContext \"server=localhost;userid=root;pwd=1;port=3306;database=syerp;sslmode=none;\" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force\n```\n\n> 自动生成所有类模型文件，typechoContext.cs数据库上下文自动创建好了\n\n```ruby\n-OutputDir  实体文件所存放的文件目录\n-ContextDir DbContext文件存放的目录\n-Context  DbContext文件名\n-Schemas  需要生成实体数据的数据表所在的模式\n-Tables  需要生成实体数据的数据表的集合\n-DataAnnotations\n-UseDatabaseNames  直接使用数据库中的表名和列名（某些版本不支持）\n-Force   强制执行，重写已经存在的实体文件\n```\n\n> 链接： [asp.net core3.1 实战开发（EF+Mysql 从数据库生成实体类到项目）](https://www.cnblogs.com/jiamiemie/p/12683369.html)\n\n##  封装数据访问层\n\n> 封装仓储Repositorys模式，把typechoContext.cs这个类复制到Typecho.Repository程序集中\n\n### typechoContext类：\n\n```c#\nusing Microsoft.EntityFrameworkCore;\nusing Typecho.Enties.Models;\nusing Typecho.IRepository;\n\nnamespace Typecho.Repository\n{\n    public partial class typechoContext : DbContext , IconcardContext\n    {   \n        public typechoContext(DbContextOptions<typechoContext> options)\n            : base(options)\n        {\n        }\n        public virtual DbSet<typecho_comments> typecho_comments { get; set; }\n        public virtual DbSet<typecho_contents> typecho_contents { get; set; }\n        public virtual DbSet<typecho_fields> typecho_fields { get; set; }\n        \n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            modelBuilder.Entity<typecho_comments>(entity =>\n            {\n                entity.HasKey(e => e.coid)\n                    .HasName(\"PRIMARY\");\n\n                entity.HasIndex(e => e.cid)\n                    .HasName(\"cid\");\n            });\n\n            modelBuilder.Entity<typecho_contents>(entity =>\n            {\n                entity.HasKey(e => e.cid)\n                    .HasName(\"PRIMARY\");\n\n                entity.HasIndex(e => e.created)\n                    .HasName(\"created\");\n            });\n\n            modelBuilder.Entity<typecho_fields>(entity =>\n            {\n                entity.HasKey(e => new { e.cid, e.name })\n                    .HasName(\"PRIMARY\");\n                entity.HasIndex(e => e.float_value)\n                    .HasName(\"float_value\");\n            });        \n                     \n        partial void OnModelCreatingPartial(ModelBuilder modelBuilder);\n    }\n}\n\n```\n\n###  IRepositorys接口：\n\n```c#\n public interface IRepositorys<T> : IDisposable where T : class\n    {\n        /// <summary>\n        /// 显式开启数据上下文事务\n        /// </summary>\n        /// <param name=\"isolationLevel\">指定连接的事务锁定行为</param>\n        void BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.Unspecified);\n\n        /// <summary>\n        /// 提交事务的更改\n        /// </summary>\n        void Commit();\n\n        /// <summary>\n        /// 显式回滚事务，仅在显式开启事务后有用\n        /// </summary>\n        void Rollback();\n\n        /// <summary>\n        /// 提交当前单元操作的更改\n        /// </summary>\n        int SaveChanges();\n         Task<int> SaveChangesAsync();\n\n        /// <summary>\n        /// 获取 当前实体类型的查询数据集，数据将使用不跟踪变化的方式来查询，当数据用于展现时，推荐使用此数据集，如果用于新增，更新，删除时，请使用<see cref=\"TrackEntities\"/>数据集\n        /// </summary>\n        IQueryable<T> Entities { get; }\n\n        /// <summary>\n        /// 获取 当前实体类型的查询数据集，当数据用于新增，更新，删除时，使用此数据集，如果数据用于展现，推荐使用<see cref=\"Entities\"/>数据集\n        /// </summary>\n        IQueryable<T> TrackEntities { get; }\n\n        /// <summary>\n        /// 插入 - 通过实体对象添加\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        /// <param name=\"isSave\">是否执行</param>\n        /// /// <returns></returns>\n        T Add(T entity, bool isSave = true);\n         Task<T> AysAdd(T entity, bool isSave = true);\n        /// <summary>\n        /// 批量插入 - 通过实体对象集合添加\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void AddRange(IEnumerable<T> entitys, bool isSave = true);\n\n        /// <summary>\n        /// 删除 - 通过实体对象删除\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(T entity, bool isSave = true);\n\n        /// <summary>\n        /// 批量删除 - 通过实体对象集合删除\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(bool isSave = false, params T[] entitys);\n\n        /// <summary>\n        /// 删除 - 通过主键ID删除\n        /// </summary>\n        /// <param name=\"id\">主键ID</param>\n        Task<int> AsyDelete(object id);\n        int Delete(object id);\n        /// <summary>\n        /// 批量删除 - 通过条件删除\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(Expression<Func<T, bool>> @where, bool isSave = true);\n\n        /// <summary>\n        /// 修改 - 通过实体对象修改\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        Task<int> AysUpdate(T entity);\n\n        int  Update(T entity);\n        /// <summary>\n        /// 批量修改 - 通过实体对象集合修改\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        void Update( params T[] entitys);\n\n        /// <summary>\n        /// 是否满足条件\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        bool Any(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 返回总条数\n        /// </summary>\n        /// <returns></returns>\n        int Count();\n\n        /// <summary>\n        /// 返回总条数 - 通过条件过滤\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        int Count(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 返回第一条记录\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        T FirstOrDefault(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 返回第一条记录 - 通过条件过滤\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        T FirstOrDefault<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n        /// <summary>\n        /// 去重查询\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        IQueryable<T> Distinct(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 条件查询\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        IQueryable<T> Where(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 条件查询 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n        /// <summary>\n        /// 条件分页查询 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"count\">返回总条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        /// <returns></returns>\n        IEnumerable<T> Where<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc = false);\n\n        /// <summary>\n        /// 条件分页查询 - 支持排序 - 支持Select导航属性查询\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"count\">返回总条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        /// <returns></returns>\n        IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, int pageIndex, int pageSize, out int count, bool isDesc = false);\n\n        /// <summary>\n        /// 获取所有数据\n        /// </summary>\n        /// <returns></returns>\n        IQueryable<T> GetAll();\n\n        /// <summary>\n        /// 获取所有数据 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        IQueryable<T> GetAll<TOrder>(Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n        /// <summary>\n        /// 根据ID查询\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"id\">主键ID</param>\n        /// <returns></returns>\n        T GetById<TType>(TType id);\n\n        /// <summary>\n        /// 获取最大值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <returns></returns>\n        TType Max<TType>(Expression<Func<T, TType>> column);\n\n        /// <summary>\n        /// 获取最大值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Max<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 获取最小值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <returns></returns>\n        TType Min<TType>(Expression<Func<T, TType>> column);\n\n        /// <summary>\n        /// 获取最小值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Min<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 获取总数\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"selector\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Sum<TType>(Expression<Func<T, TType>> selector, Expression<Func<T, bool>> @where) where TType : new();\n    }\n```\n\n### Repositorys类，CRUD功能的封装\n\n```c#\n  public class Repositorys<T> : IRepositorys<T> where T : class\n    {\n        private typechoContext _dbContext;\n        private readonly DbSet<T> _dbSet;\n        private readonly string _connStr;\n\n        public Repositorys(IconcardContext mydbcontext)\n        {\n            _dbContext = mydbcontext as typechoContext;\n            if (_dbContext == null)\n            {\n                return;\n            }\n\n            _dbSet = _dbContext.Set<T>();\n            _connStr = _dbContext.Database.GetDbConnection().ConnectionString;\n        }\n\n        public void BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.Unspecified)\n        {\n            if (_dbContext.Database.CurrentTransaction == null)\n            {\n                _dbContext.Database.BeginTransaction(isolationLevel);\n            }\n        }\n\n        public void Commit()\n        {\n            var transaction = this._dbContext.Database.CurrentTransaction;\n            if (transaction != null)\n            {\n                try\n                {\n                    transaction.Commit();\n                }\n                catch (Exception)\n                {\n                    transaction.Rollback();\n                    throw;\n                }\n            }\n        }\n\n        public void Rollback()\n        {\n            if (_dbContext.Database.CurrentTransaction != null)\n            {\n                _dbContext.Database.CurrentTransaction.Rollback();\n            }\n        }\n\n        public int SaveChanges()\n        {\n            return _dbContext.SaveChanges();\n        }\n          public async Task<int> SaveChangesAsync()\n        {\n            return await _dbContext.SaveChangesAsync();\n        }\n\n\n        public IQueryable<T> Entities\n        {\n            get { return _dbSet.AsNoTracking(); }\n        }\n\n        public IQueryable<T> TrackEntities\n        {\n            get { return _dbSet; }\n        }\n\n        public T Add(T entity, bool isSave = true)\n        {\n\n            _dbSet.Add(entity);\n            if (isSave)\n            {\n                SaveChanges();\n            }\n            return entity;\n        }\n\n         public async Task<T> AysAdd(T entity, bool isSave = true)\n        {\n           await _dbSet.AddAsync(entity);\n            if (isSave)\n            {\n               await  SaveChangesAsync();\n            }\n            return entity;\n        }\n\n        public void AddRange(IEnumerable<T> entitys, bool isSave = true)\n        {\n            _dbSet.AddRange(entitys);\n            if (isSave)\n            {\n                SaveChanges();\n            }\n        }\n\n        public void Delete(T entity, bool isSave = true)\n        {\n            this._dbSet.Remove(entity);\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        public void Delete(bool isSave = true, params T[] entitys)\n        {\n            this._dbSet.RemoveRange(entitys);\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        public async Task<int> AsyDelete(object id)\n        {\n             int de = 0;\n             //执行查询\n             var todoItem = await _dbSet.FindAsync(id);\n            if (todoItem == null)\n            {\n                //return NotFound();\n                de = 0;\n            }\n            else\n            {\n              _dbSet.Remove(todoItem);\n             de = SaveChanges();\n            }\n            return de;\n        }\n\n           public int Delete(object id)\n        {\n             int de = 0;\n             //执行查询\n             var todoItem =_dbSet.Find(id);\n            if (todoItem == null)\n            {\n                //return NotFound();\n                de = 0;\n            }\n            else\n            {\n              _dbSet.Remove(todoItem);\n             de = SaveChanges();\n            }\n            return de;\n        }\n\n        public void Delete(Expression<Func<T, bool>> @where, bool isSave = true)\n        {\n            T[] entitys = this._dbSet.Where(@where).ToArray();\n            if (entitys.Length > 0)\n            {\n                this._dbSet.RemoveRange(entitys);\n            }\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        public async Task<int> AysUpdate(T entity)\n        {\n            \n            var entry = this._dbContext.Entry(entity);\n            if (entry.State == EntityState.Detached)\n            {\n                entry.State = EntityState.Modified;\n            }\n            var da = await Task.Run(SaveChangesAsync);\n            return da;\n        }\n\n        public int Update(T entity)\n        {\n            \n            var entry = this._dbContext.Entry(entity);\n            if (entry.State == EntityState.Detached)\n            {\n                entry.State = EntityState.Modified;\n            }\n            var da = SaveChanges();\n            return da;\n        }\n        public void Update( params T[] entitys)\n        {\n            var entry = this._dbContext.Entry(entitys);\n            if (entry.State == EntityState.Detached)\n            {\n                entry.State = EntityState.Modified;\n            }\n            SaveChanges();\n        }\n\n        public bool Any(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.AsNoTracking().Any(@where);\n        }\n\n        public int Count()\n        {\n            return this._dbSet.AsNoTracking().Count();\n        }\n\n        public int Count(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.AsNoTracking().Count(@where);\n        }\n\n        public T FirstOrDefault(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.AsNoTracking().FirstOrDefault(@where);\n        }\n\n        public T FirstOrDefault<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.AsNoTracking().OrderByDescending(order).FirstOrDefault(@where);\n            }\n            else\n            {\n                return this._dbSet.AsNoTracking().OrderBy(order).FirstOrDefault(@where);\n            }\n        }\n\n        public IQueryable<T> Distinct(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.AsNoTracking().Where(@where).Distinct();\n        }\n\n        public IQueryable<T> Where(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.Where(@where);\n        }\n\n        public IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order);\n            }\n        }\n\n        public IEnumerable<T> Where<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc = false)\n        {\n            count = Count();\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n        }\n\n        public IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, int pageIndex, int pageSize, out int count, bool isDesc = false)\n        {\n            count = Count();\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n        }\n\n        public IQueryable<T> GetAll()\n        {\n            return this._dbSet.AsNoTracking();\n        }\n\n        public IQueryable<T> GetAll<TOrder>(Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.AsNoTracking().OrderByDescending(order);\n            }\n            else\n            {\n                return this._dbSet.AsNoTracking().OrderBy(order);\n            }\n        }\n\n        public T GetById<TType>(TType id)\n        {\n            return this._dbSet.Find(id);\n        }\n\n        public TType Max<TType>(Expression<Func<T, TType>> column)\n        {\n            if (this._dbSet.AsNoTracking().Any())\n            {\n                return this._dbSet.AsNoTracking().Max(column);\n            }\n            return default(TType);\n        }\n\n        public TType Max<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where)\n        {\n            if (this._dbSet.AsNoTracking().Any(@where))\n            {\n                return this._dbSet.AsNoTracking().Where(@where).Max(column);\n            }\n            return default(TType);\n        }\n\n        public TType Min<TType>(Expression<Func<T, TType>> column)\n        {\n            if (this._dbSet.AsNoTracking().Any())\n            {\n                return this._dbSet.AsNoTracking().Min(column);\n            }\n            return default(TType);\n        }\n\n        public TType Min<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where)\n        {\n            if (this._dbSet.AsNoTracking().Any(@where))\n            {\n                return this._dbSet.AsNoTracking().Where(@where).Min(column);\n            }\n            return default(TType);\n        }\n\n        public TType Sum<TType>(Expression<Func<T, TType>> selector, Expression<Func<T, bool>> @where) where TType : new()\n        {\n            object result = 0;\n\n            if (new TType().GetType() == typeof(decimal))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, decimal>>);\n            }\n            if (new TType().GetType() == typeof(decimal?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, decimal?>>);\n            }\n            if (new TType().GetType() == typeof(double))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, double>>);\n            }\n            if (new TType().GetType() == typeof(double?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, double?>>);\n            }\n            if (new TType().GetType() == typeof(float))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, float>>);\n            }\n            if (new TType().GetType() == typeof(float?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, float?>>);\n            }\n            if (new TType().GetType() == typeof(int))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, int>>);\n            }\n            if (new TType().GetType() == typeof(int?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, int?>>);\n            }\n            if (new TType().GetType() == typeof(long))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, long>>);\n            }\n            if (new TType().GetType() == typeof(long?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, long?>>);\n            }\n            return (TType)result;\n        }\n\n        public void Dispose()\n        {\n            this._dbContext.Dispose();\n        }\n    }\n```\n\n\n\n## 通过DI创建实例\n\n> 添加RepositoryFactory类和IRepositoryFactory接口\n\n### IRepositoryFactory接口：\n\n```c#\npublic interface IRepositoryFactory\n{\n    IRepositorys < T > CreateRepository < T > (IconcardContext mydbcontext) where T: class;\n}\n```\n\n### RepositoryFactory类：\n\n```c#\npublic class RepositoryFactory: IRepositoryFactory\n{\n    public IRepositorys < T > CreateRepository < T > (IconcardContext mydbcontext) where T: class\n    {\n        return new Repositorys < T > (mydbcontext);\n    }\n}\n```\n\n## Service层\n\n> 添加BaseService类和IBaseService接口\n\n### IBaseService接口：\n\n```c#\npublic interface IBaseService\n{\n    IRepositorys < T > CreateService < T > () where T: class, new();\n}\n```\n\n### BaseService类：\n\n```c#\npublic class BaseService: IBaseService\n{\n    private IRepositoryFactory _repositoryFactory;\n    private IconcardContext _mydbcontext;\n    public BaseService(IRepositoryFactory repositoryFactory, IconcardContext mydbcontext)\n    {\n        this._repositoryFactory = repositoryFactory;\n        this._mydbcontext = mydbcontext;\n    }\n    public IRepositorys < T > CreateService < T > () where T: class, new()\n    {\n        return _repositoryFactory.CreateRepository < T > (_mydbcontext);\n    }\n}\n```\n\n> 添加Service模块xxxService类和IxxxService接口，xxxService类继承父类BaseService，生成构造函数。\n\n```c#\n//构造函数 自动生成\npublic TypechoService(IRepositoryFactory repositoryFactory, IconcardContext mydbcontext) : base(repositoryFactory, mydbcontext)\n        {\n        }\n```\n\n## DI依赖注入配置\n\n### 注册DbContext\n\n```c#\nservices.AddDbContext < typechoContext > (options => options.UseMySql(Configuration.GetConnectionString(\"DefaultConnection\")));\\\\\nappsettings.json \"ConnectionStrings\":\n{\n    \"DefaultConnection\": \"Server=localhost;database=typecho;uid=root;pwd=woshishui;\"\n}\n```\n\n```c#\nservices.AddScoped < IconcardContext, typechoContext > (); //dbc\nservices.AddScoped < IRepositoryFactory, RepositoryFactory > (); //泛型工厂\nservices.AddScoped < ITypechoTestService, TypechoService > (); //ioc\n```\n\n## UI层调用service接口\n\n> TestController ：实现调用仓储封装增删改查\n\n```c#\n[Route(\"api/[controller]\")]\n[ApiController]\npublic class TestController: Controller\n{\n    private readonly typechoContext _coreDbContext;\n    private readonly ITokenHelper _tokenHelper = null;\n    // ITypechoTestService service = new TypechoService();\n    private readonly ITypechoTestService _service; //IOC依赖注入\n    public TestController(typechoContext coreDbContext, ITokenHelper tokenHelper, ITypechoTestService service)\n        {\n            _coreDbContext = coreDbContext;\n            _tokenHelper = tokenHelper;\n            _service = service;\n        }\n        /// <summary>\n        /// 验证Token\n        /// </summary>\n        /// <param name=\"tokenStr\">token</param>\n        /// <returns></returns>\n        [HttpGet(\"ValiToken\")]\n    public ReturnModel ValiToken(string tokenStr)\n        {\n            var ret = new ReturnModel\n            {\n                TnToken = new TnToken()\n            };\n            bool isvilidate = _tokenHelper.ValiToken(tokenStr);\n            if(isvilidate)\n            {\n                ret.Code = 200;\n                ret.Msg = \"Token验证成功\";\n                ret.TnToken.TokenStr = tokenStr;\n            }\n            else\n            {\n                ret.Code = 500;\n                ret.Msg = \"Token验证失败\";\n                ret.TnToken.TokenStr = tokenStr;\n            }\n            return ret;\n        }\n        /// <summary>\n        /// 验证Token 带返回状态\n        /// </summary>\n        /// <param name=\"tokenStr\"></param>\n        /// <returns></returns>\n        [HttpGet(\"ValiTokenState\")]\n    public ReturnModel ValiTokenState(string tokenStr)\n        {\n            var ret = new ReturnModel\n            {\n                TnToken = new TnToken()\n            };\n            string loginID = \"\";\n            TokenType tokenType = _tokenHelper.ValiTokenState(tokenStr, a => a[\"iss\"] == \"WYY\" && a[\"aud\"] == \"EveryTestOne\", action =>\n            {\n                loginID = action[\"loginID\"];\n            });\n            if(tokenType == TokenType.Fail)\n            {\n                ret.Code = 202;\n                ret.Msg = \"token验证失败\";\n                return ret;\n            }\n            if(tokenType == TokenType.Expired)\n            {\n                ret.Code = 205;\n                ret.Msg = \"token已经过期\";\n                return ret;\n            }\n            //..............其他逻辑\n            var data = new List < Dictionary < string,\n                string >> ();\n            var bb = new Dictionary < string,\n                string >\n                {\n                    {\n                        \"Wyy\", \"123456\"\n                    }\n                };\n            data.Add(bb);\n            ret.Code = 200;\n            ret.Msg = \"访问成功!\";\n            ret.Data = data;\n            return ret;\n        }\n        /// <summary>\n        /// 登录测试\n        /// </summary>\n        /// <param name=\"user\"></param>\n        /// <returns></returns>\n        [HttpPost(\"Login\")]\n    public IActionResult Login([FromBody] LoginInput user)\n        {\n            var ret = new ReturnModel();\n            try\n            {\n                if(string.IsNullOrWhiteSpace(user.Username) || string.IsNullOrWhiteSpace(user.Password))\n                {\n                    ret.Code = 201;\n                    ret.Msg = \"用户名密码不能为空\";\n                    return NotFound();\n                }\n                //登录操作 我就没写了 || 假设登录成功\n                if(true)\n                {\n                    Dictionary < string, string > keyValuePairs = new Dictionary < string, string >\n                    {\n                        {\n                            \"loginID\", user.Username\n                        }\n                    };\n                    ret.Code = 200;\n                    ret.Msg = \"登录成功\";\n                    ret.TnToken = _tokenHelper.CreateToken(keyValuePairs);\n                }\n            }\n            catch(Exception ex)\n            {\n                ret.Code = 500;\n                ret.Msg = \"登录失败:\" + ex.Message;\n            }\n            return Ok(ret);\n        }\n        /// <summary>\n        /// 异步查询\n        /// [ApiExplorerSettings(IgnoreApi = true)] 隐藏接口\n        /// </summary>\n        /// <returns></returns>\n        [ServiceFilter(typeof(TokenFilter))]\n        [HttpGet(\"AsyGetTest\")]\n    public async Task < IActionResult > AsyGetTest(string token)\n        {\n            return Ok(await _service.AsyGetTest());\n        }\n        /// <summary>\n        /// 过滤查询\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"AsyGetTestG\")]\n    public async Task < IActionResult > AsyGetTestG(string name)\n        {\n            var courses = _coreDbContext.typecho_test.Where(w => w.name.Contains(name));\n            return Ok(await courses.FirstAsync());\n        }\n        /// <summary>\n        /// 模糊查询\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"AsyGetTestLink\")]\n    public async Task < IActionResult > AsyGetTestLink(string name)\n        {\n            var courses = _coreDbContext.typecho_test.Where(w => EF.Functions.Like(w.name, \"%\"));\n            return Ok(await courses.ToListAsync());\n        }\n        /// <summary>\n        /// 异步删除数据\n        /// </summary>\n        /// <param name=\"id\"></param>\n        /// <returns></returns>\n        [HttpDelete(\"AsyDetTestId\")]\n    public async Task < IActionResult > AsyDetTestId(int id)\n        {\n            return Ok(await _service.AsyDetTestId(id));\n        }\n\n        /// <summary>\n        /// 异步添加数据\n        /// </summary>\n        /// <returns></returns>\n        [HttpPost(\"AsyIntTest\")]\n    public async Task < ActionResult < typecho_test >> AsyIntTest(typecho_test test)\n        {\n            return Ok(await _service.AsyIntTest(test));\n        }\n\n        /// <summary>\n        /// 异步更新数据\n        /// </summary>\n        /// <param name=\"test\"></param>\n        /// <returns></returns>\n        [HttpPut(\"AysUpTest\")]\n    public async Task < IActionResult > AysUpTest(typecho_test test)\n        {\n            var data = await Task.Run(() => _service.AysUpTest(test));\n            return Ok(data);\n        }\n\n}\n```\n\n\n\n## 参考：[三层框架项目搭建教程](https://www.cnblogs.com/han1982/p/11058788.html)',3,0,'blog/18.jpg',0,39,3,4,'2022-12-17 14:57:39','2022-12-17 14:57:39'),
(400,'# netcore3.1设置可跨域','**跨域问题**的出现，简而言之就是基于浏览器同源策略而反馈出来的一种安全机制，是前端开发调用中出现的一种十分常见的问题，且解决方法有多种','> **跨域问题**的出现，简而言之就是基于浏览器同源策略而反馈出来的一种安全机制，是前端开发调用中出现的一种十分常见的问题，且解决方法有多种，比如采用[Nginx](https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020)做代理服务器，或者在前端使用自己的代理服务器，或者是直接在后端设置允许跨域，这里采用的是最后一种解决手段。\n\n### Startup\n\nStartup类里先定义一个全局变量：\n\n```csharp\nreadonly string MyAllowSpecificOrigins = \"_myAllowSpecificOrigins\";//名字随便起\n```\n\n### ConfigureServices\n\nConfigureServices方法里写如下代码：\n\n\n```csharp\n/*请输入您需要格式化的代码*/\nservices.AddCors(options =>\n{\n  options.AddPolicy(MyAllowSpecificOrigins\n    , builder => builder.AllowAnyOrigin()\n    .WithMethods(\"GET\", \"POST\", \"HEAD\", \"PUT\", \"DELETE\", \"OPTIONS\")\n  );\n});\n```\n\n### Configure\n\nConfigure方法里添加中间件：\n\n```csharp\n app.UseCors(MyAllowSpecificOrigins);\n```\n\n\nCORS 中间件必须配置为在对 UseRouting 和 UseEndpoints的调用之间执行。 配置不正确将导致中间件停止正常运行。                                                                                                                                                                                                                                                                                                                                                                                               ',0,0,'blog/5.jpg',0,40,3,4,'2022-12-24 09:56:46','2022-12-24 09:56:46'),
(401,'lambda表达式','lambda运算符：所有的lambda表达式都是用新的lambda运算符 \" `=>` \",可以叫他，“`转到`”或者 “`成为`”。运算符将表达式分为两部分，左边指定输入参数，右边是lambda的主体。lambda 表达式是一个可用于创建委托或表达式树类型的匿名函数','### 学习参考\n\n[[C# lambda表达式（简单易懂）](https://www.cnblogs.com/VikingsTHT/p/5072185.html)]:\n\n[[C# Lambda表达式学习笔记](https://www.cnblogs.com/atomy/p/12080368.html)]\n\n### lambda简介\n\n>    lambda运算符：所有的lambda表达式都是用新的lambda运算符 \" `=>` \",可以叫他，“`转到`”或者 “`成为`”。运算符将表达式分为两部分，左边指定输入参数，右边是lambda的主体。lambda 表达式是一个可用于创建委托或表达式树类型的匿名函数\n\n​    lambda表达式：\n\n​        1.一个参数：`param=>expr`\n\n​        2.多个参数：`(x, y) => x == y`\n\n​        3.显式指定类型：`(int x, string s) => s.Length > x`\n\n​        4.使用空括号指定零个输入参数：`() => SomeMethod()`\n\n**示例1**\n\n> 例如，lambda 表达式 x => x * x 指定名为  x 的参数并返回 x 的值计算的。 如下面的示例所示，可以将此表达式传递给委托类型：\n\n```c#\ndelegate int del(int i);\nstatic void Main(string[] args)\n{\n    del myDelegate = x => x * x;\n    int j = myDelegate(5); //j = 25\n}      \n```\n\n**示例2 多参数**\n\n```c#\n//委托  逛超市\ndelegate int GuangChaoshi(int a, int b);\nstatic void Main(string[] args)\n{\n    GuangChaoshi gwl = (p, z) => z - (p + 10);\n    Console.WriteLine(gwl(10, 100) + \"\"); //打印80，z对应参数b，p对应参数a\n    Console.ReadKey();\n}\n```\n\n**示例2.1 lambda主体运算复杂**\n\n```c#\n/// <summary>\n/// 委托逛超市\n/// </summary>\n/// <param name=\"a\">花费</param>\n/// <param name=\"b\">付钱</param>\n/// <returns>找零</returns>\ndelegate int GuangChaoshi(int a, int b);\nstatic void Main(string[] args)\n{\n    GuangChaoshi gwl = (p, z) =>\n    {\n        int zuidixiaofei = 10;\n        if (p < zuidixiaofei)\n        {\n            return 100;\n        }\n        else\n        {\n            return z - p - 10;\n        }\n    };\n    Console.WriteLine(gwl(10, 100) + \"\"); //打印80，z对应参数b，p对应参数a\n    Console.ReadKey();\n}\n\n```\n\n### 委托表达式\n\n**示例1**\n\n```c#\n Func<int, string> gwl = p => p + 10 + \"--返回类型为string\";            \n            Console.WriteLine(gwl(10) + \"\");   //打印‘20--返回类型为string’，z对应参数b，p对应参数a\n            Console.ReadKey();\n```\n\n**示例2**\n\n```c#\nstatic void Main(string[] args)\n{\n    Func < int, int, bool > gwl = (p, j) =>\n    {\n        if(p + j == 10)\n        {\n            return true;\n        }\n        return false;\n    };\n    Console.WriteLine(gwl(5, 5) + \"\"); //打印‘True’，z对应参数b，p对应参数a\n    Console.ReadKey();\n}\n```\n\n> 说明：从这个例子，我们能看到，p为int类型，j为int类型，返回值为bool类型。\n\n\n\n**示例3**\n\n> 将委托实例化为 Func<int,bool> myFunc，其中 int 是输入参数，bool  是返回值。 始终在最后一个类型参数中指定返回值。 **Func<int, string,  bool>** 定义包含两个输入参数（int 和  string）且返回类型为 bool 的委托。 在调用下面的 **Func** 委托时，该委托将返回 true 或 false 以指示输入参数是否等于  5：\n\n```csharp\nFunc<int, bool> myFunc = x => x == 5;\nbool result = myFunc(4); // returns false of course\n```\n\n示例4\n\n> 当参数类型为 **Expression<Func>** 时，您也可以提供 Lambda 表达式，例如在  System.Linq.Queryable 内定义的标准查询运算符中。 如果指定 **Expression<Func>** 参数，Lambda  将编译为表达式树。\n>\n> 此处显示了一个标准查询运算符， [Count](ms-xhelp:///?method=page&id=overload%3asystem.linq.enumerable.count&vendor=Microsoft&topicVersion=110&topicLocale=ZH-CN)  方法：\n\n```c#\nint[] numbers = { 5, 4, 1, 3, 9, 8, 6, 7, 2, 0 };\nint oddNumbers = numbers.Count(n => n % 2 == 1);\n```\n\n### lambda表达式树\n\n**示例1**\n\n```c#\n/// <summary>\n/// 表达树\n/// </summary>\npublic void ExpressioTest()\n{\n    //创建一个表达式树中的参数，作为一个节点\n    Expression f = Expression.Constant(2);\n    Expression s = Expression.Constant(3);\n    Expression test = Expression.Add(f, s);\n    Console.WriteLine(test);\n}\n```\n\n**示例2**\n\n> 演示如何让 Visual C#  编译器创建一个表示  lambda 表达式 num => num < 5 (C#) 或 Function(num) num < 5 (Visual Basic) 的表达式树。\n\n```c#\nExpression<Func<int, bool>> lambda = num => num < 5;\n```\n\n\n\n**示例3** 编译表达式\n\n> [Expression<  TDelegate> ]类型提供 [Compile](ms-xhelp:///?method=page&id=overload%3asystem.linq.expressions.expression`1.compile&vendor=Microsoft&topicVersion=110&topicLocale=ZH-CN)  方法，该方法将表达式树表示的代码编译成一个可执行委托。\n\n```c#\n// 创建表达式树\nExpression < Func < int, bool >> expr = num => num < 5;\n// 将表达式树编译为委托。\nFunc < int, bool > result = expr.Compile();\n// 调用委托并将结果写入控制台。\nConsole.WriteLine(result(4));\n// Prints True.\n//还可以使用简化的语法\n//编译并运行表达式树。.\n//下面的行可以替换前面的两个语句。\nConsole.WriteLine(expr.Compile()(4));\nConsole.ReadKey();\n// Also prints True.\n```\n\n',2,0,'blog/9.jpg',0,37,104,4,'2022-12-24 10:29:37','2022-12-24 10:29:37'),
(402,'c#扩展方法','并不是任何方法都能作为扩展方法使用——它必须具有以下特征：\n> 它必须在一个非嵌套的、非泛型的静态类中（所以必须是一个静态方法）；','### 扩展方法声明\n\n> 并不是任何方法都能作为扩展方法使用——它必须具有以下特征：\n> 它必须在一个非嵌套的、非泛型的静态类中（所以必须是一个静态方法）；\n> 它至少要有一个参数；\n> 第一个参数必须附加this关键字作为前缀；\n> 第一个参数不能有其他任何修饰符（比如out或ref）；\n> 第一个参数的类型不能是指针类型。  \n\n使用扩展方法有几个值得注意的地方：\n\n1 扩展方法不能和调用的方法放到同一个类中\n\n2 第一个参数必须要，并且必须是this，这是扩展方法的标识。如果方法里面还要传入其他参数，可以在后面追加参数\n\n3 最好保证扩展方法和调用方法在同一个命名空间下\n\n#### 静态类才可以添加扩展方法\n\n```c#\n//必须是静态类才可以添加扩展方法\nstatic class Tests\n{\n    public static string Test(this string test, string name)\n    {\n        return name;\n    }\n}\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string name = null;\n        var test = name.Test(\"name\");\n        Console.WriteLine(test);\n        Console.ReadKey();\n    }\n}\n```\n\n### **一般对象的扩展方法**\n\n```c#\npublic class Person\n{\n    public string Name\n    {\n        set;\n        get;\n    }\n    public int Age\n    {\n        set;\n        get;\n    }\n}\n```\n\n```c#\n//必须是静态类才可以添加扩展方法\n//Person的扩展方法，根据年龄判断是否是成年人\npublic static bool GetBIsChild(this Person oPerson)\n{\n    if(oPerson.Age >= 18) return false;\n    else return true;\n}\n```\n\nMain方法里面调用：\n\n```c#\nvar oPerson1 = new Person();\noPerson1.Age = 20;\nvar bIsChild = oPerson1.GetBIsChild();        \n```\n\n###  泛型对象的扩展\n\n```c#\npublic static class DataContractExtensions\n{\n    //必须是静态类才可以添加扩展方法\n    //测试方法\n    public static T Test < T > (this T instance) where T: Test2\n    {\n        T Res =\n            default(T);\n        try\n        {\n            Res.AttrTest = instance.AttrTest.Substring(0, 2);\n            //其他复杂逻辑...\n        }\n        catch\n        {}\n        return Res;\n    }\n}\npublic class Test2\n{　　\n    public string AttrTest\n    {\n        set;\n        get;\n    }\n}\n```\n\n### 在空引用上调用方法\n\n```c#\n//必须是静态类才可以添加扩展方法\nstatic class Tests\n{\n    public static bool IsNull(this object x)\n    {\n        return x == null;\n    }\n}\nclass Program\n{\n    static void Main(string[] args)\n    {\n        object y = null;\n        Console.WriteLine(y.IsNull());\n        y = new object();\n        Console.WriteLine(y.IsNull());\n        Console.ReadKey();\n    }\n}\n```\n\n> 输出先是True，然后是False。如果IsNull是一个普通的实例方法， Main\n> 的第2行就会抛出一个异常。但是，这里的null是IsNull的实参。在扩展方法问世前， y.Isnull()\n> 这样的写法虽然可读性更好，却不合法，只能采用NullUtil.IsNull(y)这样的写法  \n\n### 集合扩展方法\n\n```c#\n public static void ShowItems < T > (this IEnumerable < T > _al)\n {\n     foreach(var item in _al)\n     {\n         Console.WriteLine(item);\n     }\n }\n```\n\n```c#\n static void Main(string[] args)\n {\n     //调用集合的扩展方法\n     str.ShowItems < char > ();\n }\n```\n\n',4,0,'blog/12.jpg',0,37,104,4,'2022-12-24 10:37:08','2022-12-24 10:37:08'),
(404,'winfrom界面库(CSkin) ','下载地址:[CSkin](http://www.cskin.net/)\n\n博客地址:[kin](http://bbs.cskin.net/)\n\n### 使用步骤\n\n1.工具箱右键-新建项-命名CSkin。','下载地址:[CSkin](http://www.cskin.net/)\n\n博客地址:[kin](http://bbs.cskin.net/)\n\n### 使用步骤\n\n1.工具箱右键-新建项-命名CSkin。\n\n2.将CSkin.dll拖到新建的工具箱栏里。\n\n3.控件添加完毕，控件拖拽到界面即可使用和引用。\n\n4.窗体美化需要继承CCSkinMain。\n\n###  主题美化\n\n```c#\n public partial class FrmMain : Form\n```\n\n 改成：\n\n```c#\n public partial class FrmMain : CCSkinMain\n```\n\n**窗体还可以继承以下等多种主题：**\n\n```csharp\nSkin_Color，\nSkin_DevExpress，\nSkin_Mac， Skin_Metro，\nSkin_VS\n```\n\n### 控件导入\n\n1.在工具箱的里面鼠标右键单击新建的选项卡，点击选择项。\n2.直接点击浏览，选中要添加的CSkin.dll，最新版是18年的。\n注意：工具箱CSkin.dll版本要和项目引用的dll版本相同，否则会冲突。项目引用也需要引用CSkin，不然会报错。\n3.找到下载好的CSkin.dll，选中确定。\n4.查看是否加载控件完毕，继续确定或直接回车Enter。\n5.到这里CSkin的控件就成功加入到工具箱了，看看是否有类似Skin开头的控件，可拖控件使用即可。\n\n\n\n',3,0,'blog/8.jpg',0,2,104,4,'2022-12-24 11:06:51','2022-12-24 11:06:51'),
(405,'c#中WebServices实现','Web Services 可使您的应用程序成为 Web 应用程序。Web Services 通过 Web 进行发布、查找和使用。','Web Services 可使您的应用程序成为 Web 应用程序。\n\nWeb Services 通过 Web 进行发布、查找和使用。\n\n1 创建一个**WebService**的项目\n\n2 添加Web服务（ASMX)\n\n3 启动查看是否正常\n\n### 代码实例\n\n```c#\npublic class WebService1: System.Web.Services.WebService\n{\n    SoundPlayer player = new SoundPlayer();\n    [WebMethod]\n    public string PlayMusic()\n        {\n            player.SoundLocation = @\"D:\\config\\x0pbk-swz4q.wav\";\n            player.Load();\n            player.Play();\n            return \"播放音乐中\";\n        }\n        [WebMethod]\n    public string StopMusic()\n        {\n            player.Stop();\n            player.Dispose();\n            return \"音乐关闭\";\n        }\n        [WebMethod(Description = \"测试\")]\n    public string Test()\n    {\n        return \"正常\";\n    }\n}\n```\n\n### 发布\n\n选择文件夹\n\n发布方法：文件系统\n\n点击发布即可\n\n### 服务引用\n\n打开项目，右键添加服务引用\n\n左下方点击 高级\n\n输入：http://localhost:8092/WebService1.asmx\n\n调用\n\n```c#\n  TE.WebService1 webtest = new TE.WebService1();\n   MessageBox.Show( webtest.PlayMusic());\n```\n\n',2,0,'blog/16.jpg',0,39,104,4,'2022-12-24 11:23:33','2022-12-24 11:23:33'),
(406,'netcore3.1使用jwt登录验证','### nuget安装\n\n```\nMicrosoft.AspNetCore.Authentication.JwtBearer 3.1.0 版本','\n\n### nuget安装\n\n```\nMicrosoft.AspNetCore.Authentication.JwtBearer 3.1.0 版本\n```\n\n### appsettings.json\n\n```json\n  \"Authentication\": { //jwt\n    \"JwtBearer\": {\n      \"IsEnabled\": \"true\",\n      \"SecurityKey\": \"Demo_C421AAEE0D114E9C1\",\n      \"Issuer\": \"Demo\",\n      \"Audience\": \"Demo\",\n      \"Expiration\": 2 //token过期时间 （单位：分钟）\n    }\n  }\n```\n\n### 添加扩展类和jwt配置类\n\n#### AuthConfigure.cs\n\n```csharp\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.IdentityModel.Tokens;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Snblog.Jwt\n{\n   public static class AuthConfigure\n    {\n        public static void ConfigureJwt(this IServiceCollection services, IConfiguration configuration)\n        {\n            if (bool.Parse(configuration[\"Authentication:JwtBearer:IsEnabled\"]))\n            {\n                services.AddAuthentication(options =>\n                {\n                    options.DefaultAuthenticateScheme = \"JwtBearer\";\n                    options.DefaultChallengeScheme = \"JwtBearer\";\n                }).AddJwtBearer(\"JwtBearer\", options =>\n                {\n                    options.Audience = configuration[\"Authentication:JwtBearer:Audience\"];\n \n                    options.TokenValidationParameters = new TokenValidationParameters\n                    {\n                        // The signing key must match!\n                        ValidateIssuerSigningKey = true,\n                        IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(configuration[\"Authentication:JwtBearer:SecurityKey\"])),\n \n                        // Validate the JWT Issuer (iss) claim\n                        ValidateIssuer = true,\n                        ValidIssuer = configuration[\"Authentication:JwtBearer:Issuer\"],\n \n                        // Validate the JWT Audience (aud) claim\n                        ValidateAudience = true,\n                        ValidAudience = configuration[\"Authentication:JwtBearer:Audience\"],\n \n                        // Validate the token expiry\n                        ValidateLifetime = true,\n \n                        // If you want to allow a certain amount of clock drift, set that here\n                        ClockSkew = TimeSpan.Zero\n                    };\n                });\n            }\n        }\n    }\n}\n```\n\n#### JwtConfig.cs\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace Snblog.Jwt\n{\n    public class JwtConfig\n    {\n        /// <summary>\n        /// 密钥\n        /// </summary>\n        public string SecurityKey { get; set; }\n        /// <summary>\n        /// 所属者\n        /// </summary>\n        public string Issuer { get; set; }\n \n        public string Audience { get; set; }\n \n        /// <summary>\n        /// 过期时间\n        /// </summary>\n        public int Expiration { get; set; }\n    }\n}\n\n```\n\n### **配置Startup**\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    //配置jwt\n    services.ConfigureJwt(Configuration);\n    //注入JWT配置文件\n    services.Configure<JwtConfig>(Configuration.GetSection(\"Authentication:JwtBearer\"));\n    services.AddControllers();\n}\n \npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n{\n    app.UseHttpsRedirection();\n    app.UseRouting();\n    app.UseAuthentication(); //一定要在这个位置（app.UseAuthorization()上面）\n    app.UseAuthorization();\n    app.UseEndpoints(endpoints =>\n    {\n        endpoints.MapControllerRoute(\n        name: \"default\",\n        pattern: \"{controller=Home}/{action=Index}/{id?}\");\n    });\n}\n```\n\n### 接口加特性 Authorize\n\n```csharp\n    [Authorize]\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    public class SnArticleController : ControllerBase\n    {   \n    }\n```\n\n### 登录配置\n\n```csharp\n        private readonly JwtConfig jwtModel = null;\n        public SnUserController(ISnUserService service, snblogContext coreDbContext, IOptions < JwtConfig > _jwtModel)\n            {\n                _service = service;\n                _coreDbContext = coreDbContext;\n                user = coreDbContext.SnUser;\n                jwtModel = _jwtModel.Value;\n            }\n        [HttpGet(\"Login\")]\n        public IActionResult Login(string users, string pwd)\n        {\n            if (string.IsNullOrEmpty(users) && string.IsNullOrEmpty(pwd))\n            {\n                return Ok(\"用户密码不能为空\");\n            }\n            var data = from u in user\n            where u.UserName == users && u.UserPwd == pwd\n            select u.UserName;\n            if (data.Count() == 0)\n            {\n                return Ok(\"登录失败\");\n            }\n            else\n            {\n                //return Ok(\"登录成功\");\n                var claims = new List < Claim > ();\n                claims.AddRange(new []\n                {\n                    new Claim(\"UserName\", \"111\")\n                        , new Claim(JwtRegisteredClaimNames.Sub, \"111\")\n                        , new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid()\n                            .ToString())\n                        , new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.Now.ToUnixTimeSeconds()\n                            .ToString(), ClaimValueTypes.Integer64)\n                });\n                DateTime now = DateTime.UtcNow;\n                var jwtSecurityToken = new JwtSecurityToken(\n                    issuer: jwtModel.Issuer\n                    , audience: jwtModel.Audience\n                    , claims: claims\n                    , notBefore: now\n                    , expires: now.Add(TimeSpan.FromMinutes(jwtModel.Expiration))\n                    , signingCredentials: new SigningCredentials(new SymmetricSecurityKey(Encoding.ASCII.GetBytes(jwtModel.SecurityKey)), SecurityAlgorithms.HmacSha256)\n                );\n                string token = new JwtSecurityTokenHandler()\n                    .WriteToken(jwtSecurityToken);\n                return Ok(token);\n            }\n        }\n        \n```\n\n',7,0,'blog/4.jpg',0,39,3,4,'2022-12-24 11:37:48','2022-12-24 11:37:48'),
(407,'netcore3.1集成MiniProfiler','### 安装Nuget\n\n```c#\nInstall-Package MiniProfiler.AspNetCore.Mvc\n```\n\n### startup.cs \n\n```c#','### 安装Nuget\n\n```c#\nInstall-Package MiniProfiler.AspNetCore.Mvc\n```\n\n### startup.cs \n\n```c#\n #region MiniProfiler\n            services.AddMiniProfiler(options =>\n            options.RouteBasePath = \"/profiler\"\n #endregion\n```\n\n### 激活中间件Configure\n\n```c#\n//激活UseMiniProfiler\n app.UseMiniProfiler();\n```\n\n### 自定义Swagger \n\n```html\n<!-- HTML for static distribution bundle build -->\n<script async=\"async\" id=\"mini-profiler\" src=\"/profiler/includes.min.js?v=4.2.1+b27bea37e9\"         data-version=\"4.2.1+b27bea37e9\" data-path=\"/profiler/\"         data-current-id=\"142f3c02-c5d7-42e0-be9e-2a45e46d727a\"         data-ids=\"64b457a1-275e-4bfa-9b2f-e5bd5385a80f,142f3c02-c5d7-42e0-be9e-2a45e46d727a\"         data-position=\"Left\"         data-scheme=\"Light\"         data-authorized=\"true\"         data-max-traces=\"15\"         data-toggle-shortcut=\"Alt+P\"         data-trivial-milliseconds=\"2.0\"         data-ignored-duplicate-execute-types=\"Open,OpenAsync,Close,CloseAsync\"></script> \n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>%(DocumentTitle)</title>\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"./swagger-ui.css\">\n    <link rel=\"icon\" type=\"image/png\" href=\"./favicon-32x32.png\" sizes=\"32x32\" />\n    <link rel=\"icon\" type=\"image/png\" href=\"./favicon-16x16.png\" sizes=\"16x16\" />\n    <style>\n        html {\n            box-sizing: border-box;\n            overflow: -moz-scrollbars-vertical;\n            overflow-y: scroll;\n        }\n        *,\n        *:before,\n        *:after {\n            box-sizing: inherit;\n        }\n        body {\n            margin: 0;\n            background: #fafafa;\n        }\n    </style>\n    %(HeadContent)\n</head>\n\n<body>\n    <div id=\"swagger-ui\"></div>\n    <!-- Workaround for https://github.com/swagger-api/swagger-editor/issues/1371 -->\n    <script>\n        if (window.navigator.userAgent.indexOf(\"Edge\") > -1) {\n            console.log(\"Removing native Edge fetch in favor of swagger-ui''s polyfill\")\n            window.fetch = undefined;\n        }\n    </script>\n    <script src=\"./swagger-ui-bundle.js\"></script>\n    <script src=\"./swagger-ui-standalone-preset.js\"></script>\n    <script>\n        /* Source: https://gist.github.com/lamberta/3768814\n         * Parse a string function definition and return a function object. Does not use eval.\n         * @param {string} str\n         * @return {function}\n         *\n         * Example:\n         *  var f = function (x, y) { return x * y; };\n         *  var g = parseFunction(f.toString());\n         *  g(33, 3); //=> 99\n         */\n        function parseFunction(str) {\n            if (!str) return void (0);\n\n            var fn_body_idx = str.indexOf(''{''),\n                fn_body = str.substring(fn_body_idx + 1, str.lastIndexOf(''}'')),\n                fn_declare = str.substring(0, fn_body_idx),\n                fn_params = fn_declare.substring(fn_declare.indexOf(''('') + 1, fn_declare.lastIndexOf('')'')),\n                args = fn_params.split('','');\n\n            args.push(fn_body);\n\n            function Fn() {\n                return Function.apply(this, args);\n            }\n            Fn.prototype = Function.prototype;\n\n            return new Fn();\n        }\n\n        window.onload = function () {\n            var configObject = JSON.parse(''%(ConfigObject)'');\n            var oauthConfigObject = JSON.parse(''%(OAuthConfigObject)'');\n\n            // Workaround for https://github.com/swagger-api/swagger-ui/issues/5945\n            configObject.urls.forEach(function (item) {\n                if (item.url.startsWith(\"http\") || item.url.startsWith(\"/\")) return;\n                item.url = window.location.href.replace(\"index.html\", item.url).split(''#'')[0];\n            });\n\n            // If validatorUrl is not explicitly provided, disable the feature by setting to null\n            if (!configObject.hasOwnProperty(\"validatorUrl\"))\n                configObject.validatorUrl = null\n\n            // If oauth2RedirectUrl isn''t specified, use the built-in default\n            if (!configObject.hasOwnProperty(\"oauth2RedirectUrl\"))\n                configObject.oauth2RedirectUrl = window.location.href.replace(\"index.html\", \"oauth2-redirect.html\").split(''#'')[0];\n\n            // Apply mandatory parameters\n            configObject.dom_id = \"#swagger-ui\";\n            configObject.presets = [SwaggerUIBundle.presets.apis, SwaggerUIStandalonePreset];\n            configObject.layout = \"StandaloneLayout\";\n\n            // Parse and add interceptor functions\n            var interceptors = JSON.parse(''%(Interceptors)'');\n            if (interceptors.RequestInterceptorFunction)\n                configObject.requestInterceptor = parseFunction(interceptors.RequestInterceptorFunction);\n            if (interceptors.ResponseInterceptorFunction)\n                configObject.responseInterceptor = parseFunction(interceptors.ResponseInterceptorFunction);\n\n            // Begin Swagger UI call region\n\n            const ui = SwaggerUIBundle(configObject);\n\n            ui.initOAuth(oauthConfigObject);\n\n            // End Swagger UI call region\n\n            window.ui = ui\n        }\n    </script>\n</body>\n</html>\n```\n\n将该文件放到API层的根目录下，设置文件属性为【嵌入的资源】\n\n### 修改UseSwaggerUI中间件的配置\n\n注意：这里Snblog是项目的命名空间名\n\n```c#\napp.UseSwaggerUI(c =>\n{\n    c.IndexStream = () => GetType().GetTypeInfo().Assembly.GetManifestResourceStream(\"Snblog.index.html\");\n    ////设置首页为Swagger\n    c.RoutePrefix = string.Empty;\n    //自定义页面 集成性能分析\n    c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"SN博客API\");\n    ////设置为none可折叠所有方法\n    c.DocExpansion(DocExpansion.None);\n    ////设置为-1 可不显示models\n    c.DefaultModelsExpandDepth(-1);\n});\n```\n\n',4,0,'blog/19.jpg',0,39,3,4,'2022-12-24 11:44:01','2022-12-24 11:44:01'),
(409,'netcore中使用Swagger版本控制','### 添加API枚举类型\n\n```c#\n /// <summary>\n /// 版本控制\n /// </summary>','### 添加API枚举类型\n\n```c#\n /// <summary>\n /// 版本控制\n /// </summary>\n public enum ApiVersion\n {\n     V1 = 1,\n     V2 = 2\n }\n```\n\n### **注册Swagger服务**\n\n```c#\n //遍历版本信息\n typeof(ApiVersion).GetEnumNames().ToList().ForEach(version =>\n {\n     c.SwaggerDoc(version, new OpenApiInfo\n     {\n         //Version = \"v1\", //版本号\n         Title = \"SN博客 API\", //标题\n             Description = \"EFCore数据操作 ASP.NET Core Web API\", //描述\n             TermsOfService = new Uri(\"https://example.com/terms\"), //服务条款\n             Contact = new OpenApiContact\n             {\n                 Name = \"Shayne Boyer\", //联系人\n                     Email = string.Empty, //邮箱\n                     Url = new Uri(\"https://twitter.com/spboyer\"), //网站\n             },\n             License = new OpenApiLicense\n             {\n                 Name = \"Use under LICX\", //协议\n                     Url = new Uri(\"https://example.com/license\"), //协议地址\n             }\n     });\n });\n```\n\n### **启用Swagger**\n\n```c#\n  app.UseSwaggerUI(c =>\n  {\n      typeof(ApiVersion).GetEnumNames().ToList().ForEach(version =>\n      {\n          c.IndexStream = () => GetType().GetTypeInfo().Assembly.GetManifestResourceStream(\"Snblog.index.html\");\n          ////设置首页为Swagger\n          c.RoutePrefix = string.Empty;\n          //自定义页面 集成性能分析\n          c.SwaggerEndpoint($ \"/swagger/{version}/swagger.json\", version);\n          ////设置为none可折叠所有方法\n          c.DocExpansion(DocExpansion.None);\n          ////设置为-1 可不显示models\n          c.DefaultModelsExpandDepth(-1);\n      });\n  });\n```\n\n### **在控制器中使用ApiExplorerSettings标记**\n\n```c#\n[ApiExplorerSettings(GroupName = \"V1\")]\n```',2,0,'blog/12.jpg',0,39,3,4,'2022-12-24 14:01:23','2022-12-24 14:01:23'),
(412,'netcore自定义接口依赖注入DI','namespace Snblog.Cache.CacheUtil public interface ICacheUtil// <summary>\n        /// 设置并返回缓存值(值类型)\n        /// </summary>\n        /// <typeparam name=\"T\">返回类型</typeparam>','### 定义接口\n\n**ICacheUtil.cs**\n\n```c#\nnamespace Snblog.Cache.CacheUtil\n{\n    public interface ICacheUtil\n    {\n        /// <summary>\n        /// 设置并返回缓存值(值类型)\n        /// </summary>\n        /// <typeparam name=\"T\">返回类型</typeparam>\n        /// <param name=\"key\">缓存键值</param>\n        /// <param name=\"value\">要缓存的值</param>\n        /// <returns>result</returns>\n        public T CacheNumber<T>(string key, T value);\n        /// <summary>\n        /// 设置并返回缓存值(字符串)\n        /// </summary>\n        /// <typeparam name=\"T\">返回类型</typeparam>\n        /// <param name=\"key\">缓存键值</param>\n        /// <param name=\"value\">要缓存的值</param>\n        public T CacheString<T>(string key, T value);\n    }\n}\n\n```\n\n### 继承接口\n\n```c#\nusing Snblog.Cache.Cache;\n\nnamespace Snblog.Cache.CacheUtil\n{\n    public class CacheUtil:ICacheUtil\n    {\n        //创建内存缓存对象\n        private static CacheManager _cache = new CacheManager();\n        /// <summary>\n        /// 设置并返回缓存值(值类型)\n        /// </summary>\n        /// <typeparam name=\"T\">返回类型</typeparam>\n        /// <param name=\"key\">缓存键值</param>\n        /// <param name=\"value\">要缓存的值</param>\n        /// <returns>result</returns>\n        public T CacheNumber<T>(string key, T value)\n        {\n            T result = default;\n            if (_cache.IsInCache(key)) //如果存在缓存取值\n            {\n                result = _cache.Get<T>(key);\n            }\n            else\n            {\n                if (!value.Equals(0))\n                {\n                _cache.Set_AbsoluteExpire<T>(key, value, _cache.time);\n                }\n            }\n            return result;\n        }\n\n          /// <summary>\n        /// 设置并返回缓存值(字符串)\n        /// </summary>\n        /// <typeparam name=\"T\">返回类型</typeparam>\n        /// <param name=\"key\">缓存键值</param>\n        /// <param name=\"value\">要缓存的值</param>\n        public T CacheString<T>(string key, T value)\n        {\n            T result = default;\n            if (_cache.IsInCache(key)) //如果存在缓存取值\n            {\n                result = _cache.Get<T>(key);\n            }\n            else\n            {\n                if (value != null)\n                {\n                    _cache.Set_AbsoluteExpire<T>(key, value, _cache.time);\n                }\n            }\n            return result;\n        }\n    }\n}\n\n```\n\n### DI依赖注入配置\n\n**ConfigureServices**\n\n```c#\nservices.AddScoped<ICacheUtil,CacheUtil>();\n```\n\n\n\n### 使用\n\n```c#\nprivate readonly CacheUtil _cacheUtil;\npublic SnArticleService(ICacheUtil cacheUtil,IRepositoryFactory repositoryFactory, IconcardContext mydbcontext, snblogContext coreDbContext, ILogger<SnArticleService> logger) : base(repositoryFactory, mydbcontext)\n        {\n            _coreDbContext = coreDbContext;\n            _cacheUtil= (CacheUtil)cacheUtil;\n            _logger = logger ?? throw new ArgumentNullException(nameof(Logger));\n        }\n        \n  result = _cacheUtil.CacheString(\"AsyGetTestName\" + id, result);\n```\n\n\n\n### 实例的生命周期\n\n我们上面看到了，.NET Core DI 为我们提供的实例生命周其包括三种：\n\n- Transient： 每一次GetService都会创建一个新的实例\n- Scoped： 在同一个Scope内只初始化一个实例 ，可以理解为（ 每一个request级别只创建一个实例，同一个http request会在一个 scope内）\n- Singleton ：整个应用程序生命周期以内只创建一个实例 ',2,0,'blog/7.jpg',0,42,1,4,'2022-12-24 16:45:37','2022-12-24 16:45:37'),
(413,'markdownlint插件规范Rules规则','原文：https://yijiebuyi.com/blog/79347d0e8c1739bd1f9d9d7c1dcbcccf.html\n\n### MD001\n\n Heading levels should only increment by one level at a time\n\n```\n标题级数只能每次扩大一个，也就是说不能隔级创建标题，必须h1-h2-h3...这样','原文：https://yijiebuyi.com/blog/79347d0e8c1739bd1f9d9d7c1dcbcccf.html\n\n### MD001\n\n Heading levels should only increment by one level at a time\n\n```\n标题级数只能每次扩大一个，也就是说不能隔级创建标题，必须h1-h2-h3...这样\n```\n\n### MD002 \n\nFirst heading should be a top level heading\n\n```\n文档的第一个标题必须是最高级的标题，也就是h1\n```\n\n### MD003\n\nHeading style\n\n```\n整篇文档的标题格式要统一\n```\n\n### MD004 \n\n Unordered list style\n\n```\n整篇文档的无序列表的格式要一致\n```\n\n### MD005 \n\nInconsistent indentation for list items at the same level\n\n```\n同一个等级的列表的缩进要一致\n```\n\n### MD006\n\n Consider starting bulleted lists at the beginning of the line\n\n```\n一级标题不能够缩进\n```\n\n### MD007 \n\nUnordered list indentation\n\n```\n无序列表嵌套的时候默认采取两个空格的缩进方式\n```\n\n### MD009 \n\n Trailing spaces\n\n```\n行尾最多可以添加两个空格，超出之后会有警告，最好每次都是两个空格因为两个空格刚好可以用来换行\n```\n\n### MD010\n\nHard tabs\n\n```\n不能使用tab来进行缩进，要使用空格\n```\n\n### MD011 \n\nReversed link syntax\n\n```\n内联形式的链接和创建方式是否错误，中括号和圆括号是否使用正确\n```\n\n### MD012\n\nMultiple consecutive blank lines\n\n```\n文档中不能有连续的空行（文档末可以有一个空行），在代码块中这个规则不会生效\n```\n\n### MD013\n\n Line length\n\n```\n默认行的最大长度是80，对表格代码块标题都起效果\n```\n\n### MD014\n\nDollar signs used before commands without showing output\n\n```\n在代码块中，终端命令前面不需要有美元符号，如果如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)\n```\n\n### MD018\n\nNo space after hash on atx style heading\n\n```\n标题格式如果是\"atx\"的话，#号和文字之间需要一个空格隔开\n```\n\n### MD019\n\n Multiple spaces after hash on atx style heading\n\n```\n标题格式如果是\"atx\"的话，#号和文字之间只需要一个空格隔开，不需要多个\n```\n\n### MD020 \n\nNo space inside hashes on closed atx style heading\n\n```\n在closed_atx格式的标题中，文字和前后的#号之间都需要一个空格隔开\n```\n\n### MD021\n\nMultiple spaces inside hashes on closed atx style heading\n\n```\n在closed_atx格式的标题中，文字和前后的#号之间只需要一个空格隔开，不能有多余的\n```\n\n### MD022\n\nHeadings should be surrounded by blank lines\n\n```\n标题的上下行必须都是空格\n```\n\n### MD023\n\n Headings must start at the beginning of the line\n\n```\n标题行不能缩进\n```\n\n### MD024\n\nMultiple headings with the same content\n\n```\n在文档中不能有重复性的标题\n```\n\n### MD025 \n\nMultiple top level headings in the same document\n\n```\n同一个文档中，只能有一个最高级的标题，默认也只能有一个一级标题\n```\n\n### MD026 \n\nTrailing punctuation in heading\n\n```\n标题的末尾不能有\". , ; : ! ? \"这些符号\n```\n\n### MD027 \n\nMultiple spaces after blockquote symbol\n\n```\n在创建引用块的时候，右尖号与文字之间必须有且只有一个空格\n```\n\n### MD028 \n\nBlank line inside blockquote\n\n```\n两个引用区块间不能仅用一个空行隔开或者同一引用区块中不能有空行，如果一行中没有内容，则这一行要用>开头\n```\n\n### MD029 \n\nOrdered list item prefix\n\n```\n有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字\n```\n\n### MD030\n\nSpaces after list markers\n\n```\n列表（有序、无序）的前缀符号和文字之间用1个空格隔开，在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进3个空格\n```\n\n### MD031 \n\nFenced code blocks should be surrounded by blank lines\n\n```\n单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块\n```\n\n### MD032\n\nLists should be surrounded by blank lines\n\n```\n列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表，列表的缩进必须一致，否则会警告\n```\n\n### MD033\n\nInline HTML\n\n```\n文档中不允许使用html语句\n```\n\n### MD034 \n\nBare URL used\n\n```\n单纯的链接地址需要用尖括号 (<>) 包裹，否则有些解释器不会解释为链接\n```\n\n### MD035\n\n Horizontal rule style\n\n```\n创建水平线时整篇文档要统一，要和文档中第一次创建水平线使用的符号一致\n```\n\n### MD036 \n\n Emphasis used instead of a heading\n\n```\n不能用强调来代替标题 ****\n```\n\n### MD037 \n\n Spaces inside emphasis markers\n\n```\n强调的符号和文字之间不能有空格\n```\n\n### MD038\n\nSpaces inside code span elements\n\n```\n当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格，如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开\n```\n\n### MD039\n\nSpaces inside link text\n\n```\n链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格\n```\n\n### MD040\n\nFenced code blocks should have a language specified\n\n```\n单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮\n```\n\n### MD041 \n\nFirst line in file should be a top level heading\n\n```\n文档的第一个非空行应该是文档最高级的标题，默认是1级标题\n```\n\n### MD042\n\nNo empty links\n\n```\n链接的地址不能为空\n```\n\n### MD043 \n\nRequired heading structure\n\n```\n要求标题遵循一定的结构，默认是没有规定的结构\n```\n\n### MD044\n\nProper names should have the correct capitalization\n\n```\n指定一些名称，会检查它是否有正确的大写\n```\n\n### MD045\n\n Images should have alternate text (alt text)\n\n```\n图片链接必须包含描述文\n```\n\n### MD046\n\n Code block style\n\n```\n整篇文档采用一致的代码格式\n```\n\n### MD047\n\nFiles should end with a single newline character\n\n```\n文档末尾需要一个空行结尾\n```',3,0,'blog/20.jpg',0,43,106,4,'2022-12-24 16:49:56','2022-12-24 16:49:56'),
(417,'netcore使用AngleSharp爬取数据','### nuget\n\n```\nInstall-Package AngleSharp\n```\n\n### 创建AngleSharpController.cs\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing Snblog.Service.AngleSharp;\nusing System.Threading.Tasks;','### nuget\n\n```\nInstall-Package AngleSharp\n```\n\n### 创建AngleSharpController.cs\n\n```csharp\nusing Microsoft.AspNetCore.Mvc;\nusing Snblog.Service.AngleSharp;\nusing System.Threading.Tasks;\n\n//默认的约定集将应用于程序集中的所有操作：\n[assembly: ApiConventionType(typeof(DefaultApiConventions))]\nnamespace Snblog.ControllersAngleSharp\n{\n    [Route(\"api/[controller]\")]\n    [ApiExplorerSettings(GroupName = \"AngleSharp\")] //版本控制\n    [ApiController]\n    public class AngleSharpController : ControllerBase\n    {\n        private readonly HotNewsAngleSharp _angle; //IOC依赖注入\n        #region 构造函数\n        public AngleSharpController(HotNewsAngleSharp angle)\n        {\n            _angle = angle;\n        }\n        #endregion\n        /// <summary>\n        /// 读取博客园最新文章\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"Cnblogs\")]\n        public async Task<IActionResult> Cnblogs() => Ok(await _angle.Cnblogs());\n          /// <summary>\n        /// 读取项目名称\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"GiteeItem\")]\n        public async Task<IActionResult> GiteeItem() => Ok(await _angle.GiteeItem());\n    }\n}\n```\n\n### Startup.cs注入\n\n```c#\nservices.AddScoped<HotNewsAngleSharp, HotNewsAngleSharp>();\n```\n\n### 测试调用\n\n**AngleSharpController.cs**\n\n```c#\nusing Microsoft.AspNetCore.Mvc;\nusing Snblog.Service.AngleSharp;\nusing System.Threading.Tasks;\n\n//默认的约定集将应用于程序集中的所有操作：\n[assembly: ApiConventionType(typeof(DefaultApiConventions))]\nnamespace Snblog.ControllersAngleSharp\n{\n    [Route(\"api/[controller]\")]\n    [ApiExplorerSettings(GroupName = \"AngleSharp\")] //版本控制\n    [ApiController]\n    public class AngleSharpController : ControllerBase\n    {\n        private readonly HotNewsAngleSharp _angle; //IOC依赖注入\n        #region 构造函数\n        public AngleSharpController(HotNewsAngleSharp angle)\n        {\n            _angle = angle;\n        }\n        #endregion\n        /// <summary>\n        /// 读取博客园最新文章\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"Cnblogs\")]\n        public async Task<IActionResult> Cnblogs() => Ok(await _angle.Cnblogs());\n          /// <summary>\n        /// 读取项目名称\n        /// </summary>\n        /// <returns></returns>\n        [HttpGet(\"GiteeItem\")]\n        public async Task<IActionResult> GiteeItem() => Ok(await _angle.GiteeItem());\n    }\n}\n```\n\n### 例子\n\n```c#\n获取p元素的NodeList\nvar matches = document.querySelectorAll(\"p\");\n\n返回所有div元素列表 其中class包含 note或alert\nvar matches = document.querySelectorAll(\"div.note, div.alert\");\n\n在这里，我们得到一个<p>元素的列表，其直接父元素是一个class为\"highlighted\"的div，并且位于ID为\"test\"的容器内。\nvar container = document.querySelector(\"#test\");\nvar matches = container.querySelectorAll(\"div.highlighted > p\");\n\n此示例使用属性选择器返回文档中属性名为\"data-src\"的iframe元素列表：\nvar matches = document.querySelectorAll(\"iframe[data-src]\");\n\n这里，属性选择器用于返回ID为\"userlist\"的列表中包含值为\"1\"的\"data-active\"属性的元素\nvar container = document.querySelector(\"#userlist\");\nvar matches = container.querySelectorAll(\"li[data-active=''1'']\");\n```',12,0,'blog/2.jpg',0,46,3,4,'2022-12-26 09:38:05','2022-12-26 09:38:05'),
(419,'netcore数据映射(AutoMapper)','数据库的实体模型和视图模型进行分离\n\n数据库持久化对象（Persistent Object）：顾名思义，这个对象是用来将我们的数据持久化到数据库，一般来说，持久化对象中的字段会与数据库中对应的 table 保持一致。\n','数据库的实体模型和视图模型进行分离\n\n数据库持久化对象（Persistent Object）：顾名思义，这个对象是用来将我们的数据持久化到数据库，一般来说，持久化对象中的字段会与数据库中对应的 table 保持一致。\n\n视图对象（View Object）：视图对象 VO 是面向前端用户页面的，一般会包含呈现给用户的某个页面/组件中所包含的所有数据字段信息。\n\n数据传输对象（Data Transfer Object）：数据传输对象 DTO 一般用于前端展示层与后台服务层之间的数据传递，以一种媒介的形式完成 数据库持久化对象 与 视图对象 之间的数据传递。\n\n### NuGet\n\n通过 NuGet 安装 AutoMapper 的包。\n\n```c#\nAutoMapper \nAutoMapper.Extensions.Microsoft.Dependencylnjection\n```\n\n\n\n### 配置对象转换\n\n创建MappingProfile继承抽象类 Profile\n\n```c#\nusing AutoMapper;\nusing Snblog.Models;\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\n\nnamespace Snblog.Enties.AutoMapper\n{\n    public class MappingProfile : Profile\n    {\n        /// <summary>\n        /// 配置构造函数，用来创建关系映射\n        /// </summary>\n        public MappingProfile()\n        {\n            //构建实体映射规则添加映射对象  \n            //如两个实体字段一致可直接映射关系\n            //SnUser原对象类型，SnUserDto 目标对象类型  ReverseMap，可相互转换\n            CreateMap<SnUser, SnUserDto>().ReverseMap(); \n            //CreateMap<SnUser, SnUserDto>();\n            //CreateMap<SnUserDto, SnUser>();\n        }\n    }\n}\n\n```\n\n### 表实体\n\n在转化的时候只有名字相同的字段才会成功附上对应的值。\n\n**数据库实体**\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Snblog.Models\n{\n    public partial class SnUser\n    {\n        public int UserId { get; set; }\n        public string UserIp { get; set; }\n        public string UserName { get; set; }\n        public string UserEmail { get; set; }\n        public string UserPwd { get; set; }\n        public string UserPhoto { get; set; }\n        public string UserTime { get; set; }\n        public string UserNickname { get; set; }\n        public string UserBrief { get; set; }\n    }\n}\n\n```\n\n**视图模型**\n\n```c#\nusing System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace Snblog.Models\n{\n    public partial class SnUserDto\n    {\n        public int UserId { get; set; }\n        public string UserIp { get; set; }\n        public string UserName { get; set; }\n        public string UserEmail { get; set; }\n        public string UserPwd { get; set; }\n        public string UserPhoto { get; set; }\n        public string UserTime { get; set; }\n        public string UserNickname { get; set; }\n        public string UserBrief { get; set; }\n    }\n}\n\n```\n\n\n\n### 注册服务\n\n```c#\n            #region 实体映射\n            services.AddAutoMapper(typeof(MappingProfile));\n            #endregion\n```\n\n#### 自动化注册 1\n\n```c#\n            //自动化注册\n            //Assembly.Load() 里面传的是当前项目的名称，或者类库的名称。获取当前项目下的所有类文件。\n            //通过 Lamda 表达式 Where 找到所有以 Mapper 结尾的文件。\n            //这样就可以自动注册项目内的所有 Mapper 文件了。\n            services.AddAutoMapper(\n               Assembly.Load(\"Snblog.Enties\").GetTypes()\n                   .Where(t => t.FullName.EndsWith(\"Mapper\"))\n                   .ToArray()\n           );\n```\n\n#### 自动化注册 2\n\n添加接口类 IProfile\n\n```c#\n    public interface IProfile\n    {\n     \n    }\n```\n\n在所有的 Mapper 类里面，实现这个接口。\n\n```c#\n    public class UserMapper : Profile, IProfile\n    {\n        public UserMapper()\n        {\n            CreateMap<UserDto, User>();\n            CreateMap<User, UserViewModel>()\n                .BeforeMap((u, v) => u.Remark = \"Good\")\n                .ForMember(v => v.DepartmentId, u => u.MapFrom(user => user.DepartmentId))\n                .ForMember(v => v.DepartmentName, u => u.MapFrom(user => user.DepartmentInfo.Name))\n                .AfterMap((u, v) => u.Age++);\n        }\n    }\n```\n\n\n\n再通过查找所有实现了 IProfile 接口的类，就可以找到所有的 Mapper 对象。\n\n（ Profile 是 AutoMapper 组件里的接口，必须自定义项目中的唯一标记。）\n\n创建 MapperRegister 类，实现获取所有的 Mapper 对象。\n\n```c#\n    public class MapperRegister\n    {\n        /// <summary>\n        /// 通过反射自动化注册\n        /// </summary>\n        /// <returns></returns>\n        public static Type[] MapType()\n        {\n            Assembly ass = Assembly.GetAssembly(typeof(IProfile));\n            Type[] types = ass.GetTypes();\n\n            List<Type> allList = new List<Type>();\n\n            foreach (Type item in types)\n            {\n                if (item.IsInterface) continue;//判断是否是接口\n                Type[] ins = item.GetInterfaces();\n                foreach (Type ty in ins)\n                {\n                    if (ty == typeof(IProfile))\n                    {\n                        allList.Add(item);\n                    }\n                }\n            }\n            Type[] alltypes = allList.ToArray();\n            return alltypes;\n        }\n\n    }\n```\n\n\n\n修改 StrartUp 类，调整注册方式。\n\n```c#\n        public void ConfigureServices(IServiceCollection services)\n        {\n            services.AddControllers();\n            //services.AddAutoMapper(typeof(UserMapper));\n            //自动化注册\n            services.AddAutoMapper(MapperRegister.MapType());\n\n        }\n```\n\n这样就可以每次添加 Mapper 类的时候，只需要添加 IProfile 标记，就可以自动注册了。\n\n转自 https://www.cnblogs.com/miaowacao/p/12757275.html\n\n### 应用\n\n入参控制好 Add/Up  Dto 转数据实体。\n\n返回参数 数据实体转Dto\n\n```c#\n // 创建一个字段来存储mapper对象\n  private readonly IMapper _mapper;\n  \n   public SnUserService(IMapper mapper)\n        {\n            _service = service;\n            _mapper = mapper;\n        }\n       //更新-转数据实体\n       var model = _mapper.Map<SnUser>(user);\n       int da = await CreateService<SnUser>().UpdateAsync(model);\n\n       //查询- 数据库实体转Dto\n       public async Task<List<SnUserDto>> AsyGetUser()\n        {\n            var user = await  _service.SnUser.ToListAsync();\n            return _mapper.Map<List<SnUserDto>>(user); \n        }\n```\n\n\n\n',17,0,'blog/18.jpg',0,48,3,4,'2022-12-26 09:47:02','2022-12-26 09:47:02'),
(420,'vue2增加缓存后刷新无效','`this.$router.go(0)`\n这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事\n\n### location.reload()\n\n`location.reload()`\n这种也是一样，画面一闪，效果总不是很好','### this.$router.go(0)\n\n`this.$router.go(0)`\n这种方法页面会一瞬间的白屏，体验不是很好，虽然只是一行代码的事\n\n### location.reload()\n\n`location.reload()`\n这种也是一样，画面一闪，效果总不是很好\n\n###  provide、inject\n\n3、搭配`provide、inject`使用\n\n首先在主页面 `app.vue`\n\n#### Home.vue\n\n```csharp\n    <keep-alive>\n      <!--//当前进入的路由 meta里面 keepAlive为true时走这里-->\n      <router-view v-if=\"$route.meta.keepAlive\" class=\"home-router\"></router-view>\n    </keep-alive>\n    <!--当前进入的路由 meta里面 keepAlive为false时走这里 下面 if 判断进行了取反处理-->\n    <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n\n#### App.vue\n\n```html\n<template>\n  <div id=\"app\">\n    <!-- <router-view v-if=\"isRouterAlive\"></router-view> -->\n    <home v-if=\"isRouterAlive\"></home>\n  </div>\n</template>\n\n<script>\n  import Home from ''./views/Home.vue'';\n  export default {\n    name: \"app\",\n    components: {\n      Home\n    },\n    provide() {\n      //父组件中通过provide来提供变量，在子组件中通过inject来注入变量。\n      return {\n        reload: this.reload\n      };\n    },\n    data() {\n      return {\n        isRouterAlive: true //控制视图是否显示的变量\n      };\n    },\n    methods: {\n      reload() {\n        this.isRouterAlive = false; //先关闭，\n        this.$nextTick(function () {\n          this.isRouterAlive = true; //再打开\n        });\n      }\n    }\n  };\n</script>\n\n\n```\n\n#### 在需要刷新的页面导入` inject: [''reload''],`\n\n调用刷新： \n\n```js\n export default {\n    inject: [\"reload\"],\n    }\n   `this.reload() `// 刷新页面\n```\n\n### 回退页面 keeplive 缓存问题\n\n在router/index.js中添加路由元信息，设置需要缓存的页面\n\n```js\n    meta: {\n      title:''trade.tradeTitle'',\n      keepAlive: true, // 此组件需要被缓存\n      isBack:false, //用于判断上一个页面是哪个\n    }\n```\n\n\n\n#### 钩子函数的执行顺序\n\n**不使用keep-alive**\n\n```vue\nbeforeRouteEnter --> created --> mounted --> destroyed\n```\n\n**使用keep-alive**\n\n```\nbeforeRouteEnter --> created --> mounted --> activated --> deactivated\n```\n\n再次进入缓存的页面，只会触发beforeRouteEnter -->activated --> deactivated 。created和mounted不会再执行。我们可以利用不同的钩子函数，做不同的事。务必理解上述钩子函数的执行时机和执行顺序，本教程的核心就依赖于此钩子函数\nactivated和deactivated是使用keep-alive后\n\n#### beforeRouteEnter\n\n在缓存的页面通过**beforeRouteEnter**钩子函数中判断是从哪个页面过来的\n\n```js\n    beforeRouteLeave(to, from, next) {\n      // 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）\n      // 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack\n      if (from.path === ''/SnNavigationUp'') {\n        //判断是从哪个路由过来的，\n        //刷新数据\n        to.meta.isBack = false;\n      } else {\n        //不刷新\n        to.meta.isBack = true;\n      }\n      next();\n    },\n```\n\n#### data\n\ndata中定义变量**isFirstEnter**用来判断是否第一次进入，或是否刷新了页面，默认false\n\n```c#\n data() {\n    return {\n      isFirstEnter:false,\n    };\n  },\n```\n\n#### created\n\ncreated中把isFirstEnter变为true，说明是第一次进入或刷新了页面\n\n```js\n      this.isFirstEnter = true;\n      // 只有第一次进入或者刷新页面后才会执行此钩子函数\n      // 使用keep-alive后（2+次）进入不会再执行此钩子函数\n      this.$nextTick(() => {\n        this.getall();\n      });\n```\n\n#### activated\n\nactivated中增加判断条件\n\n```js\n   activated() {\n      if (this.$route.meta.isBack || !this.isFirstEnter) {\n        // 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\n        // 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据\n        this.$nextTick(() => {\n          this.getall();\n        });\n      } else {\n        this.$route.meta.isBack = false\n        this.isFirstEnter = false;\n      }\n    },\n```\n\n\n\n直接写上也可以解决以上问题\n\n```js\nactivated() {\n     this.getall();\n    },\n```\n\n\n\n### 参考 https://blog.csdn.net/weixin_41164499/article/details/90718155\n\n',14,0,'blog/6.jpg',0,49,1,4,'2022-12-26 09:52:58','2022-12-26 09:52:58'),
(421,' 使用宝塔部署NET5Api','腾讯云安装 Centos8系统\n\n### NET环境安装\n\n在安装DotNetCore环境之前需要注册Microsoft Key以及Product Repository，并且还需要安装一些依赖，这一步每台机器只需要运行一次，具体命令如下\n','腾讯云安装 Centos8系统\n\n### NET环境安装\n\n在安装DotNetCore环境之前需要注册Microsoft Key以及Product Repository，并且还需要安装一些依赖，这一步每台机器只需要运行一次，具体命令如下\n\n```\nsudo rpm -Uvh https://packages.microsoft.com/config/rhel/7/packages-microsoft-prod.rpm\n```\n\n安装net5运行时安装\n\nhttps://dotnet.microsoft.com/download/dotnet/5.0 \n\n测试是否安装成功：\n\n```\ndotnet --version\n```\n\n### 部署 NET5 API\n\n程序发布过程省略(发布文件系统)，把编译后的程序发布到了本地 桌面\\publish 文件夹\n\n然后借助 FTP 工具 XFTP 把程序文件传输到服务器/home/wwwroot文件夹。\n\n上传完毕后，需要先通过`cd`命令进入网站根目录`/home/wwwroot`，再输入如下命令启动网站程序：\n\n```c#\ncd /www/wwwroot/net\ndotnet Snblog.dll \n```\n\n宝塔面板发布.NET5 API项目,并启动项目\n\n### Nginx设置反代访问\n\n目标url http://localhost:5000\n\n发送域名 localhost\n\n名称 可选随意\n\n\n\n### 添加进程守护\n\n宝塔安装 Supervisor\n\n添加进程\n\n启动用户： root 守护目录： /www/wwwroot/net   启动命令：dotnet Snblog.dll\n\n### vue框架刷新出现404的问题\n\n```c#\n在网站设置里配置伪静态\n\nif (!-e $request_filename) {\nrewrite ^/(.*) /index.html last;\nbreak;\n}\n```\n\n',19,0,'blog/19.jpg',0,50,3,4,'2022-12-26 09:57:10','2022-12-26 09:57:10'),
(422,'# vite2+vue3+ts搭建','### 使用 Vite 快速搭建\n\n```\nNpm\nnpm init @vitejs/app`\n\nYarn\nyarn create @vitejs/app\n```\n\n选择vue- vue-ts\n\n安装依赖','### 使用 Vite 快速搭建\n\n```\nNpm\nnpm init @vitejs/app`\n\nYarn\nyarn create @vitejs/app\n```\n\n选择vue- vue-ts\n\n安装依赖\n\n```\nnpm install\n```\n\n启动项目\n\n```\nnpm run dev\n```\n\n### 修改 Vite 配置文件\n\n```tsx\nimport { defineConfig } from ''vite''\nimport vue from ''@vitejs/plugin-vue''\nimport { resolve } from ''path''\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      ''@'': resolve(''./src'')\n    }\n  },\n  base: ''./'', // 打包路径\n  server: {\n    port: 4000, // 服务端口号\n    open: true, // 服务启动时是否自动打开浏览器\n    cors: true // 允许跨域\n  }\n})\n\n```\n\n### 配置文件\n\n如果使用 `TS` ，则需要先安装类型声明文件。\n\n```\nnpm install --save-dev @types/node\n```\n\nts\n\n```tsx\n/// <reference types=\"vite/client\" />\ndeclare module ''*.vue'' {\n  import { DefineComponent } from ''vue''\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n// declare module ''axios'';\n```\n\n### 集成路由\n\n安装 \n\n```\nnpm i vue-router@4\n```\n\n创建 `src/router/index.ts` 文件\n\n```tsx\nimport { createRouter, createWebHashHistory, RouteRecordRaw } from ''vue-router''\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: ''/home'',\n    name: ''Home'',\n    component: () => import(/* webpackChunkName: \"Home\" */ ''../views/Home/Home.vue'')\n  },\n  { path: ''/'', redirect: { name: ''Home'' } }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\nmain.ts 文件中挂载\n\n```ts\nimport { createApp } from ''vue''\nimport App from ''@/App.vue''\n\nimport router from ''@/router/index''\ncreateApp(App).use(router).mount(''#app'')\n```\n\n### 集成Vuex\n\n1. `npm i vuex@next`\n2. 创建 `src/store/index.ts` 文件\n\n```tsx\nimport {\n  createStore\n} from ''vuex''\n\nexport default createStore({\n  state: {\n    token: \"test\",\n    //设置页面是否新窗口打开\n    SetPage: false\n  },\n  mutations: {\n  },\n  actions: {},\n  modules: {}\n})\n```\n\nmain.ts 文件挂载\n\n```tsx\nimport { createApp } from ''vue''\nimport App from ''@/App.vue''\n\nimport router from ''@/router/index''\nimport store from ''@/store/index''\ncreateApp(App).use(router).use(store).mount(''#app'')\n```\n\n### 集成 Axios\n\n1. `npm i axios`\n2. 配置 `Axios`\n\n```ts\nimport axios from ''axios''\nimport qs from \"qs\";\nimport store from \"../store/index\";\nimport router from ''../router'';\n//''http://129.204.92.64:8081/'' 腾讯服务器\n// axios.defaults.baseURL = ''https://localhost:44367/'',\naxios.defaults.baseURL = process.env.VUE_APP_API_URL,\n  axios.defaults.timeout = 12000;\n// axios.defaults.headers.common[''token''] =  AUTH_TOKEN\naxios.defaults.headers.post[''Content-Type''] = ''application/json;charset=UTF-8'';\naxios.defaults.headers.post[\"Access-Control-Allow-Origin-Type\"] = \"*\"; // 允许跨域\n\naxios.interceptors.request.use(function (config: any) {\n  // 在发送请求之前做某件事\n  if (\n    config.method === \"post\" ||\n    config.method === \"put\" ||\n    config.method === \"delete\"\n  ) {\n    // 序列化\n    config.data = qs.parse(config.data);\n    // console.log(\"qs:\" + config.data);\n  }\n  // 若是有做鉴权token , 就给头部带上token\n  if (store.state.token) {\n    config.headers.Authorization = store.state.token;\n    // console.log(\"token:\" + store.state.token);\n  }\n  return config;\n}, (error: { data: { error: { message: any; }; }; }) => {\n  // Message({\n  //   //  饿了么的消息弹窗组件,类似toast\n  //   showClose: true,\n  //   message: error,\n  //   type: \"error.data.error.message\"\n  // });\n  return Promise.reject(error.data.error.message);\n})\n\naxios.interceptors.response.use(function (config: any) {\n  if (config.status === 200 || config.status === 204) {\n    return Promise.resolve(config);\n  } else {\n    return Promise.reject(config);\n  }\n  // return config;\n},\n  function (error: { response: { status: any; }; }) {\n    // return Promise.reject(error)\n    if (error.response.status) {\n      switch (error.response.status) {\n        // 401: 未登录\n        // 未登录则跳转登录页面，并携带当前页面的路径\n        // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n        case 401:\n          router.replace({\n            path: ''/login'',\n            query: {\n              // redirect: router.currentRoute.fullPath\n            }\n          });\n          break;\n        // 403 token过期              \n        case 403:\n          // 清除token\n          store.dispatch(''FedLogOut'').then(() => {\n            // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 \n            router.replace({\n              path: ''/login'',\n              query: {\n                // redirect: router.currentRoute.fullPath\n              }\n            })\n          })\n          break;\n        // 404请求不存在\n        case 404:\n          break;\n        // 其他错误，直接抛出错误提示\n        default:\n      }\n      return Promise.reject(error.response);\n    } else {\n      // 处理断网的情况\n      // eg:请求超时或断网时，更新state的network状态\n      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\n      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明\n      store.commit(''changeNetwork'', false);\n    }\n  }\n)\nexport default axios\n```\n\n**挂载**\n\n```tsx\nimport axios from ''./api/axios''\n// 全局ctx(this) 上挂载 $axios\napp.config.globalProperties.$api = axios\n```\n\n### 集成CSS预编译器\n\n```\nnpm i sass -D\n```\n\n### 环境变量配置\n\n#### .env.development\n\n```javascript\n// .env.development\n//测试环境地址\nNODE_ENV = development\nVITE_API_DOMAIN = ''https://localhost:5001/''\n```\n\n#### .env.production\n\n```javascript\nNODE_ENV = production\nVITE_API_DOMAIN = ''http://8081/''//正式环境地址\n```\n\n#### 在页面中使用\n\n```typescript\nconsole.log(import.meta.env.VITE_APP_WEB_URL)\n```\n\n#### 在 `package.json `中使用\n\n```json\n\"scripts\":{\n  \"build:dev\": \"vite build --mode development\",\n  \"build:pro\": \"vite build --mode production\"\n}\n```\n\n#### env.d.ts\n\n```ts\ninterface ImportMetaEnv {\n  VITE_API_DOMAIN: string,\n}\n```\n\n###  Tailwind CSS\n\n```\nnpm install -D tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9\n```\n\n创建配置文件\n\n```\nnpx tailwindcss init -p\n```\n\n```js\nmodule.exports = {\n  // purge: [''./src/**/*.{vue,js,ts,jsx,tsx}''], //删除未使用的CSS\n  purge: {\n    enabled: true,\n    content: [''./src/**/*.{vue,js,ts,jsx,tsx}''],\n  },\n  darkMode: false, // or ''media'' or ''class''\n  theme: {\n    screens: {\n\n      ''cx'': {\n        ''max'': ''575px''\n      },\n      ''xp'': {\n        ''min'': ''375px'',\n        ''max'': ''667px''\n      },\n    },\n    extend: {},\n  },\n  variants: {\n    extend: {},\n  },\n  // add DaisyUI plugin\n  plugins: [\n    require(''daisyui''),\n  ],\n\n  // config (optional)\n  daisyui: {\n    styled: true,\n    themes: false,\n    base: false,\n    utils: true,\n    logs: true,\n    rtl: false,\n  },\n}\n```\n\n```js\n// postcss.config.js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\nVite 默认为您生成的 ./src/index.css 文件 \n\n```css\n/* ./src/index.css */\n\n/*! @import */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n```js\n// src/main.js\nimport ''./index.css''\n```\n\n### 整合代码规范插件eslint,prettier\n\n#### 安装依赖\n\n```js\nyarn add babel-eslint -D\nyarn add @vue/eslint-config-prettier -D\nyarn add eslint -D\nyarn add eslint-plugin-prettier -D\nyarn add eslint-plugin-vue -D\nyarn add prettier -D\n复制代码\n```\n\n#### 根目录建 `.eslintrc.js`\n\n```js\n//.eslintrc.js\nmodule.exports = {\n  root: true,\n  env: {\n    node: true,\n  },\n  extends: [''plugin:vue/vue3-essential'', ''eslint:recommended''],\n  parserOptions: {\n    parser: ''babel-eslint'',\n  },\n  rules: {\n    //在此处写规则\n    ''no-unused-vars'': 0, // 定义未使用的变量\n  },\n};\n复制代码\n```\n\n####  根目录建 `.prettierrc.json`\n\n```js\n//.prettierrc.json\n{\n  //此处填写规则\n  \"singleQuote\": true,//单引号\n  \"seme\": true,//分号\n  \"tabWidth\": 2,//缩进\n  \"TrailingCooma\": \"all\",//尾部元素有逗号\n  \"bracketSpacing\": true,//对象中的空格\n}\n复制代码\n```\n\n#### `vscode` 自动格式化\n\n```js\n //settings.json\n\"editor.formatOnSave\": true,//保存时格式化\n\"files.autoSave\": \"onFocusChange\", //失去焦点时保存\n\"editor.codeActionsOnSave\": {\n  \"source.fixAll.eslint\": true\n},\n\"eslint.validate\": [\n  \"javascript\",\n  \"javascriptreact\",\n  \"typescript\"\n],  \n```\n\n### 配置GZIP压缩\n\n安装依赖\n\n```js\nyarn add vite-plugin-compression -D\n```\n\n修改 `vite.config.js`\n\n```js\n//vite.config.js\n\nimport viteCompression from ''vite-plugin-compression''\nplugins:[\n  ...\n  viteCompression({\n      verbose: true,\n      disable: false,\n      threshold: 10240,\n      algorithm: ''gzip'',\n      ext: ''.gz''\n  })\n]\n```\n\n### webpack 代理配置\n\n配置 `vite.config.ts` 文件\n\n```typescript\nserver: {\n    host: ''0.0.0.0'',\n    port: 3000,\n    open: true,\n    https: false,\n    proxy: {}\n},\n```\n\n### 生产环境移除 console\n\n配置 `vite.config.ts` 文件\n\n```typescript\nbuild:{\n  ...\n  terserOptions: {\n      compress: {\n        drop_console: true,\n        drop_debugger: true\n      }\n  }\n}\n```',173,0,'blog/11.jpg',0,4,1,4,'2022-12-26 10:04:10','2022-12-26 10:04:10'),
(423,'网站打包桌面程序–Nativefier','Nativefier 是一种命令行工具，可以用最少的配置轻松地为任何网站创建桌面应用程序。它是由 Electron 引擎生成的可执行文件（.app .exe 等），能够运行在Windows，MacOS和Linux平台。','### [Nativefier](https://www.smbinn.com/tag/nativefier)简介\n\nNativefier 是一种命令行工具，可以用最少的配置轻松地为任何网站创建桌面应用程序。它是由 Electron 引擎生成的可执行文件（.app .exe 等），能够运行在Windows，MacOS和Linux平台。\n\n[GitHub](https://www.smbinn.com/tag/github)页面：https://github.com/jiahaog/nativefier\n\n### 安装条件\n\n- macOS 10.9+ / Windows / Linux\n- Node.js >= 10和npm>= 6\n\n### 安装\n\n首先需要安装Node.js，最新版本默认集成了npm，进入官网下载并安装到计算机。下载地址：https://nodejs.org/zh-cn/\n\n安装好 Node.js 之后，还需要设置全局变量，因为加载极为缓慢，这里我们使用淘宝源来进行操作会快上不少。找到系统属性 – 高级 – 环境变量 – 新建用户变量。变量名：ELECTRON_MIRROR 变量值：http://npm.taobao.org/mirrors/electron/\n\n接下来就到了安装 Nativefier 的环节，只需在cmd命令提示符中输入 npm install -g nativefier 即可完成安装。\n\n最后，就可以用 Nativefier 来生成你想要的桌面应用程序了。例如要为https://www.smbinn.com创建桌面应用程序，只需在cmd命令提示符中输入 nativefier “https://www.smbinn.com” 生成后的程序默认在C盘用户文件夹。\n\n\n\n出处:https://www.cnblogs.com/agressor/p/14186750.html\n\n',109,0,'blog/3.jpg',0,50,108,4,'2022-12-26 10:09:46','2022-12-26 10:09:46');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;

-- 
-- Definition of diary
-- 

DROP TABLE IF EXISTS `diary`;
CREATE TABLE IF NOT EXISTS `diary` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `read` int NOT NULL COMMENT '阅读数',
  `give` int NOT NULL COMMENT '点赞',
  `user_id` int NOT NULL COMMENT '作者',
  `comment_id` int unsigned NOT NULL COMMENT '评论',
  `type_id` int NOT NULL COMMENT '分类',
  `time_create` datetime NOT NULL COMMENT '时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `sn_one_type` (`type_id`),
  KEY `one_user_id` (`user_id`),
  CONSTRAINT `one_type_id` FOREIGN KEY (`type_id`) REFERENCES `diary_type` (`id`),
  CONSTRAINT `one_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin COMMENT='日记表';

-- 
-- Dumping data for table diary
-- 

/*!40000 ALTER TABLE `diary` DISABLE KEYS */;
INSERT INTO `diary`(`id`,`name`,`text`,`img`,`read`,`give`,`user_id`,`comment_id`,`type_id`,`time_create`,`time_modified`) VALUES
(1,'123','丹尼尔·平克在《驱动力 3.0》一书中有说：“服从让我们撑过白天，而投入才能让我们撑过夜晚。”这告诉了我们一个很简单的事实：外驱让我们可以做好本职工作，而内驱才能让我们成就卓越。写过超级畅销书《全新思维》的知名商业思想家丹尼尔·平克（Daniel Pink），被称为全球50位最有影响力的商业思想家之一。','1',1,1,1,0,4,'2023-02-02 10:34:25','2023-02-02 10:34:28'),
(8,'vol.001 舔狗日记','没事，你有对象不重要，你可以偶尔回一下我的信息好吗，一天一条也行，让我知道你还在。','321321',8,9,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(9,'vol.002 舔狗日记','时隔30个小时，你终于发了信息给我，你说“宝贝，我想你了。”，我很开心，我终于以为我的舔狗日子到了，可没想到信息发出来两秒都没有，你就撤回了，你说发错了，当我说准备要回没关系的时候，我看见了红色的感叹号。','321321',1,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(10,'vol.003 舔狗日记','蒋介石因为宋美龄的一句喜欢梧桐，他便种满了整个南京。而我因为你的一句不喜欢小偷，我便放过了整个上海的电动车。','321321',1,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(11,'vol.004 舔狗日记','我今天送了你一支口红，你拿到之后很开心，在他的嘴巴上亲了一下，或许他送你口红的时候，你也会在我的嘴巴上亲一下吧。','321321',4,1,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(12,'vol.005 舔狗日记','别的妹妹叫你打游戏，你让人家语音给你发了句哥哥，你就陪她打一天。我叫你打游戏，你回了我一句 70/h。','321321',6,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(13,'vol.006 舔狗日记','今天在楼上窗户上看见你和他在公园里接吻，我看见哭了出来，并打电话给你，想问问你为什么？但你说怎么了，声音是那么好听。于是我说“以后你和他接吻的时候，能不能用我送给你的口红啊？”','321321',5,1,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(14,'vol.007 舔狗日记','今天上班不是太忙，百无聊赖，又翻出了你的相片，看了又看。今天是我认识你的第302天，也是我爱你的第302天，可是这些你并不知道，也许你知道了，也不会在意吧。 此刻的我好想你！','321321',0,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(15,'vol.008 舔狗日记','你好像从来没有对我说过晚安，我在我们的聊天记录里搜索了关键字：“晚安”，你说过一次：我早晚安排人弄死你。','321321',0,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(16,'vol.009 舔狗日记','她好像从来没有主动说过爱我，我搜索了一下关键字“爱”。在我们的聊天记录里，她只说过一次：爱奇艺会员借我一下。','321321',5,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(17,'vol.010 毒鸡汤','如果人生是一部电影，那你就是，中间弹出来的广告。','string',7,1,4,0,4,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(20,'vol.011 舔狗日记','现在已经凌晨一点多了，我望着手机屏幕迟迟没有他的消息：你知道吗？我等了一晚上你的消息。他终于回复我了：是我让你等的？','无',5,3,4,0,4,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(21,'vol.012 舔狗日记','今天你又来我们班看美女了，路过的时候瞥了一眼坐在第一排的我，我就知道你心里还是有我的。啊！真是美好的一天！','无',14,2,4,0,4,'2021-01-03 00:00:00','2020-12-18 00:00:00'),
(22,'vol.013 毒鸡汤','别以为你一无所有，至少你还有丑！','无',11,0,4,0,4,'2021-01-03 00:00:00','2020-12-18 00:00:00'),
(31,'vol.014 舔狗日记','今天打单子赚了56，给你转了52自己留了4块钱。我花两块买了两包泡面，用剩下的两块钱买了一瓶矿泉水，自己烧水泡面吃，而你用那52块钱想都没想的给你别的哥哥买了皮肤。 我太开心了，因为你用上我的钱了，以后我要赚更多的钱给你','无',11,2,4,0,4,'2021-07-20 00:00:00','2020-12-18 00:00:00'),
(33,'vol.015 舔狗日记','今天你说了要和我打电话，我等了一天，马上十二点了才打过来，我有点不高兴就挂了，你骂了句给脸不要脸。我想了一下，哎呀你还会关心我的脸，多么善良的女孩子，我发誓还能再等一天电话','无',7,3,4,0,4,'2021-09-02 00:00:00','2020-12-18 00:00:00'),
(34,'vol.016 舔狗日记','你好像成熟了，你学会隐忍，开始压抑自己对我的感情。这很好……可是我觉得自己被你忽略了……你好像看不见我。这不可能，对吗？','无',12,4,4,0,4,'2021-09-02 00:00:00','2020-12-18 00:00:00');
/*!40000 ALTER TABLE `diary` ENABLE KEYS */;

-- 
-- Definition of sn_navigation
-- 

DROP TABLE IF EXISTS `sn_navigation`;
CREATE TABLE IF NOT EXISTS `sn_navigation` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '导航标题',
  `describe` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题描述',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片路径',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '链接路径',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL COMMENT '用户',
  `time_create` datetime DEFAULT NULL,
  `time_modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `nav_user_id` (`user_id`),
  KEY `nav_type_id` (`type_id`),
  CONSTRAINT `nav_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_navigation_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `nav_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=661 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_navigation
-- 

/*!40000 ALTER TABLE `sn_navigation` DISABLE KEYS */;
INSERT INTO `sn_navigation`(`id`,`title`,`describe`,`img`,`url`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(1,'Webpack','Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.27/dist/img/webpack.png','https://www.webpackjs.com/',14,4,'2021-11-10 14:45:01','2021-11-11 16:24:54'),
(2,'React','React 起源于 Facebook 的内部项目，是一个用于构建用户界面的 JavaScript 库。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.27/dist/img/react.png','https://reactjs.bootcss.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(3,'TypeScript','TypeScript 是由微软开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.27/dist/img/typescript.png','https://typescript.bootcss.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(4,'Svelte','Svelte 是构建 Web 应用程序的一种新方法。Svelte 是一个编译器，它将声明性组件转换成高效的 JavaScript 代码，并像做外科手术一样细粒度地更新 DOM。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.27/dist/img/svelte.png','https://www.sveltejs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(5,'Next.js','Next.js 是一个轻量级的 React 服务端渲染应用框架。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.28/dist/img/nextjs.png','https://www.nextjs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(6,'Babel','Babel 是一个 JavaScript 编译器。Babel 通过语法转换器支持最新版本的 JavaScript 语法。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.27/dist/img/babeljs.png','https://www.babeljs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(7,'Node.js','Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.28/dist/img/nodejs.png','https://www.nodeapp.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(8,'Deno','Deno 是一个简单、现代且安全的 JavaScript 和 TypeScript 运行时，deno 基于 V8 引擎并使用 Rust 编程语言构建。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.28/dist/img/deno.png','https://deno.bootcss.com/',5,4,'2021-11-10 14:45:01','2022-10-18 08:37:50'),
(9,'Yarn','Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.28/dist/img/yarn.png','https://yarn.bootcss.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(10,'Yarn v2','Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。Yarn v2 与 v1 版本有很大的不同，Yarn v2 改进了 CLI 交互、支持 workspace、PnP 等新功能。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.28/dist/img/yarn.png','https://www.yarnpkg.com.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(11,'前端学习路线','好好学习，天天敲代码','https://objtube.github.io/front-end-roadmap/#/','https://objtube.github.io/front-end-roadmap/#/',15,4,'2021-11-10 14:45:01','2021-12-16 14:25:19'),
(12,'Visual Studio','功能完备的集成开发环境 (IDE)，适用于 Android、iOS、Windows、Web 和云 (IDE)','https://img-prod-cms-rt-microsoft-com.akamaized.net/cms/api/am/imageFileData/RE1Mu3b?ver=5c31','https://visualstudio.microsoft.com/zh-hans/downloads/',14,4,'2021-11-10 14:45:01','2022-10-13 10:13:40'),
(14,'现代 JavaScript','以最新的 JavaScript 标准为基准。通过简单但足够详细的内容，为你讲解从基础到高阶的 JavaScript 相关知识。','https://zh.javascript.info/','https://zh.javascript.info/',5,4,'2021-11-10 14:45:01','2022-10-18 08:38:01'),
(15,'Sass中文网','Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。','https://www.sass.hk/docs/','https://www.sass.hk/docs/',9,4,'2021-11-10 14:45:01','2022-10-18 08:37:43'),
(16,'BootstrapVue','我们开始BootstrapVue之旅游，基于全球最流行的Bootstrap V4框架，构建移动优先的响应式门户，在Vue.js前端栈基础上。','http://code.z01.com/bootstrap-vue/docs/','http://code.z01.com/bootstrap-vue/docs/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:36'),
(17,'前端导航站','前端内容汇总','http://jsdig.com/','http://jsdig.com/',15,4,'2021-11-10 14:45:01','2021-12-16 14:25:48'),
(18,'Md2All排版','Markdown排版利器，支持 \"一键排版\" 、自定义css、80多种代码高亮。\n能让Markdown内容，无需作任何调整就能一键复制到微信公众号、博客园、掘金、知乎、csdn、51cto、wordpress、hexo。。。等平台。','http://md.aclickall.com/','http://md.aclickall.com/',20,4,'2021-11-10 14:45:01','2022-10-18 08:37:29'),
(19,'VuePress','Vue 驱动的静态网站生成器','https://v0.vuepress.vuejs.org/zh/','https://v0.vuepress.vuejs.org/zh/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:24'),
(20,'Blog.Core','BCVP（Blog.Core & Vue Project）是一个开箱即用的企业级权限管理应用框架。\n采用最新的前后端完全分离技术【 ASP.NET Core Api 3.x + Vue 2.x 】。','http://apk.neters.club/.doc/','http://apk.neters.club/.doc/',4,4,'2021-11-10 14:45:01','2022-10-18 08:37:11'),
(21,'sqlSugar','.NET 4.+ & .NET CORE 高性能 轻量级 ORM框架，众多.NET框架中最容易使用的数据库访问技术','http://www.codeisbug.com/','http://www.codeisbug.com/',16,4,'2021-11-10 14:45:01','2022-11-08 15:54:28'),
(22,'Avue','一个很多骚操作的前端框架\n让数据驱动视图，减去繁琐的操作，更贴近企业级的前端开发组件','https://avuejs.com/','https://avuejs.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:02'),
(24,'Bootstrap ','基于 Bootstrap 样式库精心打造，并且额外增加了 50 多种常用的组件，为您快速开发项目带来非一般的感觉','https://blazor.sdgxgz.com/','https://blazor.sdgxgz.com/',9,4,'2021-11-10 14:45:01','2022-10-18 08:36:53'),
(25,'Editor.md','\n开源在线 Markdown 编辑器','http://editor.md.ipandao.com/','http://editor.md.ipandao.com/',20,4,'2021-11-10 14:45:01','2022-10-18 08:36:44'),
(26,'标签[c#]','','https://stackoom.com/img/logo.png','https://stackoom.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:36:32'),
(27,'Font Aweso','世界上最流行的ICON图标字体库和CSS工具包','http://www.fontawesome.com.cn/','http://www.fontawesome.com.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 08:35:25'),
(28,'Dotnet9','Donet技术论坛','https://dotnet9.com/','https://dotnet9.com/',8,4,'2021-11-10 14:45:01','2021-11-15 14:30:21'),
(29,'vol.vue','前后端分离\n\n全自动代码生成\n\n支持前端、后台扩展的快速开发框架','http://www.volcore.xyz/','http://www.volcore.xyz/',3,4,'2021-11-10 14:45:01','2022-10-18 08:35:19'),
(30,'jQuery插件库','jQuery插件库','https://www.jq22.com/','https://www.jq22.com/',5,4,'2021-11-10 14:45:01','2022-10-18 08:35:07'),
(31,'Vue.js中文文档','渐进式\nJavaScript 框架','https://vue.docschina.org/','https://vue.docschina.org/',3,4,'2021-11-10 14:45:01','2022-10-18 08:35:02'),
(33,'CSS Fonts','网络安全 CSS 字体堆栈的完整集合。','','https://www.cssfontstack.com/',9,4,'2021-11-10 14:45:01','2022-10-18 08:34:54'),
(34,'CSS速查总表 ','','http://css.cuishifeng.cn/','http://css.cuishifeng.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 08:34:40'),
(35,'爆胎','互联网长方体空间移动师','https://tvax1.sinaimg.cn/square/0084aYsLly1ggmuk8fguaj305k05kq30.jpg','https://itggg.cn/',8,4,'2021-11-10 14:45:01','2022-11-08 15:53:02'),
(36,'青找博客','我们总在生活中与「一瞬的感动」相遇。','https://tva3.sinaimg.cn/square/0084aYsLly1ggmukfjc0uj3068068dfs.jpg','https://www.linguang.me/',8,4,'2021-11-10 14:45:01','2021-11-11 16:24:27'),
(37,'axios中文网','易用、简洁且高效的http库','','http://www.axios-js.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:34:32'),
(38,'layui','由职业前端倾情打造，面向全层次的前后端开发者，低门槛开箱即用的前端 UI 解决方案','','https://www.layui.com/',5,4,'2021-11-10 14:45:01','2022-10-18 08:34:23'),
(39,'我爱斗图','在线表情包','','https://www.52doutu.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(40,'Quasar Fra','以最短时间构建高性能的VueJS用户界面','','http://www.quasarchs.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:34:13'),
(41,'Electron','使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序','','https://www.electronjs.org/',24,4,'2021-11-10 14:45:01','2022-10-18 08:34:06'),
(42,'2020年Web前端','新手入门前端，需要学习的基础内容有很多，如下。','','https://www.cnblogs.com/qianguyihao/p/8776837.html',10,4,'2021-11-10 14:45:01','2022-11-08 15:54:12'),
(43,'ZUI','一个基于 Bootstrap 深度定制开源前端实践方案，帮助你快速构建现代跨屏应用。','','https://www.openzui.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:20'),
(44,'Aplayer','Wow, such a beautiful HTML5 music player','','https://aplayer.js.org/#/zh-Hans/',24,4,'2021-11-10 14:45:01','2022-10-18 08:33:50'),
(46,'.NET万能框架','项目基于.NET 4.5构建，语法版本C#6.0，包含日常编程多数的常用封装，可以说是一个万能框架，能够用于任何基于.NET平台的项目当中。','','https://masuit.com/55',4,4,'2021-11-10 14:45:01','2022-10-18 08:33:20'),
(47,'Tailwind Grids','为 Tailwind CSS 项目轻松生成响应式网格。所有生成的类都基于 Tailwind 默认值，只需选择您的设置即可开始使用。','','https://tailwindgrids.com/#/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:16'),
(48,'CSS Inspiration -- CSS灵感','这里可以让你寻找到使用或者是学习 CSS 的灵感，以分类的形式，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。','','https://csscoco.com/inspiration/#/',9,4,'2021-11-10 14:45:01','2022-10-18 08:32:58'),
(49,'小游网','二次元技术宅','https://img.xiaoyou66.com/images/2020/02/20/tTSY.jpg','https://xiaoyou66.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(50,'全历史','全历史(Allhistory)以AI知识图谱为核心引擎,通过高度时空化、关联化数据的方式构造及展现数字人文内容,尤其是历史知识。','https://img.xiaoyou66.com/images/2020/02/20/tTSY.jpg','https://www.allhistory.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(51,'疯狂去水印','打开短视频APP， 选择要下载的视频，点击右下角分享按钮，在分享弹框中点击“复制链接”','https://douyin.video996.com/img/mp.jpg','https://douyin.video996.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(52,'知妖','知妖是一个开放的在线“妖怪”资料库。致力于收集、整理、介绍、分享古人文献中的“妖怪”。我们尽可能地收录古文献中的“妖怪”资料，让更多的人能够完整，系统地了解中国“妖怪”文化。','https://static.cbaigui.com/images/2020/04/loading.jpg!full','https://www.cbaigui.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(53,'煎蛋','地球上没有新鲜事','http://img.jandan.net/news/2020/03/2e4024373d26ccd3888e29a6f4152076.jpg!square','http://jandan.net/',10,4,'2021-11-10 14:45:01','2022-10-18 10:02:14'),
(54,'小鸡词典','查网络流行语','https://jikipedia.com/images/logo/logo_full_side.png','https://jikipedia.com/',8,4,'2021-11-10 14:45:01','2021-11-18 13:41:02'),
(55,'网站任意门','你将被传送到完全随机的一个网站，传送到任何一个网站的概率都是相等的。','https://gate.ofo.moe/social/hero-4.jpg','https://gate.ofo.moe/',11,4,'2021-11-10 14:45:01','2022-10-18 10:02:08'),
(56,'Tailwind CSS','Tailwind 是基于 PostCSS 开发的,通过 JavaScript 代码进行配置,这意味着你可以完全发挥真正的编程语言的能力。 Tailwind 不仅仅是一个 CSS 框架,他更是构建设计系统','','https://www.tailwindcss.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:11'),
(57,'Flexbox网格','基于flex显示属性的网格系统。','','http://flexboxgrid.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:59'),
(58,'purecss','一组小型的自适应CSS模块，您可以在每个Web项目中使用。','https://purecss.io/img/logo_pure@2x.png','https://purecss.io/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:55'),
(59,'vue-aplayer','A beautiful HTML5 music player for Vue.js','https://aplayer.netlify.app/docs/hero.png','https://aplayer.netlify.app/docs/',24,4,'2021-11-10 14:45:01','2022-10-18 08:32:11'),
(60,'林德熙','微软最具价值专家 Windows Development MVP','https://blog.lindexi.com/img/avatar.png','https://blog.lindexi.com/',8,4,'2021-11-10 14:45:01','2022-10-18 08:32:02'),
(61,'MahApps.Me','MahApps.Metro是一个框架，使开发人员可以轻松地为自己的WPF应用程序整合Metro或Modern UI。','https://mahapps.com/assets/img/oss.png','https://mahapps.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:31:54'),
(62,'C#入门经典教程','C# 是微软推出的一门面向对象的通用型编程语言，它除了可以开发 PC 软件、网站（借助 ASP.NET）和 APP（基于 Windows Phone），还能作为游戏脚本，编写游戏逻辑。','','http://c.biancheng.net/csharp/',13,4,'2021-11-10 14:45:01','2022-10-18 08:31:34'),
(64,'C# 指南','官方指南','https://docs.microsoft.com/favicon.ico','https://docs.microsoft.com/zh-cn/dotnet/csharp/',13,4,'2021-11-10 14:45:01','2022-10-18 08:31:07'),
(65,'Ant Design Blazor','这里是 Ant Design 的 Blazor 实现，开发和服务于企业级后台产品。','https://raw.githubusercontent.com/ant-design-blazor/ant-design-blazor/master/logo.svg','https://ant-design-blazor.gitee.io/zh-CN/docs/introduce',4,4,'2021-11-10 14:45:01','2022-09-28 11:43:42'),
(66,'mavonEditor','关于\nmavonEditor-基于Vue的markdown编辑器，支持多种个性化功能','https://raw.githubusercontent.com/ant-design-blazor/ant-design-blazor/master/logo.svg','https://github.com/hinesboy/mavonEditor',24,4,'2021-11-10 14:45:01','2022-09-28 11:44:16'),
(68,'VUE粒子','粒子背景的Vue.js组件','','https://vue-particles.netlify.app/',24,4,'2021-11-10 14:45:01','2021-11-18 14:38:44'),
(69,'Element','Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库','','https://element.eleme.cn/#/zh-CN',19,4,'2021-11-10 14:45:01','2021-11-18 14:38:29'),
(70,'outils','前端业务代码工具库','','https://www.npmjs.com/package/outils',5,4,'2021-11-10 14:45:01','2021-11-15 14:33:28'),
(71,'Anime.js','一个强大的、轻量级的用来制作动画的javascript库','','https://animejs.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:50'),
(72,'Hover.css','CSS hover 悬停效果，可以应用于链接、按钮、图片等等','','http://ianlunn.github.io/Hover/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:47'),
(73,'Waves','点击波纹效果','','http://fian.my.id/Waves/#examples',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:52'),
(74,'Viewer.js','图片滑动切换展示效果','','https://fengyuanchen.github.io/viewerjs/',5,4,'2021-11-10 14:45:01','2021-11-18 14:38:37'),
(75,'clipboard','复制粘贴插件','','https://clipboardjs.com/',24,4,'2021-11-10 14:45:01','2021-11-18 14:38:02'),
(76,'You-need-to-know-css','作为一名Web开发者，CSS是必备技能之一，我一直以为自己对CSS的掌握已经够用了，直到读Lea Verou的《CSS揭秘》，我发现自己充其量就算个会打CS的选手，书中针对我们常见的网页设计难题从不同的角度提出了多种实用又优雅的解决方案，在这里强烈的推荐给每一位从事前端相关工作和对前端有兴趣的同学，相信你一定会有所收获','https://lhammer.cn/You-need-to-know-css/static/logo.png','https://lhammer.cn/You-need-to-know-css/#/zh-cn/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:38'),
(77,'Shiro','Shiro，是alphardex平时所做的CSS创意作品集','','https://shiroi.netlify.app/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:32'),
(78,'今日热榜','每日榜单','https://file.ipadown.com/tophub/assets/images/logo.png','https://tophub.today/',11,4,'2021-11-10 14:45:01','2021-11-18 14:37:25'),
(79,'艾特网','程序员之家','https://iiter.cn/_nuxt/img/f996b71.png','https://iiter.cn/',8,4,'2021-11-10 14:45:01','2021-11-18 14:37:03'),
(80,'PostCSS','是一个用 JavaScript 工具和插件转换 CSS 代码的工具','https://www.postcss.com.cn/postcss.1b20c651.png','https://www.postcss.com.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:42'),
(81,'Articles','css技巧','','https://css-tricks.com/archives/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:10'),
(82,'JavaScript 秘密花园','此中文翻译由三生石上独立完成，博客园首发，转载请注明出处。','','https://bonsaiden.github.io/JavaScript-Garden/zh/#intro',5,4,'2021-11-10 14:45:01','2021-11-18 14:35:56'),
(83,'uni-app','uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。','https://vkceyugu.cdn.bspapp.com/VKCEYUGU-uni-app-doc/7c946930-bcf2-11ea-b997-9918a5dda011.png','https://uniapp.dcloud.io/README',21,4,'2021-11-10 14:45:01','2021-11-18 14:37:45'),
(84,'前端小册子','前端学习曲线陡峭，入门容易精通难。后期有瓶颈往往是因为前期基础不扎实。学习一点，掌握一点，貌似慢，实际快。实战是好事，但理论不扎实就着急实战并非是好事。实战帮助更好地理解理论，而不是帮助学习理论。理论学明白，项目才能踏实做，否则，在实战的过程中得到的只是零碎知识点，并没有形成完善的理论体系，收效不大\n好的代码像粥一样，都是用时间熬出来的。小火柴立志要做一名前端工匠\n\n这个小册子是小火柴总结的前端知识结构，方便自己学习，也希望能够帮到更多人\n由于里面许多内容是自己的总结，可能会有错误或纰漏之处，希望不会造成误导，多多交流','https://vkceyugu.cdn.bspapp.com/VKCEYUGU-uni-app-doc/7c946930-bcf2-11ea-b997-9918a5dda011.png','https://xiaohuochai.site/introduce.html',11,4,'2021-11-10 14:45:01','2021-11-18 14:36:36'),
(85,'uView(uni-appUI框架)','uView UI，是uni-app生态最优秀的UI框架，全面的组件和便捷的工具会让您信手拈来，如鱼得水','https://uviewui.com/common/logo.png','https://uviewui.com/',19,4,'2021-11-10 14:45:01','2021-11-18 14:36:53'),
(86,'umy-ui','为开发者准备的基于 Vue 2.0 的桌面端组件库; 流畅渲染表格万级数据','','https://www.umyui.com/',21,4,'2021-11-10 14:45:01','2021-11-18 14:36:30'),
(87,'Element UI表单设计及代码生成器','可将生成的代码直接运行在基于Element的vue项目中；也可导出JSON表单，使用配套的解析器将JSON解析成真实的表单。','','https://jakhuang.github.io/form-generator/#/',19,4,'2021-11-10 14:45:01','2021-11-18 14:36:47'),
(88,'luch-request(uni-app)','基于Promise开发的uni-app跨平台请求库','https://www.quanzhan.co/luch-request/assets/img/logo.jpg','https://www.quanzhan.co/luch-request/',21,4,'2021-11-10 14:45:01','2021-11-18 14:36:22'),
(89,'Entity Framework Core API 参考','欢迎使用 .NET API 浏览器！这个一站式商店，销售 Microsoft 提供的所有基于 .NET 的 API。 在下面的框中键入字词，开始搜索任意托管 API 吧。 可以通过我们的博文详细了解 API 浏览器。','','https://docs.microsoft.com/zh-cn/dotnet/api/?view=efcore-3.1',22,4,'2021-11-10 14:45:01','2022-10-18 08:48:47'),
(90,'Furion','Furion 是 .NET 5 平台下极易入门、极速开发的 Web 应用框架。','https://monksoul.gitee.io/fur/img/logo.png','https://dotnetchina.gitee.io/furion/',27,4,'2021-11-10 14:45:01','2023-02-06 09:22:25'),
(92,'vue-admin-beautiful','是一款基于vue+element-ui的绝佳的中后台前端开发管理框架（基于vue/cli 4 最新版，同时支持电脑，手机，平板）,他同时是拥有100+页面的大型vue前端单页应用','','https://gitee.com/chu1204505056/vue-admin-beautiful/?hmsr=github&hmpl=&hmcu=&hmkw=&hmci=',19,4,'2021-11-10 14:45:01','2021-11-18 13:41:17'),
(93,'Animate中文网','强大的跨平台的预设css3动画库\n内置了很多典型的css3动画，兼容性好使用方便','','http://www.animate.net.cn/',9,4,'2021-11-10 14:45:01','2021-11-18 13:40:25'),
(94,'jQuery API 3.3.1 速查表','速查表','','https://www.94xh.com/index.html',5,4,'2021-11-10 14:45:01','2021-11-18 13:40:08'),
(95,'flv.js(播放器)','flv.js 是一个使用纯JavaScript编写的FLV(HTML5 Flash Video)播放器。','','https://www.bootcdn.cn/flv.js/1.5.0/',5,4,'2021-11-10 14:45:01','2021-11-18 13:39:57'),
(96,'福利汇总','大千世界收集福利分享','','https://www.gifxu.com/',10,4,'2021-11-10 14:45:01','2021-11-18 12:28:16'),
(97,'Animate.css','Just-add-water CSS animations','','https://animate.style/',9,4,'2021-11-10 14:45:01','2021-11-18 10:58:10'),
(98,'Typecho','Typecho博客分享','https://qqdie.com/wp-content/themes/lighthouse/images/typecho.png','https://qqdie.com/links.html',27,4,'2021-11-10 14:45:01','2022-10-13 10:13:24'),
(99,'Umar Hansa的开发人员技巧','开发人员技巧','','https://umaar.com/dev-tips/',13,4,'2021-11-10 14:45:01','2022-12-26 16:16:55'),
(100,'iconfont','阿里巴巴图形库','','https://www.iconfont.cn/',18,4,'2021-11-10 14:45:01','2021-11-18 14:36:05'),
(101,'highlight.js','Web语法突出显示','','https://highlightjs.org/',5,4,'2021-11-10 14:45:01','2021-11-18 10:57:30'),
(102,'MakingCSS','The web tool for generating CSS3 code','','https://makingcss.com/',9,4,'2021-11-10 14:45:01','2021-11-18 10:57:38'),
(103,'CSS生成器','','','https://www.cssportal.com/',9,4,'2021-11-10 14:45:01','2021-11-18 10:37:40'),
(104,'LintCode 领扣','空前强大的  在线编程  训练系统  即刻启程！','','https://www.lintcode.com/',17,4,'2021-11-10 14:45:01','2021-11-18 10:52:12'),
(105,'postcss简介','PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。','','https://www.cnblogs.com/aidixie/p/12771985.html',9,4,'2021-11-10 14:45:01','2021-11-18 10:44:28'),
(106,'TypeScript','TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。\nTypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。','','https://www.tslang.cn/index.html',5,4,'2021-11-10 14:45:01','2021-11-18 10:44:35'),
(107,'Axios中文文档','Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。','','https://www.kancloud.cn/yunye/axios/234845',13,4,'2021-11-10 14:45:01','2021-11-18 10:44:07'),
(108,'关于ASP.NETCore的分享之路','学习路线图\nASP.NET CORE学习指南\n《基础知识掌握部分》\n《部署与组件学习部分》\n《容器化与跨平台部分》','','https://www.cnblogs.com/laozhang-is-phi/p/all-knowledge-for-netcore.html#autoid-2-1-0',15,4,'2021-11-10 14:45:01','2021-11-18 14:36:14'),
(109,'C#之Action和Func的用法','','','https://www.cnblogs.com/LipeiNet/p/4694225.html',7,4,'2021-11-10 14:45:01','2022-10-18 08:29:37'),
(110,'NanUI 界面组件','这是一个开放源代码的 .NET / .NET Core 窗体应用程序（WinForms）界面组件。您可以使用 HTML5 / CSS3 / Javascript 等前端技术来构建您的应用程序界面。主流的Javascript框架，比如Angular, React, Vue都是可以用来构架SPA应用的明智选择。使用 NanUI 界面组件将给您的窗体设计工作带来无限可能。','','https://www.formium.net/',4,4,'2021-11-10 14:45:01','2021-11-18 10:44:13'),
(112,'vuepress-theme-vdoing','一款简洁高效的VuePress 知识管理&博客 主题','https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/','https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/',3,4,'2021-11-10 14:45:01','2022-10-18 08:29:26'),
(113,'软件工艺师(bibi)','视频教程','https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/','https://space.bilibili.com/361469957/video',8,4,'2021-11-10 14:45:01','2021-11-18 10:38:51'),
(114,'NetModular','为中小型企业而生的基于.Net Core平台的模块化快速开发解决方案','https://docs.17mkh.com/images/logo.png','https://docs.17mkh.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:29:19'),
(115,'秦枫鸢梦','花有重开日，人无再少年','https://q1.qlogo.cn/g?b=qq&nk=2013143650&s=100','https://blog.zwying.com/',8,4,'2021-11-10 14:45:01','2021-11-18 10:39:15'),
(116,'Mikutap','','','https://xiabor.com/',8,4,'2021-11-10 14:45:01','2022-10-18 08:29:04'),
(117,'Typora','Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。','','https://typora.io/',27,4,'2021-11-10 14:45:01','2022-10-13 10:13:51'),
(119,'ExCSS','一个CSS3解析器C#库','','https://www.ctolib.com/ExCSS.html',4,4,'2021-11-10 14:45:01','2021-11-18 10:39:02'),
(120,'Everything','Everything中文版是一款功能强大，便捷实用的文件搜索软件。','','https://everything.en.softonic.com/',14,4,'2021-11-10 14:45:01','2022-10-18 08:27:59'),
(121,'AnyDesk','远程连接到您的计算机，无论是从办公室的另一层还是世界的另一端。 AnyDesk为IT专业人员和移动用户提供安全可靠的远程桌面连接。','','https://anydesk.com/zhs',14,4,'2021-11-10 14:45:01','2022-10-18 08:27:52'),
(122,'WebStorm','WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。','','https://www.jetbrains.com/help/webstorm/installation-guide.html',14,4,'2021-11-10 14:45:01','2021-11-18 10:43:58'),
(124,'XMind','思如泉涌 • 成竹在图','','https://www.xmind.cn/',14,4,'2021-11-10 14:45:01','2021-11-18 10:39:08'),
(125,'Postman','API开发协作平台','','https://www.postman.com/',14,4,'2021-11-10 14:45:01','2021-11-18 10:35:45'),
(126,'AutoHotkey','AutoHotkey 是一个自由、开源的宏生成器和自动化软件工具，它让用户能够自动执行重复性任务。AutoHotkey 可以修改任何应用程序的用户界面（例如，把默认的 Windows 按键控制命令替换为 Emacs 风格）。它是由定制的脚本语言驱动，旨在提供键盘快捷键或热键。——wikipedia','','https://www.autohotkey.com/',14,4,'2021-11-10 14:45:01','2021-11-17 17:10:09'),
(127,'Notepad++','Notepad++ 是在微软视窗环境之下的一个免费的代码编辑器。为了产生小巧且有效率的代码编辑器,这个在GPL许可证下的自由软体开发专案采用 win32 api 和 STL 以 ...','','https://notepad-plus-plus.org/',14,4,'2021-11-10 14:45:01','2021-11-17 17:10:00'),
(128,'字体仓库','免费字体库','','https://www.ziticangku.com/',14,4,'2021-11-10 14:45:01','2021-11-17 17:09:40'),
(129,'You-need-to-know-css','为了以后可以更爽的复制粘贴，笔者把自己的收获和工作中常用的一些CSS小样式总结成这份文档','','https://lhammer.cn/You-need-to-know-css/#/zh-cn/',9,4,'2021-11-10 14:45:01','2021-11-17 17:09:33'),
(130,'CSS Tricks','总结一些常用的 CSS 样式\n记录一些 CSS 的新属性和一点奇技淫巧\n在“动”部分下有些动画并不是 CSS 效果，因为没有地方放置，所以暂时寄存在这里\n尽量少说废话，代码简单易用，方便复制','','http://css-tricks.neatbang.com/',9,4,'2021-11-10 14:45:01','2021-11-17 17:09:22'),
(131,'animista','该项目里面有各种 CSS 实现的效果，还有代码演示，方便直接复制代码，还可以复制压缩后的代码，如果你在找某个 CSS 的效果的话，可以到这里找找看。','','https://animista.net/',9,4,'2021-11-10 14:45:01','2021-11-18 10:35:52'),
(132,'spinkit','汇集了实现各种加载效果的 CSS 代码片段。\n\nSpinKit 仅使用（transform 和 opacity）CSS 动画来创建平滑且易于自定义的动画。','','https://tobiasahlin.com/spinkit/',9,4,'2021-11-10 14:45:01','2022-10-18 08:27:41'),
(133,'Blog.Admin','框架涵盖 VUE 开发中常见的基本知识点，不仅适合初学者入门，同时也适用于企业级别的开发。','','https://vueadmin.neters.club/.doc/',19,4,'2021-11-10 14:45:01','2021-11-17 17:09:47'),
(134,'.NET Core 学习资料精选：入门','主要分享一些.NET Core比较优秀的社区资料和微软官方资料。我进行了知识点归类，让大家可以更清晰的学习.NET Core。\n\n首先感谢资料原作者的贡献。','','https://www.cnblogs.com/heyuquan/p/dotnet-basic-learning-resource.html',15,4,'2021-11-10 14:45:01','2021-11-17 17:05:08'),
(135,'.NET Core 学习资料精选：进阶','主要分享一些.NET Core比较优秀的社区资料和微软官方资料。我进行了知识点归类，让大家可以更清晰的学习.NET Core。\n\n首先感谢资料原作者的贡献。','','https://www.cnblogs.com/heyuquan/p/dotnet-advance-learning-resource.html',15,4,'2021-11-10 14:45:01','2021-11-17 17:09:11'),
(136,'ASP.NET Core on K8S 入门学习系列文章目录','K8S的入门学习放到了2019年的学习列表中，并总结了一些学习笔记和实践总结的文章并汇总在这里，希望对各位园友有帮助！','','https://www.cnblogs.com/edisonchou/',15,4,'2021-11-10 14:45:01','2021-11-18 12:28:04'),
(137,'.NET Core微服务架构学习与实践系列文章目录','拥抱开源，任重而道远！','K8S的入门学习放到了2019年的学习列表中，并总结了一些学习笔记和实践总结的文章并汇总在这里，希望对各位园友有帮助！','https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html',15,4,'2021-11-10 14:45:01','2021-11-18 10:43:50'),
(138,'C# 官方语言指南','提供许多有关 C# 语言学习资源、新增功能、概念、操作指南、编程指南和语言参考等。','','https://docs.microsoft.com/zh-cn/dotnet/csharp/',13,4,'2021-11-10 14:45:01','2021-11-17 17:04:51'),
(139,'ASP.NET Core 教程','跨平台的高性能开源框架，用于在 Windows、Mac 或 Linux 上开发基于现代化的 Web 应用程序。','','https://docs.microsoft.com/zh-cn/aspnet/core/?view=aspnetcore-5.0',15,4,'2021-11-10 14:45:01','2021-11-18 10:59:12'),
(140,'EF Core 官方教程','Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的常用数据访问技术。','','https://docs.microsoft.com/zh-cn/ef/core/',13,4,'2021-11-10 14:45:01','2021-11-17 16:56:56'),
(141,'Visual Studio 文档','学习使用强大功能提高开发效率，开发、生成、调试、测试、部署、版本控制、 DevOps 和性能分析','','https://docs.microsoft.com/zh-cn/visualstudio/?view=vs-2019',13,4,'2021-11-10 14:45:01','2021-11-17 16:56:48'),
(142,'.NET 微服务应用程序架构指南','本指南介绍如何使用 .NET Core 和 Docker 容器开发基于微服务的应用程序并对其进行管理。','','https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/',4,4,'2021-11-10 14:45:01','2021-11-18 10:43:30'),
(143,'微软 eShopOnWeb 开源框架','基于 ASP.NET Core 构建的单体分层应用架构，使用 DDD 领域驱动设计程序体系结构和部署模型。','','https://www.cnblogs.com/MrHSR/p/10855824.html',4,4,'2021-11-10 14:45:01','2021-11-17 16:56:23'),
(144,'IdentityServer4中文文档','dentityServer4 是一个免费的开源 OpenID Connect 和 OAuth 2.0 身份认证与授权框架，适用于 ASP.NET Core 平台，IdentityServer4 由 Dominick Baier 和 Brock Allen 两位大神创建和维护，您可以快捷的在应用程序中集成基于令牌的身份验证，单点登录和 API 访问控制，支持非常多的协议实现和可扩展点，IdentityServer4 由 OpenID 基金会正式认证，因此符合规范且可互操作，被微软作为 .NET 基金会项目的一部分，并根据其行为准则运行，虽然这个框架也非常的好，博客也不少，但以下整理的中文文档值得推荐学习。','','https://www.xcode.me/post/6038#',4,4,'2021-11-10 14:45:01','2021-11-17 16:56:30'),
(145,'dnSpy基于.NET的反编译工具','dnSpy是一款基于.NET的反编译与调试工具，开源免费，能够讲.NET开发的Exe和Dll程序集反编译为C#代码，同时支持断点调试和代码二次编辑，如果您只有编译后的程序集，在没有源码的情况下想还原C#源码，dnSpy绝对是首选。','','https://github.com/dnSpy/dnSpy/releases',4,4,'2021-11-10 14:45:01','2021-11-17 17:05:15'),
(146,'Visual Studio 2015','软就放出了VS2015不同版本的离线安装镜像包，支持32位和64位，现在，您就可以下载并安装它','','https://www.xcode.me/post/1916',14,4,'2021-11-10 14:45:01','2021-11-17 16:55:55'),
(147,'微软官方常用系统工具合集','这些小工具原本是为了解决工程师们平常在工作上遇到的各种问题而开发的，之后他们将这些工具集合起来称为 Sysinternals，并免费提供公众下载，其中部分还开源了，一直以来都颇受 IT 界人士的好评。如果把管理员比喻成战士的话，那么 Sysinternals 就是我们手中的良兵利器。熟悉和掌握这些工具，并且对 Windows 的体系有一定的了解，将大幅提高你的电脑维护、应用技能。','','https://www.xcode.me/post/1631',4,4,'2021-11-10 14:45:01','2021-11-17 17:04:59'),
(149,'零度编程','分享编程之美','','https://www.xcode.me/',8,4,'2021-11-10 14:45:01','2021-11-17 16:54:17'),
(150,'技术胖','专注前端开发,每年100集免费视频。','https://blogimages.jspang.com/blogtouxiang1.jpg','http://www.jspang.com/',8,4,'2021-11-10 14:45:01','2021-11-17 16:40:28'),
(151,'网站(Web App)','这里包含了基于Vue.js开发的网站应用程序，包括管理工具、网页游戏、购物社交网站等。','','https://madewith.cn/',3,4,'2021-11-10 14:45:01','2021-11-17 16:40:20'),
(152,'任务协助系统','任何业务场景，您都可以找到合适的方案 PearProject 拥有丰富且灵活的产品研发管理功能，协助您释放产品研发能力，是推动研发进程的强力驱动','','https://home.vilson.xyz/?from=madewith.cn#/',13,4,'2021-11-10 14:45:01','2021-11-17 16:40:10'),
(154,'npm','NPM（node package manager）是 Node.js 世界的包管理器。NPM 可以让 JavaScript 开发者在共享代码、复用代码以及更新共享的代码上更加方便。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/npm.png','https://www.npmjs.cn/',13,4,'2021-11-10 14:45:01','2022-10-18 10:02:47'),
(155,'Lerna','Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/lernajs.png','https://lernajs.bootcss.com/',5,4,'2021-11-10 14:45:01','2021-11-18 10:36:35'),
(157,'Nuxt.js','Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/nuxtjs.png','https://www.nuxtjs.cn/',19,4,'2021-11-10 14:45:01','2021-11-18 10:36:01'),
(158,'Parcel','Parcel - 极速、零配置的 web 应用打包工具。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/parcel.png','https://www.parceljs.cn/',13,4,'2021-11-10 14:45:01','2021-11-17 16:54:33'),
(160,'Pro Git','Pro Git 中文版（第二版）是一本详细的 Git 指南，主要介绍了 Git 的使用基础和原理，让你从 Git 初学者成为 Git 专家。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/progit.png','https://www.progit.cn/',13,4,'2021-11-10 14:45:01','2021-11-18 10:36:26'),
(161,'PurgeCSS','PurgeCSS 是一个用来删除未使用的 CSS 代码的工具，能够减小 CSS 文件的体积。例如可以用来减小 Bootstrap 等前端框架的文件体积，提升加载速度。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/purgecss.png','https://www.purgecss.cn/',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:47'),
(162,'Markdown','Markdown 是一种轻量级标记语言，便于人们使用易读易写的纯文本格式编写文档并添加格式元素。Markdown 是 John Gruber 于 2004 年创建的。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/markdown.png','https://www.markdown.xyz/',20,4,'2021-11-10 14:45:01','2021-11-16 16:37:14'),
(163,'ESLint','ESLint 是一个插件化并且可配置的 JavaScript 语法规则和代码风格的检查工具。ESLint 能够帮你轻松写出高质量的 JavaScript 代码。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/eslint.png','https://cn.eslint.org/',3,4,'2021-11-10 14:45:01','2021-11-16 16:37:05'),
(164,'Infima CSS 框架','Infima 是 Facebook 出品的一个 CSS 框架，专为内容驱动型网站而设计，并且内建对暗模式的支持。是 Docusaurus 的姊妹项目。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/infima.png','https://infima.bootcss.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:38'),
(165,'Stylus','Stylus - 富于表现力、健壮、功能丰富的 CSS 预处理语言。','https://cdn.jsdelivr.net/npm/@bootcss/www.bootcss.com@0.0.37/dist/img/stylus.png','https://stylus.bootcss.com/',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:38'),
(166,'懒得勤快','勤于发现,乐于分享','https://git.imweb.io/ldqk/imgbed/raw/master/20190606/5dc7fc1266bfd8109d1ef5e0e7630f2c_2_3_art.png','https://masuit.org/',8,4,'2021-11-10 14:45:01','2022-11-02 16:34:25'),
(167,'爱哔哔','视频解析','','https://www.ibilibili.com/',14,4,'2021-11-10 14:45:01','2021-11-16 16:36:45'),
(168,'果核剥壳','工具分享','https://www.ghpym.com/wp-content/uploads/2019/12/2020logo.png','https://www.ghpym.com/category/all/pcsoft/pccode',14,4,'2021-11-10 14:45:01','2021-11-16 16:36:59'),
(169,'醉秋风','要相信一切都是最好的安排','https://blog.slomoo.cn/slomoo.png','https://blog.slomoo.cn/',8,4,'2021-11-10 14:45:01','2021-11-16 16:36:27'),
(170,'薛定喵君','scan to see more ?','http://tiaocaoer.com/images/site_icon.png','http://tiaocaoer.com/',8,4,'2021-11-10 14:45:01','2021-11-16 16:36:51'),
(171,'舔狗日记','我们是狗,是舔狗','https://we.dog/assets/images/logo.gif','https://we.dog/',10,4,'2021-11-10 14:45:01','2021-11-16 16:35:44'),
(172,'rscss','CSS样式表结构的合理系统。\n一组简单的想法可以指导您构建可维护CSS的过程。','https://we.dog/assets/images/logo.gif','https://rscss.io/index.html',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:20'),
(173,'WEB安全色','WEB安全色','','https://www.bootcss.com/p/websafecolors/',9,4,'2021-11-10 14:45:01','2021-11-16 16:36:00'),
(174,'Adobe Color ','色輪 (或「擷取主題」標籤中的影像)','','https://color.adobe.com/zh/create/color-wheel',9,4,'2021-11-10 14:45:01','2021-11-18 10:36:08'),
(175,'中国色 ','中国色 ','','http://zhongguose.com/',9,4,'2021-11-10 14:45:01','2021-11-16 16:35:52'),
(176,'托盘式 ','利用数百万设计师的知识生成漂亮的调色板。','','https://www.palettable.io/CCCC82',9,4,'2021-11-10 14:45:01','2021-11-17 17:04:42'),
(177,'itmeo','WebGradients 是180个线性渐变的免费集合，您可以将其用作\n网站任何部分的内容背景。轻松复制CSS3跨浏览器代码\n，稍后使用！我们还为每个渐变准备了.PNG版本。\n 作为奖励，还有用于Sketch  ＆  Photoshop的软件包 。','','https://webgradients.com/',9,4,'2021-11-10 14:45:01','2021-11-17 16:56:42'),
(178,'配色表','网页设计常用色彩搭配表','','http://tool.c7sky.com/webcolor/',9,4,'2021-11-10 14:45:01','2021-11-16 16:34:27'),
(179,'avascript粒子动画引擎','avascript粒子动画引擎','','https://drawcall.github.io/Proton/#examples',9,4,'2021-11-10 14:45:01','2021-11-16 16:36:20'),
(180,'Keyframes helps you write better CSS','Dead simple visual tools to help you generate CSS for your projects.','','https://keyframes.app/',9,4,'2021-11-10 14:45:01','2021-11-16 16:35:34'),
(181,'Ant Design Pro','开箱即用的中台前端/设计解决方案','','https://pro.ant.design/index-cn',19,4,'2021-11-10 14:45:01','2021-11-17 16:39:29'),
(182,'Laravel诗词博客','','','https://www.qqphp.com/article',8,4,'2021-11-10 14:45:01','2021-11-16 15:46:38'),
(183,'hexo','快速、简洁且高效的博客框架','','https://hexo.io/zh-cn/',13,4,'2021-11-10 14:45:01','2021-11-16 16:35:21'),
(184,'Gridea',' 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。','','https://gridea.dev/',13,4,'2021-11-10 14:45:01','2021-11-16 16:35:29'),
(185,'awesome-bookmarks','个人收藏夹','','https://panjiachen.github.io/awesome-bookmarks/',11,4,'2021-11-10 14:45:01','2021-11-18 10:36:18'),
(186,'VueRequest','⚡️ 一个很酷的 Vue3 的请求库','','https://cn.attojs.org/',3,4,'2021-11-10 14:45:01','2021-11-16 16:34:20'),
(187,'牛客网','','','https://www.nowcoder.com/profile/8768562',17,4,'2021-11-10 14:45:01','2021-11-16 15:44:54'),
(188,'TinyPNG','','','https://tinypng.com/',18,4,'2021-11-10 14:45:01','2021-11-16 16:36:09'),
(189,'长征部落格','事 不 三 思 终 有 悔， 人 能 百 忍 自 无 忧。','','https://www.cz5h.com/',8,4,'2021-11-10 14:45:01','2021-11-16 15:44:02'),
(190,'Zidone','莫道君行早 更有早行人','','https://www.aye.ink/',8,4,'2021-11-10 14:45:01','2021-11-16 16:34:12'),
(191,'天涯社区','提供论坛、部落、博客、问答、文学、相册、个人空间等服务。拥有天涯杂谈、娱乐八卦、情感天地等人气栏目,以及关天茶舍、煮酒论史等高端人文论坛。','https://static.tianyaui.com/global/bbs/web/static/images/weixin_code.jpg','https://bbs.tianya.cn/',10,4,'2021-11-10 14:45:01','2021-11-16 15:45:07'),
(192,'胶囊日记','凌晨零点，集体失忆','http://s4.timepill.net/s/w220/topic/74toih.png','http://www.timepill.net/',10,4,'2021-11-10 14:45:01','2021-11-16 15:45:01'),
(193,'码库CTOlib','收集GitHub上的实用dotnet开源项目，并进行分类。每天都有新的库和项目添加到列表中。','https://www.ctolib.com/static/img/getqrcode.jpg','https://www.ctolib.com/',11,4,'2021-11-10 14:45:01','2021-11-17 16:55:45'),
(194,'SegmentFault','每一位开发者都在贡献和更新技术内容，共同参与社区建设，维护社区秩序。\n\n如果你和我们一样有技术理想，并愿意贡献自己的力量，欢迎加入我们。','https://cdn.segmentfault.com/r-d209f51c/static/logo-b.d865fc97.svg','https://segmentfault.com/',10,4,'2021-11-10 14:45:01','2021-11-17 16:55:37'),
(195,'LearnKu','编程者社区','https://cdn.learnku.com/uploads/images/201901/24/1/OyBnfB2vlk.png!/both/44x44','https://learnku.com/',10,4,'2021-11-10 14:45:01','2021-11-16 11:54:14'),
(196,'毒导航','网络资源','https://www.toxic.ltd/wp-content/uploads/2020/04/lang_logo.png','https://www.toxic.ltd/',11,4,'2021-11-10 14:45:01','2021-11-16 15:44:35'),
(197,'tailblocks','tailblocks','','https://tailblocks.cc/',19,4,'2021-11-10 14:45:01','2021-11-16 16:33:56'),
(198,'TailwindCSS 中文网','TailwindCSS 使用教程、TailwindCSS 中文文档及 TailwindCSS 相关资源','https://tailwindchina.com/logo.png','https://tailwindchina.com/',13,4,'2021-11-10 14:45:01','2021-11-16 15:46:22'),
(199,'vue-tailwind.com','针对 TailwindCss 优化的 Lightview 和完全可定制的 Vue 组件集','','https://www.vue-tailwind.com/',19,4,'2021-11-10 14:45:01','2021-11-16 16:34:05'),
(200,'emantic UI','用户界面就是 Web 的语言','','https://semantic-ui.com/',19,4,'2021-11-10 14:45:01','2021-11-16 15:46:31'),
(201,'be-a-professional-programmer','成为专业程序员路上用到的各种优秀资料、神器及框架','','http://tools.stanzhai.site/',13,4,'2021-11-10 14:45:01','2021-11-16 11:39:41'),
(202,'Bulma','现代化的CSS框架','Bulma是一个免费、开源的CSS框架，它提供了易于使用的前端的组件，您可以轻松地组合这些组件来构建响应式Web界面。','https://bulma.zcopy.site/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:31'),
(203,'PhotoKit','图片编辑器','https://photokit.com/images/editor.min.webp','https://photokit.com/?lang=zh',18,4,'2021-11-10 14:45:01','2021-11-16 14:15:02'),
(204,'V2EX','V2EX 是一个关于分享和探索的地方','','https://www.v2ex.com/',10,4,'2021-11-10 14:45:01','2021-11-16 15:44:16'),
(205,'screensiz','screensiz','','https://screensiz.es/phone',14,4,'2021-11-10 14:45:01','2021-11-17 16:55:28'),
(206,'Vue Router','用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。','https://cdn4.buysellads.net/uu/1/3386/1525189943-38523.png','https://next.router.vuejs.org/',3,4,'2021-11-10 14:45:01','2021-11-16 15:44:08'),
(207,'View UI','View UI®，即原先的 iView，是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。','https://file.iviewui.com/dist/7dcf5af41fac2e4728549fa7e73d61c5.svg','https://www.iviewui.com/docs/introduce',19,4,'2021-11-10 14:45:01','2021-11-16 15:42:35'),
(208,'it365万能解码器','it365万能解码器，能自动识别各种编码的文本文件，如：GB2312、Big5、UTF-8等。此解码器小巧，但是非常强悍。支持几十种编码，支持自动探测文件编码。一个web网页程序，就能解决文件乱码、编码转换等工作。','https://c10365.now.sh/zan/active.jpg','https://it365.gitlab.io/zh-cn/decode/?81206z',14,4,'2021-11-10 14:45:01','2021-11-16 14:15:09'),
(209,'果糖网net论坛','','https://www.donet5.com/HtmlTemplate2/com_files/logo.png','https://www.donet5.com/',10,4,'2021-11-10 14:45:01','2021-11-16 14:17:04'),
(210,'Vue3 One Piece','下一代web开发方式，更快，更轻，易维护，更多的原生支持','https://static.vue-js.com/6280b990-ff19-11ea-85f6-6fac77c0c9b3.png','https://vue3js.cn/',3,4,'2021-11-10 14:45:01','2021-11-16 14:14:50'),
(211,'vuepress-theme-vdoing','一款简洁高效的VuePress 知识管理&博客 主题','https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200409124835.png','https://doc.xugaoyi.com/',13,4,'2021-11-10 14:45:01','2021-11-16 15:42:27'),
(212,'TailwindCSS的漂亮扩展。','Tailwind Starter Kit是免费和开源的。它不会更改或从TailwindCSS向已添加的CSS添加任何CSS 。它具有多个HTML元素，并带有ReactJS，Vue和Angular的动态组件。','','https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation',19,4,'2021-11-10 14:45:01','2021-11-16 11:57:06'),
(213,'创造者日报','一群创造者','','https://creatorsdaily.com/',10,4,'2021-11-10 14:45:01','2021-11-16 14:13:23'),
(214,'唧唧','','','https://www.jijidown.com/',8,4,'2021-11-10 14:45:01','2021-11-16 14:14:34'),
(215,'OpenJudge','OpenJudge是开放的在线程序评测系统','','http://openjudge.cn/',14,4,'2021-11-10 14:45:01','2021-11-16 14:13:18'),
(217,'万有导航','','','http://wanyouw.com/',11,4,'2021-11-10 14:45:01','2021-11-16 14:13:05'),
(218,'极客阅读','','','https://jikeyuedu.cn/topic/Vue.js',10,4,'2021-11-10 14:45:01','2021-11-16 14:12:59'),
(219,'鱼塘热榜','','','https://mo.fish/',10,4,'2021-11-10 14:45:01','2021-11-16 14:12:52'),
(220,'老张的哲学','','','https://www.cnblogs.com/laozhang-is-phi/',8,4,'2021-11-10 14:45:01','2021-11-16 11:55:03'),
(221,'软件盒子','','','https://www.bsc1011.top/',11,4,'2021-11-10 14:45:01','2021-11-16 14:12:47'),
(222,'编程导航','站长是腾讯全栈开发 & 腾讯云开发高级布道师，欢迎关注他的  微信公众号【程序员鱼皮】，或添加  微信 liyupi66  交流学习 ','','https://www.code-nav.cn/recommend',11,4,'2021-11-10 14:45:01','2021-11-16 14:12:39'),
(223,'手把手教你AspNetCore WebApi：数据验证','小明最近又遇到麻烦了，小红希望对接接口传送的数据进行验证，既然是小红要求，那小明说什么都得满足呀，这还不简单嘛。','','https://www.cnblogs.com/zcqiand/p/13795675.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:33'),
(224,'缓存（MemoryCache和Redis）','这几天小明又有烦恼了，系统上线一段时间后，系统性能出现了问题，马老板很生气，叫小明一定要解决这个问题。性能问题一般用什么来解决呢？小明第一时间想到了缓存。','','https://www.cnblogs.com/zcqiand/p/13816732.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:55:11'),
(225,'Autofac一个优秀的.NET IoC框架','Autofac与C#语言的结合非常紧密，并学习它非常的简单，也是.NET领域最为流行的IoC框架之一。','','https://www.cnblogs.com/zcqiand/p/14257650.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:27'),
(226,'.net Core 使用AutoMapper','在我们的项目中慢慢的要把数据库的实体模型和视图模型进行分离，防止被人拿到我们表字段。在学校的时候自己只是有将很多数据库模型，写成一个视图模型返回到前台。','','https://www.cnblogs.com/chenxi001/p/11800943.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:21'),
(227,'Autofac 框架初识与应用','AutoFac是一个开源的轻量级的依赖注入容器，也是.net下比较流行的实现依赖注入的工具之一。','','https://www.cnblogs.com/i3yuan/archive/2021/04/13/14654547.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:15'),
(228,'Vue项目中实现用户登录及token验证','','','https://www.cnblogs.com/web-record/p/9876916.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:52'),
(229,'asp.net core 批量依赖注入服务','看园子里netcore的文章都是简单的注入几个服务的例子,在项目中肯定不会一行一行的写注册服务的代码，参考网上，找到一些解决方案，根据自己实际需求进行更改，特记录下来。','','https://www.cnblogs.com/5jia0/archive/2021/04/14/14658642.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:46'),
(230,'张鑫旭的个人主页','张鑫旭-鑫空间-鑫生活','','https://www.zhangxinxu.com/',8,4,'2021-11-10 14:45:01','2021-11-16 11:56:41'),
(231,'colorui文档','','','https://www.kancloud.cn/m22543/colorui/1289223',13,4,'2021-11-10 14:45:01','2021-11-16 11:56:35'),
(232,'lucky-canvas','一个基于 Js + Canvas 的【大转盘 & 九宫格】抽奖，致力于为 web 前端提供一个功能强大且专业可靠的组件，只需要通过简单配置即可实现自由化定制，帮助你快速的完成产品需求','','https://100px.net/',24,4,'2021-11-10 14:45:01','2021-11-16 11:56:30'),
(233,'[C#] NAudio 库的各种常见使用方式: 播放 录制 转码 音频可视化','在 NAudio 中, 常用类型有 WaveIn, WaveOut, WaveStream, WaveFileWriter, WaveFileReader, AudioFileReader 以及接口: IWaveProvider, ISampleProvider, IWaveIn, IWavePlayer','','https://www.cnblogs.com/slimenull/p/14735111.html',4,4,'2021-11-10 14:45:01','2021-11-16 11:56:24'),
(234,'.NET之生成数据库全流程','本文主要是回顾下从项目创建到生成数据到数据库(代码优先)的全部过程。采用EFCore作为ORM框架。','','https://www.cnblogs.com/azrng/p/14757769.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:16'),
(235,'24K导航','','','https://www.24kdh.com/',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:52'),
(236,'印记中文','','','https://docschina.org/',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:47'),
(237,'NuxtJS ','NuxtJS 让你构建你的下一个 Vue.js 应用程序变得更有信心。这是一个 开源 的框架，让 web 开发变得简单而强大','','https://www.nuxtjs.cn/',3,4,'2021-11-10 14:45:01','2021-11-16 11:54:41'),
(238,'Tailwind CSS文档','开始 Tailwind CSS 之旅\n用最适合您的方式学习 Tailwind','','https://www.tailwindcss.cn/docs',13,4,'2021-11-10 14:45:01','2021-11-16 11:54:36'),
(239,'outils 代码库','outils 代码库','','https://www.npmjs.com/package/outils',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:31'),
(240,'30 seconds of code ','代码片段','','https://www.30secondsofcode.org/',5,4,'2021-11-10 14:45:01','2021-11-16 11:54:24'),
(243,'Pagination.js','分页控件','','http://pagination.js.org/',24,4,'2021-11-10 14:45:01','2021-11-16 11:54:03'),
(244,'Lodash 中文文档','Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。','','https://www.lodashjs.com/',5,4,'2021-11-10 14:45:01','2021-11-16 11:53:57'),
(245,'微信SDK微信SDK','微信SDK微信SDK','','https://sdk.weixin.senparc.com/Document',4,4,'2021-11-10 14:45:01','2021-11-16 11:53:52'),
(246,'VUE API 手册','VUE API 手册','','https://vue3js.cn/vue-composition-api/',3,4,'2021-11-10 14:45:01','2021-11-16 11:53:47'),
(247,'极客导航','极客导航','','https://geekdocs.cn/',11,4,'2021-11-10 14:45:01','2021-11-16 11:47:47'),
(248,'.NET 官方文档','了解如何使用 .NET 在任何使用 C#、F# 和 Visual Basic 的平台上创建应用程序。 浏览 API 引用、代码示例、教程以及其他内容。','','https://docs.microsoft.com/zh-cn/dotnet/',4,4,'2021-11-10 14:45:01','2021-11-16 11:53:42'),
(249,'开源前哨','分享热门、有趣和实用的开源项目～','','https://www.zhihu.com/column/c_1317124962785062912',11,4,'2021-11-10 14:45:01','2021-11-16 11:53:35'),
(250,'DotNet 资源大全中文版','DotNet 资源大全中文版，内容包括：编译器、压缩、应用框架、应用模板、加密、数据库、反编译、IDE、日志、风格指南等。','','https://github.com/jobbole/awesome-dotnet-cn#api',11,4,'2021-11-10 14:45:01','2021-11-16 11:53:29'),
(251,'C#/.NET/.NET Core学习视频汇总（持续更新ing）','之前有很多小伙伴在我的公众号后台留言问有没有C#/.NET/.NET Core这方面相关的视频推荐，我一般都会推荐他们去B站搜索一下。今天刚好有空收集了网上一些比较好的C#/.NET/.NET Core这方面的学习视频，希望能够帮助到有需要的小伙伴们。当然假如你有更好的资源视频推荐可以在我的文章下面留言，开篇之前我要感谢各位小伙伴对【C#/.NET/.NET Core学习、工作、面试指南','','https://www.cnblogs.com/Can-daydayup/p/15046838.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:38'),
(256,'MYSQL中数据类型介绍','MySQL的数据类型','1','https://www.cnblogs.com/-xlp/p/8617760.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:53:17'),
(287,'LBO.net','保持饥饿！保持愚蠢！ ->C#在线编辑','','https://www.cnblogs.com/lbonet/',8,4,'2021-11-10 14:45:01','2021-11-16 11:44:54'),
(288,'牛客网','求职之前，先上牛客','','https://www.nowcoder.com/',17,4,'2021-11-10 14:45:01','2021-11-16 11:47:36'),
(289,'GitHub Profile README Generator','简历生成','','https://rahuldkjain.github.io/gh-profile-readme-generator/',14,4,'2021-11-10 14:45:01','2021-11-16 11:53:11'),
(290,'vue3最新学习资料集合，不断更新','vue3最新学习资料集合，不断更新','','https://learnku.com/articles/48928',3,4,'2021-11-10 14:45:01','2021-11-16 11:53:05'),
(292,'wangEditorV5','wangEditorV4\nTypescript 开发的 Web 富文本编辑器， 轻量、简洁、易用、开源免费','','https://www.wangeditor.com/',20,4,'2021-11-10 14:45:01','2022-10-11 13:56:18'),
(293,'最好的uniapp入门实战教程','uniapp是Dcloud公司的产品，是一个跨端开发框架，基于vue.js技术栈。开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。这是它的功能架构图','','https://juejin.cn/post/6899642866693423111#heading-16',15,4,'2021-11-10 14:45:01','2021-11-16 11:47:55'),
(294,'EFCore之详细增删改查','EFCore之详细增删改查','','https://juejin.cn/post/6965727147189075976#heading-31',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:53'),
(295,'NET Core和Blog.Core【老张的哲学】','NET Core和Blog.Core【老张的哲学】','','https://www.yuque.com/docs/share/c58f37a4-677c-4a08-b240-4f7f4088a63b#dlCt7',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:46'),
(296,'Vue3+Vite工程常用工具的接入方法','Vue3+Vite工程常用工具的接入方法','','https://juejin.cn/post/6982476410279460878',15,4,'2021-11-10 14:45:01','2021-11-16 11:48:02'),
(297,'Uni-App从入门到实战-黑马程序员杭州校区出品','Uni-App从入门到实战-黑马程序员杭州校区出品','','https://www.bilibili.com/video/BV1BJ411W7pX?p=40',15,4,'2021-11-10 14:45:01','2021-11-16 11:45:02'),
(298,'dotNet全栈开发','dotNet全栈开发\n.NET Core\\xamarin爱好者、篮球狂热爱好者https://dwz.cn/ppnuFzrZ','','https://blog.csdn.net/kebi007',8,4,'2021-11-10 14:45:01','2021-11-16 11:39:27'),
(299,'什么是 Docker','Docker 最初是 dotCloud 公司创始人 Solomon Hykes (opens new window)在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源 (opens new window)，主要项目代码在 GitHub (opens new window)上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI） (opens new window)。','','https://vuepress.mirror.docker-practice.com/',23,4,'2021-11-10 14:45:01','2021-11-15 14:30:37'),
(300,'编程之家','','','https://www.jb51.cc/netcore/index_2.html',11,4,'2021-11-10 14:45:01','2021-11-16 11:39:18'),
(304,'.NetCore中EFCore的使用整理','EntirtyFramework框架是一个轻量级的可扩展版本的流行实体框架数据访问技术.\n\n其中的.NetCore版本对应EntityFrameworkCore','','https://www.cnblogs.com/tianma3798/p/6835400.html',4,4,'2021-11-10 14:45:01','2021-11-16 11:39:00'),
(305,'【EFCORE笔记】添加数据的多种方案','','','https://www.cnblogs.com/lbonet/p/14599549.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:38:54'),
(306,'ES6 入门教程','《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。','','https://es6.ruanyifeng.com/',15,4,'2021-11-10 14:45:01','2021-11-16 11:38:48'),
(307,'图文','','','https://pixabay.com/',18,4,'2021-11-10 14:45:01','2021-11-16 11:38:41'),
(308,'免费个人图床搭建gitee+PicGo','','','https://www.cnblogs.com/jiba/p/15147616.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:38:35'),
(309,'Moment.js','JavaScript 日期处理类库','','http://momentjs.cn/',5,4,'2021-11-10 14:45:01','2021-11-16 11:38:29'),
(311,'泽泽社长','','','https://zezeshe.com/',8,4,'2021-11-10 14:45:01','2021-11-16 11:29:47'),
(312,'逗比表情包','','','https://www.dbbqb.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:41'),
(313,'两个BT','','','https://www.bttwo.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:36'),
(314,'电影蜜蜂','','','https://www.idybee.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:31'),
(315,'人人影视','','','https://yyets.dmesg.app/home',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:26'),
(316,'努努影视','','','https://www.nunuyy.cc/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:20'),
(317,'人人美剧','','','https://www.meiju11.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:09'),
(318,'pianku','','','https://www.pianku.li/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:16'),
(319,'换脸','','','https://myvoiceyourface.com/',14,4,'2021-11-10 14:45:01','2021-11-16 11:28:57'),
(320,'ECMAScript 6 入门','《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。','','https://es6.ruanyifeng.com/',5,4,'2021-11-10 14:45:01','2021-11-16 11:28:42'),
(321,'Windi CSS','下一代工具类 CSS 框架','','https://cn.windicss.org/',19,4,'2021-11-10 14:45:01','2021-11-16 11:28:37'),
(322,'wow.js','滚动时显示动画。非常Animate.css朋友 :-)\n轻松自定义动画设置：样式、延迟、长度、偏移、迭代...','https://www.delac.io/WOW/img/wow-logo.jpg','https://www.delac.io/WOW/',5,4,'2021-11-10 14:45:01','2021-11-16 11:28:27'),
(323,'.Net Core + DDD基础分层 + 项目基本框架 + 个人总结','','','https://www.cnblogs.com/shijiehaiyang/p/14918544.html',4,4,'2021-11-10 14:45:01','2021-11-16 11:28:21'),
(324,'一文梳理CSS必会知识点','','','https://juejin.cn/post/6854573212337078285',15,4,'2021-11-10 14:45:01','2022-10-18 09:55:09'),
(325,'30个你必须熟记的CSS选择器','','','https://code.tutsplus.com/zh-hans/tutorials/the-30-css-selectors-you-must-memorize--net-16048',15,4,'2021-11-10 14:45:01','2022-10-18 09:55:26'),
(326,'深入理解 TypeScript','','','https://jkchao.github.io/typescript-book-chinese/#why',15,4,'2021-11-10 14:45:01','2021-11-16 11:28:03'),
(327,'Vue Patterns CN','有用的Vue模式，技巧，提示和技巧以及有帮助的精选链接。','','https://zyszys.github.io/vue-patterns-cn/',3,4,'2021-11-10 14:45:01','2021-11-16 11:27:57'),
(328,'代码整洁的 JavaScript','','','https://github.com/beginor/clean-code-javascript',5,4,'2021-11-10 14:45:01','2021-11-15 14:33:46'),
(329,'JavaScript 风格指南','','','https://github.com/alivebao/clean-code-js',5,4,'2021-11-10 14:45:01','2021-11-16 11:27:49'),
(330,'typescript基础史上最强学习文章','','','https://juejin.cn/post/7018805943710253086',15,4,'2021-11-10 14:45:01','2021-11-16 11:27:41'),
(331,'CSS Icons','Open-source CSS, SVG and Figma UI Icons\nAvailable in SVG Sprite, styled-components, NPM & API','','https://css.gg/',9,4,'2021-11-10 14:45:01','2021-11-15 14:33:06'),
(332,'发现导航','','','https://www.nav3.cn/#/light',11,4,'2021-11-10 14:45:01','2021-11-15 14:32:33'),
(333,'50个Vue知识点','','','https://juejin.cn/post/6984210440276410399#heading-21',15,4,'2021-11-10 14:45:01','2021-11-16 11:27:19'),
(334,'daisyUI','Tailwind CSS Components','','https://daisyui.com/',19,4,'2021-11-10 14:45:01','2021-11-16 11:27:11'),
(336,'SqlSugar','NET 开源ORM框架，由果糖大数据科技团队维护和更新 ，开箱即用\n最易上手的ORM框架 ，51Job和Boss直招简历数超过 国外框架 Nhibernate PetaPoco, \n仅次于Dapp','','https://www.donet5.com/',29,4,'2021-11-10 14:45:01','2022-10-18 08:47:54'),
(337,'使用 FluentValidation 实现数据校验、验重','','','https://www.cnblogs.com/zl33842902/p/13514929.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:25:02'),
(338,'c# asp.net core 3.1 自动注入','','','https://www.cnblogs.com/Byboys/p/13744481.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:49'),
(339,'.Net Core3.1下Autofac的使用','','','https://blog.csdn.net/sammy520/article/details/114417432',15,4,'2021-11-10 14:45:01','2021-11-15 14:31:12'),
(340,'获取windows 操作系统下的硬件或操作系统信息等','','','https://www.cnblogs.com/pilgrim/p/15115782.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:56'),
(341,'pixabay','Stunning free images & royalty free stock','','https://pixabay.com/',18,4,'2021-11-10 14:45:01','2021-11-16 11:20:08'),
(342,'学会这几招,轻松让你的github脱颖而出','','','https://juejin.cn/post/6997070653010477087',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:18'),
(343,'使用模板生成网页/Pdf/Word/Png/Html的简历','','','https://github.com/liangjingkanji/Resume-Template',14,4,'2021-11-10 14:45:01','2021-11-15 14:32:41'),
(344,'ASP.NET Core定时之Quartz.NET使用','Quartz.NET 是一个功能齐全的开源作业调度系统，可用于从最小的应用程序到大型企业系统。\n\nQuartz.NET是纯净的，它是一个.Net程序集，是非常流行的Java作业调度系统Quartz的C#实现。','','https://www.cnblogs.com/LaoPaoEr/p/15129899.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:33:37'),
(345,'C# 实现发送QQ邮箱功能','','','https://www.cnblogs.com/2002-YiZhiYu/p/15118080.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:04'),
(346,'.Net Core5.0中Autofac依赖注入整合多层，项目中可直接用','','','https://www.cnblogs.com/wei325/p/15121451.html#autoid-3-0-0',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:12'),
(347,'Fantastic-admin','一款开箱即用的 Vue 中后台管理系统框架','','https://hooray.gitee.io/fantastic-admin/',19,4,'2021-11-10 14:45:01','2021-11-15 14:31:04'),
(348,'vue-element-admin','A magical vue admin','','https://panjiachen.gitee.io/vue-element-admin-site/zh/',19,4,'2021-11-10 14:45:01','2021-11-15 14:31:55'),
(349,'wallhaven','','','https://wallhaven.cc/',18,4,'2021-11-10 14:45:01','2021-11-16 11:19:39'),
(350,'基于vue3实现的vue3-seamless-scroll无缝滚动','','','https://juejin.cn/post/7001831268811800584',24,4,'2021-11-10 14:45:01','2021-11-15 14:30:03'),
(351,'在vite2和Vue3中配置Mockjs _','','','https://www.cnblogs.com/wdyyy/p/mockjs_vite2.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:31:46'),
(352,'Vue 3.0 训练营','Vue 3.0 训练营','','https://vue3.github.io/vue3-News/',3,4,'2021-11-10 14:45:01','2021-11-15 14:29:50'),
(354,'Quasar ','Quasar ','','https://quasar.dev/start/pick-quasar-flavour',19,4,'2021-11-10 14:45:01','2021-11-15 14:29:57'),
(355,'jstips','jstips','','https://www.jstips.co/zh_CN/javascript/',5,4,'2021-11-10 14:45:01','2021-11-15 14:29:33'),
(356,'Pinia','状态管理','','https://pinia.esm.dev/',3,4,'2021-11-10 14:45:01','2021-11-15 14:29:25'),
(357,'Vue-H5-Template','使用 Vue3.0+Typescript+Vant 搭建 h5 开发基础模板，并提供通用型的解决方案。','','https://docs.xwhx.top/',15,4,'2021-11-10 14:45:01','2021-11-15 14:29:20'),
(358,'片段生成器','片段生成器','','https://snippet-generator.app/',27,4,'2021-11-10 14:45:01','2022-10-13 10:15:48'),
(359,'Vben Admin ','一个开箱即用的前端框架','','https://vvbin.cn/doc-next/',19,4,'2021-11-10 14:45:01','2021-11-15 14:29:02'),
(360,'Vue-Mastery学习笔记','Vue-Mastery学习笔记','','https://www.yuque.com/nxtt7g/kompdt',15,4,'2021-11-10 14:45:01','2021-11-15 14:28:56'),
(361,'u.tools','新一代效率工具平台\n自由组合丰富插件，打造随手可取的终极神器','','https://u.tools/',27,4,'2021-11-10 14:45:01','2022-10-13 10:13:09'),
(362,'VARLET','面向Vue3的Material风格移动端组件库','','https://varlet.gitee.io/varlet-ui/#/zh-CN/home',19,4,'2021-11-10 14:45:01','2021-11-15 14:28:42'),
(363,'devhints.io','Rico''s cheatsheets','','https://devhints.io/',13,4,'2021-11-10 14:45:01','2021-11-16 11:18:39'),
(364,'TypeScript 4.0 使用手册','TypeScript语言用于大规模应用的JavaScript开发。 ✔️ TypeScript支持类型，是JavaScript的超集且可以编译成纯JavaScript代码。 ✔️ TypeScript兼容所有浏览器，所有宿主环境，所有操作系统。 ✔️ TypeScript是开源的。','','https://www.bookstack.cn/read/TypeScript-4.0-zh/README.md',13,4,'2021-11-10 14:45:01','2021-11-15 14:28:31'),
(365,'Apifox 使用文档','API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好 API 文档，API 调试、API 数据 Mock、API 自动化测试就可以直接使用，无需再次定义；API 文档和 API 开发调试使用同一个工具，API 调试完成后即可保证和 API 文档定义完全一致。高效、及时、准确！','','https://www.apifox.cn/help/',14,4,'2021-11-10 14:45:01','2021-11-15 14:28:26'),
(366,'Snipaste','Snipaste 不只是截图，善用贴图功能将帮助你提升工作效率','','https://docs.snipaste.com/zh-cn/',14,4,'2021-11-10 14:45:01','2021-11-15 14:28:20'),
(367,'【TypeScript】- 一篇够用的TS总结','【TypeScript】- 一篇够用的TS总结','','https://alexwjj.github.io/pages/cf42a74e3cc8f/',15,4,'2021-11-10 14:45:01','2021-11-15 14:28:12'),
(368,'柠檬大师的空间站','97程序员一枚，软件工程专业，现居北京，喜欢捣腾，专攻后端，用其他技术打辅助','https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg','https://leidl.top/',8,4,'2021-11-10 14:45:01','2021-11-15 14:21:59'),
(369,'Loader Gallery','customize and make your own unique loader!','','https://loading.io/spinner/',9,4,'2021-11-10 14:45:01','2021-11-15 14:28:06'),
(370,'程序员导航','程序员导航','','https://cxy521.com/',11,4,'2021-11-10 14:45:01','2021-11-15 14:17:29'),
(371,'Live Demo','Live Demo','','https://theoxiong.github.io/vue-search-panel/',24,4,'2021-11-10 14:45:01','2021-11-15 14:17:17'),
(372,'书栈网','书栈网','','https://www.bookstack.cn/',10,4,'2021-11-10 14:45:01','2021-11-15 14:16:44'),
(373,'axios','易用、简洁且高效的http库','','http://www.axios-js.com/zh-cn/',3,4,'2021-11-10 14:45:01','2021-11-15 14:16:33'),
(374,'jQuery','jQuery','','http://hemin.cn/jq/',19,4,'2021-11-10 14:45:01','2021-11-15 14:16:27'),
(375,'Linux命令大全(手册)','准确，丰富，稳定，在技术之路上为您护航！','','https://www.linuxcool.com/',15,4,'2021-11-10 14:45:01','2021-11-15 14:16:16'),
(376,'JavaScript中的这些骚操作，你都知道吗？','JavaScript中的这些骚操作，你都知道吗？','','https://juejin.cn/post/7007306019307175966',15,4,'2021-11-10 14:45:01','2021-11-15 14:16:10'),
(377,'分享32个JavaScript工作中常用的代码片段','整理一下工作中常用的JavaScript小技巧分享给大家，希望能帮助到各位小伙伴们，在工作中提升开发效率。','','https://segmentfault.com/a/1190000040637925',15,4,'2021-11-10 14:45:01','2021-11-15 14:15:58'),
(378,'Vue3的7种和Vue2的12种组件通信','Vue3的7种和Vue2的12种组件通信','','https://juejin.cn/post/6999687348120190983',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:53'),
(379,'v-md-editor','v-md-editor 是基于 Vue 开发的 markdown 编辑器组件','','https://ckang1229.gitee.io/vue-markdown-editor/zh/#%E4%BB%8B%E7%BB%8D',20,4,'2021-11-10 14:45:01','2021-11-15 14:14:18'),
(384,'前端“技师”们强推的效率开发工具汇总','各位程序员“技师”提供的小技巧的汇总。将我们平常累计的一些开发技巧分享给大家，希望能对大家有所帮助','图片链接','https://juejin.cn/post/7021320464836329502#heading-3',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:10'),
(385,'Windows 快捷操作大全','快捷键只介绍能让你成为开发大佬的，类似 Ctrl+C、Ctrl+V 这种大家熟知的，一概省略，咱们只来干货。','....','https://juejin.cn/post/7020574670097219621',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:00'),
(386,'一文让你30分钟快速掌握Vue3','经过了漫长的迭代，Vue 3.0 终于在上 2020-09-18 发布了，带了翻天覆地的变化，使用了 Typescript 进行了大规模的重构，带来了 Composition API RFC 版本，类似 React Hook 一样的写 Vue，可以自定义自己的 hook ，让使用者更加的灵活，接下来总结一下 vue 3.0 带来的部分新特性。','图片链接','https://mp.weixin.qq.com/s/1orWGlOXT2Wn2pJLK6VAIg',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:52'),
(387,'前端进阶之道','针对前端的知识难点进行细致入微的讲解，让你的进阶之路不再崎岖！','图片链接','https://yuchengkai.cn/',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:46'),
(388,'Web 控制台终极指南','一旦掌握了控制台，它将帮助我们更有条理、更快地调试并了解应用程序中发生的一切。所以我会试着用例子总结你需要知道的所有内容','图片链接','https://segmentfault.com/a/1190000040705234',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:36'),
(389,'JSRUN.NET','用代码说话,一惯的风格','图片链接','http://jsrun.net/t',13,4,'2021-11-10 14:45:01','2021-11-15 14:13:27'),
(390,'vue-manage-system','vue-manage-system','图片链接','https://github.com/lin-xin/vue-manage-system',24,4,'2021-11-10 14:45:01','2021-11-15 14:13:09'),
(391,'微信Markdown','导航简述','图片链接','https://doocs.gitee.io/md/#/',20,4,'2021-11-10 14:45:01','2021-12-15 15:00:07'),
(392,'cssreference.io','免费的 CSS 视觉指南 通过示例学习：cssreference.io是一个免费的 CSS 视觉指南。它以最流行的属性为特色，并通过插图和动画示例对其进行了解释。','图片链接','https://cssreference.io/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:53'),
(393,'css-tricks.com','可以包含（在另一个特定 HTML 元素中的特定 HTML 元素）','图片链接','https://css-tricks.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:47'),
(400,'color-ui','简述','图片链接','https://www.color-ui.com/',19,4,'2021-11-10 14:45:01','2021-11-15 14:12:39'),
(402,'codemyui','简述','图片链接','https://codemyui.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:32'),
(403,'学习CSS布局','本站教授的是现在广泛使用于网站布局领域的CSS基础。  我们假设你已经掌握了CSS的选择器、属性和值。并且你可能已经对布局有一定了解，即使亲自去写的话还是会很苦恼。如果你想要从头开始学习HTML和CSS，那么你可以看下这篇教程。不然的话，让我们看看我们是否可以让你在下一个项目少一些烦恼。','图片链接','https://zh.learnlayout.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:11:34'),
(410,'CSShake','一些 CSS 类 移动你的 DOM！','图片链接','https://elrumordelaluz.github.io/csshake/',9,4,'2021-11-10 14:45:01','2021-11-15 14:11:28'),
(411,'Nuxt3','使用 Vue 3 构建您的下一个应用程序，体验混合渲染、强大的数据获取和新功能。Nuxt 3 是一个开源框架，使 Web 开发变得简单而强大。','图片链接','https://v3.nuxtjs.org/',3,4,'2021-11-10 14:45:01','2021-11-15 14:11:21'),
(412,'Day.js中文网','Day.js是一个极简的JavaScript库，可以为现代浏览器解析、验证、操作和显示日期和时间。','图片链接','https://dayjs.fenxianglu.cn/',5,4,'2021-11-10 14:45:01','2021-11-15 10:17:04'),
(413,'fenxianglu','fenxianglu','图片链接','https://www.fenxianglu.cn/',13,4,'2021-11-10 14:45:01','2021-11-15 10:16:57'),
(414,'Vuex','Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。','图片链接','https://next.vuex.vuejs.org/zh/',3,4,'2021-11-10 14:45:01','2021-11-15 10:16:37'),
(415,'Vue I18n','Vue I18n 是 Vue.js 的国际化插件','图片链接','https://kazupon.github.io/vue-i18n/zh/',24,4,'2021-11-10 14:45:01','2021-11-15 10:16:30'),
(416,'Material Design 框架','Vuetify 是一个纯手工精心打造的 Material 样式的 Vue UI 组件库。 不需要任何设计技能 — 创建叹为观止的应用程序所需的一切都触手可及。','图片链接','https://vuetifyjs.com/zh-Hans/',19,4,'2021-11-10 14:45:01','2021-11-15 10:16:23'),
(417,'Typora+picGo+Gitee搭建图床','Vuetify 是一个纯手工精心打造的 Material 样式的 Vue UI 组件库。 不需要任何设计技能 — 创建叹为观止的应用程序所需的一切都触手可及。','图片链接','https://juejin.cn/post/7011762633691168805',15,4,'2021-11-10 14:45:01','2021-11-15 10:16:14'),
(418,'Axios的封装思想及实践（TS版本）','Axios的封装思想及实践（TS版本）','图片链接','https://juejin.cn/post/7023006049732919309',15,4,'2021-11-10 14:45:01','2021-11-15 10:16:09'),
(420,'Fect UI -Vue','@fect-ui/vue是根据 Geist-ui/vue作为设计依赖对 vue2 版本进行升级的一个Vue3UI 库。项目基于typescript,拥有更完备的类型提示和对编译器的友好支持, 相较 vue2 版本组件库进行了交互的优化。','图片链接','https://vue.miaya.art/Introduce',19,4,'2021-11-10 14:45:01','2021-11-15 10:15:53'),
(421,'CSS Layout','使用 CSS 制作的流行布局和图案','img','https://csslayout.io/',9,4,'2021-11-10 14:45:01','2021-11-15 10:13:01'),
(422,'vue3-progress','进度条','图片链接','https://vue3-progress-demo.netlify.app/',24,4,'2021-11-10 14:45:01','2021-11-11 16:31:09'),
(423,'webPack转vite所遇到的问题','webPack转vite所遇到的问题','img','https://blog.csdn.net/WH_Crx/article/details/118106097',15,4,'2021-11-10 14:45:01','2021-11-15 10:12:49'),
(424,'mind-map','vue 图文','图片链接','https://github.com/jCodeLife/mind-map/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:41'),
(425,'图像优化','在文件尺寸和质量之间选择完美平衡，并且可获取完整在线预览,您的图像从不会离开您的浏览器。','图片链接','https://zh.recompressor.com/',27,4,'2021-11-10 14:45:01','2022-10-13 10:14:49'),
(426,'Vue Trend','Vue.js Live Demo 的简单、优雅的火花线','img','https://cinwell.com/vue-trend/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:26'),
(427,'极客猿导航','导航','图片链接','https://nav.geekape.net/',11,4,'2021-11-10 14:45:01','2021-11-11 16:29:35'),
(428,'vue-fullscreen','一个用于将任意页面元素进行全屏切换的vue组件，基于 screenfull.js','图片链接','https://mirari.cc/2017/08/14/%E5%85%A8%E5%B1%8F%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6vue-fullscreen/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:14'),
(429,'CodePen','CodePen 是一个面向前端设计人员和开发人员的社交开发环境。构建和部署网站，展示您的工作，构建测试用例以学习和调试，并寻找灵感。','图片链接','https://codepen.io/',9,4,'2021-11-10 14:45:01','2021-11-15 10:12:06'),
(430,'GKA','简单的、高效的帧动画生成工具.  使用简单(仅需一行命令) 内置多种图片优化 多类生成模板，支持定制','图片链接','https://gka.js.org/#/',24,4,'2021-11-10 14:45:01','2021-11-15 10:11:54'),
(431,'Sonar','\"Sonar一个Web系统，展现了静态代码扫描的结果，结果是可以自定义的 ,支持多种语言的原理是它的扩展性 \"','图片链接','http://www.sonar.org.cn/',14,4,'2021-11-10 14:45:01','2021-11-15 10:11:18'),
(432,'highcharts','数据可视化','图片链接','http://www.sonar.org.cn/',5,4,'2021-11-10 14:45:01','2021-11-11 16:29:50'),
(433,'chartjs','图表','图片链接','https://www.chartjs.org/',5,4,'2021-11-10 14:45:01','2021-11-11 16:30:31'),
(434,'Apache ECharts','一个基于 JavaScript 的开源可视化图表库','img','https://echarts.apache.org/zh/index.html',5,4,'2021-11-10 14:45:01','2021-11-15 10:10:53'),
(435,'JavaScript Promise迷你书','本书的目的是以目前还在制定中的ECMAScript 6 Promises规范为中心，着重向各位读者介绍JavaScript中对Promise相关技术的支持情况。','img','http://liubin.org/promises-book/#introduction',13,4,'2021-11-10 14:45:01','2021-11-15 10:10:39'),
(436,'EJS','嵌入式 JavaScript 模板。','img','https://ejs.co/#promo',5,4,'2021-11-10 14:45:01','2021-11-15 10:10:14'),
(437,'Redux 中文官网','JS 应用的状态容器，提供可预测的状态管理','图片链接','https://cn.redux.js.org/',5,4,'2021-11-10 14:45:01','2021-11-11 16:30:56'),
(438,'LOCALFORAGE','localForage 是一个 JavaScript 库，通过简单类似 localStorage API 的异步存储来改进你的 Web 应用程序的离线体验。它能存储多种类型的数据，而不仅仅是字符串。','图片链接','https://localforage.docschina.org/#api-getitem',5,4,'2021-11-10 14:45:01','2021-11-11 16:37:43'),
(439,'v-charts','在使用 echarts 生成图表时，经常需要做繁琐的数据类型转化、修改复杂的配置项，v-charts 的出现正是为了解决这个痛点。基于 Vue2.0 和 echarts 封装的 v-charts 图表组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，便可轻松生成常见的图表。','图片链接','https://v-charts.js.org/#/',24,4,'2021-11-10 14:45:01','2021-11-11 16:30:48'),
(440,'pexels','免费图库','图片链接','https://www.pexels.com/zh-cn/',18,4,'2021-11-10 14:45:01','2021-11-11 16:30:40'),
(441,'HELLOGITHUB','分享 GitHub 上 有趣、入门级的开源项目','图片链接','https://hellogithub.com/',13,4,'2021-11-10 14:45:01','2021-11-15 10:09:57'),
(442,'GitHub Corners','Phew, GitHub is over ten years old now... and is unquestionably synonomous with open source. After 10 years, those GitHub ribbons are more than overdue for a cleaner, more modern alternative. This is my take.  By using SVG, these ','图片链接','https://tholman.com/github-corners/',24,4,'2021-11-10 14:45:01','2021-11-11 16:29:15'),
(444,'Vuetable-2','数据表','图片链接','https://www.vuetable.com/#current-version',24,4,'2021-11-10 14:45:01','2021-11-11 16:28:57'),
(445,'v-viewer','vue的图片查看器组件，支持旋转、缩放、缩放等，基于viewer.js','图片链接','https://mirari.cc/v-viewer/',5,4,'2021-11-10 14:45:01','2021-11-11 16:27:33'),
(446,'Vue 3 选框','为你的 Vue 3 应用程序制作的一个简单的动态选取框组件','图片链接','https://vue3-marquee.vercel.app/',24,4,'2021-11-10 14:45:01','2021-11-11 16:25:35'),
(447,' GoGoCode','代码转换从未如此简单 全网最简单易上手，可读性最强的 AST 处理工具！','图片链接','https://gogocode.io/zh',14,4,'2021-11-10 14:45:01','2021-11-11 16:23:36'),
(448,'hammerjs','hammerjs','图片链接','http://hammerjs.github.io/',5,4,'2021-11-10 14:45:01','2021-11-10 14:59:23'),
(462,'Ovilia','Ovilia','','http://zhangwenli.com/',8,4,'2021-11-15 14:37:19','2021-11-15 14:37:19'),
(463,'carbon','创建和共享源代码的精美图像。 开始在文本区域键入或拖放文件以开始使用。','','https://carbon.now.sh/',14,4,'2021-11-15 14:39:13','2021-11-15 14:39:13'),
(464,'比格张','比格张','','https://bigezhang.com/',11,4,'2021-11-15 14:39:54','2021-11-15 14:39:54'),
(471,'accordionslider','css','','https://accordionslider.com/',9,4,'2021-12-02 15:54:30','2021-12-02 15:54:30'),
(472,'vuex-module-decorators','Typescript/ES7 装饰器使 Vuex 模块变得轻而易举','','https://championswimmer.in/vuex-module-decorators/',3,4,'2021-12-02 15:57:40','2021-12-02 15:57:40'),
(473,'tool.lu','在线工具','','https://tool.lu/',27,4,'2021-12-02 16:09:02','2022-10-13 10:12:18'),
(480,'一条咸鱼与狗的博客','一条咸鱼与狗的博客','','https://purefish.cn/',8,1,'2021-12-03 15:19:28','2021-12-03 15:19:28'),
(481,'图片转码','在线图片转码','','http://www.jsons.cn/img2base64/',18,1,'2021-12-03 15:20:18','2021-12-03 15:20:18'),
(482,'防网易云','防网易云','','https://music-player.immortalboy.cn/',8,4,'2021-12-06 11:19:40','2021-12-06 11:19:40'),
(483,'讨厌的CSS','心脏强者和心灵弱者的动画。','','https://tholman.com/obnoxious/',9,4,'2021-12-06 11:22:36','2021-12-06 11:22:36'),
(484,'VueUse','Collection of essential Vue Composition Utilities','','https://vueuse.org/',3,4,'2021-12-06 11:23:45','2021-12-06 11:23:45'),
(485,'Vue.js 的表单验证','熟悉且易于设置的声明式验证 灵活 同步、异步、字段级或表单级验证  使用直观的 API 和较小的占用空间更快地构建更快的表单','','https://vee-validate.logaretm.com/v4/',24,4,'2021-12-06 11:30:47','2021-12-06 11:30:47'),
(486,'v-slot插槽','第十三篇：你会用v-slot插槽？你倒是用啊','','https://juejin.cn/post/7023188569162252295',15,4,'2021-12-06 13:35:36','2021-12-06 13:35:36'),
(487,'Jest','Jest 是一个令人愉快的 JavaScript 测试框架，专注于 简洁明快。','','https://www.jestjs.cn/',3,4,'2021-12-06 13:49:50','2021-12-06 13:49:50'),
(488,'Qui Max','Neumorphic design system for Web','','https://qvant-lab.github.io/qui-max/',24,4,'2021-12-06 13:57:02','2021-12-06 13:57:02'),
(489,'Zepto','Zepto 是一个轻量级的、针对现代高级浏览器的 JavaScript 工具库，它兼容 jQuery 的 API 。 如果你会用 jQuery，那么你就已经会用 Zepto 了。','','https://zeptojs.bootcss.com/',5,4,'2021-12-06 14:02:01','2021-12-06 14:02:01'),
(490,'ANTD PRO VUE','开箱即用的中台前端/设计解决方案','','https://pro.antdv.com/',19,4,'2021-12-06 14:05:18','2021-12-06 14:05:18'),
(491,'getwaves','Make some waves!','','https://getwaves.io/',9,4,'2021-12-06 14:06:48','2021-12-06 14:06:48'),
(492,'Normalize.css','一种现代的、支持 HTML5 的 CSS 重置替代方案','','http://necolas.github.io/normalize.css/',9,4,'2021-12-06 14:07:53','2021-12-06 14:07:53'),
(493,'vue-awesome-swiper','@vuejs 的 Swiper 组件','','https://github.surmon.me/vue-awesome-swiper/',24,4,'2021-12-06 14:13:23','2021-12-06 14:13:23'),
(494,'lru cache','A cache object that deletes the least-recently-used items.','','https://github.com/isaacs/node-lru-cache#readme',3,4,'2021-12-06 14:18:27','2021-12-06 14:18:27'),
(495,'vite-plugin-vue-docs','vite 插件 - 自动生成 vue 组件文档网站。','','https://meetqy.github.io/vite-plugin-vue-docs/#/docs',24,4,'2021-12-06 14:19:40','2021-12-06 14:19:40'),
(496,'制作缩略图','让我们制作缩略图','','http://makethumbnails.com/#options',18,4,'2021-12-06 14:25:34','2021-12-06 14:25:34'),
(497,'c#编程之路','c#编程之路','','https://www.cjavapy.com/75/',13,4,'2021-12-06 14:44:08','2021-12-06 14:44:08'),
(498,'SweetAlert','SweetAlert 使弹出消息变得简单而漂亮。','','https://sweetalert.js.org/',24,4,'2021-12-06 14:49:43','2021-12-06 14:49:43'),
(499,'Docusaurus','Docusaurus 能够帮助你建立并发布 美观的文档网站。','','https://www.docusaurus.cn/docs',13,4,'2021-12-06 14:54:36','2021-12-06 14:54:36'),
(500,'avaScript for','avaScript for','','https://www.javascript.fun/',11,4,'2021-12-06 15:07:29','2021-12-06 15:07:29'),
(501,'bootswatch','An ode to Metro','','https://bootswatch.com/cosmo/',9,4,'2021-12-06 15:10:26','2022-10-18 09:54:14'),
(502,'icons8','icons8','','https://icons8.com/',18,4,'2021-12-06 15:13:29','2021-12-06 15:13:29'),
(503,'CSS Grid Generator','CSS Grid Generator','','https://cssgrid-generator.netlify.app/',9,4,'2021-12-06 15:17:41','2021-12-06 15:17:41'),
(504,'listary','Are Clumsy File Management Systems Slowing Down Your Workflow?','','https://www.listary.com/',14,4,'2021-12-06 15:19:29','2021-12-06 15:19:29'),
(505,'Vue CLI','ue.js 开发的标准工具','','https://cli.vuejs.org/zh/',3,4,'2021-12-06 15:34:42','2021-12-06 15:34:42'),
(506,'c#扩展方法的使用','c#扩展方法的使用','','https://blog.csdn.net/liangmengbk/article/details/112393864',15,4,'2021-12-09 15:03:51','2021-12-09 15:03:51'),
(507,'fastgithub','fastgithub是使用dotnet开发的一款github加速器','','https://www.cnblogs.com/kewei/p/15533079.html',14,4,'2021-12-09 15:07:45','2021-12-09 15:07:45'),
(508,'Simple CSS','简单的 CSS媒体查询生成器 为数百种设备生成 CSS 媒体查询，包括众多 ipad 和 iphone 型号、三星、LG 的安卓设备等等。有时您必须针对特定设备，这只是一个令人不快的事实。','','https://simplecss.eu/',9,4,'2021-12-15 15:14:02','2021-12-15 15:14:02'),
(509,'BootCDN','BootCDN 稳定、快速、免费的前端开源项目 CDN 加速服务','','https://www.bootcdn.cn/',30,4,'2021-12-15 15:44:57','2022-10-18 09:53:13'),
(510,'staticfile CDN','CDN加速服务','','https://www.staticfile.org/',3,4,'2021-12-15 15:45:41','2022-10-17 15:58:01'),
(511,'convue','convue 是一个基于 vite 和 vue3 开发的一个 vite 的插件，让你拥有一套快速开发项目的体验，类似于 nuxt 和 umi.js。','','https://ziping-li.github.io/convue/zh/index.html',3,4,'2021-12-15 15:54:36','2021-12-15 15:54:36'),
(512,'G6 图可视化引擎','G6 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图可视化、图分析、或图编辑器应用。','','https://antv-g6.gitee.io/zh',19,4,'2021-12-16 14:24:41','2021-12-16 14:24:41'),
(513,'HTML DOM','with vanilla JavaScript','','https://htmldom.dev/',15,4,'2021-12-16 14:27:03','2021-12-16 14:27:03'),
(514,'rolan','即刻提升你的工作效率','','https://getrolan.com/',14,4,'2021-12-16 14:37:05','2021-12-16 14:37:05'),
(515,'极简插件','极简插件','','https://chrome.zzzmh.cn/#/index',14,4,'2021-12-16 14:46:51','2021-12-16 14:46:51'),
(516,'百页窗','一款专业的文件管理工具','','https://shutters.160.com/',14,4,'2021-12-16 15:25:10','2021-12-16 15:25:10'),
(517,'F2 移动端可视化引擎','F2 是一个专注于移动端，面向常规统计图表，开箱即用的可视化引擎，完美支持 H5 环境同时兼容多种环境（Node, 小程序），完备的图形语法理论，满足你的各种可视化需求，专业的移动设计指引为你带来最佳的移动端图表体验。','','https://antv-f2.gitee.io/zh',19,4,'2021-12-16 15:26:21','2021-12-16 15:26:21'),
(518,'Chrome插件扩展下载网','Chrome插件扩展下载网','','https://www.extfans.com/',14,4,'2021-12-16 15:29:24','2021-12-16 15:29:24'),
(520,'box-shadow 例子','所有这些 box-shadow 都是使用复制的  (点击这里尝试免费演示）。 使用 CSS Scan，您可以轻松检查或复制任何网站的 CSS。','','https://getcssscan.com/css-box-shadow-examples',9,4,'2021-12-24 13:55:12','2021-12-24 13:55:12'),
(521,'arco.design','智能设计体系 连接轻盈体验 # 全面开源的企业级产品设计系统','','https://arco.design/',19,4,'2021-12-27 09:29:51','2021-12-27 09:29:51'),
(523,'Vue 组合式 API','Vue 组合式 API','','https://vue3js.cn/vue-composition-api/',3,4,'2022-03-11 10:03:59','2022-03-11 10:03:59'),
(524,'Chart.js','Chart.js','','https://chartjs.bootcss.com/docs/getting-started/',24,4,'2022-03-11 10:04:58','2022-03-11 10:04:58'),
(525,'Cookie的使用（js-cookie插件）','Cookie的使用（js-cookie插件）','','https://www.cnblogs.com/star-meteor/p/12881296.html',15,4,'2022-03-11 10:13:20','2022-03-11 10:13:20'),
(526,'PicGo','图片上传、管理新体验','','https://picgo.github.io/PicGo-Doc/',14,4,'2022-03-11 10:37:23','2022-03-11 10:37:23'),
(527,'手册网','','','https://www.shouce.ren/',13,4,'2022-03-11 10:38:56','2022-03-11 10:38:56'),
(528,'VS插件Supercharger的安装','VS插件Supercharger的安装','','https://www.cnblogs.com/arxive/p/13513057.html',15,4,'2022-03-11 10:39:50','2022-03-11 10:39:50'),
(529,'Axios HTTP','基于 Axios 拓展的 HTTP 模块','','https://zhengxs2018.github.io/axios-http/',3,4,'2022-03-11 11:00:09','2022-03-11 11:00:09'),
(530,'图像编辑','在线图像编辑','','https://pixlr.com/cn/x/#search',14,4,'2022-03-11 11:01:36','2022-03-11 11:01:36'),
(531,'CSI.JS','CSI.JS是一个特别的前端日志系统，帮你快速重建犯罪现场。','','https://github.com/tnfe/csijs',24,4,'2022-03-11 11:13:54','2022-03-11 11:13:54'),
(532,'SunnyUI','winfrom组件文档','','https://gitee.com/yhuse/SunnyUI/wikis/pages?sort_id=3025093&doc_id=1022550',13,4,'2022-03-11 11:20:21','2022-03-11 11:20:21'),
(533,'LOCALFORAGE','改进的离线存储','','http://localforage.docschina.org/',5,4,'2022-03-23 15:16:03','2022-03-23 15:16:03'),
(534,'vite-plugin-vue-layouts','插件','','https://github.com/JohnCampionJr/vite-plugin-vue-layouts',26,4,'2022-03-23 15:20:51','2022-03-23 15:20:51'),
(535,'vite-plugin-vue-type-imports','使您能够导入类型并在您的defineProps和defineEmits','','https://github.com/wheatjs/vite-plugin-vue-type-imports',26,4,'2022-03-23 15:22:44','2022-03-23 15:22:44'),
(536,'迅速了解ES6~ES12的全部特性','迅速了解ES6~ES12的全部特性','','https://juejin.cn/post/7068935394191998990',15,4,'2022-03-23 15:23:24','2022-03-23 15:23:24'),
(537,'ES6-ES12总结','ES6-ES12总结','','https://juejin.cn/post/7012519052841074696',15,4,'2022-03-23 15:24:03','2022-03-23 15:24:03'),
(538,'一文读懂 TypeScript 泛型及应用','一文读懂 TypeScript 泛型及应用','','https://juejin.cn/post/6844904184894980104',15,4,'2022-03-23 15:24:44','2022-03-23 15:24:44'),
(539,'Vue 3 Babel JSX 插件','以 JSX 的方式来编写 Vue 代码','','https://github.com/vuejs/babel-plugin-jsx/blob/dev/packages/babel-plugin-jsx/README-zh_CN.md',26,4,'2022-03-23 15:25:59','2022-03-23 15:25:59'),
(540,'vue插件库','快速查找您想要的内容，多动手，您会发现问题如此简单！','','https://www.vue365.cn/',3,4,'2022-03-23 15:26:49','2022-03-23 15:26:49'),
(541,'.NET Core资料精选','.NET Core资料精选','','.https://www.cnblogs.com/heyuquan/p/dotnet-architecture-learning-resource.html',15,4,'2022-03-23 17:01:46','2022-03-23 17:01:46'),
(542,'总结了38个ES6-ES12的开发技巧','总结了38个ES6-ES12的开发技巧','','https://juejin.cn/post/6995334897065787422',15,4,'2022-03-23 17:02:14','2022-03-23 17:02:14'),
(543,'软件先锋','软件先锋','','https://soft.macxf.com/',14,4,'2022-03-23 17:02:50','2022-03-23 17:02:50'),
(544,'加速器','加速器','','http://101.34.95.10:8081/',14,4,'2022-03-23 17:05:19','2022-03-23 17:05:19'),
(545,'JavaScript工具函数','JavaScript工具函数','','https://juejin.cn/post/6844904181761835016',15,4,'2022-03-23 17:05:51','2022-03-23 17:05:51'),
(546,'vite-plugin-pages','使用Vite的 Vue 3 / React 应用程序的基于文件系统的路由','','https://github.com/hannoeru/vite-plugin-pages',26,4,'2022-03-24 10:49:04','2022-03-24 10:49:04'),
(547,'ProComponents','让中后台开发更简单','','https://procomponents.ant.design/',24,4,'2022-03-24 10:51:04','2022-03-24 10:51:04'),
(548,'netcore','netcore','','https://www.cnblogs.com/Can-daydayup/p/15046838.html',15,4,'2022-03-24 10:51:51','2022-03-24 10:51:51'),
(549,'Shell脚本编程30分钟入门','Shell脚本编程30分钟入门','','https://github.com/qinjx/30min_guides/blob/master/shell.md',15,4,'2022-03-24 10:52:25','2022-03-24 10:52:25'),
(550,'C#/.NET/.NET Core推荐学习书籍','C#/.NET/.NET Core推荐学习书籍','','https://www.cnblogs.com/Can-daydayup/p/14386782.html',15,4,'2022-03-24 10:54:41','2022-03-24 10:54:41'),
(551,'unplugin-icons','unplugin-icons','','https://github.com/antfu/unplugin-icons',26,4,'2022-03-24 10:59:15','2022-03-24 10:59:15'),
(552,'github 的使用技巧 ','github 的使用技巧 ','','https://juejin.cn/post/7069790758022152206',15,4,'2022-03-24 10:59:40','2022-03-24 10:59:40'),
(553,'WLib','WLib是一组对C#.NET和ArcGIS Engine开发常用代码进行封装的基础库和控件库；','','https://github.com/Windr07/WLib',4,4,'2022-03-24 11:02:43','2022-03-24 11:02:43'),
(554,'Chrome 开发者工具','Chrome 开发者工具','','https://leeon.gitbooks.io/devtools/content/',15,4,'2022-03-24 11:03:39','2022-03-24 11:03:39'),
(555,'接口大全','接口大全','','https://www.free-api.com/',11,4,'2022-03-24 11:05:56','2022-03-24 11:05:56'),
(556,'理解ASP.NET Core','理解ASP.NET Core','','https://www.cnblogs.com/xiaoxiaotank/p/15185288.html',15,4,'2022-04-02 10:39:59','2022-04-02 10:39:59'),
(557,'.NET Core中的鉴权授权正确方式(.NET5)','.NET Core中的鉴权授权正确方式(.NET5)','','https://www.cnblogs.com/wei325/p/15575141.html',15,4,'2022-04-02 10:41:23','2022-04-02 10:41:23'),
(558,'iconpark图标','丰富多彩的资源库免费使用','','https://iconpark.oceanengine.com/home',27,4,'2022-04-02 10:46:29','2022-10-17 15:47:17'),
(559,'carbon','代码片段,创建和共享源代码的精美图像。 开始键入或将文件拖放到文本区域中以开始使用。','','https://carbon.now.sh/',27,4,'2022-04-02 10:48:24','2022-10-13 10:10:45'),
(563,'HandyOrg','WPF控件库','','https://handyorg.github.io/',28,4,'2022-10-10 15:55:30','2022-10-18 08:46:08'),
(564,'v-contextmenu','右键菜单','','https://github.com/heynext/v-contextmenu',24,4,'2022-10-11 08:34:48','2022-10-11 08:34:48'),
(565,'Qing''s Blog','Qing''s Blog','','https://www.cnblogs.com/zhaoqingqing/category/527577.html',8,4,'2022-10-11 08:47:05','2022-10-11 08:47:05'),
(566,'Milkdown','插件驱动的所见即所得的Markdown编辑器框架','','https://milkdown.dev/zh-hans/',20,4,'2022-10-11 13:57:11','2022-10-11 13:57:11'),
(567,'css零代码工具箱','本站后续会推出各种前端实用的好工具，杜绝造轮子，每款工具都经过精心打磨，帮助所有程序员提高前端开发效率！','','http://www.lingdaima.com/',27,4,'2022-10-17 10:01:26','2022-10-17 15:40:30'),
(568,'丹枫无迹的博客','码农升级','','https://www.cnblogs.com/gl1573/',8,4,'2022-11-01 14:18:20','2022-11-01 14:18:31'),
(569,'码友网','我们分享C#&.NET/.NET Core及周边文章、问答、教程、资讯等。\n如果你和我们一样热爱.NET程序开发，欢迎加入我们。\n专注.NET，我们是认真的','','https://codedefault.com/',10,4,'2022-11-01 14:19:49','2022-11-01 14:19:49'),
(570,'RestSharp使用教程','RestSharp是一个.NET平台下REST和HTTP API的开源客户端库，支持的平台包括','','https://blog.csdn.net/huyu107/article/details/104502130',15,4,'2022-11-02 16:29:19','2022-11-02 16:29:19'),
(571,'发烧友软件','软件下载','','https://fsylr.com/pc/page/22',14,4,'2022-11-02 16:31:04','2022-11-02 16:31:04'),
(572,'c#使用mysql (MySqlCommand、MySqlDataAdapter、BeginTransaction)','c#使用mysql (MySqlCommand、MySqlDataAdapter、BeginTransaction)','','https://www.cnblogs.com/hepeng-web/p/14654430.html',15,4,'2022-11-02 16:32:58','2022-11-02 16:32:58'),
(573,'C#中的CSV文件读写','C#中的CSV文件读写','','https://www.cnblogs.com/timefiles/p/CsvReadWrite.html',15,4,'2022-11-02 16:33:33','2022-11-02 16:33:33'),
(574,'formkit','vue3组件库','','https://formkit.com/',3,4,'2022-11-02 16:36:06','2022-11-02 16:36:06'),
(575,'gitclone','GitHub缓存加速网站，为开发者服务（使用git2.0+）','','https://gitclone.com/',14,4,'2022-11-02 16:36:50','2022-11-02 16:36:50'),
(576,'Office交流网','Office交流网','','http://www.office-cn.net/index.html',10,1,'2022-11-07 10:21:25','2022-11-07 10:21:25'),
(577,'USB-Devices','USB-Devices','','https://www.codeproject.com/Articles/60579/A-USB-Library-to-Detect-USB-Devices',14,1,'2022-11-07 13:43:08','2022-11-07 13:43:08'),
(578,'2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）','2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）','','https://juejin.cn/post/7124117404187099172#heading-30',15,4,'2022-11-07 15:34:21','2022-11-07 15:34:21'),
(579,'前端Vuer，请收下这份《Vue3中使用JSX简明语法》','前端Vuer，请收下这份《Vue3中使用JSX简明语法》','','https://juejin.cn/post/7114063575122984973',15,4,'2022-11-07 15:34:52','2022-11-07 15:34:52'),
(580,'vite-plugin-ssr','Like Next.js/Nuxt but as do-one-thing-do-it-well Vite plugin','','https://vite-plugin-ssr.com/',26,4,'2022-11-07 15:35:47','2022-11-07 15:35:47'),
(582,'VueHooks Plus','基础和高级的 hook， 高性能逻辑的抽象封装，满足大量场景','','https://nelsonyong.gitee.io/docs/hooks/',27,1,'2022-11-08 10:22:13','2022-11-08 10:23:30'),
(583,'web-norm','每当接手一个新项目（如果项目中没有配置 eslint husky commitlint）等这些规范的话，就需要自己手动配置一遍，配置多了后我只能来句窝草','','https://github.com/lyh0371/web-norm',3,4,'2022-11-08 18:08:22','2022-11-08 18:08:22'),
(584,'bourbon','scss常用代码块','','https://www.bourbon.io/docs/latest/#padding',9,4,'2022-11-08 18:10:09','2022-11-08 18:10:09'),
(585,'UnoCSS','原子化css','','https://uno.antfu.me/',9,4,'2022-11-09 10:01:00','2022-11-09 10:01:00'),
(586,'ahooks','ahooks 的 vue 实现。\n\n许多 hooks 是从ahooks移植过来的，但是不完全一致。','','https://dewfall123.github.io/ahooks-vue/zh/',3,4,'2022-11-09 14:29:13','2022-11-09 14:29:13'),
(587,'爱给网','图片素材','','https://www.aigei.com/',18,4,'2022-11-09 14:40:56','2022-11-09 14:40:56'),
(588,' css手册','api参考文档','','https://www.apiref.com/css-zh/index.htm',9,4,'2022-11-09 14:47:43','2022-11-09 14:47:43'),
(589,'cdnjs','CDNJS 是一项免费的开源 CDN 服务，受到超过12.5% 的网站的信任，为 每月超过 2000 亿个请求，由 Cloudflare 提供支持','','https://cdnjs.com/',30,4,'2022-11-09 14:48:50','2022-11-09 14:48:50'),
(590,'gitea','一款极易搭建的自助 Git 服务','','https://try.gitea.io/',14,4,'2022-11-09 14:50:00','2022-11-09 14:50:00'),
(591,'vitest','Vitest\n由 Vite 提供支持的极速单元测试框架\n一个 Vite 原生的单元测试框架。非常的快！','','https://cn.vitest.dev/',3,4,'2022-11-09 14:51:10','2022-11-09 14:51:10'),
(592,'zzhack ','嗨！欢迎来到我的应用 zzhack ，这是一个兴趣使然的项目，zzhack 被设计为一个注重信息展示的应用，它是序列化和沉淀我思想的地方。','','https://www.zzhack.fun/about',8,4,'2022-11-09 15:10:56','2022-11-09 15:10:56'),
(593,'milkdown-vue','基于[milkdown](https://github.com/Saul-Mirone/milkdown)的封装，整合了所有常用插件的`Vue3`组件&#x20;\n','','https://cyyjs.github.io/milkdown-vue/',3,4,'2022-11-09 15:22:31','2022-11-09 15:22:31'),
(594,'vexip UI','Vexip UI 提供了一系类开箱即用的组件。\n组件库使用 组合式 Api 编写，并尽可能采用 Vue 传统的方式设计和编写组件，全量的 TypeScript（不是 AnyScript）。','','https://www.vexipui.com/zh-CN',24,4,'2022-11-09 15:24:20','2022-11-09 15:24:20'),
(595,'网道','网道（WangDoc.com）是一个文档网站，提供互联网开发文档，正在建设中。','','https://wangdoc.com/',13,4,'2022-11-09 15:25:25','2022-11-09 15:25:25'),
(596,'SQL之父','快速生成 SQL 和模拟数据，大幅提高开发测试效率！','','https://www.sqlfather.com/',16,4,'2022-11-09 15:49:47','2022-11-09 15:49:47'),
(597,'icia','类似 jQuery 的 dom 操作库。','','https://licia.liriliri.io/docs_cn.html',5,4,'2022-11-09 16:18:35','2022-11-09 16:18:35'),
(598,' ESLint 配置预设','https://github.com/antfu/eslint-config','','https://github.com/antfu/eslint-config',3,4,'2022-11-09 17:10:02','2022-11-09 17:10:02'),
(599,'pinia插件持久化','','','https://seb-l.github.io/pinia-plugin-persist/',3,4,'2022-11-09 17:11:45','2022-11-09 17:11:45'),
(600,'HappyBoot Tiger','一个中后端框架Vite2+Vue3+HappyKit+NaiveUI','','https://doc.happykit.org/',24,4,'2022-11-09 17:13:19','2022-11-09 17:13:19'),
(601,'轮子之王','将平常开发中非常常用的功能做成轮子，减少开发时间，让开发者拥有更多的时间能够摸鱼','','http://it-learning-diary.gitee.io/it-wheels-king-inline-doc/#/README',3,4,'2022-11-09 17:14:30','2022-11-09 17:14:30'),
(602,'alova','MVVM 库的请求场景管理库，它是对请求库的一种武装，而非替代品','','https://github.com/JOU-amjs/alova/blob/main/README-zh.md',3,4,'2022-11-09 17:16:20','2022-11-09 17:16:20'),
(603,'quark-design','Quark 是一款基于 Web Components 的跨框架 UI 组件库。 它可以同时在任意框架或无框架中使用。','','https://quark-design.hellobike.com/#/',19,4,'2022-11-16 08:58:03','2022-11-16 08:58:03'),
(604,'icones.js','vue3常用图标库','','https://icones.js.org/',27,4,'2022-11-18 09:18:25','2022-11-18 09:18:25'),
(605,'Quick Reference','为开发人员分享快速参考备忘清单【速查表】 (主要是方便自己)，在看到 Reference 快速参考备忘单','','http://ref.ecdata.cn/',27,4,'2022-11-18 09:19:34','2022-11-18 09:19:34'),
(606,'tdesign','tdesign','','https://tdesign.tencent.com/',24,4,'2022-11-22 15:20:58','2022-11-22 15:20:58'),
(607,'atool99','在线工具','','https://www.atool99.com/',14,4,'2022-11-24 17:04:28','2022-11-24 17:04:28'),
(608,'91huajian','一款开源的、免费的简历设计神器\n快速设计、简历主题切换，支持一键导出高清PDF、JSON数据等。','','https://91huajian.cn/',14,4,'2022-12-15 11:40:36','2022-12-15 11:40:36'),
(609,'C# 使用UUID生成各种模式方法','C# 使用UUID生成各种模式方法','','https://www.cnblogs.com/im17me/p/10336375.html',15,4,'2022-12-15 12:10:02','2022-12-15 12:10:02'),
(610,'c^ret','https://lugolabs.com/caret','','https://lugolabs.com/caret',9,4,'2022-12-15 14:27:59','2022-12-15 14:27:59'),
(611,'CSS3参考手册 ','CSS3参考手册 ','','http://css.doyoe.com/',9,4,'2022-12-15 14:35:54','2022-12-15 14:35:54'),
(612,'icon-sets','icon-sets','','https://icon-sets.iconify.design/',3,4,'2022-12-15 14:45:07','2022-12-15 14:45:07'),
(613,'程序员做饭指南','https://cook.aiurs.co/','','https://cook.aiurs.co/',13,4,'2023-01-14 10:54:41','2023-01-14 10:54:41'),
(614,'Rust 打包网页生成很小的桌面','很简单的用 Rust 打包网页生成很小的桌面 App','','https://github.com/tw93/Pake?utm_source=gold_browser_extension',14,4,'2023-01-14 11:01:53','2023-01-14 11:01:53'),
(615,'JavaScript 片段','JavaScript 代码片段集合包含各种各样的 ES6 帮助程序函数。它包括用于处理原语，数组和对象的帮助程序，以及算法，DOM操作函数和Node.js实用程序。','','https://www.30secondsofcode.org/js/p/1',5,4,'2023-01-14 11:04:33','2023-01-14 11:04:33'),
(616,'Halo','好用又强大的开源建站工具。','','https://halo.run/',14,4,'2023-02-06 09:33:37','2023-02-06 09:33:37'),
(617,'snipplr','代码片段','','https://snipplr.com/',13,4,'2023-02-06 09:44:17','2023-02-06 09:44:17'),
(618,'tobiasahlin','加载动画','','https://tobiasahlin.com/spinkit/',9,4,'2023-02-06 09:48:37','2023-02-06 09:48:37'),
(619,'Mini Sandbox','一个前端【代码/组件】的可视化方案，融合了【在线编辑 & 实时预览】等特点','','https://buuing.github.io/mini-sandbox/#/',24,4,'2023-02-06 09:56:34','2023-02-06 09:56:34'),
(620,'notion中文文档','学习 Notion, 从这里开始\n这里有最新的 Notion 中文用户手册和最新最全的资源模版','','https://notionchina.co/',13,4,'2023-02-21 09:49:19','2023-02-21 09:49:19'),
(621,'thisthat','代码片段','','https://thisthat.dev/',13,4,'2023-02-21 11:17:06','2023-02-21 11:17:06'),
(622,'await-to-js','异步等待包装器','','https://www.npmjs.com/package/await-to-js',1,4,'2023-02-23 14:08:20','2023-02-23 14:08:20'),
(623,'css动画','css动画','','https://www.webhek.com/post/css3-animation-sniplet-collection/#/',9,4,'2023-05-05 15:54:42','2023-05-05 15:54:42'),
(624,'axios-retry','','','http://www.axios-js.com/zh-cn/docs/axios-retry.html',15,4,'2023-05-16 09:11:00','2023-05-16 09:11:00'),
(625,'Hooks时代，如何写出高质量的react和vue组件','Hooks时代，如何写出高质量的react和vue组件','','https://juejin.cn/post/7123961170188304391',15,4,'2023-05-16 09:13:07','2023-05-16 09:13:07'),
(626,'代码缺乏装饰？使用ts装饰器来装饰你的代码','','','https://juejin.cn/post/7053887981928579103#heading-14',15,4,'2023-05-16 09:14:06','2023-05-16 09:14:06'),
(627,'从 await-to-js 到 try-run-js','从 await-to-js 到 try-run-js','','https://juejin.cn/post/7178467482456293434',15,4,'2023-05-16 09:14:27','2023-05-16 09:14:34'),
(628,'blueimp-md5','blueimp-md5\n','','https://www.npmjs.com/package/blueimp-md5',1,4,'2023-05-16 09:15:30','2023-05-16 09:15:30'),
(629,'hevue-img-preview','hevue-img-preview\n基于Vue.js的可能很好用的网页端图片浏览插件','','https://heyongsheng.github.io/',3,4,'2023-05-17 09:42:19','2023-05-17 09:42:30'),
(630,'gitcode','','','https://gitcode.net/dashboard/projects/home',14,4,'2023-05-17 09:44:55','2023-05-17 09:44:55'),
(631,'github中文社区','中文社区','','https://www.githubs.cn/',10,4,'2023-05-24 14:28:18','2023-05-24 14:28:18'),
(632,'vue3-video-play','vue3视频播放插件','','https://codelife.cc/vue3-video-play/',24,4,'2023-05-24 14:39:06','2023-05-24 14:39:06'),
(633,'emoji','中文表情网','','https://www.emojiall.com/zh-hans',18,4,'2023-05-24 14:45:29','2023-05-24 14:45:29'),
(634,'edge','在Windows，MacOS和Linux上运行.NET和Node.js代码','','https://github.com/tjanczuk/edge',3,4,'2023-05-27 09:56:35','2023-05-27 09:56:35'),
(635,'[保姆级] Vue3 开发文档','[保姆级] Vue3 开发文档','','https://juejin.cn/post/7220220100384407610',15,4,'2023-05-27 09:58:01','2023-05-27 09:58:01'),
(636,'vue导航','vue导航','','https://dombro.site/vue#/vue',13,4,'2023-05-27 09:59:02','2023-05-27 09:59:02'),
(637,'离职自缴社保医保+取公积金失业金记录/攻略 ','离职自缴社保医保+取公积金失业金记录/攻略 ','','https://www.cnblogs.com/anding/p/16039725.html',15,4,'2023-06-20 15:31:11','2023-06-20 15:31:11'),
(638,'Hello 2023','Hello 2023','','https://flowus.cn/share/c1169c04-17d7-4b31-ba84-580cfc514e84',15,4,'2023-06-20 15:32:20','2023-06-20 15:32:20'),
(639,'Electron + Vue3 + TS + Vite 桌面应用项目搭建教程！','','','https://juejin.cn/post/7102681636096966687',15,4,'2023-06-20 15:33:32','2023-06-20 15:33:32'),
(640,'好用便签','','','http://360bq.xianxingzhewl.top/?utm_source=360&utm_medium=cpc&utm_term=%E5%B7%A5%E4%BD%9C%E4%BE%BF%E7%AD%BE&utm_content=%E5%85%B6%E4%BB%96&utm_campaign=%E4%BE%BF%E7%AD%BE%E4%BE%BF%E7%AC%BA%E4%BE%BF%E5%88%A9%E8%B4%B4',14,4,'2023-06-20 15:34:43','2023-06-20 15:34:43'),
(641,'LINQ 到对象的扩展','','','https://morelinq.github.io/',4,4,'2023-06-20 15:41:12','2023-06-20 15:41:12'),
(642,'系统托盘','','','https://github.com/Hofknecht/SystemTrayMenu',14,4,'2023-06-20 15:45:58','2023-06-20 15:45:58'),
(643,'electron-vue 跨平台桌面应用开发实战教程','','','https://www.bookstack.cn/read/David1025-electron-vue-in-action/c42ae52c69ffc24a.md',15,4,'2023-06-25 16:40:58','2023-06-25 16:40:58'),
(644,'ScottPlot.NET','适用于 .NET 的交互式绘图库','','https://scottplot.net/',4,4,'2023-06-25 16:57:36','2023-06-25 16:57:36'),
(645,'Vue 必备的这些操作技巧','','','https://juejin.cn/post/7121564385151025165',15,4,'2023-06-25 16:58:52','2023-06-25 16:58:52'),
(646,'InfiniteGrid','InfiniteGrid','','https://naver.github.io/egjs-infinitegrid/',24,4,'2023-06-26 15:38:24','2023-06-26 15:38:24'),
(647,'pinyin-pro','一个识别准确、性能优异的专业的汉字拼音转换库','','https://pinyin-pro.cn/',24,4,'2023-06-27 08:37:20','2023-06-27 08:37:20'),
(648,'transition . css','动画','','https://www.transition.style/#out:custom:circle-swoop',9,4,'2023-06-27 08:51:59','2023-06-27 08:51:59'),
(649,'typescript-cheatsheet','','','https://rmolinamir.github.io/typescript-cheatsheet/#introduction',5,4,'2023-06-27 10:07:00','2023-06-27 10:07:00'),
(650,'一个有趣和棘手的 JavaScript 示例列表','','','https://github.com/denysdovhan/wtfjs/blob/master/README-zh-cn.md',5,4,'2023-06-27 10:09:41','2023-06-27 10:09:41'),
(651,'JavaScript开发者应懂的33个概念','','','https://github.com/stephentian/33-js-concepts',5,4,'2023-06-27 10:11:46','2023-06-27 10:11:46'),
(652,'JavaScript Snippets','','','https://www.30secondsofcode.org/js/p/1/',5,4,'2023-06-27 10:12:14','2023-06-27 10:12:14'),
(653,'CSS 函数的完整指南','像任何其他编程语言一样，CSS也有函数。它们可以插入到放置值的位置，或者在某些情况下，与另一个值声明一起插入。','','https://css-tricks.com/complete-guide-to-css-functions/',9,4,'2023-06-27 10:19:30','2023-06-27 10:19:30'),
(654,'overapi.com','','','overapi.com',13,4,'2023-06-27 10:44:57','2023-06-27 10:44:57'),
(655,'精美简单的点击复制 CSS 效果','','','https://cssfx.netlify.app/',9,4,'2023-06-27 14:29:26','2023-06-27 14:29:26'),
(656,'右键管理','','','https://github.com/BluePointLilac/ContextMenuManager',14,4,'2023-07-07 14:14:09','2023-07-07 14:14:09'),
(657,'WindowTextExtractor','窗口文本提取器','','https://github.com/AlexanderPro/WindowTextExtractor',4,4,'2023-07-07 14:14:59','2023-07-07 14:14:59'),
(658,'svgrepo','500.000+ 开放许可的 SVG 矢量和图标\n使用各种矢量库为您的项目搜索、探索和编辑最适合您的项目的免费图标或矢量。下载免费的 SVG 矢量和图标用于商业用途。','','https://www.svgrepo.com/',18,4,'2023-07-17 10:35:21','2023-07-17 10:35:21'),
(659,'vue示例','vue示例','','https://vuejsexamples.com/',3,4,'2023-07-17 15:23:50','2023-07-17 15:23:50'),
(660,'vue3风格指南','vue3风格指南','','https://cn.vuejs.org/guide/introduction.html',3,4,'2023-07-17 15:28:15','2023-07-17 15:28:15');
/*!40000 ALTER TABLE `sn_navigation` ENABLE KEYS */;

-- 
-- Definition of sn_setblog
-- 

DROP TABLE IF EXISTS `sn_setblog`;
CREATE TABLE IF NOT EXISTS `sn_setblog` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '设置的内容名称',
  `router_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '路由链接',
  `isopen` tinyint(1) NOT NULL COMMENT '是否启用',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL COMMENT '关联用户表',
  PRIMARY KEY (`id`),
  KEY `setblog_user_id` (`user_id`),
  KEY `setblog_type_id` (`type_id`),
  CONSTRAINT `setblog_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_setblog_type` (`id`),
  CONSTRAINT `setblog_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_setblog
-- 

/*!40000 ALTER TABLE `sn_setblog` DISABLE KEYS */;
INSERT INTO `sn_setblog`(`id`,`name`,`router_url`,`isopen`,`type_id`,`user_id`) VALUES
(1,'SetPage','df',0,1,4),
(2,'1','5',1,0,4);
/*!40000 ALTER TABLE `sn_setblog` ENABLE KEYS */;

-- 
-- Definition of sn_user_talk
-- 

DROP TABLE IF EXISTS `sn_user_talk`;
CREATE TABLE IF NOT EXISTS `sn_user_talk` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL,
  `talk_text` varchar(255) COLLATE utf8mb4_bin DEFAULT NULL COMMENT '说说内容',
  `talk_time` date DEFAULT NULL COMMENT '发表时间',
  `talk_read` int DEFAULT NULL,
  `talk_give` int DEFAULT NULL,
  `comment_id` int DEFAULT NULL COMMENT '评论id',
  PRIMARY KEY (`id`),
  KEY `sn_user_talk_userId` (`user_id`),
  CONSTRAINT `sn_user_talk_userId` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table sn_user_talk
-- 

/*!40000 ALTER TABLE `sn_user_talk` DISABLE KEYS */;
INSERT INTO `sn_user_talk`(`id`,`user_id`,`talk_text`,`talk_time`,`talk_read`,`talk_give`,`comment_id`) VALUES
(12,4,'omorrow is always fresh, with no mistakes in it. 明天始终崭新，无错可言。','2020-10-19 00:00:00',0,0,0),
(13,4,'人生有梦,各自精彩','2020-10-19 00:00:00',0,0,0),
(15,4,'Sometimes you have to sacrifice to do the right thing. 有时候，为了做成正确的事，你必须付出代价。','2020-10-20 00:00:00',0,0,0),
(16,4,'我就是这样,就是和你不一样','2020-10-23 00:00:00',0,0,0),
(17,4,'A brave man never surrenders. 勇者永不屈服。','2020-10-27 00:00:00',0,0,0),
(18,4,'The strongest person is the person who isn''t scared to be alone. 强大的人不会惧怕孤独。','2020-11-11 00:00:00',0,0,0),
(19,4,'Real love is always worth waiting for. 真爱永远值得等待。','2020-11-24 00:00:00',0,0,0),
(20,4,'“嗨，同志！您知道列宁格勒和斯大林格勒在哪吗？我在地图上找不到它。” “没有了，再也没有了，我们失败了，白匪和资本家再一次骑到了我们的头上，如果你要追随那颗红星，去东方吧，穿越第聂伯河，翻过乌拉尔山脉，西伯利亚平原的尽头，那里还燃烧着星星之火。”','2020-12-26 00:00:00',0,0,0);
/*!40000 ALTER TABLE `sn_user_talk` ENABLE KEYS */;

-- 
-- Definition of snippet
-- 

DROP TABLE IF EXISTS `snippet`;
CREATE TABLE IF NOT EXISTS `snippet` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin,
  `type_id` int DEFAULT NULL,
  `tag_id` int DEFAULT NULL,
  `user_id` int DEFAULT NULL,
  `label_id` int DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `uid` (`user_id`),
  KEY `tagid` (`tag_id`),
  KEY `typeid` (`type_id`),
  KEY `label` (`label_id`),
  CONSTRAINT `label` FOREIGN KEY (`label_id`) REFERENCES `snippet_label` (`id`),
  CONSTRAINT `tagid` FOREIGN KEY (`tag_id`) REFERENCES `snippet_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `typeid` FOREIGN KEY (`type_id`) REFERENCES `snippet_type` (`id`),
  CONSTRAINT `uid` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=781 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table snippet
-- 

/*!40000 ALTER TABLE `snippet` DISABLE KEYS */;
INSERT INTO `snippet`(`id`,`name`,`text`,`type_id`,`tag_id`,`user_id`,`label_id`) VALUES
(26,'生命周期','| vue3              | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| setup()           | 开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method |\n| //挂载阶段        |                                                              |\n| onBeforeMount()   | 组件挂载到节点上之前执行的函数。                             |\n| onMounted()       | 组件挂载完成后执行的函数。                                   |\n| //更新            |                                                              |\n| onBeforeUpdate()  | 组件更新之前执行的函数。                                     |\n| onUpdated()       | 组件更新完成之后执行的函数。                                 |\n| //销毁            |                                                              |\n| onBeforeUnmount() | 组件卸载(销毁)之前执行的函数。                               |\n| onUnmounted()     | 组件卸载(销毁)完成后执行的函数                               |\n| onActivated()     | 被包含在 keep-alive 中的组件，会多出两个生命周期钩子函数。被激活时执行。 |\n| onDeactivated()   | 比如从 A 组件，切换到 B 组件，A 组件消失时执行。             |\n| onErrorCaptured() | 当捕获一个来自子孙组件的异常时激活钩子函数                   |',2,2,4,5),
(27,'文本插值({{ msg }})','数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值：\n\n```html\n<span>Message: {{ msg }}</span>\n```\n\n使用的是 `Mustache` 语法 (即双大括号)，每次 `msg` 属性更改时它也会同步更新',2,2,4,5),
(28,' AXIOS String contains non ISO-8859-1',' 在头信息中存在中文，需要对其进行编码,使用encodeURIComponent()对中文信息进行编码即可。\n\n``` js\nif (storage.get(store.state.Roles)) {\n    req.headers.Authorization =\n        encodeURIComponent(storage.get(store.state.Roles)) as string\n}\n```',3,4,4,1),
(30,'命名基本约定','\n| **标识符** | **大小写** | **示例**                                 |\n| ---------- | ---------- | ---------------------------------------- |\n| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |\n| 类型       | Pascal     | public class DevsList                    |\n| 接口       | Pascal     | public interface ITableModel             |\n| 方法       | Pascal     | public void UpdateData()                 |\n| 属性       | Pascal     | Public int Length{…}                     |\n| 事件       | Pascal     | public event EventHandler Changed;       |\n| 私有字段   | Camel      | private string fieldName;                |\n| 非私有字段 | Pascal     | public string FieldName；                |\n| 枚举值     | Pascal     | FileMode{Append}                         |\n| 参数       | Camel      | public void UpdateData(string fieldName) |\n| 局部变量   | Camel      | string fieldName;                        |',1,6,4,1),
(31,'集合类的声明','**声明一个List**\n```c#\nList<string> list = new List<string>();\nlist.Add(\"a一\");\nlist.Add(\"b二\");\n\n//语法糖\nList<string> list = new List<string> {\"def\",\"OK\"};\n```\n\n**遍历集合中的项：**\n\n```c#\nforeach (string item in list)\n{\n  Console.WriteLine(item);\n}\n//语法糖\nlist.ForEach(a => Console.WriteLine(a));\n```\n',1,3,4,1),
(32,'访问修饰符','- public:公有访问，不受任何限制。\n- private:私有访问，只限于本类成员访问。\n- protected:受保护的，只限于本类和子类访问。\n- internal:内部访问，只限于本项目内访问，其他的不能访问\n- protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问',1,2,4,1),
(33,'using等于try finally','使用完释放资源，经常要用using，using实质上就是try fiannaly的一个语法糖\n\n```c#\nStreamWriter sw = null;\ntry\n{\n    sw = new StreamWriter(\"d:\\abc.txt\");\n    sw.WriteLine(\"test\");\n}\nfinally {\n    if(sw!= null) sw.Dispose();\n}\n```\n\n简化为：\n\n```c#\nusing (var sw = new StreamWriter(\"d:\\abc.txt\")) {\n    sw.WriteLine(\"test\");\n}\n```\n',1,3,4,1),
(34,'v-html','双大括号将会将数据插值为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：\n``` html\n<p>Using mustaches: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n双大括号{{}}会将数据解释为纯文本，使用 v-html 指令，将插入 HTML',2,7,4,1),
(35,'v-bind','`v-bind` 指令指示 Vue 将元素的 `id` attribute 与组件的 `dynamicId` property 保持一致。如果绑定的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除。\n\n```html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\">...</a>\n\n<!-- 缩写 -->\n<a :href=\"url\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n',2,7,4,1),
(36,'v-on:click','使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件和运行 JavaScript \n#### 基本语法\n```html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\">...</a>\n<!-- 缩写 -->\n<a @click=\"doSomething\">...</a>\n<!-- 动态参数的缩写 -->\n<a @[event]=\"doSomething\"> ... </a>\n<!-- 动态的事件名绑定处理函数 -->\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n```\n事件处理器的值：\n1. 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似) 。\n2. 方法事件处理器：一个组件的属性名、或对某个方法的访问。',2,7,4,1),
(37,'vite-plugin-restart','[github](https://github.com/antfu/vite-plugin-restart)\n\n通过监听文件修改，自动重启 vite 服务。\n\n最常用的场景就是监听 `vite.config.js` 和 `.env.development` 文件，我们知道，修改 vite 配置文件和环境配置文件，是需要重启 vite 才会生效，通过这个插件，我们将从反复重启中解脱出来。\n\n\nInstall\n\n```bash\nnpm i vite-plugin-restart -D \nyarn add vite-plugin-restart -D\n```\n\nAdd it to `vite.config.js`\n\n```js\n// vite.config.js\nimport ViteRestart from ''vite-plugin-restart''\n\nexport default {\n  plugins: [\n    ViteRestart({\n      restart: [\n        ''my.config.[jt]s'',\n      ]\n    })\n  ],\n};\n```\n',9,1,4,1),
(38,'vite-plugin-tips','[github:](https://github.com/yingpengsha/vite-plugin-tips)\n\n服务器状态提示\n\n Install\n\n``` bash\n$ npm install vite-plugin-tips -D\n```\n\n configuration\n\n``` js\nimport { viteTips } from ''vite-plugin-tips''\n\nexport default {\n  plugins: [\n    viteTips()\n  ]\n}\n```\n\n Options\n\n``` js\ninterface Options {\n  // Whether to enable relevant tips. Default is enabled.\n  connect?: boolean\n  update?: boolean\n  disconnect?: boolean\n}\n```\n\n',9,1,4,1),
(39,'script setup','## script setup\n\nscript setup可以和script同时存在,  script setup中的顶层的导入和变量声明都将自动地在该组件的模板上可用。\n\n``` js\n<script>\n  export const name = 1\n</script>\n\n<script setup>\n  import { ref } from ''vue''\n  const count = ref(0)\n</script>\n```\n',2,3,4,1),
(40,'nextTick','## nextTick\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n```ts\nimport { nextTick } from ''vue'';\n\nfunction increment() {\n  count.value++\n  nextTick(() => {\n    // 访问更新后的 DOM\n  })\n}\n\n// 还可以使用 async/await\nasync () => {\n    await nextTick()\n    // ....\n}\n```\n',2,3,4,1),
(42,'组件命名','单文件组件名应该始终是**单词大写开头** NewComponent.vue \n\n**子组件命名**\n\n- FooterSection.vue\n- FooterSectionHeading.vue\n\n**没有子组件，尝试加前缀 `the` 来命名**\n\n- TheNavbar.vue\n\n```\n// 反例\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n\n// 好例子\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n```\n\n\n',2,6,4,1),
(43,'常用命名推荐','**注意**：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名\n\n| ClassName              | 含义                                     |\n| :--------------------- | :--------------------------------------- |\n| about                  | 关于                                     |\n| account                | 账户                                     |\n| arrow                  | 箭头图标                                 |\n| article                | 文章                                     |\n| aside                  | 边栏                                     |\n| audio                  | 音频                                     |\n| avatar                 | 头像                                     |\n| bg,background          | 背景                                     |\n| bar                    | 栏（工具类）                             |\n| branding               | 品牌化                                   |\n| crumb,breadcrumbs      | 面包屑                                   |\n| btn,button             | 按钮                                     |\n| caption                | 标题，说明                               |\n| category               | 分类                                     |\n| chart                  | 图表                                     |\n| clearfix               | 清除浮动                                 |\n| close                  | 关闭                                     |\n| col,column             | 列                                       |\n| comment                | 评论                                     |\n| community              | 社区                                     |\n| container              | 容器                                     |\n| content                | 内容                                     |\n| copyright              | 版权                                     |\n| current                | 当前态，选中态                           |\n| default                | 默认                                     |\n| description            | 描述                                     |\n| details                | 细节                                     |\n| disabled               | 不可用                                   |\n| entry                  | 文章，博文                               |\n| error                  | 错误                                     |\n| even                   | 偶数，常用于多行列表或表格中             |\n| fail                   | 失败（提示）                             |\n| feature                | 专题                                     |\n| fewer                  | 收起                                     |\n| field                  | 用于表单的输入区域                       |\n| figure                 | 图                                       |\n| filter                 | 筛选                                     |\n| first                  | 第一个，常用于列表中                     |\n| footer                 | 页脚                                     |\n| forum                  | 论坛                                     |\n| gallery                | 画廊                                     |\n| group                  | 模块，清除浮动                           |\n| header                 | 页头                                     |\n| help                   | 帮助                                     |\n| hide                   | 隐藏                                     |\n| hightlight             | 高亮                                     |\n| home                   | 主页                                     |\n| icon                   | 图标                                     |\n| info,information       | 信息                                     |\n| last                   | 最后一个，常用于列表中                   |\n| links                  | 链接                                     |\n| login                  | 登录                                     |\n| logout                 | 退出                                     |\n| logo                   | 标志                                     |\n| main                   | 主体                                     |\n| menu                   | 菜单                                     |\n| meta                   | 作者、更新时间等信息栏，一般位于标题之下 |\n| module                 | 模块                                     |\n| more                   | 更多（展开）                             |\n| msg,message            | 消息                                     |\n| nav,navigation         | 导航                                     |\n| next                   | 下一页                                   |\n| nub                    | 小块                                     |\n| odd                    | 奇数，常用于多行列表或表格中             |\n| off                    | 鼠标离开                                 |\n| on                     | 鼠标移过                                 |\n| output                 | 输出                                     |\n| pagination             | 分页                                     |\n| pop,popup              | 弹窗                                     |\n| preview                | 预览                                     |\n| previous               | 上一页                                   |\n| primary                | 主要                                     |\n| progress               | 进度条                                   |\n| promotion              | 促销                                     |\n| rcommd,recommendations | 推荐                                     |\n| reg,register           | 注册                                     |\n| save                   | 保存                                     |\n| search                 | 搜索                                     |\n| secondary              | 次要                                     |\n| section                | 区块                                     |\n| selected               | 已选                                     |\n| share                  | 分享                                     |\n| show                   | 显示                                     |\n| sidebar                | 边栏，侧栏                               |\n| slide                  | 幻灯片，图片切换                         |\n| sort                   | 排序                                     |\n| sub                    | 次级的，子级的                           |\n| submit                 | 提交                                     |\n| subscribe              | 订阅                                     |\n| subtitle               | 副标题                                   |\n| success                | 成功（提示）                             |\n| summary                | 摘要                                     |\n| tab                    | 标签页                                   |\n| table                  | 表格                                     |\n| txt,text               | 文本                                     |\n| thumbnail              | 缩略图                                   |\n| time                   | 时间                                     |\n| tips                   | 提示                                     |\n| title                  | 标题                                     |\n| video                  | 视频                                     |\n| wrap                   | 容器，包，一般用于最外层                 |\n| wrapper                | 容器，包，一般用于最外层                 |',2,6,4,1),
(44,'简介','\n> Typed JavaScript at Any Scale.\n> 添加了类型系统的 JavaScript，适用于任何规模的项目。\n- TypeScript 是一门静态类型、弱类型的语言。\n- TypeScript 是完全兼容 JavaScript 的，它不会修改 JavaScript 运行时的特性。\n\n- TypeScript 可以编译为 JavaScript，然后运行在浏览器、Node.js 等任何能运行 JavaScript 的环境中。\n\n- TypeScript 拥有很多编译选项，类型检查的严格程度由你决定。\n\n- TypeScript 可以和 JavaScript 共存，这意味着 JavaScript 项目能够渐进式的迁移到 TypeScript。\n\n- TypeScript 增强了编辑器（IDE）的功能，提供了代码补全、接口提示、跳转到定义、代码重构等能力。\n\n- [JavaScript 备忘清单](http://ref.ecdata.cn/docs/javascript.html)\n- [TypeScript 官网](https://www.typescriptlang.org/)',5,2,4,1),
(45,'字符串(String)','一个字符系列，使用单引号（**''**）或双引号（**\"**）来表示字符串类型。反引号（**`**）来定义多行文本和内嵌表达式。\n\n```tsx\nlet myName: string = ''Tom'';\nlet myAge: number = 25;\n\n// 模板字符串\nlet sentence: string = `Hello, my name is ${myName}.\nI''ll be ${myAge + 1} years old next month.`;\n```\n',5,2,4,1),
(47,'C#类型转换','| 序号 | 方法 & 描述                                                  |\n| ---- | ------------------------------------------------------------ |\n| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |\n| 2    | **ToByte** 把类型转换为字节类型。                            |\n| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |\n| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |\n| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |\n| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |\n| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |\n| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |\n| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |\n| 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |\n| 11   | **ToSingle** 把类型转换为小浮点数类型。                      |\n| 12   | **ToString** 把类型转换为字符串类型。                        |\n| 13   | **ToType** 把类型转换为指定类型。                            |\n| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |\n| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |\n| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |',1,2,4,1),
(48,'CSS简介','层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现[HTML](https://baike.baidu.com/item/HTML)（[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言/6805073)的一个应用）或[XML](https://baike.baidu.com/item/XML)（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 [1] \n\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。',8,2,4,1),
(49,'代码大小写','样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。\n',8,6,4,1),
(50,'选择器','选择器根据不同的需求把不同的标签选出来这就是选择器的作用。\nCSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析\n- 可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；\n- 不可继承的样式：border, padding, margin, width, height\n\n**优先级**\n\n| 选择器         | 权重值 |\n| :------------- | :----- |\n| !important标识 | 10000  |\n| 行内样式       | 1000   |\n| id选择器       | 100    |\n| 类选择器       | 10     |\n| 标签选择器     | 1      |\n| 通配符 *       | 0      |\n\n> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符',8,6,4,1),
(51,'标签选择器','标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类的标签指定统一的CSS样式。\n\n```css\np{\n    color:red;\n }\n\n标签名{\n属性1;属性值1;\n属性2;属性值2;\n......\n}\n```\n\n作用：可以把某一类标签全部选择出来,比如所有的div标签和所有的span标签\n优点：能快速为页面中同类型的标签统一设置样式。\n缺点：不能设计差异化模式，只能选择全部的当前标签。',8,2,4,1),
(52,'类选择器','如果想要差异化选择不同的标签，单独选一个或几个标签，可以使用类选择器。\n\n语法：\n\n```css\n.类名{\n 属性1;属性值1;\n ......\n }\n```\n\n结构需要用class属性来调用class类的意思。\n\n```html\n<div class=\"red\">变颜色</div>\n```\n\n注意：\n\n- 类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的）。\n- 可以理解为给这个个标签起了一个名字，来表示。\n- 长名称或词组可以使用中横线来为选择器命名。\n- 不要使用纯数字、中文等命名，尽量使用英文字母来表示。\n- 命名要有意义，尽量使别人一眼就知道这个类名的目的。\n- 命名规范：见附件（web前端开发规范手册.doc）\n\n**类选择器口诀：\n\n> 样式点定义 结构类调用 一个或多个 开发最常用\n\n### 类命名规则\n\n| 头       | header            | 菜单     |    menu    |\n| -------- | ----------------- | -------- | :--------: |\n| 内容     | content/container | 子菜单   |  submenu   |\n| 尾       | footer            | 搜索     |   search   |\n| 导航     | nav               | 友情链接 | friendlink |\n| 侧栏     | sidebar           | 页脚     |   footer   |\n| 栏目     | column            | 版权     | copyright  |\n| 标志     | logo              | 广告     |   banner   |\n| 页面主体 | main              | 热点     |    hot     |\n| 新闻     | news              | 下载     |  download  |\n| 子导航   | subnav            |          |            |',8,2,4,1),
(53,'ID选择器','id选择器可以为标有特点id的HTML元素指定特定的样式。HTML元素以id属性来设置ID选择器，CSS中id选择器以“#”来定义。\n\n```html\n<div id=\"warning\">----</div>\n```\n\n```css\n#warning{color:red;}\n\n# id名{\n属性1;属性值1;\n......\n}\n```\n\n注意：id属性只能在每个html文档中出现一次。\n\n口诀：\n\n> 样式自定义，结构id调用，只能调用一次，别人切勿使用。\n\n### ID选择器和类选择器区别\n\n- 类选择器（class）可以有多个class，同时一个class也可以被多个使用。\n- ID选择器好比人的身份证号码，全中国是唯一的，不得重复。\n- ID选择器和类选择器最大的不同在于使用次数上。\n- 类选择器在修改样式中用的最多，ID选择器一般用于页面唯一性的元素上，经常和JAVASCRIPT搭配使用。',8,2,4,1),
(54,'通配符选择器','通配符选择器用“*”定义，它表示选取页面中所有元素（标签）\n\n语法：\n\n```bash\n * {\n属性1；属性值1；\n......\n}\n```\n\n- 通配符选择器不需要调用，自动就给所有的元素使用样式。\n- 特殊情况下才使用，后面讲解使用场景（以下是清除所有的元素标签的内外边距，后期讲）。\n\n```css\n* {\nmargin: 0;\npadding: 0;\n}\n```\n',8,2,4,1),
(55,'属性选择器','```html\n<ul>\n    <li foo>1</li>\n    <li foo=\"abc\">2</li>\n    <li foo=\"abc efj\">3</li>\n    <li foo=\"abcefj\">4</li>\n    <li foo=\"efjabc\">5</li>\n    <li foo=\"ab\">6</li>\n</ul>\n```\n\n```css\n//选择 attribute=value 的所有元素。\n[foo=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性包含单词 value 的所有元素。\n[foo~=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始\n[foo^=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束\n[foo$=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性中包含 value 子串的每个元素。\n[foo*=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性值以 value 开头的所有元素。\n[foo|=abc]{\n    background-color:red;\n}\n```\n',8,2,4,1),
(57,'子选择器','子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。\n\n```css\n ul>li>p{\n   border: 1px solid red;\n}\n语法：元素1>元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有直接后代（子元素）元素2.\n\n注意：\n\n- 元素1和元素2中间用大于号隔开。\n- 元素1是父级元素，2是子级元素，最终选择的是元素2.\n- 元素2必须是亲儿子，其孙子、重孙不归他管，也可以叫亲儿子选择器。',8,2,4,1),
(58,'并集选择器','并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。\n\n并集选择器是各选择器通过英文逗号（，）连接而成，任何形式的选择器都可以作为并集选择器的一部分。\n\n```text\n语法：元素1,元素2{样式声明}\n```\n\n上述语法表示选择元素1和元素2.',8,2,4,1),
(59,'相邻兄弟选择器','```css\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n//选择紧接在 element元素之后的 element 元素。\nh1+p{\n    color:red;\n}\n```\n\n',8,2,4,1),
(60,'一般兄弟选择器','```css\n//选择前面有 element1 元素的每个 elem 元素。\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n h1~p{\n   border: 1px solid red;\n}\n```\n\n',8,2,4,1),
(61,'伪类选择器','伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第一个，第n个元素。\n\n伪类选择器书写最大的特点是用冒号（：）表示，比如:hover :first-child\n\n因为伪类选择器很多，比如有链接伪类、结构伪类等，所以这里，先给大家讲解常用的链接伪类选择器。\n\n链接伪类选择器\n\n| a:link    | /*选择所有未被访问的链接*/               |\n| --------- | ---------------------------------------- |\n| a:visited | /*选择所有已被访问的链接*/               |\n| a:hover   | /*选择鼠标指针位于其上的链接*/           |\n| a:active  | /*选择活动链接（鼠标按下未弹起的链接）*/ |\n\n注意：\n\n- 为了确保生效，请按照LVHA的循环顺序声明\n\n```text\n:link    :visited-   :hover-    :active \n```\n\n- 记忆法：love hate或者lv包hao\n- 因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。\n\n链接选择器在实际工作开发中的写法：\n\n```css\n/*a是标签选择器 所有的链接*/\na{\ncolor:gray;\ntext:decoration:none;\n}\n/* :hover是链接伪类选择器 鼠标经过*/\na:hover{\ncolor:red;/*鼠标经过的时候，由原来的灰色变成了红色；*/\ntext-decoration:underline;\n}\n```\n\n#### :focus伪类选择器\n\n：focus伪类选择器用于选取获得焦点的表单元素。\n\n焦点是光标，一般情况下（input）类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。\n\n```css\n语法：input:focus{\nbackgroud-color:yellow;\n}\n```\n',8,2,4,1),
(62,'伪元素选择器','```css\nelement::first-line\n\n//p 元素的第一行发生改变\np:first-line{\n    background-color:yellow;\n}\n\nelement::first-letter\n//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色\nh1:first-letter{\n    color:yellow;\n}\n\n//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用\nelement::before\n\n//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它\nelement::after\n\n//选择被用户选取的元素部分。\n::selection\n```\n',8,2,4,1),
(63,'外边距(margin)','margin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。\n\nmargin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。\n\n| 值       | 说明                                        |\n| :------- | :------------------------------------------ |\n| auto     | 设置浏览器边距。 这样做的结果会依赖于浏览器 |\n| *length* | 定义一个固定的margin（使用像素，pt，em等）  |\n| *%*      | 定义一个使用百分比的边距                    |\n\n#### 边距属性\n\n| 属性          | 描述                                       |\n| :------------ | :----------------------------------------- |\n| margin        | 简写属性。在一个声明中设置所有外边距属性。 |\n| margin-bottom | 设置元素的下外边距。                       |\n| margin-left   | 设置元素的左外边距。                       |\n| margin-right  | 设置元素的右外边距。                       |\n| margin-top    | 设置元素的上外边距。                       |\n\n#### 单边外边距属性\n\n在CSS中，它可以指定不同的侧面不同的边距：\n\n```css\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n```\n\n#### Margin - 简写属性\n\n为了缩短代码，有可能使用一个属性中margin指定的所有边距属性。这就是所谓的简写属性。\n\n所有边距属性的简写属性是 **margin** :\n\n```css\nmargin:100px 50px;\n```\n\nmargin属性可以有一到四个值。\n\n- margin:25px 50px 75px 100px;\n  - 上边距为25px\n  - 右边距为50px\n  - 下边距为75px\n  - 左边距为100px\n- margin:25px 50px 75px;\n  - 上边距为25px\n  - 左右边距为50px\n  - 下边距为75px\n- margin:25px 50px;\n  - 上下边距为25px\n  - 左右边距为50px\n- margin:25px;\n  - 所有的4个边距都是25px\n\n#### 居中显示\n\n```css\nmargin: 0 auto;\n```\n',8,2,4,1),
(64,'padding填充','当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。\n\n单独使用 padding 属性可以改变上下左右的填充\n\n| 值       | 说明                                |\n| :------- | :---------------------------------- |\n| *length* | 定义一个固定的填充(像素, pt, em,等) |\n| *%*      | 使用百分比值定义一个填充            |\n\n#### 单边内边距属性\n\n在CSS中，它可以指定不同的侧面不同的填充：\n\n```css\npadding-top:25px;\npadding-bottom:25px;\npadding-right:50px;\npadding-left:50px;\n```\n\n#### 简写属性\n\n为了缩短代码，它可以在一个属性中指定的所有填充属性。\n\n这就是所谓的简写属性。所有的填充属性的简写属性是 **padding** :\n\n```css\npadding:25px 50px;\n```\n\nPadding属性，可以有一到四个值。\n\n **padding:25px 50px 75px 100px;**\n\n- 上填充为25px\n\n- 右填充为50px\n\n- 下填充为75px\n\n- 左填充为100px\n\n  **padding:25px 50px 75px;**\n\n- 上填充为25px\n\n- 左右填充为50px\n\n- 下填充为75px\n\n  **padding:25px 50px;**\n\n- 上下填充为25px\n\n- 左右填充为50px\n\n  **padding:25px;**\n\n- 所有的填充都是25px',8,2,4,1),
(65,'属性背景效果(background)','- background-color\n- background-image\n- background-repeat\n- background-attachment\n- background-position\n\n颜色值通常以以下方式定义:\n\n- 十六进制 - 如：\"#ff0000\"\n- RGB - 如：\"rgb(255,0,0)\"\n- 颜色名称 - 如：\"red\"\n',8,2,4,1),
(66,'背景颜色(background)','```css\n background-color: #ffffff;\n```',8,2,4,1),
(67,'背景图像(background)','background-image 属性描述了元素的背景图像.\n\n默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.\n\n```css\nbackground: no-repeat center/100% url(\"../img/index.png\");\n```\n',8,2,4,1),
(68,'多个背景图片(background)','```css\nbody {\n  background-image:\n url(https://xxxx.svg),\n url(https://xxxxxx.svg);\n  background-position: center, top;\n  background-repeat: repeat, no-repeat;\n  background-size: contain, cover;\n}\n```\n',8,2,4,1),
(69,'水平方向平铺(background)','```css\nbackground-image:url(''gradient2.png'');\nbackground-repeat:repeat-x;\n```\n',8,2,4,1),
(70,'设置定位与不平铺(background)','让背景图像不影响文本的排版\n如果你不想让图像平铺，你可以使用 background-repeat 属性:\n```css\nbackground-image:url(''img_tree.png'');\nbackground-repeat:no-repeat;\n```\n',8,2,4,1),
(71,'网格背景图像(background)','```html\n<body>\n<div class=\"container\">\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n</div>\n</body>\n```\n\n```css\nbody {\n margin: 0;\n  padding: 0;\n}\n\n.container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background: black;\n  display: grid;\n  grid-template-columns: 25fr 30fr 40fr 15fr;\n  grid-template-rows: 20fr 45fr 5fr 30fr;\n  grid-gap: 20px;\n  .item_img {\n    background-image: url(''https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80'');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-attachment: fixed;\n  background-size: cover;\n}\n}\n```\n\n',8,3,4,1),
(72,'全局背景颜色','### 全局背景颜色\n\n```js\nmounted() {\n  document.querySelector(''body'').setAttribute(''style'', ''background-color:#f7f7f7'')\n},\nbeforeDestroy() {\n  document.querySelector(''body'').removeAttribute(''style'')\n}\n```\n\n',2,3,4,1),
(73,'背景属性(background)','| Property              | 描述                                         |\n| :-------------------- | :------------------------------------------- |\n| background            | 简写属性，作用是将背景属性设置在一个声明中。 |\n| background-attachment | 背景图像是否固定或者随着页面的其余部分滚动。 |\n| background-color      | 设置元素的背景颜色。                         |\n| background-image      | 把图像设置为背景。                           |\n| background-position   | 设置背景图像的起始位置。                     |\n| background-repeat     | 设置背景图像是否及如何重复。                 |',8,2,4,1),
(74,'元素隐藏','```css\n/**这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；**/\nvisibility: hidden; \n/**属性，设置0可以使一个元素完全透明；**/\nopacity: 0;CSS3\n/**设置一个很大的 left 负值定位，使元素定位在可见区域之外；**/\nposition: absolute; \n/**元素会变得不可见，并且不会再占用文档的空间；**/\ndisplay: none; \n/**将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；**/\ntransform: scale(0); \n```\n\n\n\n\n\n',8,3,4,1),
(75,'虚线效果','```css\n.dotted-line{\n    border: 1px dashed transparent;\n    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);\n}\n```\n',8,3,4,1),
(76,'文本超出省略号','**单行文本**\n\n```css\n.single-ellipsis{\n  width: 500px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```\n\n**多行文本**\n\n```css\n.multiline-ellipsis {\n  display: -webkit-box;\n  word-break: break-all;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 4; //需要显示的行数\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n```\n',8,3,4,1),
(77,'自动打字','```html\n<div class=\"bruce flex-ct-x\">\n    <div class=\"auto-typing\">Do You Want To Know More About CSS Development Skill</div>\n</div>\n```\n\n```css\n@mixin typing($count: 0, $duration: 0, $delay: 0) {\n    overflow: hidden;\n    border-right: 1px solid transparent;\n    width: #{$count + 1}ch;\n    font-family: Consolas, Monaco, Monospace;\n    white-space: nowrap;\n    animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;\n}\n.auto-typing {\n    font-weight: bold;\n    font-size: 30px;\n    color: #09f;\n    @include typing(52, 5);\n}\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n@keyframes caret {\n    50% {\n        border-right-color: currentColor;\n    }\n}\n```\n\n',8,3,4,1),
(78,'渐变色文字','```css\n<h2 class=\"gradient-text\">Gradient text</h2>\n<style>\n.gradient-text {\n  background-image: linear-gradient(90deg, red, blue);\n  background-clip: text;\n  color: transparent;\n}\n</style>\n```\n\n',8,3,4,1),
(79,'清除overflow的滚动条','```css\n.div{\n  overflow: auto\n}\n\n.div::-webkit-scrollbar{\n    display: none;\n}\n```\n\n',8,3,4,1),
(80,'字体属性','CSS使用font-family属性定义文本的字体系列。\n\n```css\np { font-family:\"微软雅黑\";}\ndiv {font-family:Arial,\"Microsoft Yahei\",\"微软雅黑\"；}\n```\n\n注意：\n\n- 各种字体之间必须使用英文状态下的逗号隔开。\n- 一般情况下，如果有空格隔开的多个单词组成的字体，加引号。\n- 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示。\n- 最常见的几个字体：\n\n```css\nbody {font-family:\"Microdoft Yahei\",tohoma,arial,\"Hiyayinosan GB\";}\n```\n',8,2,4,1),
(81,'字体大小','CSS使用font-size属性定义字体大小\n\n```css\np {font-size:20px;}\n```\n\n注意：\n\n- px（像素）大小是我们网页最常用的单位。\n- 谷歌浏览器默认的文字大小为16px。\n- 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。\n- 可以给body指定整个页面文字的大小',8,2,4,1),
(82,'字体粗细','CSS使用font-weight属性设置文字字体的粗细。\n\n```css\np {font-weight:normal\\body\\bolder\\light\\number;}\n```\n\n参数：\n\n| normal | 正常字体（相当于number=400）              |\n| ------ | ----------------------------------------- |\n| bold   | 粗体（相当于number=700）                  |\n| bolder | 特粗体（IF5+）                            |\n| light  | 细体（IF5+）                              |\n| number | 100/200/300/400/500/600/700/800/900(IF5+) |\n\nnumber语法：\n\n```css\np {font-weight:400;}\n```\n\n注意：\n\n- 学会加粗标签（比如h和strong等）不加粗，或者其他标签加粗\n- 实际开发时，我们更喜欢用字表示粗细。',8,2,4,1),
(83,'文字模式','CSS使用font-style属性设置文本的网络。\n\n```css\np { font-style: normal; }\n```\n\n| 属性值 | 作用                                                 |\n| ------ | ---------------------------------------------------- |\n| normal | 默认值，浏览器会显示标准的字体样式 font-size：normal |\n| italic | 浏览器会显示斜体的字体样式                           |\n\n注意：平时我们很少给文字加斜体，反而要给斜体标签（em，；）改为不斜体字体。',8,2,4,1),
(84,'字体的复合属性','```css\nbody { font-style font-weight font-size/line-height font-family;}\n```\n\n注意：\n\n- 使用font属性时，必须按上面的语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开。\n- 不需要设置的属性可以忽略（取默认值），但必须保留 font-size和font-family属性，否则font属性将不起作用。',8,2,4,1),
(85,'文本属性','color属性用于定义文本的颜色\n\n```css\ndiv {\ncolor:red;\n    }\n```\n\n注意：开发中最常用的时十六进制。\n\n| 表示           | 属性值                          |\n| -------------- | ------------------------------- |\n| 预定义的颜色值 | red，green，blue，pink          |\n| 十六进制       | #FF0000，#FF6600，#FF29D794     |\n| RGB代码        | rgb（255,0,0）或rgb(100%,0%,0%) |',8,2,4,1),
(86,'文本对齐','text-align属性用于设置元素内文本内容的水平对齐方式。\n\n```css\ndiv {\ntext-align:center;\n}\n```\n\n| 属性值 | 解释             |\n| ------ | ---------------- |\n| left   | 左对齐（默认值） |\n| right  | 右对齐           |\n| center | 居中对齐         |',8,2,4,1),
(87,'文本装饰','text-decoration属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等。\n\n```css\ndiv {\ntext-decoration:underline;\n}\n```\n\n| 属性值       | 解释                            |\n| ------------ | ------------------------------- |\n| none         | 默认，没有装饰线（最常用）      |\n| underline    | 下划线：链接a自带下划线（常用） |\n| overline     | 上划线（几乎不用）              |\n| line-through | 删除线（不常用）                |',8,2,4,1),
(88,'文本缩进','text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。\n\n```css\ndiv {\ntext-indent:10px/2em;\n}\n```\n\n*:2em代表2个字符',8,2,4,1),
(89,'行间距','line-height属性用于设置行间的距离（行高），可以控制文本的行与行之间的距离。\n\n```css\np { line-height: 26px;}\n```\n\n**:用Faststone chature 软件的标尺测量上一行的行底与下一行的行底之间的距离。',8,2,4,1),
(90,'文本转换','文本转换属性是用来指定在一个文本中的大写和小写字母。\n可用于所有字句变成大写或小写字母，或每个单词的首字母大写。\n```css\np.uppercase {text-transform:uppercase;}\np.lowercase {text-transform:lowercase;} \np.capitalize {text-transform:capitalize;}\n```\n\n',8,2,4,1),
(91,'CSS常用片段','```css\n/* 字体颜色 */\n  color: #888888;\n/* 字体粗细 */\n  font-weight: 400;\n/* 字体大小 */\n  font-size: 14px;\n/* 文字居中 */\n  text-align: center;\n/* 字体行内居中 */\n  line-height: 45px;\n /*字体加深*/\n text-shadow: 0 0 1px rgba(0,0,0,.3);\n /*起始段落空2格*/\n text-indent: 2em;\n```\n\n',8,3,4,1),
(92,'描绘波浪线','```html\n<div class=\"bruce flex-ct-x\">\n    <p class=\"waveline-text\">波浪线文字</p>\n</div>\n```\n\n```css\n@mixin waveline($h, $color: #f66) {\n    position: relative;\n    &::after {\n        position: absolute;\n        left: 0;\n        top: 100%;\n        width: 100%;\n        height: $h;\n        background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);\n        background-size: $h * 2 $h * 2;\n        content: \"\";\n    }\n}\n.waveline-text {\n    height: 20px;\n    line-height: 20px;\n    letter-spacing: 10px;\n    @include waveline(10px);\n}\n```\n',8,3,4,1),
(93,'下划线跟随','```html\n<div class=\"bruce flex-ct-x\">\n    <ul class=\"underline-navbar\">\n        <li>11111</li>\n        <li>22222</li>\n        <li>33333</li>\n    </ul>\n</div>\n```\n\n```css\n.underline-navbar {\n    display: flex;\n    li {\n        position: relative;\n        padding: 10px;\n        cursor: pointer;\n        font-size: 20px;\n        color: #09f;\n        transition: all 300ms;\n        &::before {\n            position: absolute;\n            left: 100%;\n            top: 0;\n            border-bottom: 2px solid transparent;\n            width: 0;\n            height: 100%;\n            content: \"\";\n            transition: all 300ms;\n        }\n        &:active {\n            background-color: #09f;\n            color: #fff;\n        }\n        &:hover {\n            &::before {\n                left: 0;\n                top: 0;\n                z-index: -1;\n                border-bottom-color: #09f;\n                width: 100%;\n                transition-delay: 100ms;\n            }\n            & + li::before {\n                left: 0;\n            }\n        }\n    }\n}\n```\n\n\n\n',8,3,4,1),
(94,'透明opacity','### 透明opacity\n\n```css\n opacity: 0.9;\n```\n',8,3,4,1),
(95,'水平垂直居中','**HTML结构如下**\n\n```html\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n```\n\n#### 使用Flex布局\n\n```css\n.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\nFlex布局是我日常使用过程中使用最频繁的一种方案，通过很简单的几行代码就可以实现我们想要的布局。\n\n#### 绝对定位\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    /* top和left是以左上角为坐标原点 */\n    top: 50%;\n    left: 50%;\n    /* transform：translate的属性值为百分数时，是以元素自身为参考 */\n    transform: translate(-50%,-50%);\n}\n\n/* 或者 */\n.child {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n```\n\n值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。\n\n#### Flex的另一种方法\n\n```css\n.parent {\n    display: flex;\n}\n.child {\n    margin: auto;\n}\n```\n\n#### Grid布局\n\n```css\n.parent {\n    display: grid;\n}\n.child {\n    justify-self: center;\n    align-self: center;\n}\n```\n\nGrid布局也是比较常用的一种方法，一般用在构建整体布局的时候用到的比较多。它有固定和灵活的尺寸，还可以通过名称或网格线把目标放置在指定的位置。\n\n#### Table布局\n\n```css\n.parent {\n    display: table;\n}\n.child {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n```\n\n',8,3,4,1),
(96,'内部样式表','内部样式表是写到html页面内部，是将所有的CSS代码抽取出来，单独放到一个style标签中。\n\n```css\n<style>\n     div{\n         color:red;\n         font-size: 12px;\n         }\n</style>\n```\n\n- 标签理论上可放在HTML文档的任何地方，但一般会放在文档的head标签中\n- 通过此种方式，可以方便控制当前整个页面中的元素样式设置。\n- 代码结构清晰，但是并没有实现结构与样式完全分离。',8,6,4,1),
(97,'边框样式','边框样式属性指定要显示什么样的边界。\n\nborder-style属性用来定义边框的样式\nnone: 默认无边框\ndotted: 定义一个点线边框\ndashed: 定义一个虚线边框\nsolid: 定义实线边框\ndouble: 定义两个边框。 两个边框的宽度和 border-width 的值相同\ngroove: 定义3D沟槽边框。效果取决于边框的颜色值\nridge: 定义3D脊边框。效果取决于边框的颜色值\ninset:定义一个3D的嵌入边框。效果取决于边框的颜色值\noutset: 定义一个3D突出边框。 效果取决于边框的颜色值\n\n```css\n/* 样式 1px */\nborder-style: ridge;\n```',8,2,4,1),
(98,'边框宽度','通过 border-width 属性为边框指定宽度。\n\n为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。\n\n**注意：**CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。\n\n```css\np.one {    \nborder-style:solid; \nborder-width:5px; \n}\np.two {   \nborder-style:solid;   \nborder-width:medium;\n}\n```\n\n',8,2,4,1),
(99,'边框颜色','border-color属性用于设置边框的颜色。\n\n您还可以设置边框的颜色为\"transparent\"。\n**注意：** border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。\n\n```css\n/* 边框宽度1px 样式 颜色 */\n  border: 1px solid #868686;\n\np.one {  \nborder-style:solid; \nborder-color:red; \n}\np.two {  \nborder-style:solid; \nborder-color:#98bf21;\n}\n```\n\n',8,2,4,1),
(100,'单独设置各边(border)','border-style属性有1-4个值：\n- border-style:dotted solid double dashed;\n  - 上边框 dotted\n  - 右边框 solid\n  - 底边框 double\n  - 左边框 dashed\n- border-style:dotted solid double;\n  - 上边框 dotted\n  - 左、右边框 solid\n  - 底边框 double\n\n可以指定不同的侧面不同的边框：\n\n```css\n/* 上下左右 */\nborder-top-style:dotted; \nborder-right-style:solid;  \nborder-bottom-style:dotted; \nborder-left-style:solid; \n\n/* 多属性 */\nborder-bottom: 1px solid #edeef0;\n```\n',8,2,4,1),
(101,'边框边角弧度','```css\nborder-radius: 5px;\n```\n',8,2,4,1),
(102,'边框的斜线语法','```css\n.border-radius {\n  border-radius: 50px 25px / 25px 50px;\n}\n```',8,3,4,1),
(103,'实线边框','```css\n-webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n```\n\n',8,3,4,1),
(104,'悬停放大图片特效','```css\n.img-wrapper img {\n  -webkit-transition: 0.3s linear;\n  transition: 0.3s linear;\n}\n\n.img-wrapper img:hover {\n  transform: scale(1.1);\n}\n```\n\n',8,3,4,1),
(105,'定位(position)','position 属性指定了元素的定位类型。\n\nposition 属性的五个值：\n\nstatic, relative, fixed, absolute, sticky',8,2,4,1),
(106,'static定位','HTML 元素的默认值，即没有定位，遵循正常的文档流对象。\n\n静态定位的元素不会受到 top, bottom, left, right影响。\n\n```css\ndiv.static {    \nposition: static;   \nborder: 3px solid #73AD21; \n}\n```\n',8,2,4,1),
(107,'fixed定位','元素的位置相对于浏览器窗口是固定位置。\n\n即使窗口是滚动的它也不会移动：\n\n```css\np.pos_fixed {   \nposition:fixed;   \ntop:30px;   \nright:5px; \n}\n```\n\n**注意：** Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。\n\nFixed定位使元素的位置与文档流无关，因此不占据空间。\n\nFixed定位的元素和其他元素重叠。',8,2,4,1),
(108,'relative定位','相对定位元素的定位是相对其正常位置。\n\n```css\nh2.pos_left {   \nposition:relative; \nleft:-20px; \n} \nh2.pos_right {\nposition:relative; \nleft:20px; \n}\n```\n\n移动相对定位元素，但它原本所占的空间不会改变。\n\n```css\nh2.pos_top { \nposition:relative;  \ntop:-50px;\n}\n```\n\n相对定位元素经常被用来作为绝对定位元素的容器块。',8,2,4,1),
(109,'absolute定位','绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html\n\n```css\nh2 {   \nposition:absolute;  \nleft:100px;  \ntop:150px; \n}\n```\n\nabsolute 定位使元素的位置与文档流无关，因此不占据空间。\n\nabsolute 定位的元素和其他元素重叠。',8,2,4,1),
(110,'sticky定位','sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。\n\n**position: sticky;** 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。\n\n它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。\n\n```css\ndiv.sticky {   \nposition: -webkit-sticky; /* Safari */  \nposition: sticky; \ntop: 0;  \nbackground-color: green;   \nborder: 2px solid #4CAF50; \n}\n```\n',8,2,4,1),
(111,'重叠的元素','元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素\n\nz-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）\n\n一个元素可以有正数或负数的堆叠顺序：\n\n```css\nimg {    \nposition:absolute; \nleft:0px;   \ntop:0px;  \nz-index:-1;\n}\n```\n\n具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。\n\n**注意：** 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。',8,2,4,1),
(112,'定位属性','\"CSS\" 列中的数字表示哪个CSS(CSS1 或者CSS2)版本定义了该属性。\n\n| 属性       | 说明                                                         | 值                                                           | CSS  |\n| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--- |\n| bottom     | 定义了定位元素下外边距边界与其包含块下边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| clip       | 剪辑一个绝对定位的元素                                       | *shape *auto inherit                                         | 2    |\n| cursor     | 显示光标移动到指定的类型                                     | *url* auto crosshair default pointer move e-resize ne-resize nw-resize n-resize se-resize sw-resize s-resize w-resize text wait help | 2    |\n| left       | 定义了定位元素左外边距边界与其包含块左边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| overflow   | 设置当元素的内容溢出其区域时发生的事情。                     | auto hidden scroll visible inherit                           | 2    |\n| overflow-y | 指定如何处理顶部/底部边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| overflow-x | 指定如何处理右边/左边边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| position   | 指定元素的定位类型                                           | absolute fixed relative static inherit                       | 2    |\n| right      | 定义了定位元素右外边距边界与其包含块右边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| top        | 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 | auto *length % *inherit                                      | 2    |\n| z-index    | 设置元素的堆叠顺序                                           | *number *auto inherit                                        | 2    |',8,2,4,1),
(113,'定位示例','#### 元素固定\n\n```css\n@media (min-height: 500px) {\n    .site-header {\n        position: sticky;\n        top: 0;\n        /*other styles*/\n    }\n}\n```\n\n#### 居中定位\n\n示例1\n\n```c#\n   position: absolute;\n    width: 50%;\n    height: 80%;\n    overflow: auto;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n```\n\n示例2\n\n```css\n.tag_search {\n\n  @apply relative;\n  height: 50px;\n\n  div {\n    @apply absolute top-1/2 left-1/2;\n    width: 40%;\n    transform: translate(-50%, -50%);\n  }\n}\n```\n\n示例3\n\n@apply居中\n\n```css\n  // 居中\n  @apply top-1/2 left-1/2 absolute;\n  transform: translate(-50%, -50%);\n```\n',8,3,4,1),
(114,'设置全局片段','有些代码片段是需要经常写的，我们在VSCode中我们可以生成一个代码片段，方便我们快速生成。\n\n1.复制自己需要生成代码片段的代码；\n\n2.[snippet-generator.app/](https://link.juejin.cn?target=https%3A%2F%2Fsnippet-generator.app%2F) 在网站中生成代码片段；\n\n3.在VSCode中配置代码片段；\n\n设置 - 用户代码片段 - - 粘贴生成的代码片段\n\n1. 可以直接打开现有代码片段\n2. 可以选择创建全局代码片段\n3. 可以选择创建当前文件夹的代码片段',13,2,4,1),
(116,'Code Spell Checker','检测你写代码时拼写的单词是否正确。\n\n#### 安装方法\n\n1. 在应用商店中搜索Code Spell Checker。\n2. 点击安装，等待安装完成，然后重启VSCode。\n\n#### Add Word to Workspace Dictionaries\n\n（向工作区词典添加单词）\n\n选中要添加的单词–>右击鼠标–>点击这个Add Word to Workspace Dictionaries，这样下次在拼写这个单词的时候便不会出现波浪线的提示。\n\n#### Add Word to User Dictionary\n\n（将单词添加到用户词典）\n操作步骤如上，只需要选中不同的Add Word to User Dictionary功能即可。\n\n#### Ignore Word\n\n（忽略单词）\n\n操作步骤如上，只需要选中不同的Ignore Word功能即可。\n\n\n#### 删除单词解决方案：\n\nAdd Word to Workspace Dictionaries，这就是意味着添加进来了工作区词典，而在VSCode中创建项目时，系统会给我们生成一个.vscode的文件夹，修改settings.json即可\n\n\n\n\nAdd Word to User Dictionary，这就需要我们再我们再VSCode的系统设置中修改。\n\n设置–>用户–>扩展–>找到安装的Code Spell Checker–>打开settings.json，在其中找到图6的内容，在其中修改添加错的单词，我在其中添加的是bindblur单词。\n\n Ignore Word，方法和第一个一样，因为都是在.vscode中的setting.json文件中。\n\n\n#### 总结\n\nAdd Word to Workspace Dictionaries和Ignore Word仅是将word添加到该项目中，如果再新建一个项目以前添加的word将不再在新项目中生效，而Add Word to User Dictionary是将word添加到VSCode的系统中，所以即是新建一个项目也不会提示有波浪线。',13,1,4,1),
(117,'Code Runner','可以让你在 `vscode` 里方便的运行某个文件或者运行选取的某段代码。\n### Bracket Pair Colorizer 2\n\n- 给你的括号用颜色标记一下，这样当你的函数块里面有很多嵌套，就比较容易理清楚。\n\n### Debugger for Chrome\n\n- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？\n- [在 vscode 中调试 vue](',13,1,4,1),
(118,'Debugger for Chrome','### Debugger for Chrome\n\n- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？\n- [在 vscode 中调试 vue',13,1,4,1),
(119,'ESLint','- 代码检查及错误提示。\n- 结合 Prettier 插件可以让我们快速格式化代码。',13,1,4,1),
(120,'Prettier','- 格式化代码，规范代码风格。',13,1,4,1),
(121,'int.TryParse()','```csharp\npublic static bool TryParse(string s, out Int32 result);\n```\n\n转换成功返回true,否则返回false\n\n```c#\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n',1,3,4,1),
(122,'string转换枚举类型','枚举 字段 = （枚举）Enum.Pares(typeof(枚举)，转换的字段)；\n\n```csharp\n QQ state = (QQ) Enum.Pares(typeof(QQ )，str);\n```\n\n\n\n',1,3,4,1),
(123,'命名规范','- Pascal法：首字母大写，连接词的首字母也都大写\n  →GetInfo\n- Camel：第一个单词的首字母小写\n  →getInfo\n- MENTIONS:\n\n1. 成员变量最好加一个“_”\n2. 接口的名称前加前缀“*I*”',1,6,4,1),
(124,'代码编写规则','- 尽量使用接口\n- 局部变量尽量在最接近的地方使用\n- 不要使用goto系列语句（除非是在跳出深层循环时）\n- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型\n- switch语句要有**default**来处理意外情况',1,6,4,1),
(125,'问号的演变','表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值\n\n```c#\nstring a = null;\nvar b = a??””;\n```\n\n',1,3,4,1),
(126,'类型实例化','```c#\npublic class Abc\n{\n    public int ID {get; set; }\n    public string Name { get; set; }\n}\n\npublic static void Main(string[] args)\n{\n  var abc = new Abc\n  {\n    ID = 1,\n    Name = \"yukaizhao\",\n  };\n}\n```\n',1,3,4,1),
(127,'匿名类','匿名类在linq to sql或者entity framework中返回查询数据时很好用。\n\n```csharp\nvar a = new {\n    ID = 1,\n    Name=”yukaizhao”,\n};\n```\n',1,3,4,1),
(128,'NULL条件运算符','```csharp\n//使用代码\nCustomer customer = new Customer();\nstring name = customer?.Name;\n\n//编译代码\nCustomer customer = new Customer();\nif (customer != null)\n{\n    string name = customer.Name;\n}\n//和??组合起来使用\nif (customer?.Face()??false)\n还可以两个一起组合来使用\nint? contactNameLen = contact?.Name?.Length; \n```\n\n在对象使用前检查是否为null。如对象空，则赋值给变量为空值，所以例子中需要一个为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。',1,3,4,1),
(129,'字符串格式化','String.Format:使用{0}占位符、必须顺序来格式化\n\n```csharp\n    var contactInfo = string.Format(\"Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}\", \n    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);\n\n    //新的语法\n    var contactInfo2 = $\"Id:{contact.Id} Name:{contact.Name} EmailAddr:\n    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n\n    //新格式化方式还支持任何表达式的直接赋值：\n    var contactInfo = $\"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? \"Frank\" : \n    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n',1,3,4,1),
(130,'绑定属性(v-bind)','```html\n<img v-bind:src=\"imgUrl\"/>\n```\n',2,7,4,1),
(131,'动态绑定(v-bind)','在某些情况下，我们属性的名称可能也不是固定的：\n如果属性名称不是固定的，我们可以使用 `:[属性名]=''值''` 的格式来定义\n这种绑定的方式，我们称之为动态绑定属性；\n```js\nconst objectOfAttrs = {\n  id: ''container'',\n  class: ''wrapper''\n}\n//通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\n<div v-bind=\"objectOfAttrs\"></div>\n```\n\n\n',2,7,4,1),
(132,'绑定style(v-bind)','CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n-  绑定style对象语法\n```\n:style=\"包含css样式的对象\"\n:style=\"{属性名: ''属性值''}\"\n```\n​      1- {color: ''red''} 这里需要注意属性值必须添加'''', 如果没有引号会将red当做变量去数据中寻找\n​      2- { fontSize: ''24px''} ,这里也可以写成烤串命名法，但是需要用''''包起来，否则会报错\n​      3- {fontSize: `${finalFontSize}px`} 也可以写成字符串拼接\n​      4- :style=\"finalStyleObj\" 也可以直接绑定对象\n​      5- 也可以写在方法或者计算属性中\n``` html\n  <!-- <h2 :style=\"{key(属性名):value(属性值)}\">{{massage}}</h2> -->\n  <!-- 这里要加'' ''要不然vue会去解析50px这个变量然后报错 -->\n  :style=\"{fontSize: ''50px''}\">{{massage}}\n  <!-- finalSize当成一个变量在使用 -->\n  :style=\"{fontSize: finalSize}\">{{massage}}\n  <!-- 也可以拼接 -->\n   :style=\"{fontSize: finalSize + ''px'',color:finalColor}\">{{massage}}\n  <!-- 数组语法 -->\n  :style=\"[baseStyle,baseStyle1]\">{{massage}}\n\n\nconst app = new Vue({\n	el: \"#app\",\n	data: {	\n        finalSize: 100,\n        finalColor: ''red'',\n        baseStyle:{color:''red''},\n        baseStyle1:{fontSize:''75px''}\n		}})\n\n```\n\n',2,7,4,1),
(133,'JavaScript表达式','```js\n{{ number + 1 }}\n{{ ok ? ''YES'' : ''NO'' }}\n{{ message.split('''').reverse().join('''') }\n<div :id=\"`list-${id}`\"></div>\n```\n\n这些表达式都会被作为 JavaScript ，以组件为作用域解析执行。\n\n在 vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中',2,3,4,1),
(134,'调用函数(v-bind)','可以在绑定的表达式中使用一个组件暴露的方法：\n```html\n<span :title=\"toTitleDate(date)\">\n  {{ formatDate(date) }}\n</span>\n```\n\n',2,7,4,1),
(135,'内联事件处理器(v-on:click)','\n```js\nconst count = ref(0)\n```\n```js\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n',2,7,4,1),
(136,'方法事件处理器(v-on:click)','`v-on` 也可以接受一个方法名或对某个方法的调用。\n\n```js\nconst name = ref(''Vue.js'')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` 是 DOM 原生事件\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\n<!-- `greet` 是上面定义过的方法名 -->\n<button @click=\"greet\">Greet</button>\n```\n\n通过被触发事件的 `event.target.tagName` 访问到该 DOM 元素。',2,7,4,1),
(137,'内联处理器中调用方法(v-on:click)','除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：\n\n```js\nfunction say(message) {\n  alert(message)\n}\n<button @click=\"say(''hello'')\">Say hello</button>\n<button @click=\"say(''bye'')\">Say bye</button>\n```\n',2,7,4,1),
(138,'内联事件处理器中访问事件参数(v-on:click)','有时需要在内联事件处理器中访问原生 DOM 事件。可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数：\n```js\nfunction warn(message, event) {\n  // `这里可以访问 DOM 原生事件`\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n```\n```html\n<!-- 使用特殊的 $event 变量 -->\n<button @click=\"warn(''Form cannot be submitted yet.'', $event)\">\n  Submit\n</button>\n\n<!-- 使用内联箭头函数 -->\n<button @click=\"(event) => warn(''Form cannot be submitted yet.'', event)\">\n  Submit\n</button>\n```\n',2,7,4,1),
(139,'多事件处理器(v-on:click)','事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n\n```html\n<button @click=\"one($event), two($event)\">Submit</button>\n```\n\n```js\n  one(event) {\n    // 第一个事件处理器逻辑...\n  },\n  two(event) {\n   // 第二个事件处理器逻辑...\n  }\n```\n',2,7,4,1),
(140,'事件修饰符(v-on:click)','在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n```html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n<!-- 点击事件将只会触发一次 -->\n<a v-on:click.once=\"doThis\"></a\n    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n',2,7,4,1),
(141,'按键修饰符','在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。\n\n```html\n<!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` -->\n<input @keyup.enter=\"submit\" />\n\n<!--仅会在 $event.key 为 ''PageDown'' 时调用事件处理。 -->\n<input @keyup.page-down=\"onPageDown\" />\n```\n\n',2,7,4,1),
(142,'.exact修饰符','\n修饰符允许你控制由精确的系统修饰符组合触发的事件\n```html\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n',2,7,4,1),
(143,'系统按键修饰符','你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n```html\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n<!-- Ctrl + 点击 -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n',2,7,4,1),
(144,'事件处理器标注类型','在处理原生 DOM 事件时，应该为我们传递给事件处理器的参数正确地标注类型\n\n```js\nfunction handleChange(event) {\n  // `event` 隐式地标注为 `any` 类型\n  console.log(event.target.value)\n}\n```\n\n```html\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个 `event` 参数会隐式地标注为 `any` 类型。这也会在 `tsconfig.json` 中配置了 `\"strict\": true` 或 `\"noImplicitAny\": true` 时报出一个 TS 错误。因此，建议显式地为事件处理器的参数标注类型。此外，你可能需要显式地强制转换 `event` 上的 property：\n\n```js\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n```\n',2,7,4,1),
(145,'项目目录对照','``` bash\n.\n├── vue.config.js/                      # webpack 配置文件；\n├── config/                     # 与项目构建相关的常用的配置选项；\n│   ├── index.js                # 主配置文件\n│   ├── dev.env.js              # 开发环境变量\n│   ├── prod.env.js             # 生产环境变量\n│   └── test.env.js             # 测试环境变量\n│\n├── src/\n│   ├── main.js                 # 的入口文件；\n│   ├── assets/                 # 共用的代码以外的资源，如：图片、图标、视频 等；\n│   ├── api/                    # 网络模块，如：接口；\n│   ├── router/                 # 路由模块\n│   ├── I18n/                   # 国际化模块\n│   ├── pages/                  # 单页页面\n│   ├── vuex/                   # 组件共享状态\n│   ├── components/             # 共用的组件；； 这里的存放的组件应该都是展示组件\n│   │   ├── base/               # 基本组件，如：共用的弹窗组件，loading加载组件，提示组件。\n│   │   ├── common/             # 共用的全局组件，封装的导航条，底部组件等等\n│   │   ├── temp/               # 模板组件，如：相同的页面封装成一个组件。\n│   │   ├── UItemp/             # UI组件，如：项目中特定的按钮，消息数字，等等一些样式可以封装成组件的。\n│   ├── common/                 # 共用的资源，如：常用的图片、图标，共用的组件、模块、样式，常量文件等等；\n│   │   ├── compatible/         # 兼容模块，如：适合App和微信各种接口的模块；\n│   │   ├── extension/          # 已有类的扩展模块，如：对 Array 类型进行扩展的模块；\n│   │   ├── libraries/          # 存放自己封装的或者引用的库；\n│   │   ├── tools/              # 自己封装的一些工具\n│   │   ├── constant.js         # 存放js的常量；\n│   │   ├── constant.scss       # 存放scss的常量；\n│   │   └── ...\n│   └── app/                    # 存放项目业务代码；\n│       ├── App.vue             # app 的根组件；\n├── public/                     # 纯静态资源，该目录下的文件不会被webpack处理，该目录会被拷贝到输出目录下；\n├── .babelrc                    # babel 的配置文件\n├── .editorconfig               # 编辑器的配置文件；可配置如缩进、空格、制表类似的参数；\n├── .eslintrc.js                # eslint 的配置文件\n├── .eslintignore               # eslint 的忽略规则\n├── .gitignore                  # git的忽略配置文件\n├── .postcssrc.js               # postcss 的配置文件\n├── CHAGNELOG.md                # 版本更新变更release\n├── index.html                  # HTML模板\n├── package.json                # npm包配置文件，里面定义了项目的npm脚本，依赖包等信息\n└── README.md                   # 项目信息文档\n```\n',2,6,4,1),
(146,'组件使用规范','- 使用时以`v-`开头\n- 命名遵循组件命名规范\n- 推荐使用单标签闭合\n\n``` html\n<v-BaseButton :data=\"data\"/>\n<script>\n export default{\n     components:{\n         \"v-BaseButton\":BaseButton\n     }\n }\n</srcipt\n```\n',2,8,4,1),
(147,'目录命名','**参照项目命名规则，有复数结构时，要采用复数命名法**。例：docs、assets、components、directives、mixins、utils、views。\n- 文件名统一采用小写\n- 特殊缩写名称可大写开头\n\n```\n│   ├── pages/                 \n│   ├── components/\n│   │   ├── UItemp/\n```\n',2,8,4,1),
(148,'命名原则','祖先模块不能出现下划线，除了是全站公用模块，如 `mod_` 系列的命名：\n\n**推荐：**\n```html\n<div class=\"modulename\">\n    <div class=\"modulename_info\">\n        <div class=\"modulename_son\"></div>\n        <div class=\"modulename_son\"></div>\n        ...\n    </div>\n</div>\n\n<!-- 这个是全站公用模块，祖先模块允许直接出现下划线 -->\n<div class=\"mod_info\">\n    <div class=\"mod_info_son\"></div>\n    <div class=\"mod_info_son\"></div>\n    ...        \n</div>\n```\n',2,8,4,1),
(149,'模块命名','全站公共模块：以 `mod_` 开头\n\n```html\n<div class=\"mod_yours\"></div>\n```\n\n业务公共模块：以 `业务名_mod_` 开头\n\n```html\n<div class=\"paipai_mod_yours\"></div>\n```\n',2,8,4,1),
(150,'图片命名','- 图片文件夹一般遵从页面或者模块命名,如：`login/`）\n- 图片不可随意命名，且严禁使用0，1，等数字直接命名图片。\n- 图片命名可遵循：用途+描述，多个单词用下划线隔开，如：`login_icon.png`,`pwd_icon.png`\n- 10k以下图片建议放置`assets/img`下（webpack打包时直接转为base64嵌入）\n- 大图且不常更换的图片放置`public/img`下\n- 可用css编写的样式严禁使用图片\n- 国际化图片，后缀使用简体`-cn`,英文`-en`,繁体`-tw`\n\n```\n│   ├── assets/               \n│   │   ├── img/                          # 图片\n│   │   │    ├── common/                  # 公共图片\n│   │   │    │    ├── default_avatar.png  # 默认头像\n│   │   │    ├── login/                   # 登录模块\n│   │   │    │    ├── login1.png          # 登录模块图片\n│   │   │    │    ├── login_icon-en.png      \n│   │   │    │    ├── login_icon-cn.png     \n│   │   │    │    ├── login_icon-tw.png      \n│   │   │    ├── userInfo/                # 用户中心模块的图片\n```\n',2,8,4,1),
(151,'v-once','- v-once 用于指定元素或者组件只渲染一次\n- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；\n- 该指令可以用于性能优化；\n- 如果是子节点，也是只会渲染一次\n\n```html\n<span v-once>这个将不会改变: {{ msg }}</span>\n```\n',2,7,4,1),
(152,'v-if','用于按条件渲染一个区块。\n`v-if` 是“真实的”按条件渲染，因为它确保了条件区块内的事件监听器和子组件都会在切换时被销毁与重建。\n\n`v-if` 也是**懒加载**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块会直到条件首次变为 true 时才渲染。\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n',2,7,4,1),
(153,'v-else','v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则将不会识别它\n```html\n<h1 v-else>Oh no </h1>\n```\n',2,7,4,1),
(154,'template上的v-if','`v-if` 是一个指令，他必须依附某个元素。但想要切换不只一个元素呢？在这种情况下我们可以在一个 `<template>` 元素上使用 `v-if`，这只是一个不可见的包裹元素，最后渲染的结果并不会包含这个 `<template>` 元素。\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。',2,7,4,1),
(155,'v-show','按条件显示一个元素\n\n`v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的CSS 属性。\n`v-show` 不支持在 `<template>` 元素上使用，也没有 `v-else` 来配合。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n',2,7,4,1),
(156,'v-for','v-for的基本格式是 \"item in 数组\nv-for也支持遍历对象，并且支持有一二三个参数\n\n一个参数： \"value in object\";\n二个参数： \"(value, key) in object\";\n三个参数： \"(value, key, index) in object\";\n\nv-for同时也支持数字的遍历',2,2,4,1),
(157,'定义数组渲染列表(v-for)','```js\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n```html\n<li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n</li>\n```\n',2,7,4,1),
(158,'可选参数(v-for)','在 `v-for` 块中可以完整地访问父作用域内的属性。`v-for` 也支持使用可选的第二个参数，表示当前项的位置索引。\n\n```js\nconst parentMessage = ref(''Parent'')\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n\n```html\n<li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n',2,7,4,1),
(159,'变量别名解构(v-for)','```html\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- 有 index 索引时 -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\n',2,7,4,1),
(160,'用of替代in分隔符(v-for)','```html\n<div v-for=\"item of items\"></div>\n```\n',2,7,4,1),
(161,'对象(v-for)','遍历一个对象的所有属性。\n```vue\n  <li v-for=\"value in myObject\">\n    {{ value }}\n  </li>\n```\n```js\nconst myObject = reactive({\n  title: ''如何在 Vue 中渲染列表'',\n  author: ''王小明'',\n})\n```\n提供第二个的参数为 property 名称 (键名)\n```html\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n```\n用第三个参数作为索引\n```html\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n```\n唯一key\n```html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n',2,7,4,1),
(162,'使用值范围(v-for)','`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n```html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n 在template使用\n```html\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n```\n',2,7,4,1),
(163,'组件上使用(v-for)','```html\n<my-component v-for=\"item in items\" :key=\"item.id\">\n</my-component>\n```\n\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还是应该使用 props：\n\n```html\n<my-component\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n></my-component>\n```\n\n',2,7,4,1),
(164,'for&if同时使用','当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 <template> 中\n\n```html\n//1\n<template v-for=\"(item, index) in ResultList\" :key=\"index\">\n   <a @click=\"onk(item.path)\" v-if=\"item.identity\">\n    {{item.title}}\n   </a>\n</template>\n//2\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n',2,7,4,1),
(165,'v-text','都是用于将数据显示在界面中，但是通常只接受一个string类型\n用于更新元素的 textContent\n```html\n<div v-text=\"message\"></div>\n<div v-text=\"msg\"></div> 等价于 <div>{{msg}}</div>\n```\n',2,7,4,1),
(166,'v-pre','- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签\n- 跳过不需要编译的节点，加快编译的速度\n```html\n<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->\n```\n\n',2,7,4,1),
(167,'v-cloak','保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。',2,7,4,1),
(168,'自定义指令','注册一个全局指令 v-focus, 指令的功能在页面加载时，元素获得焦点：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n\n<script>\nconst app = Vue.createApp({})\n// 注册一个全局自定义指令 `v-focus`\napp.directive(''focus'', {\n  // 当被绑定的元素挂载到 DOM 中时……\n  mounted(el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\napp.mount(''#app'')\n</script>\n```\n\n我们也可以在实例使用 directives 选项来注册局部指令，这样指令只能在这个实例中使用：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n<script>\nconst app = {\n   data() {return {}},\n   directives: {\n      focus: {\n         // 指令的定义\n         mounted(el) {\n            el.focus()\n         }\n      }\n   }\n}\nVue.createApp(app).mount(''#app'')\n```',2,7,4,1),
(169,'循环指定次数(v-for)','```html\n<a-button type=\"primary\" shape=\"round\" @click=\"GetMonth(index)\" \n          v-for=\"index of 12\" :key=\"index\">{{ index }}月\n</a-button>\n```\n\n\n\n',2,7,4,1),
(173,'ces','ces',1,1,4,1),
(174,'获取本日开始时间','```csharp\n/// <summary>\n/// 获取本日开始时间（0点0分0秒）\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetDayStart(this DateTime dateTime)\n{\n  return dateTime.Date;\n}\n```\n\n\n\n',1,3,4,1),
(175,'获取本日结束时间','```csharp\n/// <summary>\n/// 获取本日结束时间（23点59分59秒）\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetDayEnd(this DateTime dateTime)\n{\n  return dateTime.Date.AddDays(1).AddMilliseconds(-1);\n}\n```\n\n\n\n',1,3,4,1),
(176,'获取本周开始时间','```csharp\n/// <summary>\n/// 获取本周开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetWeekStart(this DateTime dateTime)\n{\n  return dateTime.AddDays(-(int) dateTime.DayOfWeek + 1).GetDayStart();\n}    \n```\n\n\n\n',1,3,4,1),
(177,'获取本周结束时间','```csharp\n/// <summary>\n/// 获取本周结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetWeekEnd(this DateTime dateTime)\n{\n  return dateTime.AddDays(7 - (int) dateTime.DayOfWeek).GetDayEnd();\n}\n```\n\n\n\n',1,3,4,1),
(178,'获取本月开始时间','```csharp\n/// <summary>\n/// 获取本月开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetMonthStart(this DateTime dateTime)\n{\n  return new DateTime(dateTime.Year, dateTime.Month, 1, 0, 0, 0, 0);\n}\n\n```\n\n\n\n',1,3,4,1),
(179,'获取本月结束时间','```csharp\n /// <summary>\n /// 获取本月结束时间\n /// </summary>\n /// <param name=\"dateTime\"></param>\n /// <returns></returns>\n public static DateTime GetMonthEnd(this DateTime dateTime)\n {\n   return GetMonthStart(dateTime).AddMonths(1).AddMilliseconds(-1);\n }\n```\n\n\n\n',1,3,4,1),
(180,'获取本季度开始时间','```csharp\n/// <summary>\n/// 获取本季度开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetSeasonStart(this DateTime dateTime)\n{\n  var time = dateTime.AddMonths(0 - ((dateTime.Month - 1) % 3));\n  return DateTime.Parse(time.AddDays(-time.Day + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n}\n```\n\n\n\n',1,3,4,1),
(181,'获取本季度结束时间','```csharp\n/// <summary>\n/// 获取本季度结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetSeasonEnd(this DateTime dateTime)\n{\n  var time = dateTime.AddMonths((3 - ((dateTime.Month - 1) % 3) - 1));\n  return DateTime.Parse(time.AddMonths(1).AddDays(-time.AddMonths(1).Day + 1).AddDays(-1).ToString(\"yyyy/MM/dd 23:59:59\"));\n}\n```\n\n\n\n',1,3,4,1),
(182,'获取本年开始时间','```csharp\n/// <summary>\n/// 获取本年开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetYearStart(this DateTime dateTime)\n{\n  return DateTime.Parse(dateTime.AddDays(-dateTime.DayOfYear + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n}\n```\n\n\n\n',1,3,4,1),
(183,'获取本年结束时间','```csharp\n/// <summary>\n/// 获取本年结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetYearEnd(this DateTime dateTime)\n{\n  var time2 = dateTime.AddYears(1);\n  return DateTime.Parse(time2.AddDays(-time2.DayOfYear).ToString(\"yyyy/MM/dd 23:59:59\"));\n}\n```\n\n\n\n',1,3,4,1),
(184,'北京时间转换成unix时间戳','```csharp\n/// <summary>\n/// 北京时间转换成unix时间戳(10位/秒)\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static long BeijingTimeToUnixTimeStamp10(this DateTime dateTime)\n{\n  return(long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalSeconds;\n}\n```\n\n\n\n',1,3,4,1),
(186,'北京时间转换成unix时间戳(13位/毫秒)','```csharp\n/// <summary>\n/// 北京时间转换成unix时间戳(13位/毫秒)\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static long BeijingTimeToUnixTimeStamp13(this DateTime dateTime)\n{\n  return(long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalMilliseconds;\n}\n```\n\n\n\n',1,3,4,1),
(188,'10位unix时间戳转换成北京时间','```csharp\n/// <summary>\n/// 10位unix时间戳转换成北京时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime UnixTimeStamp10ToBeijingTime(this long unixTimeStamp)\n{\n  return new DateTime(1970, 1, 1, 8, 0, 0).AddSeconds(unixTimeStamp);\n}\n```\n\n\n\n',1,3,4,1),
(190,'13位unix时间戳转换成北京时间','```csharp\n/// <summary>\n/// 13位unix时间戳转换成北京时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime UnixTimeStamp13ToBeijingTime(this long unixTimeStamp)\n{\n  return new DateTime(1970, 1, 1, 8, 0, 0).AddMilliseconds(unixTimeStamp);\n}\n```\n\n\n\n',1,3,4,1),
(192,'当前日期所在月份第一个指定星期几的日期','```csharp\n/// <summary>\n/// 当前日期所在月份第一个指定星期几的日期\n/// </summary>\n/// <param name=\"date\">给定日期</param>\n/// <param name=\"dayOfWeek\">星期几</param>\n/// <returns>所对应的日期</returns>\npublic static DateTime GetFirstWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n{\n  var dt = date.GetMonthStart();\n  while(dt.DayOfWeek != dayOfWeek) dt = dt.AddDays(1);\n  return dt;\n}\n```\n\n\n\n',1,3,4,1),
(193,'当前日期所在月份最后1个指定星期几的日期','```csharp\n/// <summary>\n/// 当前日期所在月份最后1个指定星期几的日期\n/// </summary>\n/// <param name=\"date\">给定日期</param>\n/// <param name=\"dayOfWeek\">星期几</param>\n/// <returns>所对应的日期</returns>\npublic static DateTime GetLastWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n{\n  var dt = date.GetMonthEnd();\n  while(dt.DayOfWeek != dayOfWeek) dt = dt.AddDays(-1);\n  return dt;\n}\n```\n\n\n\n',1,3,4,1),
(196,'给定日期所在月份共有多少天','```csharp\n/// <summary>\n/// 给定日期所在月份共有多少天\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static int GetCountDaysOfMonth(this DateTime date)\n{\n  return date.GetMonthEnd().Day;\n}\n```\n\n\n\n',1,3,4,1),
(197,'当前日期与给定日期是否是同一天','```csharp\n/// <summary>\n/// 当前日期与给定日期是否是同一天\n/// </summary>\n/// <param name=\"date\">当前日期</param>\n/// <param name=\"dateToCompare\">给定日期</param>\n/// <returns></returns>\npublic static bool IsDateEqual(this DateTime date, DateTime dateToCompare)\n{\n  return date.Date == dateToCompare.Date;\n}\n```\n\n\n\n',1,3,4,1),
(198,'是否是周未','```csharp\n/// <summary>\n/// 是否是周未\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsWeekend(this DateTime date)\n{\n  return date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday;\n}\n```\n\n\n\n',1,3,4,1),
(199,'是否是工作日','```csharp\n/// <summary>\n/// 是否是工作日\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsWeekDay(this DateTime date)\n{\n  return !date.IsWeekend();\n}\n```\n\n\n\n',1,3,4,1),
(200,'判断是否为今天','```csharp\n/// <summary>\n/// 判断是否为今天\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsToday(this DateTime date)\n{\n  return date.Date == DateTime.Now.Date;\n}\n```\n\n\n\n',1,3,4,1),
(201,'ShellExecute使用','### ShellExecute\n\n若ShellExecute函数调用成功，则返回值为被执行程序的实例句柄。若返回值小于32，则表示出现错误。\n\n```csharp\n  /// <summary>\n        /// ShellExecute\n        /// </summary>\n        /// <param name=\"hwnd\">指定父窗口句柄:ntPtr.Zero</param>\n        /// <param name=\"lpszOp\">指定要进行的操作:Open</param>\n        /// <param name=\"lpszFile\">指定要打开的文件名|路径</param>\n        /// <param name=\"lpszParams\">指定命令行参数: 0 | \"\"</param>\n        /// <param name=\"lpszDir\">用于指定默认目录:0 | \"\"</param>\n        /// <param name=\"FsShowCmd\">显示模式: 0:隐藏 1~11</param>\n        /// <returns></returns>\n        [DllImport(\"shell32.dll\")]\n        private static extern int ShellExecute(IntPtr hwnd, StringBuilder lpszOp, StringBuilder lpszFile, StringBuilder lpszParams, StringBuilder lpszDir, int FsShowCmd);\n\n\n        /// <summary>\n        /// 打开程序/文件夹\n        /// </summary>\n        /// <param name=\"path\">路径</param>\n        /// <param name=\"FsShow\">显示模式 默认1</param>\n        public static void OpenFile(string path, int FsShow = 1)\n        {\n            ShellExecute(IntPtr.Zero, new StringBuilder(\"Open\"), new StringBuilder(@path), new StringBuilder(\"\"), new StringBuilder(\"\"), FsShow);\n        }\n```\n\n',1,3,4,1),
(202,'WindiCSS','## WindiCSS\n\n[指令 | Windi CSS](https://cn.windicss.org/features/directives.html)\n\n**Windi CSS** 是下一代工具优先的 CSS 框架。\n\n如果你已经熟悉了 [Tailwind CSS](https://tailwindcss.com/docs)，可以把 Windi CSS 看作是**按需供应的** Tailwind 替代方案，它为你提供了更快的加载体验，**完美兼容 Tailwind v2.0**，并且拥有很多额外的酷炫功能',14,2,4,1),
(203,'自动值推导',' Windi CSS 提供自动值推导功能，可以在类名中使用任意值，然后生成相应的样式，用起来比使用标准的 sass 要方便很多。例如：\n\n- `w-192px` 可以自动解析为 `width: 192px;`\n- `w-[25%]` 可以自动解析为 `width: 25%;` ，也相当于 `width: 48px;`\n- `h-12` 可以自动解析为 `height: 3rem;` ，根据当前的根元素的字体大小也相当于 `height: 48px;',14,3,4,1),
(204,'Important前缀','### Important前缀\n\n使用 important 也是非常方便，只需在任意工具类的前面使用 `!` 前缀，使它们变为 `!important`，就可以覆盖之前的样式规则中指定的属性了。\n\n如 `w-192px` 添加 `!` 前缀为 `!w-192px',14,3,4,1),
(205,'Shortcuts','使用相同的工具类合集时，出现很多重复性代码， Shortcuts 特性可以工具类的名字组合在一起定义成一个新的名字，在任何地方使用，就免去了大量重复冗余的代码。\n\n配置文件 `windi.config.ts` 中添加 `shortcuts` 字段：\n\n```typescript\nexport default {\n  theme: {\n    /* ... */\n  },\n  shortcuts: {\n    ''box view'': ''w-[25%] h-12 rounded-md m-4px'',\n  },\n}\n```\n\n就可以把页面代码修改为下面这样，页面展示效果是一样的，但是代码更加简洁明了。\n\n```html\n<div class=\"bg-blue-400 box-view\"></div>\n```',14,3,4,1),
(206,'响应式设计','Windi CSS 中轻松实现响应式设计。将可变修饰（variant）的前缀加到对应的工具类前，比如 `md:`、`lg:`。\n\n> |      | 默认                | 带有 `<` 前缀         | 带有 `@` 前缀                                 |\n> | ---- | ------------------- | --------------------- | --------------------------------------------- |\n> | sm   | (min-width: 640px)  | (max-width: 639.9px)  | (min-width: 640px) and (max-width: 767.9px)   |\n> | md   | (min-width: 768px)  | (max-width: 767.9px)  | (min-width: 768px) and (max-width: 1023.9px)  |\n> | lg   | (min-width: 1024px) | (max-width: 1023.9px) | (min-width: 1024px) and (max-width: 1279.9px) |\n> | xl   | (min-width: 1280px) | (max-width: 1279.9px) | (min-width: 1280px) and (max-width: 1535.9px) |\n> | 2xl  | (min-width: 1536px) | (max-width: 1535.9px) | (min-width: 1536px)                           |\n\n```html\n<div class=\"lg:bg-red-400 md:bg-red-200 sm:bg-red-100 box-view\"></div>\n\n<div class=\"phone:(bg-red-400 text-light-100 p-10) iPad:(p-50 bg-blue-700) lg:(p-100 bg-cyan-800 text-50px)\">\n    响应式\n</div>\n\n <div\n    w:phone=\"bg-red-400 text-light-100 p-10\"\n    w:iPad=\"bg-blue-700 p-50\"\n    w:lg=\"p-100 bg-cyan-800 text-50px\"\n>\n    响应式\n</div>\n\n@screen <xp {\n}\n```\n\n根据业务需求来自定义断点，在 `windi.config.ts` 中配置\n\n```tsx\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  theme: {\n    screens: {\n      tablet: ''640px'',\n      laptop: ''1024px'',\n      desktop: ''1280px'',\n    },\n  },\n})\n\n```',14,3,4,1),
(207,'@apply','将 `@apply` 在 style 块中同一行的、一些已存在的工具类上使用，和 Shortcuts 效果差不多，适合抽取成一个通用工具类。\n\n```html\n<style lang=\"scss\" scoped>\n...\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n</style>\n```\n',14,3,4,1),
(208,'@variants','通过把 css 工具类定义包装在 `@variants` 中，用来生成带有一些屏幕可变修饰，状态可变修饰，主题可变修饰的工具类。\n\n```html\n<template>\n    <h3>使用 Windi CSS</h3>\n    <div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n      <div class=\"bg-red-400 box-view2\"></div>\n      <div class=\"bg-green-400 box-view2\"></div>\n      <div class=\"bg-blue-400 box-view2\"></div>\n    </div>\n    <br>\n</template>\n\n<style lang=\"scss\" scoped>\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n@variants focus, hover {\n  .box-view2 {\n    @apply bg-red-200;\n  }\n}\n</style>\n```\n',14,3,4,1),
(209,'@screen','`@screen` 媒体查询，通过名称来引用断点，以此来取代通过复制你 CSS 里面的值来实现。\n\n```html\n<style lang=\"scss\" scoped>\n...\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n// lg 就是上文响应式设计中的断点 (min-width: 1024px)\n@screen lg {\n  .box-view2 {\n    @apply bg-red-200;\n  }\n}\n\n// 上下效果一样\n@media (min-width: 1024px) {\n  .box-view2{\n    // background-color: rgba(254, 202, 202) = bg-red-200\n    background-color: rgba(254, 202, 202)\n  }\n}\n</style>\n```\n',14,3,4,1),
(210,'@layer','`@layer` 指令用来确认每个 class 的排序。合法的层级为 `基础 (base)`, `组件 (components)` 和 `工具类 (utilities)`。',14,3,4,1),
(211,'theme()','`theme()` 函数可以让我们通过 `.` 运算符来获取想要设置的值。\n\n```html\n<template> \n    <h3>使用 Windi CSS</h3>\n    <div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n      <div class=\"bg-red-400 box-view2 light-red\"></div>\n      <div class=\"bg-green-400 box-view2\"></div>\n      <div class=\"bg-blue-400 box-view2\"></div>\n    </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n.light-red {\n  background-color: theme(\"colors.red.200\");\n}\n</style>\n```\n',14,3,4,1),
(212,'属性化模式','属性化在 Windi CSS 中默认下是可选的，在 `windi.config.ts` 配置中开启，并根据需求使用。\n\n```typescript\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  attributify: true,\n})\n```\n\n把上面的代码改为下面的方式，效果和上面讲到的响应式设计是一样的，这样写可以让我们的目录更加清晰。\n\n```html\n<h3>使用 Windi CSS</h3>\n<div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n    <div\n        lg=\"bg-red-400 box-view\"\n        md=\"bg-red-200 box-view\"\n        sm=\"bg-red-100 box-view\"\n      ></div>\n    <div class=\"bg-green-400 box-view\"></div>\n    <div class=\"bg-blue-400 box-view\"></div>\n</div>\n```\n\n如果担心命名冲突，可以在 `windi.config.ts` 配置中通过属性化方式添加自定义前缀：\n\n```html\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  attributify: {\n    prefix: ''w:'',\n  },\n})\n<h3>使用 Windi CSS</h3>\n<div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n    <div\n        w:lg=\"bg-red-400 box-view\"\n        w:md=\"bg-red-200 box-view\"\n        w:sm=\"bg-red-100 box-view\"\n      ></div>\n    <div class=\"bg-green-400 box-view\"></div>\n    <div class=\"bg-blue-400 box-view\"></div>\n</div>\n```\n\n',14,3,4,1),
(213,'Plugin插件','[Windi CSS](https://link.juejin.cn?target=https%3A%2F%2Fcn.windicss.org%2Fplugins%2Finterfaces.html) 官方以及社区提供了很多 plugin 插件使用，让我们操作 css 更加方便和高效，而且我们也可以通过 Windi CSS 的接口，来开发自己的插件。\n\n插件同样需要在 Windi CSS 的配置文件 `windi.config.ts` 中引入即可。\n\n```typescript\nexport default {\n  theme: {\n    // ...\n  },\n  // 引入插件\n  plugins: [\n    require(''windicss/plugin/typography''),\n    // ...\n  ],\n}\n```\n',14,1,4,1),
(214,'选择器选择','- 尽量少用通用选择器\n- 不使用 ID 选择器\n- 不使用无具体语义定义的标签选择器\n\n```css\n/* 推荐Class */\n.jdc {}\n.jdc li {}\n.jdc li p{}\n```\n',8,6,4,1),
(215,'属性值引号','css属性值用到引号时，统一用单引号\n\n```css\n/* 推荐 */\n.jdc { \n    font-family: ''Hiragino Sans GB'';\n}\n```\n\n',8,6,4,1),
(216,'属性书写顺序','建议遵循以下顺序：\n\n1. 布局定位属性：display / position / float / clear / visibility / overflow\n2. 自身属性：width / height / margin / padding / border / background\n3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …',8,6,4,1),
(217,'CSS注释','### CSS注释\n\n```css\n/*这是个注释*/\np\n{\n    text-align:center;\n    /*这是另一个注释*/\n    color:black;\n    font-family:arial;\n}\n```',8,6,4,1),
(218,'文件信息注释','在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息\n\n```css\n@charset \"UTF-8\";\n/**\n * @desc File Info\n * @author Author Name\n * @date 2015-10-10\n */\n```\n\n',8,6,4,1),
(219,'常用命名','| **CSS类名**           | **说明**               |\n| --------------------- | ---------------------- |\n| **布局**              |                        |\n| layout                | 布局容器               |\n| wrapper/wrap          | 控制布局宽度的外围容器 |\n| header/head/hd        | 头部/顶部              |\n| main/bd               | 主体部分               |\n| footer/foot/ft        | 底部                   |\n| sidebar               | 侧边栏                 |\n| **容器**              |                        |\n| banner                | 广告栏                 |\n| content               | 内容部分               |\n| copyright             | 版权                   |\n| list                  | 列表                   |\n| menu/submenu          | 菜单/二级菜单          |\n| nav/subnav            | 导航栏/二级导航        |\n| **组件/细节**         |                        |\n| arrow                 | 箭头                   |\n| btn                   | 按钮                   |\n| download              | 下载                   |\n| logo                  | 徽标                   |\n| message/msg           | 信息                   |\n| news                  | 新闻                   |\n| product               | 产品                   |\n| search                | 搜索                   |\n| status                | 状态                   |\n| summary               | 摘要                   |\n| tab                   | 标签页                 |\n| tag                   | 标签                   |\n| text/txt              | 文本                   |\n| tip                   | 提示                   |\n| title/subtitle        | 标题/二级标题          |\n| **尺寸**              |                        |\n| large                 | 大                     |\n| middle                | 中等                   |\n| small                 | 小                     |\n| mini                  | 迷你                   |\n| **位置**              |                        |\n| top/right/bottom/left | 上/右/下/左            |\n| **关系**              |                        |\n| first                 | 第一个                 |\n| last                  | 最后一个               |\n| prev                  | 上一个                 |\n| current               | 当前项                 |\n| next                  | 下一个                 |\n| forward               | 向前                   |\n| back                  | 向后                   |\n| **状态**              |                        |\n| primary               | 主要                   |\n| info                  | 提示信息               |\n| success               | 成功                   |\n| warning               | 一般警告               |\n| danger/error          | 严重警告/错误警告      |\n| link                  | 文字链接               |\n| plain/ghost           | 按钮是否镂空           |\n| light                 | 亮模式                 |\n| dark                  | 暗模式                 |\n| disabled              | 禁用                   |\n| active                | 激活                   |\n| checked               | 选中                   |\n| loading               | 加载中                 |',8,6,4,1),
(220,'选择器使用情况','| 选择器         | 作用                   | 用法及隔开代码                      | 使用情况 |\n| -------------- | ---------------------- | ----------------------------------- | -------- |\n| 后代选择器     | 用来选择后代元素       | 符号是空格 .nav a                   | 较多     |\n| 子代选择器     | 选择最近一级元素       | 符号是大于 .nav>p                   | 较少     |\n| 并集选择器     | 选择某些相同样式的元素 | 符号是逗号 .nav，header             | 较多     |\n| 链接伪类选择器 | 选择不同状态的链接     | 重点记住a{}和a：hover实际开发的写法 | 较多     |\n| ：focus        | 选择获得光标的表单     | input：focus记住这个写法            | 较少     |',8,2,4,1),
(221,'CSS的三种样式表','按照CSS样式书写的位置（或者引入方式）\n\n- 行业样式表（行内式）\n- 内部样式表（嵌入式）\n- 外部样式表（链接式）',8,6,4,1),
(222,'行内样式表','行内样式表是在元素标签内部的style属性中设置CSS样式，适合于修改简单样式。\n\n```css\n<div style=\"color:red; font-size:12px;\">青春不常在，抓紧谈恋爱</div>\n```\n\n- style其实就是标签的属性\n- 在双引号中间，写法要符合CSS规范。\n- 可以控制当前的标签设置样式。\n- 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用。\n- 使用行内样式表设定CSS，通常也被成为行内式引入。',8,6,4,1),
(223,'外部样式表','实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。\n\n引入外部样式表分为两步：\n\n- 新建一个后缀名为CSS的样式文件，把所有CSS代码都放入此文件中。\n- 在HTML页面中，使用<link>标签引入这个文件。\n\n```css\nlink rel=\"style sheet\" href\"CSS文件路径\"\n```\n\n',8,2,4,1),
(224,'CSS引入方式总结','| 样式表     | 优点                     | 缺点         | 使用情况   | 控制范围     |\n| ---------- | ------------------------ | ------------ | ---------- | ------------ |\n| 行内样式表 | 书写方便；权重高         | 结构样式混写 | 较少       | 控制一个标签 |\n| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离 | 较多       | 控制一个页面 |\n| 外部样式表 | 完全实现结构和样式相分离 | 需要引入     | 最多(推荐) | 控制多个页面 |',8,2,4,1),
(225,'变量','### 变量\n\n变量用来存储需要在CSS中复用的信息，如颜色和字体,通过$符号去声明一个变量。\n可复用属性尽量抽离为页面变量，易于统一维护\n\n```css\n$color: red;\n.jdc {\n    color: $color;\n    border-color: $color;\n}\n```\n转换全局变量可添加 `!global` 声明：\n```css\n $width: 5em !global;\n```',10,2,4,1),
(226,'混合(mixin)','根据功能定义模块，然后在需要使用的地方通过 `@include` 调用，避免编码时重复输入代码段\n\n```css\n@mixin icon($x:0, $y:0) {\n    background: url(/img/icon.png) no-repeat $x, $y;\n}\n.test {\n   @include icon(-10px, 0);\n}\n```\n查看: [混合(Mixins)](http://ref.ecdata.cn/docs/sass.html#sass-混合mixins)',10,2,4,1),
(227,'占位选择器(%) ','以 `%` 标识定义，通过 `@extend` 调用\n\n```css\n%borderbox {\n    box-sizing: border-box;\n}\n.jdc {\n    @extend %borderbox;\n}\n```\n',10,6,4,1),
(228,'继承(extend)','通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码\n```css\n.jdc_1 {\n    color: red;\n}\n.jdc_2 {\n    @extend .jdc_1;\n}\n```\n\n',10,2,4,1),
(229,'循环(for)','```\n结束值不执行：\n@for 变量 from 开始值 through 结束值 {}\n结束值也执行：\n@for 变量 from 开始值 to 结束值 {}\n```\n\n注意：`#{}` 是连接符，变量连接使用时需要依赖\n\n```scss\n@for $i from 1 through 3 {\n    .jdc_#{$i} {\n        background-position: 0 (-20px) * $i;\n    }\n}\n```',10,2,4,1),
(230,'循环(each)','```scss\n@each $name in list, detail {\n    .jdc_#{$name} {\n        ...\n    }\n}\n@each $name, $color in (list, red), (detail, blue) {\n    .jdc_#{$name} {\n      ...\n    }\n}\n```',10,3,4,1),
(231,'函数(function)','```css\n@function pxToRem($px) {\n    @return $px / 10px * 1rem;\n}\n.jdc {\n    font-size: pxToRem(12px);\n}\n```\n',10,3,4,1),
(232,'运算规范','### 运算规范\n\n运算符之间空出一个空格\n\n```scss\n.jdc {\n    width: 100px - 50px;\n    height: 30px / 5;\n}\n```\n\n单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意\n\n```scss\n// 正确的运算格式\n.jdc {\n    width: 100px - 50px;\n    width: 100px + 50px;\n    width: 100px * 2;\n    width: 100px / 2;\n}\n```\n\n',10,6,4,1),
(233,'居中(flex)','使用 Flexbox 实现子元素的居中效果\n```css\n@mixin center-children {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n```css\n.parent {\n    @include center-children;\n}\n```\n\n',10,3,4,1),
(235,'插值(#{})','通过 `#{}` 语句在选择器或属性名中使用变量：\n```css\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: blue;\n}\n```\n\n编译为\n\n```css\np.foo {\n  border-color: blue; }\n```\n\n',10,3,4,1),
(236,'嵌套(Nesting)','```css\n.container{\n  .left-area{\n    ...\n  }\n}\n```',10,2,4,1),
(237,'父选择器(&)','& 表示自身的意思。\n```css\n.container{\n  &.right-area{\n   background-color : #0000\n }\n}\n```\n\n',10,3,4,1),
(238,'Mixin(混合)','### Mixin(混合)\n\n用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。\n\n```scss\n@mixin 名字（参数1，参数2，...）\n{\n........样式.......\n}\n\ndiv{\n    @include 名字;  \n}\n```\n\n',10,3,4,1),
(242,'循环(while)','### while循环\n\n``` css\n$gao: 1;\n@while $gao<4 {\n    .div#{$gao}{\n        height: $gao*10px;\n    }\n   $gao : $gao+1;\n}\n```\n\n\n\n',10,3,4,1),
(243,'v-model','在处理表单时，常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。v-model 在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n#### 基本使用\n```html\n<input v-model=\"text\">\n```\n#### 多行文本\n```html\n<textarea v-model=\"message\"></textarea>\n```\n',2,7,4,1),
(244,'复选框(v-model)','单一的复选框，绑定的是布尔类型值：\n\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\n```\n',2,7,4,1),
(245,'多个复选框(v-model)','绑定同一个数组：\n```js\nconst checkedNames = ref([])\n```\n```html\n<div>选择的名字有：{{ checkedNames }}</div>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n```\n',2,7,4,1),
(246,'选择框(v-model)','单选时：\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\">\n  <option disabled value=\"\">请选择</option>\n  <option>A</option>\n  <option>B</option>\n</select\n```\n\n多选时 (绑定到一个数组)：\n\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n</select>\n```\n\n用 `v-for` 渲染的动态选项：\n\n```html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<div>选择的是：{{ selected }}</div>\n```\n\n```js\nconst selected = ref(''A'')\nconst options = ref([\n  { text: ''One'', value: ''A'' },\n  { text: ''Two'', value: ''B'' },\n])\n```',2,7,4,1),
(247,'值绑定(v-model)','对于单选按钮，复选框和选择器选项，`v-model` 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：\n\n```html\n<!-- `picked` 在被选择时是字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` 只会为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` 在第一项被选中时为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select\n```\n',2,7,4,1),
(248,'修饰符(v-model)','.lazy：默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：\n```html\n<!-- 在 \"change\" 事件后同步更新而不是 \"input\" -->\n<input v-model.lazy=\"msg\" />\n```\n.number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n```html\n<input v-model.number=\"age\" />\n```\n.trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n```html\n<input v-model.trim=\"msg\" />\n```\n',2,7,4,1),
(249,'vue-tsc','```\n//安装\nnpm i vue-tsc -D\n//用法\nvue-tsc --noEmit && vite build\n```\n\nvue3 命令行类型检查工具基于 IDE 插件 [Volar](https://github.com/johnsoncodehk/volar)。\n\n```\n//类型检查：\nvue-tsc --noEmit\n//构建 dts\nvue-tsc --declaration --emitDeclarationOnly\n```\n',2,1,4,1),
(250,'normalize','统一浏览器的初始样式\n\n```js\n//安装\nnpm install --save normalize.css\n\n//main中引入\nimport ''normalize.css/normalize.css''\n```\n\n',2,1,4,1),
(251,'unplugin-vue-components','自动引入组件\n```\nnpm unplugin-vue-components -D\n```\n```js\n// vite.config.js\nimport Components from ''unplugin-vue-components/vite''\nimport { AntDesignVueResolver } from ''unplugin-vue-components/resolvers''\n  Components({\n    dts: true, // ts支持\n    dirs: [''src/components'', ''src/views''], // 自定义路径按需导入\n    resolvers: [AntDesignVueResolver()] // antd直接使用组件,无需在任何地方导入组件\n  }),\n```\n\n',2,1,4,1),
(252,'${}模版字符串','```JS\nconsole.info(`大家好，我叫${name}，今年${age}岁了`)\n// 等价于\nconsole.info(''大家好，我叫'' + name + ''，今年'' + age + ''岁了'')\nreturn get(`${Api.FY}/${identity}/${type}/${pageindex}/${pagesize}`);\n```',2,3,4,1),
(253,'console.log','console.log({name})取代console.log(''name'', name)\n\n```js\nconsole.log({name})\n```\n\n',2,3,4,1),
(254,'globalProperties','globalProperties\n- 类型：[key: string]: any\n- 默认：undefined\n\n#### 全局使用\n```javascript\n//main.js\nimport { createApp } from ''vue''\nimport App from ''./App.vue''\nconst app = createApp(App)\n// 获取原型\nconst prototype = app.config.globalProperties\n// 绑定参数\nprototype.name = ''Jerry''\n```\n#### 组件内使用\n```js\n<script setup>\n  import { getCurrentInstance } from ''vue''\n  // 获取原型 获取上下文实例，ctx=vue2的this\n  const { proxy } = getCurrentInstance()\n  // 输出\n  console.log(proxy.name)\n</script>\n```\n',2,3,4,1),
(255,'vue3对await的支持','不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup 。\n\n```js\n//vue3\n<script setup>\n  const post = await fetch(''/api'').then(() => {})\n</script>\n```\n\n',2,2,4,1),
(256,'CSS变量注入','```html\n<template>\n  <span>Jerry</span>  \n</template>\n\n<script setup>\n  import { reactive } from ''vue''\n  const state = reactive({\n    color: ''red''\n  })\n</script>\n\n<style scoped>\n  span {\n    // 使用v-bind绑定state中的变量\n    color: v-bind(''state.color'');\n  }  \n</style>\n```',2,3,4,1),
(257,'定义倒计时','```ts\nsetTimeout(async () => {\n   await ConutSort();//方法\n  }, 2000);//间隔2秒\n });\n```\n\n',2,3,4,1),
(258,'is动态组件切换','```html\n  <div>\n    <a href=\"#\" @click.prevent=\"comName = ''login''\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName = ''register''\">注册</a>\n    <a href=\"#\" @click.prevent=\"comName = ''logOut''\">退出</a>\n     <!--  <component></component>来展示对应名称的组件,相当于一个占位符 // :is 属性指定 组件名称 -->\n    <component :is=\"comName\"></component>\n  </div>\n```\n\n',2,3,4,1),
(259,'清除缓存组件','```js\n// beforeRouteLeave()钩子\n// 判断是否要到详情页\n  beforeRouteLeave(to, from, next) {\n      if (to.path === \"/goods_detail\") {\n        from.meta.keepAlive = true;\n      } else {\n        from.meta.keepAlive = false;\n      }\n      next();\n    }\n```\n\n',2,3,4,1),
(260,'传值编码/解码','```js\n//编码\nlet paths = encodeURIComponent(path)\n//解码\nlet paths = decodeURIComponent(path)\n```\n\n',2,3,4,1),
(261,'回调顶部','```html\n <div id=\"backtop\">\n   <p @click=\"backtop\"></p>\n </div>\n```\n\n```js\n  static BackTop() {\n    // eslint-disable-next-line func-names\n    const timer = setInterval(function () {\n      const osTop = document.documentElement.scrollTop || document.body.scrollTop\n      const isPeed = Math.floor(-osTop / 5)\n      document.body.scrollTop = osTop + isPeed\n      document.documentElement.scrollTop = document.body.scrollTop\n      if (osTop === 0) {\n        clearInterval(timer)\n      }\n    }, 30)\n  }\n```',2,3,4,1),
(262,'日期格式化(moment)','`moment` 是一个 `JavaScript` 日期处理类库。\n\n```\nnpm install moment --save\n```\n\n```js\n /**\n   * 日期格式化\n   * @param time\n   */\n  static MomentTime(time: any) {\n    moment(time).format(''YYYY-MM-DD- H:mm:ss'')\n  }\n\n  /**\n   *  日期格式化\n   * @param time\n   */\n  static async MomentTimeList(time: any) {\n    await time.data.forEach((res: any) => {\n      res.timeCreate = moment(res.timeCreate).format(''YYYY-MM-DD- H:mm:ss'')\n    })\n  }\n```\n\n',2,3,4,1),
(263,'随机数(Random)','```js\n  /**\n   * 随机数\n   * @param minNum 最小值\n   * @param maxNum 最大值\n   * @param counts 循环次数\n   * @returns\n   */\n  static Random(minNum: number, maxNum: number, counts: number) {\n    let i = 0\n    let count\n    do {\n      i += 1\n      const res = `${Math.random() * (maxNum - minNum + 1) + minNum}`\n      count = parseInt(res, 10)\n    } while (i < counts)\n    return count\n  }\n```',2,3,4,1),
(264,'vue-router','vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。\n\n```\nnpm install vue-router@4\n```\n定义index.ts\n\nmain.ts引入\n\n```js\nimport router from ''./router/index''\nconst app = createApp(App)\napp.use(router)\n```\n',15,2,4,1),
(265,'路由导航流程','1. 导航被触发\n2. 在失活的组件里调用  beforeRouteLeave 守卫\n3. 调用全局 beforeEach 前置守卫\n4. 重用的组件调用 beforeRouteUpdate 守卫（2.2+）\n5. 路由配置调用 beforeEnter\n6. 解析异步路由组件\n7. 在被激活的组件里调用 beforeRouteEnter 守卫\n8. 调用全局的 beforeResolve 守卫（2.5+）\n9. 导航被确认\n10. 调用全局的 afterEach\n11. 触发 DOM 更新\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入',15,2,4,1),
(266,'Hash路由模式','hash 历史模式是用 `createWebHashHistory()` 创建的不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHashHistory } from ''vue-router''\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n',15,2,4,1),
(267,'history路由模式','history:用 `createWebHistory()` 创建 HTML5 模式，推荐使用这个模式不会有历史，不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHistory } from ''vue-router''\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n',15,2,4,1),
(268,'router-link to=\"xxx\"','表示目标路由的链接。 被点击后，会立刻把 to 的值传到 router.push()，这个值可以是字符串或者是描述目标位置的对象。\n\n```html\n<!-- 字符串 -->\n<router-link to=\"home\">Home</router-link>\n\n<!-- 使用 v-bind 的 JS 表达式 -->\n<router-link v-bind:to=\"''home''\">Home</router-link>\n\n<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->\n<router-link :to=\"''home''\">Home</router-link>\n\n<!-- 同上 -->\n<router-link :to=\"{ path: ''home'' }\">Home</router-link>\n\n<!-- 命名的路由 -->\n<router-link :to=\"{ name: ''user'', params: { userId: 123 }}\">User</router-link>\n\n<!-- 带查询参数，下面的结果为 /register?plan=private -->\n<router-link :to=\"{ path: ''register'', query: { plan: ''private'' }}\">Register</router-link>\n```\n',15,2,4,1),
(269,'replace','设置 replace 属性,点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录。\n\n```html\n//声明式\n<router-link :to=\"{ path: ''/abc''}\" replace></router-link>\n\n//编程式\nrouter.replace(...)\n```\n',15,2,4,1),
(270,'append','设置 append 属性后，则在当前 (相对) 路径前添加其路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b\n\n```html\n<router-link :to=\"{ path: ''relative/path''}\" append></router-link>\n```\n\n',15,2,4,1),
(271,'tag','有时候想要 `<router-link>` 渲染成某种标签，例如 `<li>`。 于是我们使用 `tag` prop 类指定何种标签，同样它还是会监听点击，触发导航。\n\n```html\n<router-link to=\"/foo\" tag=\"li\">foo</router-link>\n<!-- 渲染结果 -->\n<li>foo</li>\n```\n\n',15,2,4,1),
(272,'active-class','设置 链接激活时使用的 CSS 类名。可以通过以下代码来替代。\n\n```html\n<style>\n   ._active{\n      background-color : red;\n   }\n</style>\n<p>\n   <router-link v-bind:to = \"{ path: ''/route1''}\" active-class = \"_active\">1</router-link>\n   <router-link v-bind:to = \"{ path: ''/route2''}\" tag = \"span\">2</router-link>\n</p>\n```\n\n',15,2,4,1),
(273,'exact-active-class','配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代。\n\n```html\n<p>\n   <router-link v-bind:to = \"{ path: ''/route1''}\" exact-active-class = \"_active\">Router Link 1</router-link>\n   <router-link v-bind:to = \"{ path: ''/route2''}\" tag = \"span\">Router Link 2</router-link>\n</p>\n```\n',15,2,4,1),
(274,'event','声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。\n\n```html\n<router-link v-bind:to = \"{ path: ''/route1''}\" event = \"mouseover\">Router Link 1</router-link>\n```\n\n以上代码设置了 event 为 mouseover ，及在鼠标移动到 Router Link 1 上时导航的 HTML 内容会发生改变。',15,2,4,1),
(275,'router-view','`router-view` 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。',15,2,4,1),
(276,'useRoute/useRouter','```html\n<script setup>\n  import { useRoute, useRouter } from ''vue-router''\n  const route = useRoute()  // 路由信息\n  console.log(route.query)\n  const router = useRouter()// 路由跳转\n  router.push(''/newPage'')\n</script>\n```\n\n',15,2,4,1),
(277,'路由导航守卫','```html\n<script setup>\n  import { onBeforeRouteLeave, onBeforeRouteUpdate } from ''vue-router''\n\n  // 添加一个导航守卫，在当前组件将要离开时触发。\n  onBeforeRouteLeave((to, from, next) => {\n    next()\n  })\n\n  // 添加一个导航守卫，在当前组件更新时触发。\n  // 在当前路由改变，但是该组件被复用时调用。\n  onBeforeRouteUpdate((to, from, next) => {\n    next()\n  })\n</script>\n```\n\n',15,2,4,1),
(278,'全局前置守卫','在路由跳转前触发，可在执行 next 方法前做一些身份登录验证的逻辑。\n\n```js\nconst router = new createRouter({})\n//to: 即将要进入的目标 用一种标准化的方式\n//from: 当前导航正要离开的路由 用一种标准化的方式\nrouter.beforeEach((to, from, next) => {\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n  // 返回 false 以取消导航\n  return false\n})\n```\n\n',15,2,4,1),
(279,'全局解析守卫','与 beforeEach 类似，也是路由跳转前触发，区别是还需在`所有组件内守卫和异步路由组件被解析之后`，也就是在组件内 beforeRouteEnter 之后被调用。\n\n```js\nrouter.beforeResolve((to, from, next) => {\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n})\n```\n',15,2,4,1),
(280,'全局后置钩子','和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身。它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n\n```js\nrouter.afterEach((to, from) => {\n  // ...\n})\n```\n\n',15,2,4,1),
(281,'路由独享守卫','可在路由配置上直接定义 beforeEnter\n\n```js\nconst routes = [\n  {\n    path: ''/users/:id'',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n```\n\n',15,2,4,1),
(282,'组件内的守卫','组件内可直接定义如下路由导航守卫\n\n```js\nconst Foo = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 不能获取组件实例 this\n    // 当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate(to, from) {\n    // 当前路由改变，但是组件被复用时调用\n    // 可访问实例 this\n  },\n  beforeRouteLeave(to, from) {\n    // 导航离开组件时被调用\n  }\n}\n```\n\n',15,2,4,1),
(283,'router封装','## router封装index\n\n```js\n//index.js\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { createRouter, createWebHistory, RouteRecordRaw, _RouteRecordBase } from ''vue-router''\nimport NProgress from ''nprogress''\n\ndeclare module ''vue-router'' {\n  interface _RouteRecordBase {\n    hidden?: boolean | string | number\n  }\n}\nconst routes: RouteRecordRaw[] = [\n   {\n    path: ''/index'',\n    name: ''index'',\n    component: () => {\n      return import(''../views/page/article/Index.vue'')\n    },\n    meta: {\n      keepAlive: true\n    },\n    children: [\n      // 添加子路由\n      {\n        path: ''indexColumn'',\n        name: ''indexColumn'',\n        component: () => {\n          return import(''../views/page/article/components/indexColumn.vue'')\n        }\n      }\n    ]\n  },\n  { path: ''/'', redirect: { name: ''Home'' } },\n]\n\nconst router = createRouter({\n  history: createWebHistory(), //历史模式会制造页面刷新\n  routes\n})\n// 页面切换之前取消上一个路由中未完成的请求\nrouter.beforeEach((_to: any, _from: any, next: () => void) => {\n  NProgress.start()\n  next()\n})\nrouter.afterEach(() => {\n  // 进度条\n  NProgress.done()\n})\nexport default router\n```\n\n',15,3,4,1),
(284,'基础跳转','```js\nimport { useRoute, useRouter } from ''vue-router''\nconst route = useRoute() // 参数的获取  this.$route\nconst router = useRouter() // 方法使用  this.$router\nrouter.push({\n  path: num,\n  query: {\n    t: +new Date()\n  }\n})\n```\n\n',15,2,4,1),
(285,'无参跳转','```js\n// 字符串\nrouter.push(''home'')\n// 对象\nrouter.push({ path: ''home'' })\n```\n\n',15,3,4,1),
(286,'带参跳转','```js\n/**\n * 传值跳转\n * @param path 路径\n * @param value 值\n */\nconst routerId = async (path: string, value: number | string) => {\n  await router.push({\n    path: path,\n    query: {\n      id: value,\n      t: +new Date()\n    }\n  })\n}\n```\n获取跳转过来的参数\n\n```tsx\nimport { useRoute } from ''vue-router''\n const route = useRoute()\n const state = reactive({\n      id: route.query.id,\n })\n```\n',15,3,4,1),
(287,'刷新当前路由','```js\n//+new Date()保证每次点击路由的query项都是不一样的，确保会重新刷新view\nconst routers = async (path: string) => {\n  await router.push({\n    path: path,\n    query: {\n      t: +new Date()\n    }\n  })\n}\n```\n\n',15,3,4,1),
(289,'router.go(n)','这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。\n\n```js\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n// 前进 3 步记录\nrouter.go(3)\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n',15,2,4,1),
(290,'子路由','```html\n<a-menu-item key=\"1\" @click=\"Routers(''/Admin-index/ArticleTable'')\">\n文章列表</a-menu-item>\n<router-view></router-view>\n```\n\n路由配置\n\n```tsx\n{\n  path: ''/Admin-index'',\n  name: ''Admin-index'',\n  component: () => import(''@/views/admin/index/index.vue''),\n  children: [   // 添加子路由\n    {\n      path: ''ArticleTable'',\n      name: ''ArticleTable'',\n      component: () => import(''@/views/admin/article/ArticleTable.vue''),\n    },\n  ]\n},\n```\n\n',15,3,4,1),
(291,'配置404页面','\\* 代表通配符，若放在任意路由前，会被先匹配，导致跳转到 404 页面，所以需将如下配置置于最后。\n\n```js\n{\n  path: ''*'',\n  name: ''404''\n  component: () => import(''./404.vue'')  \n}\n```\n\n',15,3,4,1),
(292,'路由对象/属性类型报错','引入 _RouteRecordBase 定义 hidden\n\n```js\nimport {\n    createRouter,\n    createWebHashHistory,\n    RouteRecordRaw,\n    _RouteRecordBase \n} from ''vue-router''\n\ndeclare module ''vue-router''{\n    interface _RouteRecordBase {\n        hidden?: boolean | string | number\n    }\n}\n\nconst routes: Array<RouteRecordRaw> = [\n {\n        path: ''/'',\n        redirect: ''/login'',\n    },\n    {\n        path: ''/login'',\n        name:''login'',\n       	hidden: false,\n        component: () => import(''@/views/login.vue''), // 懒加载组件\n    }\n]\n\n```\n',15,4,4,1),
(293,'常用的命名规范','- `camelCase`（小驼峰式命名法 —— 首字母小写）\n- `PascalCase`（大驼峰式命名法 —— 首字母大写）\n- `kebab-case`（短横线连接式）\n- `Snake`（下划线连接式）\n\n#### 项目名 \n\n全部采用小写方式， 以**短横线**分隔。 例：`my-project-name`。',2,6,4,1),
(294,'CSS文件名','全部采用小写方式， 优先选择单个单词命名，多个单词命名以**短横线**分隔。\n\n```lua\n|- normalize.less\n|- base.less\n|- date-picker.scss\n|- input-number.scss\n```\n\n',2,8,4,1),
(295,'单例组件名','只拥有单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。\n\n这不意味着组件只可用于一个单页面，而是*每个页面*只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，*只是目前*在每个页面里只使用一次。\n\n比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n\n',2,8,4,1),
(296,'基础组件名','> 基础组件：不包含业务，独立、具体功能的基础组件，比如**日期选择器**、**模态框**等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。\n\n特定样式和约定的基础组件(展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。**基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。**\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n',2,6,4,1),
(297,'业务组件','> 业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。\n\n**掺杂了复杂业务的组件（拥有自身 `data`、`prop` 的相关处理）即业务组件**应该以 `Custom` 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。\n\n```\ncomponents/\n|- CustomCard.vue\n```\n\n\n\n\n\n',2,6,4,1),
(298,'紧密耦合的组件名','**和父组件紧密耦合的子组件应该以父组件名作为前缀命名。**  因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n\n',2,6,4,1),
(299,'变量命名','- 命名方法：camelCase\n- 命名规范：类型 + 对象描述或属性的方式\n\n``` js\nlet tableTitle = \"LoginTable\"\nlet mySchool = \"我的学校\"\n```\n\n',2,6,4,1),
(300,'常量命名','- 命名方法：全部大写下划线分割\n- 命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词\n\n```javascript\nconst MAX_COUNT = 10\nconst URL = ''http://test.host.com''\n```\n\n',2,6,4,1),
(301,'方法命名','- 命名方法：camelCase\n- 命名规范：统一使用动词或者动词 + 名词形式\n\n```js\n// 1、普通情况下，使用动词 + 名词形式\njumpPage、openCarInfoDialog\n// 2、请求数据方法，以 data 结尾\ngetListData、postFormData\n// 3、单个动词的情况\ninit、refresh\n```\n\n| 动词 | 含义                         | 返回值                                                  |\n| ---- | ---------------------------- | ------------------------------------------------------- |\n| can  | 判断是否可执行某个动作 (权 ) | 函数返回一个布尔值。true：可执行；false：不可执行；     |\n| has  | 判断是否含有某个值           | 函数返回一个布尔值。true：含有此值；false：不含有此值； |\n| is   | 判断是否为某个值             | 函数返回一个布尔值。true：为某个值；false：不为某个值； |\n| get  | 获取某个值                   | 函数返回一个非布尔值                                    |\n| set  | 设置某个值                   | 无返回值、返回是否设置成功或者返回链式对象              |\n\n\n\n',2,6,4,1),
(302,'指令缩写(:@#)','- **用 `:` 表示 `v-bind:`**\n- **用 `@` 表示 `v-on:`**\n- **用 `#` 表示 `v-slot:`**',2,7,4,1),
(303,'img默认设置','#### 让图片元素隐藏\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.style.display=''none''\"/>\n1\n```\n\n#### 设置默认图\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.src=''默认图片的url地址''\"/>\n1\n```\n\n第二种方式为常用的方法，但当onerror中设置的图片路径也不存在时就会导致浏览器一直加载这个图，造成堆栈溢出错误。\n所以，通常在后面加上 **this.οnerrοr=null;** 保证onerror里的事件只执行一次。所以完整的写法为：\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.src=''默认图片的url地址'';this.οnerrοr=null\"/>\n```\n\n',2,3,4,1),
(306,'scss介绍','- [Sass 官方文档](https://sass-lang.com/documentation) *(sass-lang.com)*\n- [Sass 中文文档](https://www.sass.hk/docs/) *(sass.hk)*\n\nSass 是一种 CSS 的预编译语言\n\n```bash\n$ npm install -g sass\n```\n\n在 Node.js 环境中使用 Sass\n\n```bash\n$ sass source/index.scss build/index.css\n$ sass --watch input.scss output.css\n$ sass --watch app/sass:public/css\n```\n\n\n\n',10,2,4,1),
(307,'注释','```\n/*\n 多行注释\n 块注释\n 块注释\n*/\n\n// 单行注释\n```\n\n',10,2,4,1),
(308,'字符串插值','``` css\n$wk: -webkit-;\n.rounded-box {\n  #{$wk}border-radius: 4px;\n}\n```\n\n\n',10,2,4,1),
(309,'模块(片段)','```css\n// _base.scss\n$font-stack:    Helvetica, sans-serif;\n$primary-color: #333;\n注意以下划线开头的 Sass 文件\n\n// styles.scss\n@use ''base'';\n\n.inverse {\n  background-color: base.$primary-color;\n  color: white;\n}\n```\n\n',10,2,4,1),
(310,'@import','```css\n@import ''./other_sass_file'';\n@import ''/code'', ''lists'';\n// 纯 CSS @imports\n@import \"theme.css\";\n@import url(theme);\n```\n\n`.sass` 或 `.sass` 扩展名是可选的。',10,2,4,1),
(311,'混合(Mixins默认值)','```css\n@mixin pad($n: 10px) {\n    padding: $n;\n}\nbody {\n    @include pad(15px);\n}\n```\n',10,3,4,1),
(313,'混合(Mixins默认变量)',' ```css\n$default-padding: 10px;\n@mixin pad($n: $default-padding) {\n  padding: $n;\n}\nbody {\n  @include pad(15px);\n}\n```',10,3,4,1),
(314,'@media','```css\n/* 超小设备 (手机, 600px 以下屏幕设备) */\n@media only screen and (max-width: 600px) {   \n}\n/* 小设备 (平板电脑和大型手机，600 像素及以上) */\n@media only screen and (min-width: 600px) { \n}\n/* 中型设备（平板电脑，768 像素及以上） */\n@media only screen and (min-width: 768px) {\n} \n/* 大型设备（笔记本电脑/台式机，992 像素及以上） */\n@media only screen and (min-width: 992px) {\n} \n/* 超大型设备（大型笔记本电脑和台式机，1200 像素及以上） */\n@media only screen and (min-width: 1200px) {\n}\n```\n',10,3,4,1),
(315,'循环(each嵌套)','\n```scss\n$icons: (\"eye\": \"\\f112\", \"start\": \"\\f12e\");\n\n@each $name, $glyph in $icons {\n  .icon-#{$name}:before {\n    display: inline-block;\n    font-family: \"Icon Font\";\n    content: $glyph;\n  }\n}\n```\n\n',10,3,4,1),
(316,'条件(if)','```css\n@mixin avatar($size, $circle: false) {\n  width: $size;\n  height: $size;\n  @if $circle {\n    border-radius: $size / 2;\n  }\n}\n.square-av {\n  @include avatar(100px, $circle: false);\n}\n.circle-av {\n  @include avatar(100px, $circle: true);\n}\n```',10,3,4,1),
(317,'Map','\n```css\n$map: (key1: value1, key2: value2, key3: value3);\nmap-get($map, key1)\n```\n\n',10,3,4,1),
(318,'基础指令','指令是带有 v- 前缀的特殊属性。\n\n指令用于在表达式的值改变时，将某些行为应用到 DOM 上。',2,2,4,1),
(319,'v-else-if','```html\n<div v-if=\"type === ''A''\">\n  A\n</div>\n<div v-else-if=\"type === ''B''\">\n  B\n</div>\n<div v-else-if=\"type === ''C''\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n',2,7,4,1),
(320,'基础类型','JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n\n- 常用：boolean、number、string、array、enum、any、void\n- 不常用：tuple、null、undefined、never',5,2,4,1),
(321,'Boolean','布尔值是最基础的数据类型，在 TypeScript 中，使用 `boolean` 定义布尔值类型：\n\n\n```ts\nlet isDone: boolean = false;\n```\n\n',5,2,4,1),
(322,'Number','双精度 64 位浮点值。它可以用来表示整数和分数。\n\n\n```ts\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\n',5,2,4,1),
(323,'任意类型(Any)','声明为 any 的变量可以赋予任意类型的值。\n\n```tsx\nlet myFavoriteNumber: any = ''seven'';\nmyFavoriteNumber = 7;\n```\n\n\n\n',5,2,4,1),
(324,'元组[]','数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\n定义一对值分别为 `string` 和 `number` 的元组：\n\n```tsx\nlet x: [string, number];\nx = [''Runoob'', 1];    // 运行正常\nx = [1, ''Runoob''];    // 报错\nconsole.log(x[0]);    // 输出 Runoob\n```\n',5,2,4,1),
(325,'访问元组[]','元组中元素使用索引来访问，第一个元素的索引值为 0，第二个为 1，以此类推第 n 个为 n-1，语法格式如下:\n\n```\ntuple_name[index]\n```\n\n以下实例定义了元组，包含了数字和字符串两种类型的元素：\n\n```tsx\nvar mytuple = [10,\"Runoob\"]; // 创建元组\nconsole.log(mytuple[0]) \nconsole.log(mytuple[1])\n```\n',5,2,4,1),
(326,'元组运算[]','我们可以使用以下两个函数向元组添加新元素或者删除元素：\n\n- push() 向元组添加元素，添加在最后面。\n- pop() 从元组中移除元素（最后一个），并返回移除的元素。\n\n```tsx\nvar mytuple = [10,\"Hello\",\"World\",\"typeScript\"]; \nconsole.log(\"添加前元素个数：\"+mytuple.length)    // 返回元组的大小\n \nmytuple.push(12)                                    // 添加到元组中\nconsole.log(\"添加后元素个数：\"+mytuple.length) \nconsole.log(\"删除前元素个数：\"+mytuple.length) \nconsole.log(mytuple.pop()+\" 元素从元组中删除\") // 删除并返回删除的元素\n        \nconsole.log(\"删除后元素个数：\"+mytuple.length)\n```\n\n',5,2,4,1),
(327,'更新元组[]','元组是可变的，这意味着我们可以对元组进行更新操作：\n\n```js\nvar mytuple = [10, \"Runoob\", \"Taobao\", \"Google\"]; // 创建一个元组\nconsole.log(\"元组的第一个元素为：\" + mytuple[0]) \n \n// 更新元组元素\nmytuple[0] = 121     \nconsole.log(\"元组中的第一个元素更新为：\"+ mytuple[0])\n```\n\n',5,2,4,1),
(328,'解构元组[]','我们也可以把元组元素赋值给变量，如下所示：\n\n``` js\nvar a =[10,\"Runoob\"] \nvar [b,c] = a \nconsole.log( b )    \nconsole.log( c )\n```\n\n',5,2,4,1),
(329,'数组(Array)','Array数组对象是使用单独的变量名来存储一系列的值。\n#### 数组定义\n\n简单的方法使用「类型 + 方括号」来表示数组：\n\n```js\ninterface IItem {\n  id: number;\n  name: string;\n  isGod: boolean;\n}\nconst objectArr: IItem[] = [{ id: 1, name: ''俊劫'', isGod: true }];\n// or\nconst objectArr: Array<IItem> = [{ id: 1, name: ''俊劫'', isGod: true }];\nconst numberArr: number[] = [1, 2, 3];\nconst arr: (number | string)[] = [1, \"string\", 2];\n```\n',5,2,4,1),
(330,'忽略不要的元素(Array)','如果需要从数组或元组中取出某个或某几个特定的元素的话，可以在解构语句中插入额外的逗号，忽略掉不需要的元素：\n\n```tsx\nconst [a, , b] = [1, 5, 10];  // a <- 1, b <- 10\n```\n\n',5,2,4,1),
(331,'数组泛型(Array)','我们也可以使用数组泛型（Array Generic） `Array<elemType>` 来表示数组：\n\n```ts\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\nlet arr2:Array<string> = [\"1\",\"2\"]\n```\n',5,2,4,1),
(332,'联合类型数组(Array)','```js\nlet arr:(number | string)[];\n// 表示定义了一个名称叫做arr的数组, \n// 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据\narr3 = [1, ''b'', 2, ''c''];\n\nconst arr: (number | string)[] = [1, \"string\", 2];\n```',5,2,4,1),
(333,'交叉&类型(Array)','- 交叉类型：由多个类型组成，用 `&` 连接\n\n```tsx\ninterface Waiter {\n  anjiao: boolean;\n  say: () => {};\n}\n\ninterface Teacher {\n  anjiao: boolean;\n  skill: () => {};\n}\n\n// 交叉类型 \n// 同名类型会进行合并，同名基础类型属性的合并返回：never\n// 同名非基础类型属性可以正常合并\nfunction judgeWho(jishi: Waiter & Teacher) {}\n```',5,2,4,1),
(334,'指定对象成员的数组(Array)','```js\n// interface是接口,后面会讲到\ninterface Arrobj{\n    name:string,\n    age:number\n}\nlet arr3:Arrobj[]=[{name:''jimmy'',age:22}]\n```\n\n',5,2,4,1),
(335,'数组解构(Array)','```js\nlet x: number, let y: number ,let z: number;\nlet five_array = [0,1,2,3,4];\n[x,y,z] = five_array;\n```\n',5,2,4,1),
(336,'数组展开运算符(Array)','```javascript\nlet two_array = [0,1];\nlet five_array = [...two_array,2,3,4];\n```\n\n',5,2,4,1),
(337,'数组循环(Array)','```javascript\nlet colors: string[] = [\"red\", \"green\", \"blue\"];\nfor(let i in colors) {\n  console.log(i);\n}\n```\n',5,2,4,1),
(338,'多维数组(Array)','一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。\n\n最简单的多维数组是二维数组，定义方式如下：\n\n``` js\nvar arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]\n```\n\n',5,2,4,1),
(339,'数组.concat()','连接两个或更多的数组，并返回结果。\n\n```tsx\nvar alpha = [\"a\", \"b\", \"c\"]; \nvar numeric = [1, 2, 3];\n\nvar alphaNumeric = alpha.concat(numeric); \nconsole.log(\"alphaNumeric : \" + alphaNumeric );    // a,b,c,1,2,3   \n```',5,2,4,1),
(340,'数组.every()','检测数值元素的每个元素是否都符合条件。\n\n```tsx\nfunction isBigEnough(element, index, array) { \n        return (element >= 10); \n}        \nvar passed = [12, 5, 8, 130, 44].every(isBigEnough); \nconsole.log(\"Test Value : \" + passed ); // false\n```\n',5,2,4,1),
(341,'数组.filter()',' 检测数值元素，并返回符合条件所有元素的数组。\n\n```tsx\nfunction isBigEnough(element, index, array) { \n   return (element >= 10); \n}         \nvar passed = [12, 5, 8, 130, 44].filter(isBigEnough); \nconsole.log(\"Test Value : \" + passed ); // 12,130,44\n```\n',5,2,4,1),
(342,'数组.forEach()','数组每个元素都执行一次回调函数。\n\n```tsx\nlet num = [7, 8, 9]; num.forEach(function (value) {\n    console.log(value); });\n`编译成 JavaScript 代码：`\nvar num = [7, 8, 9]; num.forEach(function (value) {  \n    console.log(value);  \n    // 7   8   9 });\n```\n\n',5,2,4,1),
(343,'数组.indexOf()','搜索数组中的元素，并返回它所在的位置。如果搜索不到，返回值 -1，代表没有此项。\n\n```tsx\nvar index = [12, 5, 8, 130, 44].indexOf(8);\nconsole.log(\"index is : \" + index );  // 2\n```\n',5,2,4,1),
(344,'数组.join()','把数组的所有元素放入一个字符串。         \n\n```tsx\nvar arr = new Array(\"Google\",\"Runoob\",\"Taobao\"); \n          \nvar str = arr.join(); \nconsole.log(\"str : \" + str );  // Google,Runoob,Taobao\n          \nvar str = arr.join(\", \"); \nconsole.log(\"str : \" + str );  // Google, Runoob, Taobao\n          \nvar str = arr.join(\" + \"); \nconsole.log(\"str : \" + str );  // Google + Runoob + Taobao\n```',5,2,4,1),
(345,'数组.lastIndexOf()','返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。\n\n```tsx\nvar index = [12, 5, 8, 130, 44].lastIndexOf(8); \nconsole.log(\"index is : \" + index );  // 2\n```\n\n',5,2,4,1),
(346,'数组.map()','通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n```tsx\nvar numbers = [1, 4, 9]; \nvar roots = numbers.map(Math.sqrt); \nconsole.log(\"roots is : \" + roots );  // 1,2,3\n```\n\n',5,2,4,1),
(347,'数组.pop()','删除数组的最后一个元素并返回删除的元素。              \n\n```tsx\nvar numbers = [1, 4, 9]; \n          \nvar element = numbers.pop(); \nconsole.log(\"element is : \" + element );  // 9\n          \nvar element = numbers.pop(); \nconsole.log(\"element is : \" + element );  // 4\n```\n\n',5,2,4,1),
(348,'数组.push()','向数组的末尾添加一个或更多元素，并返回新的长度。      \n\n```tsx\nvar numbers = new Array(1, 4, 9); \nvar length = numbers.push(10); \nconsole.log(\"new numbers is : \" + numbers );  // 1,4,9,10 \nlength = numbers.push(20); \nconsole.log(\"new numbers is : \" + numbers );  // 1,4,9,10,20\n```\n\n',5,2,4,1),
(349,'数组.reduce()','将数组元素计算为一个值（从左到右）。              \n\n```tsx\nvar total = [0, 1, 2, 3].reduce(function(a, b){ return a + b; }); \nconsole.log(\"total is : \" + total );  // 6\n```\n\n',5,2,4,1),
(350,'数组.reduceRight()','将数组元素计算为一个值（从右到左）。        \n\n``` tsx\nvar total = [0, 1, 2, 3].reduceRight(function(a, b){ return a + b; }); \nconsole.log(\"total is : \" + total );  // 6\n```\n\n',5,2,4,1),
(351,'数组.reverse()','反转数组的元素顺序。                             \n\n```tsx\nvar arr = [0, 1, 2, 3].reverse(); \nconsole.log(\"Reversed array is : \" + arr );  // 3,2,1,0\n```\n\n',5,2,4,1),
(352,'数组.shift()','删除并返回数组的第一个元素。                          \n\n```tsx\nvar arr = [10, 1, 2, 3].shift(); \nconsole.log(\"Shifted value is : \" + arr );  // 10\n```',5,2,4,1),
(353,'数组.slice()','选取数组的的一部分，并返回一个新数组。             \n\n```tsx\nvar arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; \nconsole.log(\"arr.slice( 1, 2) : \" + arr.slice( 1, 2) );  // mango\nconsole.log(\"arr.slice( 1, 3) : \" + arr.slice( 1, 3) );  // mango,banana\n```\n',5,2,4,1),
(354,'数组.some()','检测数组元素中是否有元素符合指定条件。             \n\n```tsx\nfunction isBigEnough(element, index, array) { \n   return (element >= 10);     \n} \nvar retval = [2, 5, 8, 1, 4].some(isBigEnough);\nconsole.log(\"Returned value is : \" + retval );  // false\n          \nvar retval = [12, 5, 8, 1, 4].some(isBigEnough); \nconsole.log(\"Returned value is : \" + retval );  // true\n```\n\n',5,2,4,1),
(355,'数组.sort()','对数组的元素进行排序。                                \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); \nvar sorted = arr.sort(); \nconsole.log(\"Returned string is : \" + sorted );  // banana,mango,orange,sugar\n```',5,2,4,1),
(356,'数组.splice()','从数组中添加或删除元素。                           \n\n```tsx\nvar arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"];  \nvar removed = arr.splice(2, 0, \"water\");  \nconsole.log(\"After adding 1: \" + arr );    // orange,mango,water,banana,sugar,tea \nconsole.log(\"removed is: \" + removed); \n          \nremoved = arr.splice(3, 1);  \nconsole.log(\"After removing 1: \" + arr );  // orange,mango,water,sugar,tea \nconsole.log(\"removed is: \" + removed);  // banana\n```\n',5,2,4,1),
(357,'数组.toString()','把数组转换为字符串，并返回结果。                \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\");         \nvar str = arr.toString(); \nconsole.log(\"Returned string is : \" + str );  // orange,mango,banana,sugar\n```\n',5,2,4,1),
(358,'数组.unshift()','向数组的开头添加一个或更多元素，并返回新的长度。   \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); \nvar length = arr.unshift(\"water\"); \nconsole.log(\"Returned array is : \" + arr );  // water,orange,mango,banana,sugar \nconsole.log(\"Length of the array is : \" + length ); // 5\n```\n',5,2,4,1),
(359,'空值(Void)','JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 `void` 表示没有任何返回值的函数：\n\n```ts\nfunction alertName(): void {\n    alert(''My name is Tom'');\n}\n```\n\n声明一个 `void` 类型的变量没有什么用，因为你只能将它赋值为 `undefined` 和 `null`（只在 --strictNullChecks 未指定时）：\n\n```ts\nlet unusable: void = undefined;\n```\n\n',5,2,4,1),
(360,'Null和Undefined','可以使用 `null` 和 `undefined` 来定义这两个原始数据类型：\n\n```ts\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n与 `void` 的区别是，`undefined` 和 `null` 是所有类型的子类型。也就是说 `undefined` 类型的变量，可以赋值给 `number` 类型的变量：\n\n```ts\n// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n而 `void` 类型的变量不能赋值给 `number` 类型的变量：\n\n```ts\nlet u: void;\nlet num: number = u;\n// Type ''void'' is not assignable to type ''number''.\n```',5,2,4,1),
(361,'枚举(Enum)','提高代码可维护性，统一维护某些枚举值，避免 `JiShi === 1`这种魔法数字。`JiShi === JiShiEnum.BLUEJ`这样写，老板一眼就知道我想找谁。\n\n```javascript\n// 初始值默认为 0\nenum JiShiEnum {\n     REDJ,\n     BLUEJ,\n}\n// 设置初始值\nenum JiShiEnum {\n     REDJ = 8,\n     BLUEJ,\n}\nconst jishi: JiShiEnum = JiShiENUM.BLUE\nconsole.log(jishi) // 9\n// 字符串枚举，每个都需要声明\nenum JiShiEnum {\n     REDJ = \"8号\",\n     BLUEJ = \"9号\",\n}\n\n```\n\n默认情况下，初始值为 0，其余的成员会从 1 开始自动增长。',5,2,4,1),
(362,'常数枚举(Enum)','常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n\n常数枚举是使用 `const enum` 定义的枚举类型：\n\n```ts\nconst enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n假如包含了计算成员，则会在编译阶段报错：\n\n```ts\nconst enum Color {Red, Green, Blue = \"blue\".length};\n// index.ts(1,38): error TS2474: In ''const'' enum declarations member initializer must be constant expression.\n```\n',5,2,4,1),
(363,'外部枚举(Enum)','`declare` 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n外部枚举（Ambient Enums）是使用 `declare enum` 定义的枚举类型：\n\n```ts\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n上例的编译结果是：\n\n```js\nvar directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n外部枚举与声明语句一样，常出现在声明文件中。\n\n同时使用 `declare` 和 `const` 也是可以的：\n\n```ts\ndeclare const enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n编译结果：\n```js\nvar directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n',5,2,4,1),
(364,'Never','`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n\n```javascript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n',5,2,4,1),
(365,'类型断言','通过这种方式可以告诉编译器，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\n\n类型断言有两种形式：\n\n- “尖括号”语法\n\n```javascript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- as 语法\n\n```javascript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n```\n\n\n\n',5,2,4,1),
(366,'交叉类型(&)','交叉类型是将多个类型合并为一个类型, 表示\"并且\"的关系,用&连接多个类型, 常用于对象合并:\n\n其返回类型既要符合 `T` 类型也要符合 `U` 类型\n\n```tsx\n//1\ninterface A {a:number};\ninterface B {b:string};\n\nconst a:A = {a:1};\nconst b:B = {b:''1''};\nconst ab:A&B = {...a,...b};\n\n//2\ninterface Ant {\n    name: string;\n    weight: number;\n}\n\ninterface Fly {\n    flyHeight: number;\n    speed: number;\n}\n\n// 少了任何一个属性都会报错\nconst flyAnt: Ant & Fly = {\n    name: ''蚂蚁呀嘿'',\n    weight: 0.2,\n    flyHeight: 20,\n    speed: 1,\n};\n```\n',5,2,4,1),
(367,'联合类型(|)','- 联合类型：某个变量可能是多个 interface 中的其中一个，用 `|` 分割\n\n  其返回类型为连接的多个类型中的任意一个\n\n```ts\nlet name: string | number;\nconsole.log(name.toString());\nname = 1;\nconsole.log(name.toFixed(2));\nname = \"hello\";\nconsole.log(name.length);\n```\n',5,2,4,1),
(368,'类型别名','类型别名用来给一个类型起个新名字。\n\n```tsx\ntype Message = string | string[];\n\nlet greet = (message: Message) => {\n  // ...\n};\n}\n```\n上例中，我们使用 `type` 创建类型别名。\n类型别名常用于联合类型',5,2,4,1),
(369,'Unknown类型','就像所有类型都可以赋值给 `any`，所有类型也都可以赋值给 `unknown`。这使得 `unknown` 成为 TypeScript 类型系统的另一种顶级类型（另一种是 `any`）。下面我们来看一下 `unknown` 类型的使用示例：\n\n```typescript\nlet value: unknown;\n\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\nvalue = Symbol(\"type\"); // OK\n```\n',5,2,4,1),
(370,'函数声明(Function)','两种常见的定义函数的方式\n+ 函数声明（Function Declaration）\n+ 和函数表达式（Function Expression）：\n\n```tsx\n// 函数声明（Function Declaration）\nfunction sum(x, y) {\n    return x + y;\n}\nasync function clickName(id: number) {\n ...\n}\n// 函数表达式（Function Expression）\nlet mySum = function (x, y) {\n    return x + y;\n};  \n```\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```tsx\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\n```\n',5,2,4,1),
(371,'箭头函数(Function)','### 箭头函数(Function)\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n```tsx\nmyBooks.forEach(() => console.log(''Done reading''));\n\nmyBooks.forEach(title => console.log(title));\n\nmyBooks.forEach((title, idx, arr) => \n  console.log(idx + ''-'' + title);\n);\n\nmyBooks.forEach((title, idx, arr) => {\n  console.log(idx + ''-'' + title);\n});\n```\n\n使用示例\n\n```javascript\n// 未使用箭头函数\nfunction Book() {\n  let self = this;\n  self.publishDate = 2016;\n  setInterval(function() {\n    console.log(self.publishDate);\n  }, 1000);\n}\n\n// 使用箭头函数\nfunction Book() {\n  this.publishDate = 2016;\n  setInterval(() => {\n    console.log(this.publishDate);\n  }, 1000);\n}\n```\n',5,2,4,1),
(372,'参数类型和返回类型(Function)','### 参数类型和返回类型(Function)\n\n```tsx\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n```\n\n',5,2,4,1),
(373,'函数类型(Function)','```tsx\nlet IdGenerator: (chars: string, nums: number) => string;\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\nIdGenerator = createUserId;\n```\n',5,2,4,1),
(374,'可选参数及默认参数(Function)','输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，用 `?` 表示可选的参数\n可选参数必须接在必需参数后面\n```tsx\n// 可选参数\nfunction createUserId(name: string, age?: number, \n  id: number): string {\n    return name + id;\n}\n\n// 默认参数\nfunction createUserId(name: string = ''Semlinker'', age?: number, \n  id: number): string {\n    return name + id;\n}\n```\n',5,2,4,1),
(375,'剩余参数(Function)','有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。\n\n使用 `...rest` 的方式获取函数中的剩余参数（rest 参数）\n\n```tsx\nfunction push(array, ...items) {\n  items.forEach(function(item) {\n    array.push(item);\n  });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n```\n\n',5,2,4,1),
(376,' 匿名函数(Function)','### 匿名函数(Function)\n\n匿名函数是一个没有函数名的函数。\n\n匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。\n\n我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。\n\n语法格式如下：\n\n```tsx\nvar res = function( [arguments] ) { ... }\n```\n\n#### 不带参数\n\n```tsx\nvar msg = function() {\nreturn \"hello world\"; \n} \nconsole.log(msg())\n```\n\n#### 带参数\n\n```tsx\nvar res = function(a:number,b:number) {\nreturn a*b;  \n}; \nconsole.log(res(12,2))\n```\n\n#### 匿名函数自调用\n\n匿名函数自调用在函数后使用 () 即可：\n\n```tsx\n(function () {   \nvar x = \"Hello!!\";      \nconsole.log(x)  \n})()\n```\n\n',5,2,4,1),
(377,'重载','重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n使用重载定义多个 `reverse` 的函数类型：\n\n```ts\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    ///\n}\n```\n\n我们重复定义了多次函数 `reverse`，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。',5,2,4,1),
(378,'类(Class)','在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n### 类的概念\n\n这里对类相关的概念做一个简单的介绍。\n\n- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法\n- 对象（Object）：类的实例，通过 `new` 生成\n- 面向对象（OOP）的三大特性：封装、继承、多态\n- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 `Cat` 和 `Dog` 都继承自 `Animal`，但是分别实现了自己的 `eat` 方法。此时针对某一个实例，我们无需了解它是 `Cat` 还是 `Dog`，就可以直接调用 `eat` 方法，程序会自动判断出来应该如何执行 `eat`\n- 存取器（getter & setter）：用以改变属性的读取和赋值行为\n- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 `public` 表示公有属性或方法\n- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口',5,2,4,1),
(379,'定义类(Class)','```tsx\nclass Greeter {\n   static cname: string = ''Greeter''; // 静态属性\n   greeting: string; // 成员属行\n\n    //构造函数 会在对象创建时调用\n   constructor(message: string) { // 构造函数 - 执行初始化操作\n     this.greeting = message; //通过 this 向新建的对象中添加属性\n   }\n    static getClassName() { // 静态方法\n      return ''Class name is Greeter'';\n    }\n    greet() { // 成员方法\n      return \"Hello, \" + this.greeting;\n    }\n}\n//定义实例属性   需要通过对象的实例去访问\nlet greeter = new Greeter(\"world\");\n```\n',5,2,4,1),
(380,'类的继承(Class)','使用 `extends` 关键字实现继承，子类中使用 `super` 关键字来调用父类的构造函数和方法。\n\n```tsx\nclass Cat extends Animal {\n  constructor(name) {\n     // 调用父类的 constructor(name)\n    super(name); \n    console.log(this.name);\n  }\n  sayHi() {\n    return ''Meow, '' + super.sayHi(); // 调用父类的 sayHi()\n  }\n}\n\nlet c = new Cat(''Tom''); // Tom\nconsole.log(c.sayHi()); // Meow, My name is Tom\n```\n',5,2,4,1),
(381,'方法重写(Class)','类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n其中 super 关键字是对父类的直接引用，该关键字可以引用父类的属性和方法。\n\n```tsx\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n```\n',5,2,4,1),
(382,'属性存取器(Class)','- 对于一些不希望被任意修改的属性，可以将其设置为 `private`，直接将其设置为 `private` 将导致无法再通过对象修改其中的属性\n\n使用 getter 和 setter 可以改变属性的赋值和读取行为：\n\n```js\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  get name() {\n    return ''Jack'';\n  }\n  set name(value) {\n    console.log(''setter: '' + value);\n  }\n}\n\nlet a = new Animal(''Kitty''); // setter: Kitty\na.name = ''Tom''; // setter: Tom\nconsole.log(a.name); // Jack\n```',5,2,4,1),
(383,'静态方法(Class)','使用 `static` 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：\n\n```tsx\nclass Animal {\n  static isAnimal(a) {\n    return a instanceof Animal;\n  }\n}\n\nlet a = new Animal(''Jack'');\nAnimal.isAnimal(a); // true\na.isAnimal(a); // TypeError: a.isAnimal is not a function\n```\n',5,2,4,1),
(384,'实例属性(Class)','ES6 中实例的属性只能通过构造函数中的 `this.xxx` 来定义，ES7 提案中可以直接在类里面定义：\n\n```js\nclass Animal {\n  name = ''Jack'';\n\n  constructor() {\n    // ...\n  }\n}\n\nlet a = new Animal();\nconsole.log(a.name); // Jack\n```\n',5,2,4,1),
(385,'静态属性(Class)','ES7 提案中，可以使用 `static` 定义一个静态属性：\n\n```tsx\nclass Animal {\n  static num = 42;\n\n  constructor() {\n    // ...\n  }\n}\n\nconsole.log(Animal.num); // 42\n```\n\n',5,2,4,1),
(386,'类和接口','类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。\n\n以下实例红 AgriLoan 类实现了 ILoan 接口：\n\n```tsx\ninterface ILoan { \n   interest:number \n} \nclass AgriLoan implements ILoan { \n   interest:number \n   rebate:number \n   constructor(interest:number,rebate:number) { \n      this.interest = interest \n      this.rebate = rebate \n   } \n} \n \nvar obj = new AgriLoan(10,1) \nconsole.log(\"利润为 : \"+obj.interest+\"，抽成为 : \"+obj.rebate )\n```\n\n一个类可以实现多个接口：\n\n```tsx\ninterface Alarm {\n    alert(): void;\n}\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log(''Car alert'');\n    }\n    lightOn() {\n        console.log(''Car light on'');\n    }\n    lightOff() {\n        console.log(''Car light off'');\n    }\n}\n```\n\n上例中，`Car` 实现了 `Alarm` 和 `Light` 接口，既能报警，也能开关车灯。',5,2,4,1),
(387,'访问修饰符','分别是 `public`、`private` 和 `protected`。\n\n- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的\n- `private` 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n- `protected` 修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的\n\n一些例子：\n\n```tsx\nclass Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name); // Jack\na.name = ''Tom'';\nconsole.log(a.name); // Tom\n```\n\n上面的例子中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的。',5,2,4,1),
(389,'访问修饰符(private)','很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了：\n\n```tsx\nclass Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name);\na.name = ''Tom'';\n\n// index.ts(9,13): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n// index.ts(10,1): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n```\n\n需要注意的是，TypeScript 编译之后的代码中，并没有限制 `private` 属性在外部的可访问性。\n\n使用 `private` 修饰的属性或方法，在子类中也是不允许访问的：\n\n```tsx\nclass Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n// index.ts(11,17): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n```\n',5,2,4,1),
(390,'访问修饰符(protected)','而如果是用 `protected` 修饰，则允许在子类中访问：\n\n```ts\nclass Animal {\n  protected name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n```\n\n当构造函数修饰为 `private` 时，该类不允许被继承或者实例化：\n\n```tsx\nclass Animal {\n  public name;\n  private constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\nlet a = new Animal(''Jack'');\n// index.ts(7,19): TS2675: Cannot extend a class ''Animal''. Class constructor is marked as private.\n// index.ts(13,9): TS2673: Constructor of class ''Animal'' is private and only accessible within the class declaration.\n```\n\n当构造函数修饰为 `protected` 时，该类只允许被继承：\n\n```tsx\nclass Animal {\n  public name;\n  protected constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\nlet a = new Animal(''Jack'');\n// index.ts(13,9): TS2674: Constructor of class ''Animal'' is protected and only accessible within th\n```\n\n',5,2,4,1),
(391,'参数属性','修饰符和`readonly`还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\n\n```tsx\nclass Animal {\n  // public name: string;\n  public constructor(public name) {\n    // this.name = name;\n  }\n}\n```\n\n',5,2,4,1),
(392,'只读(readonly)','只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\n\n```tsx\nclass Animal {\n  readonly name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name); // Jack\na.name = ''Tom'';\n\n// index.ts(10,3): TS2540: Cannot assign to ''name'' because it is a read-only property.\n```\n\n注意如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面。\n\n```tsx\nclass Animal {\n  // public readonly name;\n  public constructor(public readonly name) {\n    // this.name = name;\n  }\n}\n```\n',5,2,4,1),
(393,'抽象类','`abstract` 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nlet a = new Animal(''Jack'');\n// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class ''Animal''.\n```\n\n上面的例子中，我们定义了一个抽象类 `Animal`，并且定义了一个抽象方法 `sayHi`。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new Cat(''Tom'');\n// index.ts(9,7): error TS2515: Non-abstract class ''Cat'' does not implement inherited abstract member ''sayHi'' from class ''Animal''.\n```\n\n上面的例子中，我们定义了一个类 `Cat` 继承了抽象类 `Animal`，但是没有实现抽象方法 `sayHi`，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\nclass Cat extends Animal {\n  public sayHi() {\n    console.log(`Meow, My name is ${this.name}`);\n  }\n}\nlet cat = new Cat(''Tom'');\n```\n\n上面的例子中，我们实现了抽象方法 `sayHi`，编译通过了。',5,2,4,1),
(394,'类的类型(Class)','给类加上 TypeScript 的类型很简单，与接口类似：\n\n```tsX\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayHi(): string {\n    return `My name is ${this.name}`;\n  }\n}\nlet a: Animal = new Animal(''Jack'');\nconsole.log(a.sayHi()); // My name is Jack\n```\n\n',5,2,4,1),
(395,'接口(interface)','interface 接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。\n\n### 基础示例\n\n接口一般首字母大写\n\n定义的变量比接口少了一些属性是不允许的\n\n多一些属性也是不允许的\n\n```tsx\ninterface Person {\n    name: string;\n    age: number;\n}\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25\n};\n```\n\n定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。',5,2,4,1),
(396,'可选属性(interface)','有时我们希望不要完全匹配一个形状\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: ''Tom''\n};\n\ninterface Person {\n    name: string;\n    age?: number;\n}\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性**',5,2,4,1),
(397,'任意属性(interface)','有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: ''Tom'',\n    gender: ''male''\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25,\n    gender: ''male''\n};\n```\n\n',5,2,4,1),
(398,'只读属性(interface)','有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```tsx\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: ''Tom'',\n    gender: ''male''\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to ''id'' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。',5,2,4,1),
(399,'函数类型(interface)','为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```tsx\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\n下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```tsx\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n',5,2,4,1),
(400,'可索引的类型(interface)','与使用接口描述函数类型差不多，我们也可以描述那些能够 “通过索引得到” 的类型，比如 `a[10]` 或 `ageMap[\"daniel\"]` 。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```tsx\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型',5,2,4,1),
(401,'混合类型(interface)','先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时作为函数和对象使用，并带有额外的属性。\n\n```tsx\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = function(start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function() {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。',5,2,4,1),
(402,'接口继承(interface)','接口继承就是说接口可以通过其他接口来扩展自己。\n\nTypescript 允许接口继承多个接口。\n\n继承使用关键字 **extends**。\n\n单接口继承语法格式：\n\n```\nChild_interface_name extends super_interface_name\n```\n\n多接口继承语法格式：\n\n```\nChild_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name\n```\n\n继承的各个接口使用逗号 **,** 分隔。',5,2,4,1),
(403,'单继承实例(interface)','```tsx\ninterface Person { \nage:number \n}   \ninterface Musician extends Person { \ninstrument:string \n}  \nvar drummer = <Musician>{};\ndrummer.age = 27  \ndrummer.instrument = \"Drums\"\nconsole.log(\"年龄:  \"+drummer.age) \nconsole.log(\"喜欢的乐器:  \"+drummer.instrument)\n```\n',5,2,4,1),
(404,'多继承实例(interface)','```tsx\ninterface IParent1 { \n    v1:number \n} \ninterface IParent2 { \n    v2:number \n} \ninterface Child extends IParent1, IParent2 { } \nvar Iobj:Child = { v1:12, v2:23} \nconsole.log(\"value 1: \"+Iobj.v1+\" value 2: \"+Iobj.v2)\n```\n',5,2,4,1),
(405,'接口定义函数(interface)','接口不仅可以定义对象, 还可以定义函数:\n\n```tsx\n// 声明接口\ninterface Core {\n    (n:number, s:string):[number,string]\n}\n\n// 声明函数遵循接口定义\nconst core:Core = (a,b)=>{\n    return [a,b];\n}\n```\n',5,2,4,1),
(406,'接口定义类(interface)','先简单看下如何给类定义接口, 后面的课程具体讲类:\n\n```tsx\n// 定义\ninterface Animate {\n    head:number;\n    body:number;\n    foot:number;\n    eat(food:string):void;\n    say(word:string):string;\n}\n```\n\n```tsx\n// implements\nclass Dog implements Animate{\n    head=1;\n    body=1;\n    foot=1;\n    eat(food){\n        console.log(food);\n    }\n    say(word){\n        return word;\n    }\n}\n```\n\n',5,2,4,1),
(407,'类型声明','使用 **类型声明** 来描述一个对象的类型\n\n```tsx\ntype myType = {\n  name: string;\n  age: number;\n};\nconst person1: myType = {\n  name: ''hzw'',\n  age: 18,\n};\n```\n\n类型声明不可以重复写 接口可以重复写,内容会自动合并',5,2,4,1),
(408,'instanceof','instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。\n\n```tsx\nclass Person{ } \nvar obj = new Person() \nvar isPerson = obj instanceof Person; \nconsole.log(\"obj 对象是 Person 类实例化来的吗？ \" + isPerson);\n```\n\n',5,2,4,1),
(409,'typeof','typeof 操作符可以用来获取一个变量或对象的类型\n\n```tsx\ninterface Hero {\n  name: string;\n  skill: string;\n}\n\nconst zed: Hero = { name: \"影流之主\", skill: \"影子\" };\ntype LOL = typeof zed; // type LOL = Hero\n```\n\n在上面代码中，我们通过 typeof 操作符获取 zed 变量的类型并赋值给 LOL 类型变量，之后我们就可以使用 LOL 类型\n\n```tsx\nconst ahri: LOL = { name: \"阿狸\", skill: \"魅惑\" };\n```\n',5,2,4,1),
(410,'keyof','keyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键\n\n```tsx\ninterface Point {\n    x: number;\n    y: number;\n}\n\n// type keys = \"x\" | \"y\"\ntype keys = keyof Point;\n```\n\n用 keyof 可以更好的定义数据类型\n\n```js\nfunction get<T extends object, K extends keyof T>(o: T, name: K): T[K] {\n  return o[name]\n}\n```\n\n',5,2,4,1),
(411,'Partial<T>','将T中所有属性转换为可选属性。返回的类型可以是T的任意子集\n\n```tsx\nexport interface UserModel {\n  name: string;\n  age?: number;\n  sex: number;\n}\n\ntype JUserModel = Partial<UserModel>\n// =\ntype JUserModel = {\n    name?: string | undefined;\n    age?: number | undefined;\n    sex?: number | undefined;\n}\n\n// 源码解析\ntype Partial<T> = { [P in keyof T]?: T[P]; };\n```\n\n',5,3,4,1),
(412,'Required<T>','通过将T的所有属性设置为必选属性来构造一个新的类型。与Partial相反\n\n```tsx\ntype JUserModel2 = Required<UserModel>\n// =\ntype JUserModel2 = {\n    name: string;\n    age: number;\n    sex: number;\n}\n```\n\n',5,3,4,1),
(413,'Readonly<T>','将T中所有属性设置为只读\n\n```tsx\ntype JUserModel3 = Readonly<UserModel>\n\n// =\ntype JUserModel3 = {\n    readonly name: string;\n    readonly age?: number | undefined;\n    readonly sex: number;\n}\n```\n',5,3,4,1),
(414,'Record<K,T>','构造一个类型，该类型具有一组属性K，每个属性的类型为T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。\n\n简单理解：K对应对应的key，T对应对象的value，返回的就是一个声明好的对象\n\n```tsx\ntype TodoProperty = ''title'' | ''description'';\ntype Todo = Record<TodoProperty, string>;\n// =\ntype Todo = {\n    title: string;\n    description: string;\n}\n\ninterface IGirl {\n  name: string;\n  age: number;\n}\n\ntype allGirls = Record<string, IGirl>\n```\n\n',5,3,4,1),
(415,'Pick<T,K>','在一个声明好的对象中，挑选一部分出来组成一个新的声明对象\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  done: boolean;\n}\ntype TodoBase = Pick<Todo, \"title\" | \"done\">;\n// =\ntype TodoBase = {\n    title: string;\n    done: boolean;\n}\n```\n',5,3,4,1),
(416,'Exclude<T,U>','从T中排除可分配给U的属性，剩余的属性构成新的类型\n\n```tsx\ntype T0 = Exclude<''a'' | ''b'' | ''c'', ''a''>; \n\n// = \n\ntype T0 = \"b\" | \"c\"\n```\n',5,3,4,1),
(417,'Extract<T,U>','从T中抽出可分配给U的属性构成新的类型。与Exclude相反\n\n```tsx\ntype T0 = Extract<''a'' | ''b'' | ''c'', ''a''>; \n\n// = \n\ntype T0 = ''a''\n```\n',5,3,4,1),
(418,'Parameters<T>','返回类型为T的函数的参数类型所组成的数组\n\n```tsx\ntype T0 = Parameters<() => string>;  // []\n\ntype T1 = Parameters<(s: string) => void>;  // [string]\n```\n\n',5,3,4,1),
(419,'ReturnType<T>','function T的返回类型\n\n```tsx\ntype T0 = ReturnType<() => string>;  // string\n\ntype T1 = ReturnType<(s: string) => void>;  // void\n```\n\n',5,3,4,1),
(420,'InstanceType<T>','返回构造函数类型T的实例类型\n\n```tsx\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype T0 = InstanceType<typeof C>;  // C\n```\n',5,3,4,1),
(421,'字符串字面量类型','### 字符串字面量类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个。\n\n```ts\ntype EventNames = ''click'' | ''scroll'' | ''mousemove'';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById(''hello''), ''scroll'');  // 没问题\nhandleEvent(document.getElementById(''world''), ''dblclick''); // 报错，event 不能为 ''dblclick''\n\n// index.ts(7,47): error TS2345: Argument of type ''\"dblclick\"'' is not assignable to parameter of type ''EventNames''.\n```\n\n上例中，使用 `type` 定了一个字符串字面量类型 `EventNames`，它只能取三种字符串中的一种。\n\n注意，**类型别名与字符串字面量类型都是使用 `type` 进行定义。**',5,2,4,1),
(422,'泛型(Generics)','泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。',5,2,4,1),
(423,'泛型接口(Generics)','```tsx\ninterface GenericIdentityFn<T> {\n    (arg: T): T;\n}\n```\n\n',5,2,4,1),
(424,'泛型类(Generics)','```tsx\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n### 使用示例\n\n```tsx\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\ncreateArray<string>(3, ''x''); // [''x'', ''x'', ''x'']\n\n// T 自定义名称\nfunction myFun<T>(params: T[]) {\n  return params;\n}\nmyFun <string> ([\"123\", \"456\"]);\n\n// 定义多个泛型\nfunction join<T, P>(first: T, second: P) {\n  return `${first}${second}`;\n}\njoin <number, string> (1, \"2\");\n```\n\n上例中，我们在函数名后添加了 <T>，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array<T> 中即可使用了\n\n',5,2,4,1),
(425,'多个类型参数(Generics)','定义泛型的时候，可以一次定义多个类型参数：\n\n```tsx\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\nswap([7, ''seven'']); // [''seven'', 7]\n```\n\n上例中，我们定义了一个 `swap` 函数，用来交换输入的元组',5,2,4,1),
(426,'泛型约束(Generics)','在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\n泛型进行约束\n\n```ts\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n```\n\n上例中，我们使用了 `extends` 约束了泛型 `T` 必须符合接口 `Lengthwise` 的形状，也就是必须包含 `length` 属性。\n\n\n\n多个类型参数之间也可以互相约束：\n\n```ts\nfunction copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\nlet x = { a: 1, b: 2, c: 3, d: 4 };\ncopyFields(x, { b: 10, d: 20 });\n```\n\n上例中，我们使用了两个类型参数，其中要求 `T` 继承 `U`，这样就保证了 `U` 上不会出现 `T` 中不存在的字段。',5,2,4,1),
(427,'泛型参数的默认类型(Generics)','TypeScript 2.3 以后，可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\n```ts\nfunction createArray<T = string>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n```\n\n',5,2,4,1),
(428,'泛型继承(Generics)','也可以对泛型的范围进行约束\n\n使用 `T extends MyInter` 表示泛型 `T` 必须是 `MyInter` 的子类，不一定非要使用接口类和抽象类同样适用；\n\n```tsx\ninterface MyInter{\n  length: number;\n}\n\nfunction test<T extends MyInter>(arg: T): number{\n  return arg.length;\n}\n```\n',5,2,4,1),
(429,'模块','TypeScript 代码必须使用路径进行导入。这里的路径既可以是相对路径，以 `.` 或 `..` 开头，也可以是从项目根目录开始的绝对路径，如 `root/path/to/file` 。\n\n```tsx\nimport {Symbol1} from ''google3/path/from/root'';\nimport {Symbol2} from ''../parent/file'';\nimport {Symbol3} from ''./sibling'';\n```\n\n',5,2,4,1),
(430,'导出','代码中必须使用具名的导出声明。\n\n```tsx\n// 1\nexport class Foo { ... }\n```\n\n```tsx\n// 2\nconst someVar = 123;\ntype someType = {\n  type: string;\n};\nexport { someVar, someType };\n```\n\n也可以用重命名变量的方式导出：\n\n```tsx\n// foo.ts\nconst someVar = 123;\nexport { someVar as aDifferentName };\n```\n\n#### 导出可见性\n\nTypeScript 不支持限制导出符号的可见性。因此，不要导出不用于模块以外的符号。一般来说，应当尽量减小模块的外部 API 的规模。\n\n#### 可变导出\n\n虽然技术上可以实现，但是可变导出会造成难以理解和调试的代码，尤其是对于在多个模块中经过了多次重新导出的符号。这条规则的一个例子是，不允许使用 `export let` 。\n\n```tsx\n// 不要这样做！\nexport let foo = 3;\n// 在纯 ES6 环境中，变量 foo 是一个可变值，导入了 foo 的代码会观察到它的值在一秒钟之后发生了改变。\n// 在 TypeScript 中，如果 foo 被另一个文件重新导出了，导入该文件的代码则不会观察到变化。\nwindow.setTimeout(() => {\n    foo = 4;\n}, 1000 /* ms */);\n```\n\n如果确实需要允许外部代码对可变值进行访问，应当提供一个显式的取值器。\n\n```tsx\n// 应当这样做！\nlet foo = 3;\nwindow.setTimeout(() => {\n    foo = 4;\n}, 1000 /* ms */);\n// 使用显式的取值器对可变导出进行访问。\nexport function getFoo() { return foo; };\n```\n\n有一种常见的编程情景是，要根据某种特定的条件从两个值中选取其中一个进行导出：先检查条件，然后导出。这种情况下，应当保证模块中的代码执行完毕后，导出的结果就是确定的。\n\n```tsx\nfunction pickApi() {\n    if (useOtherApi()) return OtherApi;\n    return RegularApi;\n}\nexport const SomeApi = pickApi();\n```\n\n',5,2,4,1),
(431,'容器类','不要为了实现命名空间创建含有静态方法或属性的容器类。\n\n```tsx\n// 不要这样做！\nexport class Container {\n    static FOO = 1;\n    static bar() { return 1; }\n}\n```\n\n应当将这些方法和属性设为单独导出的常数和函数。\n\n```tsx\n// 应当这样做！\nexport const FOO = 1;\nexport function bar() { return 1; }\n```\n\n',5,2,4,1),
(432,'导入','在 ES6 和 TypeScript 中，导入语句共有四种变体：\n\n| 导入类型 | 示例                             | 用途                                       |\n| -------- | -------------------------------- | ------------------------------------------ |\n| 模块     | `import * as foo from ''...'';`    | TypeScript 导入方式                        |\n| 解构     | `import {SomeThing} from ''...'';` | TypeScript 导入方式                        |\n| 默认     | `import SomeThing from ''...'';`   | 只用于外部代码的特殊需求                   |\n| 副作用   | `import ''...'';`                  | 只用于加载某些库的副作用（例如自定义元素） |\n\n```tsx\n// 应当这样做！从这两种变体中选择较合适的一种（见下文）。\nimport * as ng from ''@angular/core'';\nimport {Foo} from ''./foo'';\nimport { someVar as aDifferentName } from ''./foo'';\n\n// 只在有需要时使用默认导入。\nimport Button from ''Button'';\n\n// 有时导入某些库是为了其代码执行时的副作用。\nimport ''jasmine'';\nimport ''@polymer/paper-button'';\n```\n\n从其他模块导入后整体导出：\n\n```tsx\nexport * from ''./foo'';\n```\n\n从其他模块导入后，部分导出：\n\n```tsx\nexport { someVar } from ''./foo'';\n```\n\n通过重命名，部分导出从另一个模块导入的项目：\n\n```tsx\nexport { someVar as aDifferentName } from ''./foo'';\n```\n\n#### 选择模块导入还是解构导入？\n\n根据使用场景的不同，模块导入和解构导入分别有其各自的优势。\n\n虽然模块导入语句中出现了通配符 `*` ，但模块导入并不能因此被视为其它语言中的通配符导入。相反，模块导入语句为整个模块提供了一个名称，模块中的所有符号都通过这个名称进行访问，这为代码提供了更好的可读性，同时令模块中的所有符号可以进行自动补全。模块导入减少了导入语句的数量，降低了命名冲突的出现几率，同时还允许为被导入的模块提供一个简洁的名称。在从一个大型 API 中导入多个不同的符号时，模块导入语句尤其有用。\n\n解构导入语句则为每一个被导入的符号提供一个局部的名称，这样在使用被导入的符号时，代码可以更简洁。对那些十分常用的符号，例如 Jasmine 的 `describe` 和 `it` 来说，这一点尤其有用。\n\n```tsx\n// 不要这样做！无意义地使用命名空间中的名称使得导入语句过于冗长。\nimport {TableViewItem, TableViewHeader, TableViewRow, TableViewModel,\nTableViewRenderer} from ''./tableview'';\nlet item: TableViewItem = ...;\n\n// 应当这样做！使用模块作为命名空间。\nimport * as tableview from ''./tableview'';\nlet item: tableview.Item = ...;\n```\n\n#### 重命名导入\n\n在代码中，应当通过使用模块导入或重命名导出解决命名冲突。此外，在需要时，也可以使用重命名导入（例如 `import {SomeThing as SomeOtherThing}` ）。\n\n在以下几种情况下，重命名导入可能较为有用：\n\n1. 避免与其它导入的符号产生命名冲突。\n2. 被导入符号的名称是自动生成的。\n3. 被导入符号的名称不能清晰地描述其自身，需要通过重命名提高代码的可读性，如将 RxJS 的 `from` 函数重命名为 `observableFrom` 。\n\n#### 默认导入／导出\n\n- 使用\n\n  ```tsx\n  export default\n  ```\n\n  - 在一个变量之前（不需要使用 `let/const/var`）；\n  - 在一个函数之前；\n  - 在一个类之前。\n\n```ts\n// some var\nexport default (someVar = 123);\n\n// some function\nexport default function someFunction() {}\n\n// some class\nexport default class someClass {}\n```\n\n- 导入使用 `import someName from ''someModule''` 语法（你可以根据需要为导入命名）：\n\n```ts\nimport someLocalNameForThisFile from ''./foo'';\n```\n\n',5,2,4,1),
(433,'函数的合并','我们可以使用重载定义多个函数类型：\n\n```tsx\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === ''number'') {\n        return Number(x.toString().split('''').reverse().join(''''));\n    } else if (typeof x === ''string'') {\n        return x.split('''').reverse().join('''');\n    }\n}\n```\n',5,2,4,1),
(434,'接口的合并','接口中的属性在合并时会简单的合并到一个接口中：\n\n```tsx\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    weight: number;\n}\n```\n\n相当于：\n\n```tsx\ninterface Alarm {\n    price: number;\n    weight: number;\n}\n```\n\n注意，**合并的属性的类型必须是唯一的**：\n\n```tsx\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错\n    weight: number;\n}\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: string;  // 类型不一致，会报错\n    weight: number;\n}\n\n// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable ''price'' must be of type ''number'', but here has type ''string''.\n```\n\n接口中方法的合并，与函数的合并一样：\n\n```tsx\ninterface Alarm {\n    price: number;\n    alert(s: string): string;\n}\ninterface Alarm {\n    weight: number;\n    alert(s: string, n: number): string;\n}\n```\n\n相当于：\n\n```tsx\ninterface Alarm {\n    price: number;\n    weight: number;\n    alert(s: string): string;\n    alert(s: string, n: number): string;\n}\n```\n',5,2,4,1),
(435,'类的合并','类的合并与接口的合并规则一致',5,2,4,1),
(436,'tsconfig.json','### tsconfig.json 的作用\n\n- 用于标识 TypeScript 项目的根路径；\n- 用于配置 TypeScript 编译器；\n- 用于指定编译的文件。\n\n### tsconfig.json 重要字段\n\n- files - 设置要编译的文件的名称；\n- include - 设置需要进行编译的文件，支持路径模式匹配；\n- exclude - 设置无需进行编译的文件，支持路径模式匹配；\n- compilerOptions - 设置与编译流程相关的选项。\n\ncompilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。\n\n### 文件配置选项\n\n#### 1. include\n\n- 用来指定哪些目录下的ts文件需要被编译\n- 默认值：`[\"**/*\"]`\n- `**` 表示任意目录 \n- `*` 表示任意文件\n\n```js\n//表示根目录下src目录下任意目录任意文件\n\"include\": [\n  \"./src/**/*\" \n],\n```\n\n#### 2. exclude\n\n- 用来指定哪些目录下的 `ts` 文件不需要被编译\n- 默认值：`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`\n\n```js\n//表示不编译根目录下src目录下test目录下任意目录任意文件\n\"exclude\":[\n  \"./src/test/**/*\"  \n],\n```\n\n#### 3. extends\n\n- 用来定义 **被继承的配置文件**\n- 引入后,当前配置文件中会自动包含引入文件中的所有配置信息\n\n```js\n//当前配置文件中会自动包含根目录下base.json中的所有配置信息\n\"extends\": \"./base.json\",\n```\n\n#### 4. files\n\n- 用来指定被编译的文件列表,需要把文件一个个列出来比较麻烦,只有需要编译的文件少时才会用到.\n\n```js\n //只会编译根目录下01目录下的hello.ts\n\"files\": [\"./01/hello.ts\"],\n```\n\n### compilerOptions\n\n- 编译选项是配置文件中非常重要也比较复杂的配置选项\n- 在 `compilerOptions` 中包含多个子选项，用来完成对编译的配置\n\n#### 1. target\n\n- 用来指定 `TS` 被编译为的 `ES` 版本\n- 可选值：`ES3`（**默认**）、`ES5`、`ES6/ES2015`、`ES7/ES2016`、`ES2017`、`ES2018`、`ES2019`、`ES2020`、`ESNext`(**最新版本的ES**)\n\n```js\n//我们所编写的ts代码将会被编译为ES6版本的js代码\n\"compilerOptions\": {\n    \"target\": \"ES6\"\n}\n复制代码\n```\n\n#### 2. module\n\n- 用来指定要使用的模块化的解决方案\n- 可选值：`CommonJS`、`UMD`、`AMD`、`System`、`ES2020`、`ESNext`、`None`\n\n```js\n\"compilerOptions\": {\n    \"module\": \"CommonJS\"\n}\n复制代码\n```\n\n#### 3. lib\n\n- 用来指定项目中要使用的库 一般浏览器情况下不需要设置\n- 可选值：`ES5`、`ES6/ES2015`、`ES7/ES2016`、`ES2017`、`ES2018`、`ES2019`、`ES2020`、`ESNext`、`DOM`、`WebWorker`、`ScriptHost` `......`\n\n```js\n\"compilerOptions\": {\n    \"lib\": [\"ES6\", \"DOM\"],\n}\n复制代码\n```\n\n#### 4. outDir,rootDir\n\n- `outDir` 用来指定编译后文件所在的目录\n- `rootDir` 用来指定代码的根目录\n\n- 默认情况下，编译后的 `js` 文件会和 `ts` 文件位于相同的目录，设置 `outDir` 后可以改变编译后文件的位置\n\n```js\n\"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n}\n复制代码\n```\n\n#### 5. outFile\n\n- 将编译后的代码合并为一个文件\n- 设置 `outFile` 后,所有的全局作用域中的代码会合并到同一个文件中\n\n- 如果 `module` 制定了 `None`、`System` 或 `AMD` 则会将模块一起合并到文件之中\n\n```js\n\"compilerOptions\": {\n    \"outFile\": \"dist/app.js\"\n}\n复制代码\n```\n\n#### 6.allowJs\n\n- 是否对 `js` 文件进行编译,默认为 `false`\n\n#### 7.checkJs\n\n- 是否检测 `js` 代码是否符合语法规范,默认为 `false`\n\n#### 8.removeComments\n\n- 是否移除注释,默认为 `false`\n\n#### 9.noEmit\n\n- 是否不生成编译后的文件,默认为 `false`\n\n#### 10.noEmitOnError\n\n- 是否不生成编译后的文件(**当出现错误时**),默认为 `false`\n\n```js\n\"compilerOptions\": {\n     \"allowJs\": true,\n     \"checkJs\": true,\n     \"removeComments\": false,\n     \"noEmit\": false,\n     \"noEmitOnError\": true\n}\n```\n\n#### 11.严格检查\n\n- **strict**\n- - 启用所有的严格检查，默认值为 `true`，设置后相当于开启了所有的严格检查\n\n- **alwaysStrict**\n\n- - 总是以严格模式对代码进行编译\n\n- **noImplicitAny**\n\n- - 禁止隐式的 `any` 类型\n\n- **noImplicitThis**\n\n- - 禁止类型不明确的 `this`\n\n- **strictBindCallApply**\n\n- - 严格检查 `bind`、`call` 和 `apply` 的参数列表\n\n- **strictFunctionTypes**\n\n- - 严格检查函数的类型\n\n- **strictNullChecks**\n\n- - 严格的空值检查\n\n- **strictPropertyInitialization**\n\n- - 严格检查属性是否初始化\n\n#### 12.额外检查\n\n- **noFallthroughCasesInSwitch**\n\n- - 检查 `switch` 语句包含正确的 `break`\n\n- **noImplicitReturns**\n\n- - 检查函数没有隐式的返回值\n\n- **noUnusedLocals**\n\n- - 检查未使用的局部变量\n\n- **noUnusedParameters**\n\n- - 检查未使用的参数\n\n- **allowUnreachableCode**\n\n- - 检查不可达代码\n  - 可选值：`true`，忽略不可达代码;`false`，不可达代码将引起错误\n\n',5,2,4,1),
(437,'tsconfig.json示例','```javascript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"isolatedModules\": false,\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"experimentalDecorators\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"types\": [\"vite/client\"],\n    \"baseUrl\": \".\",\n    \"lib\": [\"dom\", \"esnext\"],\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@comp/*\": [\"src/components/*\"],\n      \"@api/*\": [\"src/api/*\"],\n      \"@vi/*\": [\"src/views/*\"],\n      \"@h/*\": [\"src/hooks/*\"]\n    }\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\n```\n\n### compilerOptions 选项\n\n```ts\n{\n  \"compilerOptions\": {\n\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: ''ES3'' (default), ''ES5'', ''ES6''/''ES2015'', ''ES2016'', ''ES2017'', or ''ESNEXT''\n    \"module\": \"commonjs\",                  // 指定使用模块: ''commonjs'', ''amd'', ''system'', ''umd'' or ''es2015''\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: ''preserve'', ''react-native'', or ''react''\n    \"declaration\": true,                   // 生成相应的 ''.d.ts'' 文件\n    \"sourceMap\": true,                     // 生成相应的 ''.map'' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 ''ts.transpileModule'' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 ''use strict''\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： ''node'' (Node.js) or ''classic'' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n}\n```\n\n',5,3,4,1),
(438,'命名规范','| 命名法                                 | 分类                                   |\n| -------------------------------------- | -------------------------------------- |\n| 帕斯卡命名法（ `UpperCamelCase` ）     | 类、接口、类型、枚举、装饰器、类型参数 |\n| 驼峰式命名法（ `lowerCamelCase` ）     | 变量、参数、函数、方法、属性、模块别名 |\n| 全大写下划线命名法（ `CONSTANT_CASE`） | 全局常量、枚举值                       |\n| 私有成员命名法（ `#ident` ）           | 不允许使用                             |\n\n1. 不要使用`I`做为接口名前缀。\n2. 不要为私有属性名添加`_`前缀。\n3. 尽可能使用完整的单词拼写命名。',5,6,4,1),
(439,'导入模块','导入模块的命名空间时使用驼峰命名法（`lowerCamelCase`），文件名则使用蛇形命名法（`snake_case`）。例如：\n\n```ts\nimport * as fooBar from ''./foo_bar'';\n```\n\n',5,3,4,1),
(440,'常量','常量命名（`CONSTANT_CASE`）表示某个值不可被修改。它还可以用于虽然技术上可以实现，但是用户不应当试图修改的值，比如并未进行深度冻结（deep frozen）的值。\n\n```tsx\nconst UNIT_SUFFIXES = {\n    ''milliseconds'': ''ms'',\n    ''seconds'': ''s'',\n};\n// UNIT_SUFFIXES 使用了常量命名，\n// 这意味着用户不应试图修改它，\n// 即使它实际上是一个可变的值。\n```\n\n这里所说的常量，也包括类中的静态只读属性：\n\n```tsx\nclass Foo {\n    private static readonly MY_SPECIAL_NUMBER = 5;\n\n    bar() {\n        return 2 * Foo.MY_SPECIAL_NUMBER;\n    }\n}\n```\n',5,2,4,1),
(441,'组件','1. 1个文件对应一个逻辑组件 （比如：解析器，检查器）。\n2. 不要添加新的文件。\n3. `.generated.*`后缀的文件是自动生成的，不要手动改它。',5,6,4,1),
(442,'类型','1. 不要导出类型/函数，除非你要在不同的组件中共享它。\n2. 不要在全局命名空间内定义类型/值。\n3. 共享的类型应该在`types.ts`里定义。\n4. 在一个文件里，类型定义应该出现在顶部。',5,6,4,1),
(443,'错误提示信息','1. 在句子结尾使用`.`。\n2. 对不确定的实体使用不定冠词。\n3. 确切的实体应该使用名字（变量名，类型名等）\n4. 当创建一条新的规则时，主题应该使用单数形式（比如：An external module cannot...而不是External modules cannot）。\n5. 使用现在时态。',5,6,4,1),
(444,'错误提示信息代码','提示信息被划分类成了一般的区间。如果要新加一个提示信息，在上条代码上加1做为新的代码。\n\n- 1000 语法信息\n- 2000 语言信息\n- 4000 声明生成信息\n- 5000 编译器选项信息\n- 6000 命令行编译器信息\n- 7000 noImplicitAny信息',5,6,4,1),
(445,'普通方法','由于种种原因，我们避免使用一些方法，而使用我们自己定义的。\n\n1. 不使用ECMAScript 5函数；而是使用[core.ts](https://github.com/Microsoft/TypeScript/blob/master/src/compiler/core.ts)这里的。\n2. 不要使用`for..in`语句；而是使用`ts.forEach`，`ts.forEachKey`和`ts.forEachValue`。注意它们之间的区别。\n3. 如果可能的话，尝试使用`ts.forEach`，`ts.map`和`ts.filter`代替循环。\n\n',5,6,4,1),
(446,'用 JSDoc 还是注释？','TypesScript 中有两种类型的注释：\n\nJSDoc `/** ... */` \n\n普通注释 `// ... 或者 /* ... */` 。\n\n- 对于文档，也就是用户应当阅读的注释，使用 `/** JSDoc */` 。\n- 对于实现说明，也就是只和代码本身的实现细节有关的注释，使用 `// 行注释` 。\n\nJSDoc 注释能够为工具（例如编辑器或文档生成器）所识别，而普通注释只能供人阅读。',5,6,4,1),
(447,'对所有导出的顶层模块进行注释','使用 `/** JSDoc */` 注释为代码的用户提供信息。这些注释应当言之有物，切忌仅仅将属性名或参数名重抄一遍。如果代码的审核人认为某个属性或方法的作用不能从它的名字上一目了然地看出来的话，这些属性和方法同样应当使用 `/** JSDoc */` 注释添加说明文档，无论它们是否被导出，是公开还是私有的。',5,6,4,1),
(448,'不要使用@override','不要在 TypeScript 代码中使用 `@override` 注释。 `@override` 并不会被编译器视为强制性约束，这会导致注释与实现上的不一致性。如果纯粹为了文档添加这一注释，反而令人困惑。',5,6,4,1),
(449,'注释必须言之有物','虽然大多数情况下文档对代码十分有益，但对于那些并不用于导出的符号，有时其函数或参数的名称与类型便足以描述自身了。\n\n注释切忌照抄参数类型和参数名，如下面的反面示例：\n\n```tsx\n// 不要这样做！这个注释没有任何有意义的内容。\n/** @param fooBarService Foo 应用的 Bar 服务 */\n```\n\n因此，只有当需要添加额外信息时才使用 `@param` 和 `@return` 注释，其它情况下直接省略即可。\n\n```tsx\n/**\n * 发送 POST 请求，开始煮咖啡\n * @param amountLitres 煮咖啡的量，注意和煮锅的尺寸对应！\n */\nbrew(amountLitres: number, logger: Logger) {\n    // ...\n}\n```\n',5,6,4,1),
(450,'参数属性注释','通过为构造函数的参数添加访问限定符，参数属性同时创建了构造函数参数和类成员。例如，如下的构造函数\n\n```tsx\nclass Foo {\n    constructor(private readonly bar: Bar) { }\n}\n```\n\n为 `Foo` 类创建了 `Bar` 类型的成员 `bar` 。\n\n如果要为这些成员添加文档，应使用 JSDoc 的 `@param` 注释，这样编辑器会在调用构造函数和访问属性时显示对应的文档描述信息。\n\n```tsx\n/** 这个类演示了如何为参数属性添加文档 */\nclass ParamProps {\n    /**\n     * @param percolator 煮咖啡所用的咖啡壶。\n     * @param beans 煮咖啡所用的咖啡豆。\n     */\n    constructor(\n        private readonly percolator: Percolator,\n        private readonly beans: CoffeeBean[]) {}\n}\n/** 这个类演示了如何为普通成员添加文档 */\nclass OrdinaryClass {\n    /** 下次调用 brew() 时所用的咖啡豆。 */\n    nextBean: CoffeeBean;\n\n    constructor(initialBean: CoffeeBean) {\n        this.nextBean = initialBean;\n    }\n}\n```\n',5,6,4,1),
(451,'函数调用注释','如果有需要，可以在函数的调用点使用行内的 `/* 块注释 */` 为参数添加文档，或者使用字面量对象为参数添加名称并在函数声明中进行解构。注释的格式和位置没有明确的规定。\n\n```tsx\n// 使用行内块注释为难以理解的参数添加说明：\nnew Percolator().brew(/* amountLitres= */ 5);\n\n// 或者使用字面量对象为参数命名，并在函数 brew 的声明中将参数解构：\nnew Percolator().brew({amountLitres: 5});\n/** 一个古老的咖啡壶 {@link CoffeeBrewer} */\nexport class Percolator implements CoffeeBrewer {\n    /**\n     * 煮咖啡。\n     * @param amountLitres 煮咖啡的量，注意必须和煮锅的尺寸对应！\n     */\n    brew(amountLitres: number) {\n        // 这个实现煮出来的咖啡味道差极了，不管了。\n        // TODO(b/12345): 优化煮咖啡的过程。\n    }\n}\n```\n',5,6,4,1),
(452,'将文档置于装饰器之前','文档、方法或者属性如果同时具有装饰器（例如 `@Component`）和 JSDoc 注释，应当将 JSDoc 置于装饰器之前。\n\n禁止将 JSDoc 置于装饰器和被装饰的对象之间。\n\n```tsx\n// 不要这样做！JSDoc 被放在装饰器 @Component 和类 FooComponent 中间了！\n@Component({\n    selector: ''foo'',\n    template: ''bar'',\n})\n/** 打印 \"bar\" 的组件。 */\nexport class FooComponent {}\n```\n\n应当将 JSDoc 置于装饰器之前。\n\n```tsx\n/** 打印 \"bar\" 的组件。 */\n@Component({\n    selector: ''foo'',\n    template: ''bar'',\n})\nexport class FooComponent {}\n```\n',5,6,4,1),
(453,'对象解构','```tsx\nlet person = {\n  name: ''Semlinker'',\n  gender: ''male''\n};\n\nlet {name, gender} = person;\n```\n',5,3,4,1),
(454,'对象展开运算符','```tsx\nlet person = {\n  name: ''Semlinker'',\n  gender: ''male'',\n  address: ''Xiamen''\n};\n// 组装对象\nlet personWithAge = {...person, age: 31};\n// 获取除了某些项外的其它项\nlet {name, ...rest} = person;\n```\n',5,3,4,1),
(455,'延时设定','```tsx\nsetTimeout(async () => {\ndataList.show = false\n}, 1200)\n```\n',5,3,4,1),
(456,'布尔型Attribute','```html\n<button :disabled=\"isButtonDisabled\">\n  Button\n</button>\n```\n',2,3,4,1),
(457,'动态参数(v-bind)','```html\n<a v-bind:[attributeName]=\"url\"> ... </a>\n<!-- 简写 -->\n<a :[attributeName]=\"url\"> ... </a>\n这里的 attributeName 会作为一个 JS 表达式被动态执行\n```\n',2,3,4,1),
(458,'什么是CSS','- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)\n- 样式定义**如何显示** HTML 元素\n- 样式通常存储在**样式表**中\n- 把样式添加到 HTML 4.0 中，是为了**解决内容与表现分离的问题**\n- **外部样式表**可以极大提高工作效率\n- 外部样式表通常存储在 **CSS 文件**中\n- 多个样式定义可**层叠**为一个',8,2,4,1),
(459,'后代选择器','后代选择器又称为包含选择器，可以选择父元素里面子元素，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n```CSS\nul li{\n    border: 1px solid red;\n}\n\n语法：元素1 元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有元素2（后代元素）。\n\n注意：\n\n- 元素1与元素2中间用空格隔开\n- 元素1是父级，元素2是子级，最终选择是元素2.',8,2,4,1),
(460,'背景透明(background)','```css\nbackground-color: hsla(0,0%,100%,.7);\n```\n\n',8,2,4,1),
(461,'背景渐变','使用方式:\n```css\n//渐变(方向)\nbackground: linear-gradient(to right, rgba(255, 255, 255, 0),#3FB6F7,rgba(255,255,255,0));\n\n//渐变(角度)\nbackground: linear-gradient(88deg, #4DF7BF 0%, rgba(77, 247, 191, 0.26) 12%, rgba(77, 247, 191, 0) 100%);\n```\n',8,2,4,1),
(462,'边框渐变','```css\n.border-grident{\n  margin-top: 20px;\n  width: 200px;\n  height: 200px;\n  border: 4px solid;\n  border-image: linear-gradient(to right, #8f41e9, #578aef) 4;\n}\n```\n',8,3,4,1),
(463,'瀑布流(column)','```html\n      <div class=\"w-full h-800px overflow-auto\">\n        <div class=\"test\">\n          <div v-for=\"(item, index) in rSnippet\" :key=\"index\" class=\"item\">\n            <div class=\"text-xl text-center\">{{ item.name }}</div>\n            <v-md-preview ref=\"preview\" :text=\"item.text\" />\n          </div>\n        </div>\n      </div>\n```\n\n```css\n.test {\n  margin: 0 auto;\n  column-count: 2;\n  column-gap: 10px;\n  counter-reset: count;\n\n  .item {\n    position: relative;\n    margin-bottom: 10px;\n    // page-break-inside: avoid;\n    // -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n这种方式超出宽高度使用 overflow-y-scroll 只能左右滑动',8,3,4,1),
(464,'瀑布流(grid)','超出宽高度使用 overflow-y-scroll 可以上下滑动\n\n```html\n    <div class=\"test mt-4\">\n        <div class=\"bg-warm-gray-600 w-80 h-40\" t2></div>\n        <div class=\"bg-warm-gray-700 w-80 h-40 text2\"></div>\n        <div class=\"bg-slate-500\" w-80 h-50></div>\n        <div class=\"bg-warm-gray-500 w-80 h-50\"></div>\n        <div class=\"bg-warm-gray-800 w-80 h-20\"></div>\n        <div class=\"bg-warm-gray-100 w-80 h-70\"></div>\n        <div class=\"bg-warm-gray-200 w-80 h-40\"></div>\n        <div class=\"bg-warm-gray-500 w-80 h-60\"></div>\n      </div>\n```\n\n```css\n.test {\n  display: grid;\n  grid-gap: 10px;\n\n  /* 可以看到，网格大小，占据位置是需要提前设定的 */\n  grid-template-columns: repeat(3, 1fr);\n  box-sizing: border-box;\n  width: 80%;\n  height: 800px;\n  padding: 10px;\n  background-color: rgb(189 100 100);\n\n  @apply overflow-y-scroll;\n\n  div {\n    /* 避免子元素被分割的 2种方式 */\n    page-break-inside: avoid;\n    -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n',8,3,4,1),
(465,'居中(flex)','```css\n.center-layout {\n	display: flex;\n	justify-content: center; // 内容自适应：上下居中\n	align-items: center; // 子项对齐方式：左右居中\n}\n```\n',8,3,4,1),
(466,'居中(fixed)','```css\n   .fixed-c {\n            height: 80px;\n            width: 90%;\n            position: fixed;\n            margin: auto;\n            bottom: 0; /*底部固定*/\n            left: 0; /*实现div的居中*/\n            right: 0; /*实现div的居中*/\n            text-align: center; /*div的内容居中*/\n            background: red;\n            line-height: 80px; /*垂直居中*/\n          }\n```\n',8,3,4,1),
(467,'平滑滚动','```css\n html {\n  scroll-behavior: smooth;\n}\n```\n',8,3,4,6),
(468,'绝对居中','```css\n.Absolute-Center {\n  margin: auto;\n  position: absolute;\n  top: 0; left: 0; bottom: 0; right: 0;\n}\n```\n',8,3,4,1),
(469,'文字居中','```css\n<div class=\"container\">\n    <div class=\"item\"></div>\n</div>\n\n.container {\n    text-align: center;\n}\n```\n',8,3,4,1),
(470,'块级元素居中','适用于块级元素，其实就是把要居中的子元素的 margin-left、margin-right 都设置为 auto，该方法能让子元素水平居中，但是对浮动元素和绝对定位的元素无效。\n\n```css\n.item {\n    margin: auto;\n}\n```\n',8,3,4,1),
(471,'绝对定位','```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    /* top和left是以左上角为坐标原点 */\n    top: 50%;\n    left: 50%;\n    /* transform：translate的属性值为百分数时，是以元素自身为参考 */\n    transform: translate(-50%,-50%);\n}\n\n/* 或者 */\n.child {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n```\n\n值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。',8,3,4,1),
(472,'svue3','```json\n  \"vue3+ts+scss\": {\n    \"prefix\": \"svue3\",\n    \"body\": [\n      \"<script lang=\\\"ts\\\" setup></script>\",\n      \"<template>\",\n      \"  <div></div>\",\n      \"</template>\",\n      \"\",\n      \"<style lang=\\\"scss\\\" scoped></style>\"\n    ],\n    \"description\": \"vue3\"\n  }\n```',13,3,4,1),
(473,'smounted','```json\n\"组件挂载完成后执行的函数\": {\n  \"prefix\": \"smounted\",\n  \"body\": [\n    \"onMounted(async () => {})\"\n  ],\n  \"description\": \"组件挂载完成后执行的函数\"\n}\n```\n',13,3,4,1),
(474,'sdefineAsyncComponent','```json\n\"异步组件加载\": {\n  \"prefix\": \"sdefineAsyncComponent\",\n  \"body\": [\n    \"const xxxx= defineAsyncComponent(() => {\",\n    \"  return import(''@/components/editor/xxxx.vue'')\",\n    \"})\",\n    \"<xxxx></xxxx>\"\n  ],\n  \"description\": \"异步组件加载\"\n}\n```\n',13,3,4,1),
(475,'sRefNumber','```json\n\"响应式变量\": {\n  \"prefix\": \"sRefNumber\",\n  \"body\": [\n    \"const rNumber= ref(0)\"\n  ],\n  \"description\": \"响应式变量\"\n}\n```\n',13,3,4,1),
(476,'sInterface','```json\n\"接口定义\": {\n  \"prefix\": \"sInterface \",\n  \"body\": [\n    \"export interface Ixxx {\",\n    \"  id: number\",\n    \"  name: ''''\",\n    \"}\",\n    \"export const xxxForm: Ixxx = reactive({\",\n    \"  id: 0,\",\n    \"  name: ''''\",\n    \"})\"\n  ],\n  \"description\": \"接口定义\"\n}\n```\n',13,3,4,1),
(477,'sDefinePropsStr','```json\n\"vue3中父子传值\": {\n  \"prefix\": \"sDefinePropsStr\",\n  \"body\": [\n    \"defineProps({\",\n    \"  nameStr: {\",\n    \"    type: String,\",\n    \"    required: true\",\n    \"  }\",\n    \"})\",\n    \" <p>{{ nameStr}}</p>\"\n  ],\n  \"description\": \"vue3中父子传值\"\n}\n```\n',13,3,4,1),
(478,'sAxiosAsync','```json\n\"Axios请求\": {\n  \"prefix\": \"sAxiosAsync\",\n  \"body\": [\n    \"await xxx.GetFun(xxx).then((res: any) => {})\"\n  ],\n  \"description\": \"Axios请求\"\n}\n```\n',13,3,4,1),
(479,'sAxiosAll','```json\n\"axios并发执行\": {\n  \"prefix\": \"sAxiosAll\",\n  \"body\": [\n    \"  axios.all([1, 2]).then(\",\n    \"    axios.spread((res: any,res2: any) => {\",\n    \"     //\",\n    \"    })\",\n    \"  )\"\n  ],\n  \"description\": \"axios并发执行\"\n}\n```\n',13,3,4,1),
(480,'sReactive','```json\n\"返回对象的响应式副本\": {\n  \"prefix\": \"sReactive\",\n  \"body\": [\n    \"const rData = reactive({\",\n    \"  id: number,\",\n    \"  name: ''''\",\n    \"})\"\n  ],\n  \"description\": \"返回对象的响应式副本\"\n}\n```\n',13,3,4,1),
(481,'sApply','```json\n\"CSS @apply\": {\n  \"prefix\": \"sApply\",\n  \"body\": [\n    \"@apply ;\"\n  ],\n  \"description\": \"CSS @apply\"\n}\n```\n',13,3,4,1),
(482,'sGetCurrentInstance','```json\n\"获取全局挂载的内容\": {\n  \"prefix\": \"sGetCurrentInstance\",\n  \"body\": [\n    \"const { proxy }: any = getCurrentInstance()\"\n  ],\n  \"description\": \"获取全局挂载的内容\"\n}\n```\n',13,3,4,1),
(483,'sEnun_Api','```json\n\"定义枚举api字段\": {\n  \"prefix\": \"sEnun_Api\",\n  \"body\": [\n    \"enum Api {\",\n    \"  FY = '''',\",\n    \"  SUM = '''',\",\n    \"  BYID = '''',\",\n    \"  CONTAINS = '''',\",\n    \"  ADD = '''',\",\n    \"  UPDATE = '''',\",\n    \"  DELETE = ''''\",\n    \"}\"\n  ],\n  \"description\": \"定义枚举api字段\"\n}\n```\n',13,3,4,1),
(484,'sFunAsync','```json\n\"定义异步方法\": {\n  \"prefix\": \"sFunAsync\",\n  \"body\": [\n    \"const name = async (data: any) => {\",\n    \"  //\",\n    \"}\"\n  ],\n  \"description\": \"定义异步方法\"\n}\n```\n',13,3,4,1),
(485,'sFun','```json\n\"定义方法\": {\n  \"prefix\": \"sFun\",\n  \"body\": [\n    \"const name = (data: any) => {\",\n    \"  //\",\n    \"}\"\n  ],\n  \"description\": \"定义方法\"\n}\n```\n',13,3,4,1),
(486,'sSvg','```json\n\"导入svg图片\": {\n  \"prefix\": \"sSvg\",\n  \"body\": [\n    \"import svg from ''@assets/svg/xxx.svg?component''\",\n    \"<svg />\"\n  ],\n  \"description\": \"导入svg图片\"\n}\n```\n',13,3,4,1),
(487,'sApply--','sApply--\n\n``` json\n\"unocss @apply\": {\n  \"prefix\": \"sApply--\",\n  \"body\": [\n    \"--at-apply:\"\n  ],\n  \"description\": \"unocss @apply\"\n}\n```\n',13,3,4,1),
(488,'跳转新窗口','```ts\n/**\n * @description: 跳转新页面\n * @param {string} url\n * @return {*}\n */\nfunction winUrl(url: string): any {\n  window.open(url)\n}\n\nasync function resolveId(path: string, id: number) {\n  const { href } = resolve(path, id)\n  await winUrl(href)\n}\n```\n',15,3,4,1),
(489,'ref属性','虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素\n\n```html\n<input ref=\"input\">\n```\n\n',2,2,4,1),
(490,'访问模板(ref)','### 访问模板(ref)\n\n利用`ref`函数获取组件中的标签元素。\n\n声明一个同名的 ref：\n\n```html\n<script setup>\nimport { ref, onMounted } from ''vue''\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n注意，你只可以**在组件挂载后**才能访问 ref。如果你想在模板中的表达式上访问 `$refs.input`，在初次渲染时会是 `null`\n\n如果你正试图观察一个模板 ref 的变化，确保考虑到 ref 的值为 `null` 的情况：\n\n```tsx\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // 此时还未挂载，或此元素已经被卸载（例如经过 v-if 控制）\n  }\n})\n```\n\n利用`ref`函数获取组件中的标签元素。\n\n```html\n<template>\n  <input type=\"text\" ref=\"inputRef\">\n</template>\n\n<script>\nimport { onMounted, ref } from ''vue''\nexport default {\n  setup() {\n    // 定义dom元素\n    const inputRef = ref<HTMLElement|null>(null)\n    // 自动获取焦点\n    onMounted(() => {\n      inputRef.value && inputRef.value.focus()\n    })\n\n    return {\n      inputRef\n    }\n  },\n}\n</script>\n```\n\n',2,2,4,1),
(491,'设置窗口高度(ref)','### 设置窗口高度(ref)\n\n**template**\n\n```html\n<template>\n    <div class=\"demo1-container\">\n        <p>通过ref直接拿到dom</p>\n        <div ref=\"sectionRef\" class=\"ref-section\"></div>\n        <button @click=\"higherAction\" class=\"btn\">变高</button>\n    </div>\n</template>\n```\n\n**script setup**\n\n```tsx\nimport {ref} from ''vue''\nconst sectionRef = ref()\nlet height = 100;\nconst higherAction = () => {\n    height += 50;\n    sectionRef.value.style = `height: ${height}px`;\n}\n```\n\n',2,3,4,1),
(492,'将dom引用放到数组中(ref)','### 将dom引用放到数组中(ref)\n\n```html\n<template>\n    <div class=\"demo2-container\">\n        <div class=\"list-section\">\n            <div :ref=\"setRefAction\" @click=\"higherAction(index)\" class=\"list-item\" v-for=\"(item, index) in state.list\" :key=\"index\">\n                <span>{{item}}</span>\n            </div>\n        </div>\n    </div>\n</template>\n```\n\nscript setup\n\n```tsx\nimport { reactive } from ''vue''\nconst state = reactive({\n    list: [1, 2, 3, 4, 5, 6, 7],\n    refList: [] as Array<any>\n})\nconst setRefAction = (el: any) => {\n    state.refList.push(el);\n}\n```\n',2,3,4,1),
(493,'通过子组件emit传递ref','template\n```html\n<template>\n    <div ref=\"cellRef\" @click=\"cellAction\" class=\"cell-item\">\n        <span>{{item}}</span>\n    </div>\n</template>\n```\n\nscript setup\n\n```tsx\nimport {ref} from ''vue'';\n\nconst props = defineProps({\n    item: Number\n})\nconst emit = defineEmits([''cellTap'']);\nconst cellRef = ref();\nconst cellAction = () => {\n    emit(''cellTap'', cellRef.value);\n}\n```\n\n',2,3,4,1),
(494,'v-for中的ref','当 `ref` 在 `v-for` 中使用时，相应的 ref 中包含的值是一个数组，它将在元素被挂载后填充：\n\ntemplate\n\n```html\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\nscript setup\n\n```tsx\nimport { ref, onMounted } from ''vue''\n\nconst list = ref([\n  /* ... */\n])\nconst itemRefs = ref([])\nonMounted(() => console.log(itemRefs.value))\n```\n\n应该注意的是，ref 数组**不能**保证与源数组相同的顺序。',2,3,4,1),
(495,'函数型ref','`ref` attribute 还可以绑定为函数，每次组件更新时被调用。函数接受该元素引用作为第一个参数：\n\n```html\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\n```\n\n如果使用一个动态的 `:ref` 绑定，也可以传一个函数。当元素卸载时，这个 `el` 参数会是 `null`。你当然也可以使用一个方法而不是内联函数。',2,2,4,1),
(496,'组件上的ref','#### 组件上的ref\n\n 也可以被用在一个子组件上\n\nscript setup\n\n```tsx\nimport { ref, onMounted } from ''vue''\nimport Child from ''./Child.vue''\n\nconst child = ref(null)\nonMounted(() => {\n  // child.value 为 <Child /> 这个组件实例\n})\n```\n\n```html\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，意味着父组件对子组件每个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，应该只在绝对需要时才使用组件引用。多数情况下，应该使用标准的 props 和 emit 接口来实现父子组件交互。\n\n有一个例外的情况，使用了 `<script setup>` 的组件时**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\nscript setup\n\n```tsx\nimport { ref } from ''vue''\nconst a = 1\nconst b = ref(2)\ndefineExpose({\n  a,\n  b\n})\n```\n\n当父组件通过模板 ref 获取到了该组件的实例，得到的实例类型为 `{ a: number, b: number }` (ref 都会自动解套，和一般的实例一样)。',2,2,4,1),
(497,'插槽(slot)','向一个组件传递内容，可使用插槽。通过插槽来分发内容，即插槽作为分发内容的出口。使用`<slot>`作为想要插入内容的占位符。\n\n插槽 `slot` 通常用于两个父子组件之间，最常见的应用就是我们使用一些 `UI` 组件库中的弹窗组件时，弹窗组件的内容是可以让我们自定义的，这就是使用了插槽的原理。\n\n- `slot` 是 `Vue3` 中的内置标签。\n- `slot` 相当于给子组件挖出了一个槽，可以用来填充内容。\n- 父组件中调用子组件时，子组件标签之间的内容元素就是要放置的内容，它会把 `slot` 标签替换掉。',2,2,4,3),
(498,'基本使用(slot)','在子组件放置插槽\n\n子组件**child.vue**\n\n```html\n<template>\n  // 匿名插槽\n  <slot/>\n  // 具名插槽\n  <slot name=''title''/>\n  // 作用域插槽\n  <slot name=\"footer\" :scope=\"state\" />\n</template>\n```\n\n父组件\n\n```html\n<template>\n  <child>\n    // 匿名插槽\n    <span>我是默认插槽</span>\n    // 具名插槽\n    <template #title>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n    </template>\n    // 作用域插槽\n    <template #footer=\"{ scope }\">\n      <footer>作用域插槽——姓名：{{ scope.name }}，年龄{{ scope.age }}</footer>\n    </template>\n  </child> \n</template>\n<script setup>\n  // 引入子组件\n  import child from ''./child.vue''\n</script>\n```\n',2,3,4,3),
(499,'插槽简写(slot)','```html\n<Dialog>\n  <template #header>\n    <div>1 </div>    \n  </template>\n  <template #default>\n    <div>2</div>\n  </template>\n  <template #footer>\n    <div>3</div>\n  </template>\n</Dialog>\n```\n\n',2,3,4,1),
(500,'渲染作用域(slot)','插槽内容可以访问到父组件的数据，因为插槽内容本身也是在父组件模板的一部分。\n\n```html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\n这里的两个 `{{ message }}` 插值表达式渲染的内容都是一样的。\n\n插槽内容**无法访问**子组件的数据，请牢记一条规则：\n\n> 任何父组件模板中的东西都是被编译到父组件的作用域中；而任何子组件模板中的东西都只被编译到子组件的作用域中',2,2,4,1),
(501,'默认插槽(slot)','### 默认插槽(slot)\n\n经常会遇到外部没有提供任何内容的情况，此时可能会为插槽提供一个默认的内容来渲染。 SubmitButton组件\n\n```html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\n如果外部没有提供任何插槽内容，我们可能想在 `<button>` 中渲染“提交”这两个字。要让这两个字成为默认内容，需要写在 `<slot>` 标签之间：\n\n```html\n<button type=\"submit\">\n  <slot>\n    提交 <!-- 默认内容 -->\n  </slot>\n</button>\n```\n\n当在父组件中使用 `<submit-button>` 但不提供任何插槽内容：\n\n```html\n<SubmitButton />\n```\n\n那么将渲染出下面这样的 DOM 结构，包含默认的“提交”二字：\n\n```html\n<button type=\"submit\">提交</button>\n```\n\n如果提供了别的内容给插槽,那么渲染的 DOM 中会选择使用提供的插槽内容',2,2,4,1),
(502,'多个插槽(slot)','有时一个组件中可能会有多个插槽的插口。\n\n```html\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n对于这种场景，`<slot>` 元素可以有一个特殊的 attribute `name`，可以是一个独一无二的标识符，用来区分各个插槽，确定每一处最终会渲染的内容：\n\n```html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n没有提供 `name` 的 `<slot>` 插口会隐式地命名为“default”。\n\n在父组件中使用到 `<BaseLayout>` 时，我们需要给各个插槽传入内容，为了模板片段让各入各门、各寻其所。此时就需要用到**具名插槽**了：\n\n要为具名插槽传入内容，我们需要使用一个含 `v-slot` 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：\n\n```html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n',2,2,4,1),
(503,'插槽简写(slot)','`v-slot` 有对应的简写 `#`，\n\n向 `<BaseLayout>` 传递内容的代码，指令均使用的是缩写形式：\n\n```html\n<BaseLayout>\n  <template #header>\n    <h1>这里是一个页面标题</h1>\n  </template>\n\n  <template #default>\n    <p>一个文章内容的段落</p>\n    <p>另一个段落</p>\n  </template>\n\n  <template #footer>\n    <p>这里有一些联系方式</p>\n  </template>\n</BaseLayout>\n```\n\n',2,2,4,1),
(504,'动态插槽名(slot)','动态指令参数在 `v-slot` 上也是有效的，即可以定义下面这样的动态插槽名：\n\n插槽可以是一个变量名 const name = ref(''header'')\n\n```html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- 缩写为 -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n注意这里的表达式和动态指令参数受相同的语法限制',2,2,4,1),
(505,'作用域插槽(slot)','在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时利用父组件域内和子组件域内的数据。要做到这一点，我们需要让子组件将一部分数据在渲染时提供给插槽。\n\n而我们确实也有办法这么做！我们可以像对组件传递 props 那样，向一个插槽的插口上传递 attribute：\n\n```html\n<!-- <MyComponent> 的模板 -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽 props 时，一般的默认插槽和具名插槽的使用方式有了一些小小的区别。下面我们将会展示是怎样的不同，首先是一个默认插槽，通过子组件标签上的 `v-slot` 指令，直接接收到了一个插槽 props 对象：\n\n```html\n<MyComonent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n<MyComponent>\n```\n\n子组件传入插槽的 props 作为了 `v-slot` 指令的值，可以在插槽内的表达式中访问。\n\n可以将作用于插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\n\n```tsx\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = ''hello''\n  return (\n    `<div>${\n      // 在插槽函数调用时传入 props\n      slots.default({ text: greetingMessage, count: 1 })\n    }</div>`\n  )\n}\n```\n\n实际上，这已经和作用域插槽的最终的代码编译结果、以及手动地调用渲染函数的方式非常类似了。\n\n`v-slot=\"slotProps\"` 可以类比这里的函数签名，和函数的参数类似，我们也可以在 `v-slot` 使用：\n\n```tsx\n<MyComonent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n<MyComponent>\n```\n\n',2,2,4,1),
(506,'具名作用域插槽(slot)','具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 `v-slot` 指令的值被访问到：`v-`。当使用缩写时是这样：\n\n```html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ headerProps }}\n  </template>\n</MyComponent>\n```\n\n向具名插槽中传入 props：\n\n```html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\n注意插槽上的 `name` 是由 Vue 保留的，不会作为 props 传递给插槽。因此最终 `headerProps` 的结果是 `{ message: ''hello'' }`。',2,2,4,1),
(507,'provide/inject','### provide/inject\n\n提供 和 注入 是很简单理解的\n\n> 实现跨层级组件(祖孙)间通信\n\n在多层嵌套组件中使用，不需要将数据一层一层地向下传递,可以实现跨层级组件通信\n\n **父组件**\n\n```tsx\nconst info = reactive({\n   title: ''Vue3学习''\n })\n//提供的数据名，数据值\nprovide(''info'', info)\n```\n\n**子组件**\n\n```js\n//获取对应数据的值\nconst color = inject(''info'')\n```\n\n',2,2,4,1),
(508,'应用层Provide','要为组件后代供给数据，需要使用到 `provide()`函数：\n\n```tsx\nimport { provide } from ''vue''\nprovide(/* 注入名 */ ''message'', /* 值 */ ''hello!'')\n```\n\n接收两个参数。第一个参数被称为**注入名**，\n\n第二个参数是供给的值，值可以是任意类型，包括响应式的状态，比如一个 ref：\n\n```tsx\nimport { ref, provide } from ''vue''\n\nconst count = ref(0)\nprovide(''key'', count)\n```\n\n供给的响应式状态使后代组件可以由此和供给者建立响应式的联系。',2,2,4,1),
(509,'Inject(注入)','要注入祖先组件供给的数据，需使用 `inject()`函数：\n\n```tsx\nimport { inject } from ''vue''\nconst message = inject(''message'')\n```\n\n如果供给的值是一个 ref，注入进来的就是它本身，而**不会**自动解套。这使得被注入的组件保持了和供给者的响应性链接。\n\n同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 同步调用：\n\n```tsx\nimport { inject } from ''vue''\nexport default {\n  setup() {\n    const message = inject(''message'')\n    return { message }\n  }\n}\n```\n\n',2,2,4,1),
(510,'provide/inject标注类型','provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型， Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：\n\n```tsx\nimport { provide, inject, InjectionKey } from ''vue''\n\nconst key = Symbol() as InjectionKey<string>\n      \nprovide(key, ''foo'') // 若提供的是非字符串值会导致错误\n\nconst foo = inject(key) // foo 的类型：string | undefined\n```\n\n建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。\n\n当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明：\n\n```tsx\nconst foo = inject<string>(''foo'') // 类型：string | undefined\n```\n\n注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。\n\n当提供了一个默认值后，这个 `undefined` 类型就可以被移除：\n\n```tsx\nconst foo = inject<string>(''foo'', ''bar'') // 类型：string\n```\n\n如果你确定该值将始终被提供，则还可以强制转换该值：\n\n```tsx\nconst foo = inject(''foo'') as string\n```\n\n',2,2,4,1),
(511,'provide/inject传递函数','```tsx\n// 获取歌手详情\nconst getArtistDetail = async () => {\n    let params = {\n        id: route.query.id\n    }\n    await artistDetail(params).then(res => {\n        state.list = res.data.data\n        state.artistName = state.list.artist.name\n    })\n}\n// 获取歌手名称，使用 provide 传递给孙子组件使用\nconst getArtistName = () => {\n    return state.artistName\n}\n// provide 传值\nprovide(\"getArtistName\", getArtistName())\n```\n',2,2,4,1),
(512,'动画(Transition)','提供了两个内置组件，可以制作基于状态变化的过渡和动画：\n\n- `<Transition>` 会在一个元素或组件进入和离开 DOM 时应用动画。\n- `<TransitionGroup>` 会在一个元素或组件被插入到 `v-for` 列表中，或是被移动或从其中移除时应用动画。\n\n除了这两个组件，也可以通过其他技术手段来应用动画，如切换 CSS 类或用状态绑定样式来驱动动画。',2,2,4,2),
(513,'数组语法(v-bind)','1- 数组语法：`[''rose'', ''abc'']`\n2- 三元运算： `[''rose'', ''abc'', isActive ? ''active'': '''']`\n3- 数组中添加对象： `[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]`,这里其实写三元有点复杂，所以数组语法中也支持嵌套对象语法。\n\n```html\n<template id=\"my-app\">\n  <div class=\"cos\" :class=\"[''rose'', ''abc'']\">数组语法1</div>\n  <div class=\"cos\" :class=\"[''rose'', ''abc'', isActive ? ''active'': '''']\">\n    三元运算\n  </div>\n  <div\n       class=\"cos\"\n       :class=\"[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]\"\n       >\n    数组中添加对象\n  </div>\n</template>\n```\n\n```tsx\n<script>\n  const App = {\n    template: \"#my-app\",\n    data() {\n      return {\n        isActive: false,\n        classObj: { active: true, rose: true },\n      };\n    },\n  };\n  Vue.createApp(App).mount(\"#app\");\n</script>\n```\n',2,2,4,5),
(514,'绑定一个对象(v-bind)','我们希望将一个对象的所有属性，绑定到元素上的所有属性，非常简单，可以直接使用 v-bind 绑定一个 对象；\n这种写法在高阶组件中常用。\n案例：info对象会被拆解成div的各个属性\n\n```html\n<div v-bind=\"cos\">属性直接绑定一个对象</div>\n<!-- \n这里是数据：\ncos: {\n    name: ''wang'',\n    age: 28,\n    job: ''web'',\n},\n-->\n```\n',2,7,4,5),
(515,'认识插槽Slot','- 在开发中经常封装一个个可复用的组件：\n\n- - 前面通过props传递给组件一些数据，让组件来进行展示；\n  - 但是为了让这个组件具备更强的通用性，不能将组件中的内容限制为固定的div、span等等元素；\n  - 比如某种情况下希望组件显示的是一个按钮，某种情况下希望显示的是一张图片；\n  - 所以，应该让使用者可以决定某一块区域到底存放什么内容和元素；',2,2,4,3),
(516,'如何使用插槽slot','- 定义插槽slot：\n\n- - 插槽的使用过程其实是抽取共性、预留不同；\n  - 将共同的元素、内容依然在组件内进行封装；\n  - 同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素；\n\n- 如何使用slot呢？\n\n- - Vue中将 <slot> 元素作为承载分发内容的出口；\n  - 在封装组件中，使用特殊的元素<slot>就可以为封装组件开启一个插槽；\n  - 该插槽插入什么内容取决于父组件如何使用；',2,2,4,3),
(517,'Transition组件','vue提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',2,2,4,2),
(518,'基于CSS的过渡','过渡 CSS 类\n\n有 6 个应用于进入与离开过渡效果的 CSS 类。\n\n1. `v-enter-from`：进入动画的起始状态。这个 CSS 类在元素插入之前添加，在元素插入完成后的下一帧移除。\n2. `v-enter-active`：进入动画的生效状态，应用于整个进入动画阶段。这个 CSS 类在元素被插入之前被添加，在过渡/动画完成之后移除。这个类可以用来定义进入动画的持续时间、延迟与速度曲线类型。\n3. `v-enter-to`：进入动画的结束状态。这个 CSS 类在元素插入完成后的下一帧被添加 (也就是 `v-enter-from` 被移除的同时)，在过渡/动画完成之后移除。\n4. `v-leave-from`：离开动画的起始状态，在离开过渡效果被触发时立即添加，在一帧后被移除。\n5. `v-leave-active`：离开动画的生效状态，应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡/动画完成之后移除。这个类可以用来定义离开动画的持续时间、延迟与速度曲线类型。\n6. `v-leave-to`：离开动画的结束状态。这个 CSS 类在一个离开动画被触发后的下一帧被添加 (也就是 `v-leave-from` 被移除的同时)，在过渡/动画完成之后移除。\n\n`v-enter-active` 和 `v-leave-active` 给了我们为进入和离开动画指定不同速度曲线的能力。',2,2,4,2),
(519,'为过渡命名','可以通过一个 `name` prop 来声明一种过渡：\n\n```html\n<Transition name=\"fade\">\n  ...\n</Transition>\n```\n\n对于一个有名字的过渡，它的过渡相关 CSS 类会以其名字而不是 `v` 作为前缀。举个例子，上面被应用的 CSS 类将会是 `fade-enter-active` 而不是 `v-enter-active`。这个“fade”过渡的 CSS 类将会是这样：\n\n```css\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n```\n',2,2,4,2),
(520,'Transition搭配CSS','`<Transition>` 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 `transition` CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n\n下面是一个更高级的例子，使用不同的持续时间和速度曲线来过渡多个属性：\n\n```html\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n\n\n\n### CSS的animation',2,2,4,2),
(521,'CSS中的Animation','原生 CSS 动画和 CSS trasition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。\n\n对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` 类下面声明它们。下面是一个示例：\n\n```html\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    你好！你会看到这里正在跳跃！\n  </p>\n</Transition>\n```\n\n```css\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n',2,2,4,2),
(522,'自定义过渡类','你也可以向 `<Transition>` 传递以下的 props 来指定自定义的过渡类：\n\n- `enter-from-class`\n- `enter-active-class`\n- `enter-to-class`\n- `leave-from-class`\n- `leave-active-class`\n- `leave-to-class`\n\n你传入的这些类会覆盖相应阶段的默认类名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如Animate.css\n\n```html\n<!-- 假设你已经引入了 Animate.css -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n',2,2,4,2),
(523,'同时使用Transition和Animation','Vue 需要附加事件侦听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。如果你仅仅使用二者其中之一，Vue 可以自动探测到正确的类型。\n\n然而在某些场景中，你或许想要在同一个元素上同时使用它们两个，举个例子，触发了一个 CSS 动画的同时，由于副作用触发了另一个 CSS 过渡。此时你需要显式地传入 `type` prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`：\n\n```html\n<Transition type=\"animation\">...</Transition>\n```\n',2,2,4,2),
(524,'深层级过渡与显式过渡时间','尽管过渡类仅能应用在 `<Transition>` 的直接子元素上，我们还是可以使用深层级的 CSS 选择器，使深层级的元素发生过渡。\n\n```html\n<Transition name=\"nested\">\n  <div v-if=\"show\" class=\"outer\">\n    <div class=\"inner\">\n      Hello\n    </div>\n  </div>\n</Transition>\n```\n\n```css\n/* 应用于深层级元素的规则 */\n.nested-enter-active .inner,\n.nested-leave-active .inner {\n  transition: all 0.3s ease-in-out;\n}\n\n.nested-enter-from .inner,\n.nested-leave-to .inner {\n  transform: translateX(30px);\n  opacity: 0;\n}\n```\n\n我们甚至可以在深层级的元素上添加一个过渡延迟，这会创建一个交错进入动画序列：\n\n```css\n/* 延迟进入深层级元素以获得交错效果 */\n.nested-enter-active .inner {\n  transition-delay: 0.25s;\n}\n```\n\n然而，这会带来一个小问题。默认情况下，`<Transition>` 组件会通过监听过渡根元素上的**第一个** `transitionend` 或者 `animationend` 事件来尝试自动判断过渡何时结束。而在深层级的过渡中，期望的行为应该是等待所有内部元素的过渡完成。\n\n在这种情况下，你可以通过向 `<Transition>` 组件传入 `duration` prop 来显式指定的过渡持续时间 (以毫秒为单位)。总持续时间应该匹配延迟加上内部元素的过渡持续时间：\n\n```html\n<Transition :duration=\"550\">...</Transition>\n```\n\n如果有必要的话，你也可以用对象的形式传入，分开指定进入和离开所需的时间：\n\n```html\n<Transition :duration=\"{ enter: 500, leave: 800 }\">...</Transition>\n```\n',2,2,4,2),
(525,'JavaScript钩子','你可以通过监听 `<Transition>` 组件事件的方式在过渡过程中挂上钩子函数：\n\n```html\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\n\n```\n\n```tsx\n// 在元素被插入到 DOM 之前被调用\n// 用这个来设置元素的 \"enter-from\" 状态\nfunction onBeforeEnter(el) {},\n\n// 在元素被插入到 DOM 之后的下一帧被调用\n// 用这个来开始进入动画\nfunction onEnter(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 当进入过渡完成时调用。\nfunction onAfterEnter(el) {}\nfunction onEnterCancelled(el) {}\n\n// 在 leave 钩子之前调用\n// 大多数时候，你应该只会用到 leave 钩子\nfunction onBeforeLeave(el) {}\n\n// 在离开过渡开始时调用\n// 用这个来开始离开动画\nfunction onLeave(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 在离开过渡完成、\n// 且元素已从 DOM 中移除时调用\nfunction onAfterLeave(el) {}\n\n// 仅在 v-show 过渡中可用\nfunction leaveCancelled(el) {}\n```\n\n这些钩子可以与 CSS 过渡/动画结合使用，也可以单独使用。\n\n在使用仅由 JavaScript 执行的动画时，最好是添加一个 `:css=\"false\"` prop。这显式地向 Vue 表明跳过 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡。\n\n```html\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n```\n\n在有了 `:css=\"false\"` 后，我们就全权自己负责控制什么时候过渡结束了。这种情况下对于 `@enter` 和 `@leave` 钩子来说，回调函数 `done` 就是必须的。否则，钩子将被同步调用，过渡将立即完成。',2,2,4,2),
(526,'可重用过渡','得益于 Vue 的组件系统，过渡是可以被重用的。要创建一个可被重用的过渡，我们需要为 `<Transition>` 组件创建一个包裹组件，并向内传入插槽内容：\n\n```html\n<!-- MyTransitio.vue -->\n<script>\n// JavaScript 钩子逻辑...\n</script>\n\n<template>\n  <!-- 包裹内置的 Transition 组件 -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- 向内传递插槽内容 -->\n  </Transition>\n</tempalte>\n\n<style>\n/*\n  必要的 CSS...\n  注意：避免在这里使用 <style scoped>\n  因为那不会应用到插槽内容上\n*/\n</style>\n```\n\n现在 `MyTransition` 可以在导入后像内置组件那样使用了：\n\n```html\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\n```\n\n',2,2,4,2),
(527,'出现时过渡','如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 `appear` attribute：\n\n```html\n<Transition appear>\n  ...\n</Transition>\n```\n',2,2,4,2),
(528,'过渡模式','### \n\n在之前的例子中，进入和离开的元素都是在同时开始动画的，并且我们必须将它们设为 `position: absolute` 以避免二者同时存在时出现的布局问题。\n\n然而，在某些场景中这可能不是个好的方案，或者并不能符合行为预期。我们可能想要先执行离开动画，然后在其完成**之后**再执行元素的进入动画。手动编排这样的动画是非常复杂的，好在我们可以通过向 `<Transition>` 传入一个 `mode` prop 来实现这个行为：\n\n```html\n<Transition mode=\"out-in\">\n  ...\n</Transition>\n```\n\n将之前的例子改为 `mode=\"out-in\"` 后是这样：\n\n`<Transition>` 也支持 `mode=\"in-out\"`，虽然这并不常用。',2,2,4,2),
(530,'组件间过渡','`<Transition>` 也可以用在动态组件之间：\n\n```html\n<Transition name=\"fade\" mode=\"out-in\">\n  <component :is=\"activeComponent\"></component>\n</Transition>\n```\n\n',2,2,4,2),
(531,'动态过渡','`<Transition>` 的 props (比如 `name`) 也可以是动态的！这让我们可以根据状态变化动态地应用不同类型的过渡：\n\n```html\n<Transition :name=\"transitionName\">\n  <!-- ... -->\n</Transition>\n```\n\n当你使用 Vue 的过渡类约定规则定义了 CSS 过渡/动画，并想在它们之间切换时，这可能很有用。\n\n你也可以根据你的组件的当前状态在 JavaScript 过渡钩子中应用不同的行为。在此篇的最后，我们可以得出结论，创建动态过渡的终极方式是创建可重用的过渡组件，这些组件接受 prop 来改变过渡的性质。现在在编写动画时，就只有你想不到，没有做不到的了。',1,2,4,2),
(532,'控制动画时长','就是我们不管CSS中的动画和过渡时长，以标签为准。可以绑定属性`<transition :duration=\"1000\">` 来控制时长，意思是1秒后，结束动画和过渡。',2,2,4,2),
(533,'过度&动画的使用','```html\n<template>\n  <div id=\"app\">\n    <router-view v-slot=\"{ Component }\">\n      <transition name=\"fade\">\n        <keep-alive>\n          <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n        </keep-alive>\n      </transition>\n      <transition name=\"fade\">\n        <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n      </transition>\n    </router-view>\n  </div>\n</template>\n```\n\n```js\n\n<style lang=\"scss\">\n\n/* 可以为进入和离开动画设置不同的持续时间和动画函数 */\n.fade-enter-active {\n  //进入过程\n  animation: fade-in 0.8s cubic-bezier(0.39, 0.575, 0.565, 1) both;\n}\n.fade-leave-active {\n  //离开过程\n  animation: fade-out 0.3s ease-out both;\n}\n//进入开始和离开结束的状态\n.fade-enter-to {\n  opacity: 0;\n}\n//进入开始和离开结束的状态\n.fade-leave-to {\n  opacity: 0;\n}\n\n@keyframes fade-in {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes fade-out {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n```\n',2,3,4,2),
(534,'动态切换组件','```html\n<template>\n    <div class=\"dynamicComponent\">\n        <ul>\n            <li v-for=\"(item, index) in tabList\" :key=\"index\" @click=\"change(index)\">{{ item.name }}</li>\n        </ul>\n        <!-- is的值是哪个组件的名称就显示哪个组件 -->\n        <component :is=\"state.com\"></component>\n    </div>\n</template>\n```\n\n```tsx\n//<script setup name=\"funcDynamicComponent\">\nimport A from ''./component/A.vue''\nimport B from ''./component/B.vue''\nimport C from ''./component/C.vue''\n\n// 因为 reactive 是响应式数据 proxy 但是组件确不需要响应式，所有需要使用 markRaw 或者 shallowRef 来避免\nconst tabList = reactive([\n    { name: ''A 组件'', com: markRaw(A) },\n    { name: ''B 组件'', com: markRaw(B) },\n    { name: ''C 组件'', com: markRaw(C) },\n])\nconst state = reactive({\n    com: tabList[0].com,\n})\n\n// 切换组件\nconst change = (index) => {\n    state.com = tabList[index].com\n}\n//</script>\n```\n',2,3,4,4),
(535,'动态切换组件2','```html\n<template>\n    <component :is=\"component[state.activeName]\" @closeDialog=\"closeDialog\" />\n</template>\n```\n\n```tsx\n//<script setup>\nimport Dashboard from ''./component/dashboard.vue'' // 登录指示板\nimport Code from ''./component/code.vue'' // 扫码登录\nimport Email from ''./component/email.vue'' // 邮箱登录\n\n// 跟踪自身 .value 变化的 ref，配合 component 使用\nconst component = shallowRef({\n	dashboard: Dashboard,\n	code: Code,\n	email: Email,\n})\n\n// 定义响应式数据\nconst state = reactive({\n	activeName: ''dashboard'', // 登录方式\n})\n//</script>\n```\n\n',2,3,4,4),
(536,'滚动属性','| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| **clientWidth**  | 获取元素可视部分的宽度，即 CSS 的 width 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域。 |\n| **clientWidth**  | 获取元素可视部分的高度，即 CSS 的 height 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域。 |\n| **offsetWidth**  | 元素在页面中占据的宽度总和，包括 width、padding、border 以及滚动条的宽度。 |\n| **offsetHeight** | 只读属性，返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 |\n| **scrollWidth**  | 只读属性，是元素内容宽度的一种度量，括由于溢出导致的视图中不可见内容。 |\n| **scrollHeight** | 只读属性，是元素内容宽度的一种度量，括由于溢出导致的视图中不可见内容。 |\n| **scrollTop**    | 可以获取或设置一个元素的内容垂直滚动的像素数。               |\n| **scrollLeft**   | 可以读取或设置元素滚动条到元素左边的距离。                   |\n\n\n',2,3,4,6),
(537,'横向滚动','```js\n// HTML\n<div ref=\"xxxRef\"></div>\n<button @click=\"onScroll(''left'')\"></button>\n<button @click=\"onScroll(''right'')\"></button>\n \n// JS\nimport { ref, nextTick } from ''vue''\nconst xxxRef = ref(null)\nconst onScroll = (type) => {\n  nextTick(() => {\n    const distance = type === ''left'' ? 0 : xxxRef.value.scrollWidth;\n    xxxRef.value.scrollLeft = distance\n  })\n}\n```\n',2,3,4,6),
(538,'竖向滚动','```js\n// HTML\n<div ref=\"xxxRef\"></div>\n<button @click=\"onScroll(''top'')\">顶部</button>\n<button @click=\"onScroll(''bottom'')\">底部</button>\n \n// JS\nimport { ref, nextTick } from ''vue''\nconst xxxRef = ref(null)\nconst onScroll = (type) => {\n  nextTick(() => {\n    const distance = type === ''top'' ? 0 : xxxRef.value.scrollHeight;\n    xxxRef.value.scrollTop = distance\n  })\n}\n```\n',2,3,4,6),
(539,'滑动指定位置','```js\n  <button @click=\"onScroll2(200)\">下滑</button>\n  <button @click=\"onScroll3(200)\">上划</button>\n  <div ref=\"xxxRef\"></div>\n  \n  const onScroll2 = (type: number) => {\n  nextTick(() => {\n    xxxRef.value.scrollTop += type\n  })\n}\nconst onScroll3 = (type: number) => {\n  nextTick(() => {\n    xxxRef.value.scrollTop -= type\n  })\n}\n```\n',2,3,4,6),
(540,'丝滑滚动','``` css\nscroll-behavior: smooth;\n```\n\n\n',2,3,4,6),
(541,'网页文件下载','```tsx\nconst confirm = async (names: string, path: string) => {\n  let fileName = names + path.slice(-4)\n  await common.FileDownload(path).then((res: any) => {\n    // 地址转换\n    let url = window.URL.createObjectURL(res.data)\n    console.log(''%c [ url ]-32'', ''font-size:13px; background:pink; color:#bf2c9f;'', url)\n    // 文件名\n\n    const a = document.createElement(''a'')\n    a.setAttribute(''href'', url)\n    a.setAttribute(''download'', fileName)\n    document.body.append(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  message.success(''Click on Yes'')\n}\n```\n',2,3,4,5),
(542,'axios方法调用','```tsx\n //常用\n await computer.Get(data).then(r => {\n    rData = r.data\n  })\n  //简化\nrData = await (await computer.Get(data)).data\n```\n\n',3,3,4,5),
(543,'CSS变量注入','```tsx\n<template>\n  <span>变量注入</span>  \n</template>\n<script lang=\"ts\" setup>\n  import { ref } from ''vue''\n  const color = ref(''red'')\n</script>\n<style scoped>\n  span {\n    /* 使用v-bind绑定组件中定义的变量 */\n    color: v-bind(''color'');\n  }  \n</style>\n```\n',2,3,4,5),
(544,'JS隐式类型转换','// 字符串转数字代码对比 \n\n```js\nconst price = parseInt(''32''); //传统方式\nconst price = Number(''32''); //传统方式\nconst price = +''32''; //新方式\n```\n\n// 日期转换为时间戳代码对比 \n\n```js\nconst timeStamp = new Date().getTime(); //传统方式\nconst timeStamp = +new Date(); //新方式\n```\n\n//布尔转数字新方式\n\n```js\nconsole.log(+true); // Return: 1\nconsole.log(+false); // Return: 0\n```\n\n',6,3,4,5),
(545,'动态导入css样式','**dynamicScss.ts**\n\n```ts\nconst SCSS: number = 1\nasync function toScss(nameCss: string) {\n  switch (nameCss) {\n    case ''sAbout'':\n      if (SCSS === 1) {\n        import(''../views/sAbout/index.scss'')\n      }\n      break\n    case ''index'':\n      if (SCSS === 1) {\n        import(''../views/sAbout/index.scss'')\n      }\n  }\n}\nexport default toScss\n```\n\n```tsx\nimport { toScss } from \"../../hooks/dynamicScss\";\nawait toScss(\"sAbout\");\n```\n\n',2,3,4,5),
(546,'封装ts属性','**data.ts**\n\n```tsx\nimport { reactive } from \"vue\";\nexport interface BlogsList {\n  rData: any, // 显示的数据\n  page: number, //页码\n  pagesize: number, //每页条数\n  count: number, //总数\n}\n\nexport const blogsList: BlogsList = reactive({\n  rData: [],\n  page: 1,\n  pagesize: 10,\n  count: 0,\n})\n```\n\n **vue**\n\n```tsx\nimport { blogsList } from \"../Blogs/components/data\";\n```\n',2,3,4,5),
(547,'函数封装',' **index.ts**\n\n```tsx\nexport class blogs {\n\n  static async Getxxx() {\n    await article.GetFyAsync(page,pagesize).then((r: any) => {\n      return rData = r.data;\n    });\n  }\n}\n```\n\n**index.vue**\n\n```ts\nimport { blogs } from \"./index\";\nawait blogs.Getxxx();\n```\n\n',2,3,4,5),
(548,'模板调试','场景:在Vue开发过程中, 经常会遇到template模板渲染时JavaScript变量出错的问题, 此时也许你会通过console.log来进行调试 这时可以在开发环境挂载一个 log 函数\n\n```html\n// main.js\napp.config.globalProperties.$log = window.console.log\n// 组件内部\n<div>{{$log(info)}}</div>\n```\n',2,3,4,5),
(549,'校验数据类型','```js\nexport const typeOf = function(obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()\n}\n```\n\n```js\ntypeOf(''树哥'')  // string\ntypeOf([])  // array\ntypeOf(new Date())  // date\ntypeOf(null) // null\ntypeOf(true) // boolean\ntypeOf(() => { }) // function\n```\n\n',6,3,4,5),
(550,'大小写转换','**参数：**\n\n- str 待转换的字符串\n- type 1-全大写 2-全小写 3-首字母大写\n\n```js\nexport const turnCase = (str, type) => {\n  switch (type) {\n    case 1:\n      return str.toUpperCase()\n    case 2:\n      return str.toLowerCase()\n    case 3:\n      //return str[0].toUpperCase() + str.substr(1).toLowerCase() // substr 已不推荐使用\n      return str[0].toUpperCase() + str.substring(1).toLowerCase()\n    default:\n      return str\n  }\n}\n```\n\n```js\nturnCase(''vue'', 1) // VUE\nturnCase(''REACT'', 2) // react\nturnCase(''vue'', 3) // Vue\n```\n',2,3,4,5),
(551,'解析URL参数','```js\nexport const getSearchParams = () => {\n  const searchPar = new URLSearchParams(window.location.search)\n  const paramsObj = {}\n  for (const [key, value] of searchPar.entries()) {\n    paramsObj[key] = value\n  }\n  return paramsObj\n}\n```\n\n```js\n// 假设目前位于 https://****com/index?id=154513&age=18;\ngetSearchParams(); // {id: \"154513\", age: \"18\"}\n```\n',6,3,4,5),
(552,'判断手机是Andoird还是IOS','```js\n/** \n * 1: ios\n * 2: android\n * 3: 其它\n */\nexport const getOSType=() => {\n  let u = navigator.userAgent, app = navigator.appVersion;\n  let isAndroid = u.indexOf(''Android'') > -1 || u.indexOf(''Linux'') > -1;\n  let isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n  if (isIOS) {\n    return 1;\n  }\n  if (isAndroid) {\n    return 2;\n  }\n  return 3;\n}\n```\n',6,3,4,5),
(553,'生成UUID','```js\nfunction uuid() {\n  var temp_url = URL.createObjectURL(new Blob());\n  var uuid = temp_url.toString(); // blob:https://xxx.com/b250d159-e1b6-4a87-9002-885d90033be3\n  URL.revokeObjectURL(temp_url);\n  return uuid.substr(uuid.lastIndexOf(\"/\") + 1);\n}\n```\n',6,3,4,5),
(555,'使用&&替代if','```js\nconst doSometions = () => {}\nconst isTrue = true\nlet temp = ''''\nif(isTrue){\n    doSometings()\n    temp = ''isTrue''\n}\n\n// 替代方案\nisTrue && this.doSometings()\nisTrue && (temp == ''isTrue'')\n```\n',6,3,4,5),
(556,'数组对象根据字段去重','**参数：**\n\n- arr 要去重的数组\n- key 根据去重的字段名\n\n```js\nexport const uniqueArrayObject = (arr = [], key = ''id'') => {\n  if (arr.length === 0) return\n  let list = []\n  const map = {}\n  arr.forEach((item) => {\n    if (!map[item[key]]) {\n      map[item[key]] = item\n    }\n  })\n  list = Object.values(map)\n\n  return list\n}\n```\n\n```js\nconst responseList = [\n    { id: 1, name: ''树哥'' },\n    { id: 2, name: ''黄老爷'' },\n    { id: 3, name: ''张麻子'' },\n    { id: 1, name: ''黄老爷'' },\n    { id: 2, name: ''张麻子'' },\n    { id: 3, name: ''树哥'' },\n    { id: 1, name: ''树哥'' },\n    { id: 2, name: ''黄老爷'' },\n    { id: 3, name: ''张麻子'' },\n]\n\nuniqueArrayObject(responseList, ''id'')\n// [{ id: 1, name: ''树哥'' },{ id: 2, name: ''黄老爷'' },{ id: 3, name: ''张麻子'' }]\n```\n\n',6,3,4,7),
(557,'滚动到元素位置','```js\nexport const smoothScroll = element =>{\n    document.querySelector(element).scrollIntoView({\n        behavior: ''smooth''\n    });\n};\n```\n\n```js\nsmoothScroll(''#target''); // 平滑滚动到 ID 为 target 的元素\n```\n',6,3,4,6),
(559,'三元运算符简化ifelse','```js\n//Longhand \nlet marks = 26; \nlet result; \nif (marks >= 30) {\n   result = ''Pass''; \n} else { \n   result = ''Fail''; \n} \n//Shorthand \nlet result = marks >= 30 ? ''Pass'' : ''Fail'';\n```\n',6,3,4,8),
(560,'||运算符给变量指定默认值','本质是利用了`||`运算符的特点，当前面的表达式的结果转成布尔值为`false`时，则值为后面表达式的结果\n\n短路运算有时候可以用来代替一些比较简单的 `if else`\n\n```js\n//Longhand\nlet imagePath;\nlet path = getImagePath();\n\nif (path !== null && path !== undefined && path !== '''') {\n    imagePath = path;\n} else {\n    imagePath = ''default.jpg'';\n}\n\n//Shorthand\nlet imagePath = getImagePath() || ''default.jpg'';\nlet c = a || b\n```\n\n',6,3,4,8),
(561,'使用字符串模板简化代码','```js\n//Longhand\nconsole.log(''You got a missed call from '' + number + '' at '' + time);\n//Shorthand\nconsole.log(`You got a missed call from ${number} at ${time}`);\n```\n\n',6,3,4,5),
(562,'网页跳转','```tsx\n  //当前窗口跳转\n   self.location.href=url\n  //新窗口跳转\n   window.open(url)\n  //跳转链接 返回上一页\n   window.history.back(-1);\n```\n\n self 指代当前窗口对象，属于window 最上层的对象。\n\n  location.href 指的是某window对象的url的地址\n\n  self.location.href 指当前窗口的url地址，去掉self默认为当前窗口的url地址，一般用于防止外部的引用\n\ntop.location.href:为引用test.html页面url的**父窗口对象的url**',6,3,4,5),
(563,'取最后一位数字','```javascript\nconst num = 12345\nconst num2 = ''54321''\nconsole.log(num%10) // 5\nconsole.log(num2%10) // 1 当然隐式转换也是可以的\n```\n\n',6,3,4,5),
(564,'滚动到页面顶部','```js\nconst goToTop = () => window.scrollTo(0, 0);\ngoToTop();\n```\n',6,3,4,6),
(565,'判断简化','如果有下面的这样的一个判断：\n\n```javascript\nif(a === undefined || a === 10 || a=== 15 || a === null) {\n    //...\n}\n```\n\n就可以使用数组来简化这个判断逻辑：\n\n```javascript\nif([undefined, 10, 15, null].includes(a)) {\n    //...\n}\n```\n\n这样代码就会简洁很多，并且便于扩展，如果还有需要等于a的判断，直接在数组中添加即可。',6,3,4,8),
(566,'一元运算符简化字符串转数字','```js\n//Longhand\nlet total = parseInt(''453'');\nlet average = parseFloat(''42.6'');\n\n//Shorthand\nlet total = +''453'';\nlet average = +''42.6'';\n```\n\n',6,3,4,8),
(567,'清空数组','如果想要清空一个数组，可以将数组的length置于0:\n\n```javascript\nlet array = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\narray.length = 0 \nconsole.log(array)  // []\n```\n\n',6,3,4,7),
(568,'验证undefined和null','如果有这样一段代码：\n\n```javascript\nif(a === null || a === undefined) {\n    doSomething()\n}\n```\n\n也就是如果需要验证一个值如果等于null或者undefined时，需要执行一个操作时，可以使用空值合并运算符来简化上面的代码：\n\n```javascript\na ?? doSomething()\n```\n',6,3,4,5),
(569,'组元素转化为数字','如果有一个数组，想要把数组中的元素转化为数字，可以使用map方法来实现：\n\n```javascript\nconst array = [''12'', ''1'', ''3.1415'', ''-10.01''];\narray.map(Number);  // [12, 1, 3.1415, -10.01]\n```\n',6,3,4,7),
(570,'检查日期是否有效','该方法用于检测给出的日期是否有效：\n\n```javascript\nconst isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());\n\nisDateValid(\"December 17, 1995 03:24:00\");  // true\n```\n',6,3,4,9),
(571,'计算两个日期之间的间隔','该方法用于计算两个日期之间的间隔时间：\n\n```javascript\nconst dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\n\ndayDif(new Date(\"2021-11-3\"), \n       new Date(\"2022-2-1\"))  // 90\n```\n\n距离过年还有90天~',6,3,4,9),
(572,'查找日期位于一年中的第几天','该方法用于检测给出的日期位于今年的第几天：\n\n```javascript\nconst dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayOfYear(new Date());   // 307\n```\n\n2021年已经过去300多天了~',6,3,4,9),
(573,'全局挂载','```tsx\n//main\nimport axios from ''./api/axios''\nconst app = createApp(App);\n// 全局ctx(this) 上挂载 $axios\napp.config.globalProperties.$api = axios\n\n//vue\nconst { proxy }: any = getCurrentInstance() //获取上下文实例，ctx=vue2的this\n proxy.$api\n```\n',2,3,4,5),
(574,'简化consolelog','\n\n进行调试时书写很多console.log()就会比较麻烦，使用以下形式来简化：\n\n```javascript\nconst c = console.log.bind(document) \nc(996) \nc(\"hello world\")\n```\n',6,3,4,5),
(575,'生成长度为N的数组','\n```js\n// 生成长度为100的数组\nconst arrN = [...Array(100).keys()]\n// [0,1,2,3,...,99]\n```\n',6,3,4,7),
(576,'取整','```javascript\nconst num = 123.456\nconsole.log(num | 0) // 123\n```\n',6,3,4,5),
(577,'邮箱验证','```js\nexport const isEmail = (e) => {\nreturn /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(e)\n}\n```\n',6,3,4,5),
(578,'手机号码','\n\n```js\nexport const isMobile = (e) => {\nreturn /^1[0-9]{10}$/.test(e)\n}\n```\n',6,3,4,5),
(579,'带有多个条件的 if 语句','```js\n//longhand\nif (x === ''abc'' || x === ''def'' || x === ''ghi'' || x ===''jkl'') {\n    //logic\n}\n//shorthand\nif ([''abc'', ''def'', ''ghi'', ''jkl''].includes(x)) {\n   //logic\n}\n```\n',6,3,4,8),
(580,'简化 if true...else','对于不包含大逻辑的 if-else 条件，可以使用下面的快捷写法。我们可以简单地使用三元运算符来实现这种简化。\n\n```js\n// Longhand\nlet test: boolean;\nif (x > 100) {\n  test = true;\n} else {\n  test = false;\n}\n// Shorthand\nlet test = x > 10 ? true : false;\n//或者我们也可以直接用\nlet test = x > 10;\nconsole.log(test);\n```',6,3,4,5),
(581,'声明变量','想要声明两个具有相同的值或相同类型的变量时，可以使用这种简写。\n\n```js\n//Longhand\nlet test1;\nlet test2 = 1;\n//Shorthand\nlet test1,\n  test2 = 1;\n```',6,3,4,5),
(582,'null、undefined 和空值检查','我们创建了新变量，有时候想要检查引用的变量是不是为非 null 或 undefined。JavaScript 确实有一个很好的快捷方式来实现这种检查。\n\n```js\n// Longhand\nif (test1 !== null || test1 !== undefined || test1 !== '''') {\n  let test2 = test1;\n}\n// Shorthand\nlet test2 = test1 || '''';\n```',6,3,4,5),
(583,'滚动监听','\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop\n  // 可视区的高度\n  const { clientHeight } = document.documentElement\n  if (scrollTop > clientHeight) {\n    hHead.value = false\n  } else {\n    hHead.value = true\n  }\n}\n\nonDeactivated(() => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll)\n})\nonMounted(async () => {\n  await GetType()\n  // 给window添加一个滚动监听事件\n  window.addEventListener(''scroll'', scroll)\n})\n```\n\n',2,3,4,6),
(584,'给多个变量赋值','想给多个不同的变量赋值时，这种技巧非常有用。\n\n```js\n//Longhand\nlet test1, test2, test3;\ntest1 = 1;\ntest2 = 2;\ntest3 = 3;\n//Shorthand\nlet [test1, test2, test3] = [1, 2, 3];\n```',6,3,4,5),
(585,'简便的赋值操作符','编程过程中，我们要处理大量的算术运算符。这是 JavaScript 变量赋值操作符的有用技巧之\n\n```js\n// Longhand\ntest1 = test1 + 1;\ntest2 = test2 - 1;\ntest3 = test3 * 20;\n// Shorthand\ntest1++;\ntest2--;\ntest3 *= 20;\n```',6,3,4,8),
(586,'if 判断值是否存在','这是我们都在使用的一种常用的简便技巧，在这里仍然值得再提一下。\n\n```js\n// Longhand\nif (test1 === true) or if (test1 !== \"\") or if (test1 !== null)\n// Shorthand //检查空字符串、null或者undefined\nif (test1)\n```\n\n注意：如果 test1 有值，将执行 if 之后的逻辑，这个操作符主要用于 null 或 undefinded 检查。',6,3,4,11),
(587,'用于多个条件判断的 && 操作符','如果只在变量为 true 时才调用函数，可以使用 && 操作符。\n\n```js\n//Longhand\nif (test1) {\n  callMethod();\n}\n//Shorthand\ntest1 && callMethod();\n```',6,3,4,11),
(588,'for each循环','这是一种常见的循环简化技巧。\n\n```js\n// Longhand\nfor (var i = 0; i < testData.length; i++)\n// Shorthand\nfor (let i in testData) or  for (let i of testData)\n```\n\n遍历数组的每一个变量。\n\n```js\nfunction testData(element, index, array) {\n  console.log(''test['' + index + ''] = '' + element);\n}\n[11, 24, 32].forEach(testData);\n// logs: test[0] = 11, test[1] = 24, test[2] = 32\n```',6,3,4,12),
(589,'比较后返回','我们也可以在 return 语句中使用比较，它可以将 5 行代码减少到 1 行。\n\n```javascript\n// Longhand\nlet test;\nfunction checkReturn() {\n  if (!(test === undefined)) {\n    return test;\n  } else {\n    return callMe(''test'');\n  }\n}\nvar data = checkReturn();\nconsole.log(data); //output test\nfunction callMe(val) {\n  console.log(val);\n}\n// Shorthand\nfunction checkReturn() {\n  return test || callMe(''test'');\n}\n```',6,3,4,11),
(590,'箭头函数','```js\n//Longhand\nfunction add(a, b) {\n  return a + b;\n}\n//Shorthand\nconst add = (a, b) => a + b;\n```\n\n更多例子：\n\n```js\nfunction callMe(name) {\n  console.log(''Hello'', name);\n}\ncallMe = (name) => console.log(''Hello'', name);\n```',6,3,4,13),
(591,'简短的函数调用','我们可以使用三元操作符来实现多个函数调用。\n\n```js\n// Longhand\nfunction test1() {\n  console.log(''test1'');\n}\nfunction test2() {\n  console.log(''test2'');\n}\nvar test3 = 1;\nif (test3 == 1) {\n  test1();\n} else {\n  test2();\n}\n// Shorthand\n(test3 === 1 ? test1 : test2)();\n```',6,3,4,13),
(592,'switch简化','我们可以将条件保存在键值对象中，并根据条件来调用它们。\n\n```js\n// Longhand\nswitch (data) {\n  case 1:\n    test1();\n    break;\n  case 2:\n    test2();\n    break;\n  case 3:\n    test();\n    break;\n  // ...\n}\n// Shorthand\nvar data = {\n  1: test1,\n  2: test2,\n  3: test\n};\ndata[something] && data[something]();\n```',6,3,4,5),
(593,'隐式返回','通过使用箭头函数，我们可以直接返回值，不需要 return 语句。\n\n```javascript\n//longhand\nfunction calculate(diameter) {\n  return Math.PI * diameter\n}\n//shorthand\ncalculate = diameter => (\n  Math.PI * diameter;\n)\n```',6,3,4,13),
(594,'指数表示法','```js\n// Longhand\nfor (var i = 0; i < 10000; i++) { ... }\n// Shorthand\nfor (var i = 0; i < 1e4; i++) {\n```',6,3,4,12),
(595,'默认参数值','```js\n//Longhand\nfunction add(test1, test2) {\n  if (test1 === undefined) test1 = 1;\n  if (test2 === undefined) test2 = 2;\n  return test1 + test2;\n}\n//shorthand\nadd = (test1 = 1, test2 = 2) => test1 + test2;\nadd(); //输出结果: 3\n```',6,3,4,13),
(596,'undefined检查和默认赋值','```js\nlet test1 = undefined,\n    test2 = test1 || '''';\nconsole.log(\"undefined check\", test2); // 输出 \"\"\n```\n\n一般值检查\n\n```js\nlet test1 = ''test'',\n  test2 = test1 || '''';\nconsole.log(test2); // 输出: ''test''\n```\n\n**另外，对于上述的 4、5、6 点，都可以使用?? 操作符。**\n\n如果左边值为 null 或 undefined，就返回右边的值。默认情况下，它将返回左边的值。\n\n```js\nconst test = null ?? ''default'';\nconsole.log(test);\n// 输出结果: \"default\"\nconst test1 = 0 ?? 2;\nconsole.log(test1);\n// 输出结果: 0  \n```',6,3,4,10),
(597,'延展操作符简化','```js\n//longhand\n// 使用concat连接数组\nconst data = [1, 2, 3];\nconst test = [4, 5, 6].concat(data);\n//shorthand\n// 连接数组\nconst data = [1, 2, 3];\nconst test = [4, 5, 6, ...data];\nconsole.log(test); // [ 4, 5, 6, 1, 2, 3]\n```\n\n我们也可以使用延展操作符进行克隆。\n\n```js\n//longhand\n// 克隆数组\nconst test1 = [1, 2, 3];\nconst test2 = test1.slice();\n//shorthand\n//克隆数组\nconst test1 = [1, 2, 3];\nconst test2 = [...test1];\n```',6,3,4,7),
(598,'模板字面量','如果你厌倦了使用 + 将多个变量连接成一个字符串，那么这个简化技巧将让你不再头痛。\n\n```js\n//longhand\nconst welcome = ''Hi '' + test1 + '' '' + test2 + ''.'';\n//shorthand\nconst welcome = `Hi ${test1} ${test2}`;\n```',6,3,4,10),
(599,'跨行字符串','当我们在代码中处理跨行字符串时，可以这样做。\n\n```js\n//longhand\nconst data = ''abc abc abc abc abc abc\\n\\t'' + ''test test,test test test test\\n\\t'';\n//shorthand\nconst data = `abc abc abc abc abc abc\n         test test,test test test test`;\n```',6,3,4,10),
(600,'对象属性赋值','```js\nlet test1 = ''a'';\nlet test2 = ''b'';\n//Longhand\nlet obj = { test1: test1, test2: test2 };\n//Shorthand\nlet obj = { test1, test2 };\n```',6,3,4,10),
(601,'将字符串转成数字','\n```js\n//Longhand\nlet test1 = parseInt(''123'');\nlet test2 = parseFloat(''12.3'');\n//Shorthand\nlet test1 = +''123'';\nlet test2 = +''12.3'';\n```',6,3,4,10),
(602,'解构赋值','```js\n//longhand\nconst test1 = this.data.test1;\nconst test2 = this.data.test2;\nconst test2 = this.data.test3;\n//shorthand\nconst { test1, test2, test3 } = this.data;\n```',6,3,4,10),
(603,'数组find简化','当我们有一个对象数组，并想根据对象属性找到特定对象，find 方法会非常有用。\n\n```js\nconst data = [\n  {\n    type: ''test1'',\n    name: ''abc''\n  },\n  {\n    type: ''test2'',\n    name: ''cde''\n  },\n  {\n    type: ''test1'',\n    name: ''fgh''\n  }\n];\nfunction findtest1(name) {\n  for (let i = 0; i < data.length; ++i) {\n    if (data[i].type === ''test1'' && data[i].name === name) {\n      return data[i];\n    }\n  }\n}\n//Shorthand\nfilteredData = data.find((data) => data.type === ''test1'' && data.name === ''fgh'');\nconsole.log(filteredData); // { type: ''test1'', name: ''fgh'' }\n```',6,3,4,7),
(604,'条件查找简化','如果我们要基于不同的类型调用不同的方法，可以使用多个 else if 语句或 switch，但有没有比这更好的简化技巧呢？\n\n```js\n// Longhand\nif (type === ''test1'') {\n  test1();\n} else if (type === ''test2'') {\n  test2();\n} else if (type === ''test3'') {\n  test3();\n} else if (type === ''test4'') {\n  test4();\n} else {\n  throw new Error(''Invalid value '' + type);\n}\n// Shorthand\nvar types = {\n  test1: test1,\n  test2: test2,\n  test3: test3,\n  test4: test4\n};\nvar func = types[type];\n!func && throw new Error(''Invalid value '' + type);\nfunc();\n```',6,3,4,5),
(605,'indexOf的按位操作简化','在查找数组的某个值时，我们可以使用 indexOf() 方法。但有一种更好的方法，让我们来看一下这个例子。\n\n```js\n//longhand\nif (arr.indexOf(item) > -1) {\n  // item found\n}\nif (arr.indexOf(item) === -1) {\n  // item not found\n}\n//shorthand\nif (~arr.indexOf(item)) {\n  // item found\n}\nif (!~arr.indexOf(item)) {\n  // item not found\n}\n```\n\n按位 ( ~ ) 运算符将返回 true（-1 除外），反向操作只需要!~。另外，也可以使用 include() 函数。\n\n```js\nif (arr.includes(item)) {\n  // 如果找到项目，则为true\n}\n```',6,3,4,7),
(606,'重复字符串多次','为了重复操作相同的字符，我们可以使用 for 循环，但其实还有一种简便的方法。\n\n```js\n//longhand\nlet test = '''';\nfor (let i = 0; i < 5; i++) {\n  test += ''test '';\n}\nconsole.log(str); // test test test test test\n//shorthand\n''test ''.repeat(5);\n```',6,3,4,10),
(607,'时间格式化','该方法可以用于将时间转化为 hour:minutes:seconds 的格式：\n\n```javascript\nconst timeFromDate = (date) => date.toTimeString().slice(0, 8);\n\ntimeFromDate(new Date(2021, 11, 2, 12, 30, 0)); // 12:30:00\ntimeFromDate(new Date()); // 返回当前时间 09:00:00\n```',6,3,4,9),
(608,'查找数组的最大值和最小值','```js\nconst arr = [1, 2, 3];\nMath.max(…arr); // 3\nMath.min(…arr); // 1\n```',6,3,4,7),
(609,'获取字符串的字符','```js\nlet str = ''abc'';\n//Longhand\nstr.charAt(2); // c\n//Shorthand\nstr[2]; // c\n```',6,3,4,10),
(610,'指数幂简化','```js\n//longhand\nMath.pow(2, 3); // 8\n//shorthand\n2 ** 3; // 8\n```',6,3,4,5),
(611,'号码判断','```js\nexport const isPhone = (e) => {\n  return /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(e);\n};\n```',6,3,4,5),
(612,'是否url地址','```js\nexport const isURL = (e) => {\n  return /^http[s]?:\\/\\/.*/.test(e);\n};\n```',6,3,4,5),
(613,'是否字符串','```js\nexport const isNumber = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''String'';\n};\n```',6,3,4,5),
(614,'是否数字','```js\nexport const isNumber = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Number'';\n};\n```',6,3,4,5),
(615,'是否boolean','```js\nexport const isBoolean = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Boolean'';\n};\n```',6,3,4,5),
(616,'是否函数','```js\nexport const isFunction = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Function'';\n};\n```',6,3,4,5),
(617,'是否为null','```js\nexport const isNull = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Null'';\n};\n```',6,3,4,5),
(618,'是否undefined','```js\nexport const isUndefined = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Undefined'';\n};\n```',6,3,4,5),
(619,'是否对象','```js\nexport const isObject = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Object'';\n};\n```',6,3,4,5),
(620,'是否数组','```js\nexport const isArray = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Array'';\n};\n```',6,3,4,5),
(621,'是否正则','```js\nexport const isRegExp = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''RegExp'';\n};\n```',6,3,4,5),
(622,'是否错误对象','```js\nexport const isError = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Error'';\n};\n```',6,3,4,5),
(623,'是否Symbol函数','```js\nexport const isSymbol = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Symbol'';\n};\n```',6,3,4,5),
(624,'是否Promise对象','```js\nexport const isPromise = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Promise'';\n};\n```',6,3,4,5),
(625,'是否Set对象','```js\nexport const isSet = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Set'';\n};\nexport const us = navigator.userAgent.toLowerCase();\n```',6,3,4,5),
(626,'是否是微信浏览器','```js\nexport const isWeiXin = () => {\n  return ua.match(/microMessenger/i) == ''micromessenger'';\n};\n```',6,3,4,5),
(627,'是否是QQ浏览器','```js\nexport const isQQBrowser = () => {\n  return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i);\n};\n```',6,3,4,5),
(628,'是否是移动端','```js\nexport const isDeviceMobile = () => {\n  return /android|webos|iphone|ipod|balckberry/i.test(ua);\n};\n```',6,3,4,5),
(629,'是否是爬虫','```js\nexport const isSpider = () => {\n  return /adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sougou orion spider/.test(\n    ua\n  );\n};\n```',6,3,4,5),
(630,'是否 ios','```js\nexport const isIos = () => {\n  var u = navigator.userAgent;\n  if (u.indexOf(''Android'') > -1 || u.indexOf(''Linux'') > -1) {\n    //安卓手机\n    return false;\n  } else if (u.indexOf(''iPhone'') > -1) {\n    //苹果手机\n    return true;\n  } else if (u.indexOf(''iPad'') > -1) {\n    //iPad\n    return false;\n  } else if (u.indexOf(''windows Phone'') > -1) {\n    //winphone手机\n    return false;\n  } else {\n    return false;\n  }\n};\n```',6,3,4,5),
(631,'是否 PC 端','```js\nexport const isPC = () => {\n  var userAgentInfo = navigator.userAgent;\n  var Agents = [''Android'', ''iPhone'', ''SymbuanOS'', ''Windows Phone'', ''iPad'', ''iPod''];\n  var flag = true;\n  for (var i = 0; i < Agents.length; i++) {\n    if (userAgentInfo.indexOf(Agents[i]) > 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n```',6,3,4,5),
(632,'去除 html 标签','```js\nexport const removehtmltag = (str) => {\n  return str.replace(/<[^>]+>/g, '''');\n};\n```',6,3,4,5),
(633,'获取url参数','```js\nexport const getQueryString = (name) => {\n  const reg = new RegExp(''(^|&)'' + name + ''=([^&]*)(&|$)'', ''i'');\n  const search = window.location.search.split(''?'')[1] || '''';\n  const r = search.match(reg) || [];\n  return r[2];\n};\n```',6,3,4,5),
(634,'动态引入 js','```js\nexport const injectScript = (src) => {\n  const s = document.createElement(''script'');\n  s.type = ''text/JavaScript'';\n  s.async = true;\n  s.src = src;\n  const t = document.getElentsByTagName(''script'')[0];\n  t.parentNode.insertBefore(s, t);\n};\n```',6,3,4,5),
(635,'根据url地址下载','```js\nexport const download = (url) => {\n  var isChrome = navigator.userAgent.toLowerCase().indexOf(''chrome'') > -1;\n  var isSafari = navigator.userAgent.toLowerCase().indexOf(''safari'') > -1;\n  if (isChrome || isSafari) {\n    var link = document.createElement(''a'');\n    link.href = url;\n    if (link.download !== undefined) {\n      var fileName = url.substring(url.lastIndexOf(''/'') + 1, url.length);\n      link.download = fileName;\n    }\n    if (document.createEvent) {\n      var e = document.createEvent(''MouseEvents'');\n      e.initEvent(''click'', true, true);\n      link.dispatchEvent(e);\n      return true;\n    }\n  }\n  if (url.indexOf(''?'') === -1) {\n    url += ''?download'';\n  }\n  window.open(url, ''_self'');\n  return true;\n};\n```',6,3,4,5),
(636,'el 是否包含某个 class','```js\nexport const hasClass = (el, className) => {\n  let reg = new RegExp(''(^|\\\\s)'' + className + ''(\\\\s|$)'');\n  return reg.test(el.className);\n};\n```',6,3,4,5),
(637,'el 添加某个 class','```js\nexport const addClass = (el, className) => {\n  if (hasClass(el, className)) {\n    return;\n  }\n  let newClass = el.className.split('' '');\n  newClass.push(className);\n  el.className = newClass.join('' '');\n};\n```',6,3,4,5),
(638,'el 去除某个 class','```js\nexport cosnt removeClass = (el,className)=>{\nif(!hasClass(el,className)){\nreturn\n}\nlet reg = new RegExp(''(^|\\\\s)''+className+''(\\\\s|$)'',''g'')\nel.className = el.className.replace(reg,'''')\n}\n```',6,3,4,5),
(639,'获取滚动的坐标','```js\nexport const getScrollPosition = (el = window) => ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop\n});\n```',6,3,4,6),
(640,'滚动到顶部','```js\nexport cosnt scrollToTop = ()=>{\nconst c = document.documentElement.scrollTop || document.body.scrollTop;\nif(c>0){\nwindow.requestAnimationFrame(scrollToTop);\nwindow.scrollTo(0,c-c/8);\n}\n}\n```\n',6,3,4,6),
(641,'el 是否在视口范围','```js\nexport const elementIsVisibleInViewport = (el,partiallyVisib = false)=>{\ncosnt {top,left,right,bottom} = el.getBoundingClienRect();\nconst {innerHeight,innerWidth} = window;\nreturn partiallyVisible\n? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) && ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth)) : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\n}\n```',6,3,4,5),
(642,'Object.entries()','这个方法可以将对象转换为对象数组。\n\n```js\nconst data = { test1: ''abc'', test2: ''cde'', test3: ''efg'' };\nconst arr = Object.entries(data);\nconsole.log(arr);\n/** Output:\n[ [ ''test1'', ''abc'' ],\n  [ ''test2'', ''cde'' ],\n  [ ''test3''\n```',6,3,4,7),
(643,'判断类型集合','```js\nexport const checkStr = (str, type) => {\nswitch (type) {\ncase ''phone'':\n//手机号码\nreturn /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str);\ncase ''tel'':\n//座机\nreturn /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str);\ncase ''card'':\n//身份证\nreturn /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/.test(str);\ncase ''pwd'':\n//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线\nreturn /^[a-zA-Z]\\w{5,17}$/.test(str)\ncase ''postal'':\n//邮政编码\nreturn /[1-9]\\d{5}(?!\\d)/.test(str);\ncase ''QQ'':\n//QQ号\nreturn /^[1-9][0-9]{4,9}$/.test(str);\ncase ''email'':\n//邮箱\nreturn /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);\ncase ''money'':\n//金额(小数点2位)\nreturn /^\\d*(?:\\.\\d{0,2})?$/.test(str);\ncase ''URL'':\n//网址\nreturn /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#])?/.test(str)\ncase ''IP'':\n//IP\nreturn /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test(str);\ncase ''date'':\n//日期时间\nreturn /^(\\d{4})\\-(\\d{2})\\-(\\d{2}) (\\d{2})(?:\\:\\d{2}|:(\\d{2}):(\\d{2}))$/.test(str) || /^(\\d{4})\\-(\\d{2})\\-(\\d{2})$/.test(str) case ''number'':\n//数字\nreturn /^[0-9]$/.test(str);\ncase ''english'':\n//英文\nreturn /^[a-zA-Z]+$/.test(str);\ncase ''chinese'':\n//中文\nreturn /^[\\\\u4E00-\\\\u9FA5]+$/.test(str);\ncase ''lower'':\n//小写\nreturn /^[a-z]+$/.test(str);\ncase ''upper'':\n//大写\nreturn /^[A-Z]+$/.test(str);\ncase ''HTML'':\n//HTML标记\nreturn /<(\"[^\"]*\"|''[^'']*''|[^''\">])*>/.test(str);\ndefault:\nreturn true;\n}\n}\n```',6,3,4,11),
(644,'严格的身份证校验','```js\nexport const isCardID = (sId) => {\n  if (!/(^\\d{15}$)|(^\\d{17}(\\d|X|x)$)/.test(sId)) {\n    console.log(''你输入的身份证长度或格式错误'');\n    return false;\n  }\n  //身份证城市\n  var aCity = {\n    11: ''北京'',\n    12: ''天津'',\n    13: ''河北'',\n    14: ''山西'',\n    15: ''内蒙古'',\n    21: ''辽宁'',\n    22: ''吉林'',\n    23: ''黑龙江'',\n    31: ''上海'',\n    32: ''江苏'',\n    33: ''浙江'',\n    34: ''安徽'',\n    35: ''福建'',\n    36: ''江西'',\n    37: ''山东'',\n    41: ''河南'',\n    42: ''湖北'',\n    43: ''湖南'',\n    44: ''广东'',\n    45: ''广西'',\n    46: ''海南'',\n    50: ''重庆'',\n    51: ''四川'',\n    52: ''贵州'',\n    53: ''云南'',\n    54: ''西藏'',\n    61: ''陕西'',\n    62: ''甘肃'',\n    63: ''青海'',\n    64: ''宁夏'',\n    65: ''新疆'',\n    71: ''台湾'',\n    81: ''香港'',\n    82: ''澳门'',\n    91: ''国外''\n  };\n  if (!aCity[parseInt(sId.substr(0, 2))]) {\n    console.log(''你的身份证地区非法'');\n    return false;\n  }\n  // 出生日期验证\n  var sBirthday = (sId.substr(6, 4) + ''-'' + Number(sId.substr(10, 2)) + ''-'' + Number(sId.substr(12, 2))).replace(\n      /-/g,\n      ''/''\n    ),\n    d = new Date(sBirthday);\n  if (sBirthday != d.getFullYear() + ''/'' + (d.getMonth() + 1) + ''/'' + d.getDate()) {\n    console.log(''身份证上的出生日期非法'');\n    return false;\n  }\n  // 身份证号码校验\n  var sum = 0,\n    weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],\n    codes = ''10X98765432'';\n  for (var i = 0; i < sId.length - 1; i++) {\n    sum += sId[i] * weights[i];\n  }\n  var last = codes[sum % 11];\n  //计算出来的最后一位身份证号码\n  if (sId[sId.length - 1] != last) {\n    console.log(''你输入的身份证号非法'');\n    return false;\n  }\n  return true;\n};\n```',6,3,4,11),
(645,'随机数范围','```js\nexport const random = (min, max) => {\nif (arguments.length === 2) {\nreturn Math.floor(min + Math.random() * ((max + 1) - min))\n} else {\nreturn null;\n}\n```',6,3,4,5),
(646,'将阿拉伯数字翻译成中文的大写数字','```js\nexport const numberToChinese = (num) => {\n  var AA = new Array(''零'', ''一'', ''二'', ''三'', ''四'', ''五'', ''六'', ''七'', ''八'', ''九'', ''十'');\n  var BB = new Array('''', ''十'', ''百'', ''仟'', ''萬'', ''億'', ''点'', '''');\n  var a = ('''' + num).replace(/(^0*)/g, '''').split(''.''),\n    k = 0,\n    re = '''';\n  for (var i = a[0].length - 1; i >= 0; i--) {\n    switch (k) {\n      case 0:\n        re = BB[7] + re;\n        break;\n      case 4:\n        if (!new RegExp(''0{4}//d{'' + (a[0].length - i - 1) + ''}$'').test(a[0])) re = BB[4] + re;\n        break;\n      case 8:\n        re = BB[5] + re;\n        BB[7] = BB[5];\n        k = 0;\n        break;\n    }\n    if (k % 4 == 2 && a[0].charAt(i + 2) != 0 && a[0].charAt(i + 1) == 0) re = AA[0] + re;\n    if (a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re;\n    k++;\n  }\n  if (a.length > 1) {\n    re += BB[6];\n    for (var i = 0; i < a[1].length; i++) re += AA[a[1].charAt(i)];\n  }\n  if (re == ''一十'') re = ''十'';\n  if (re.match(/^一/) && re.length == 3) re = re.replace(''一'', '''');\n  return re;\n};\n```',6,3,4,5),
(647,'将数字转换为大写金额','```js\nexport const changeToChinese = (Num) => {\n//判断如果传递进来的不是字符的话转换为字符\nif (typeof Num == \"number\") {\nNum = new String(Num);\n};\nNum = Num.replace(/,/g, \"\")\n//替换tomoney()中的“,”\nNum = Num.replace(/ /g, \"\")\n//替换tomoney()中的空格\nNum = Num.replace(/￥/g, \"\")\n//替换掉可能出现的￥字符\nif (isNaN(Num)) {\n//验证输入的字符是否为数字\n//alert(\"请检查小写金额是否正确\");\nreturn \"\";\n};\n//字符处理完毕后开始转换，采用前后两部分分别转换\nvar part = String(Num).split(\".\");\nvar newchar = \"\";\n//小数点前进行转化\nfor (var i = part[0].length - 1; i >= 0; i--) {\nif (part[0].length > 10) {\nreturn \"\";\n//若数量超过拾亿单位，提示\n}\nvar tmpnewchar = \"\"\nvar perchar = part[0].charAt(i);\nswitch (perchar) {\ncase \"0\":\ntmpnewchar = \"零\" + tmpnewchar;\nbreak;\ncase \"1\":\ntmpnewchar = \"壹\" + tmpnewchar;\nbreak;\ncase \"2\":\ntmpnewchar = \"贰\" + tmpnewchar;\nbreak;\ncase \"3\":\ntmpnewchar = \"叁\" + tmpnewchar;\nbreak;\ncase \"4\": tmpnewchar = \"肆\" + tmpnewchar;\nbreak;\ncase \"5\": tmpnewchar = \"伍\" + tmpnewchar;\nbreak;\ncase \"6\": tmpnewchar = \"陆\" + tmpnewchar;\nbreak;\ncase \"7\": tmpnewchar = \"柒\" + tmpnewchar;\nbreak;\ncase \"8\": tmpnewchar = \"捌\" + tmpnewchar;\nbreak;\ncase \"9\": tmpnewchar = \"玖\" + tmpnewchar;\nbreak;\n}\nswitch (part[0].length - i - 1) {\ncase 0:\ntmpnewchar = tmpnewchar + \"元\";\nbreak;\ncase 1:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"拾\";\nbreak;\ncase 2:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"佰\";\nbreak;\ncase 3:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"仟\";\nbreak;\ncase 4:\ntmpnewchar = tmpnewchar + \"万\";\nbreak;\ncase 5:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"拾\";\nbreak;\ncase 6:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"佰\";\nbreak;\ncase 7:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"仟\";\nbreak;\ncase 8:\ntmpnewchar = tmpnewchar + \"亿\";\nbreak;\ncase 9:\ntmpnewchar = tmpnewchar + \"拾\";\nbreak;\n}\nvar newchar = tmpnewchar + newchar;\n}\n//小数点之后进行转化\nif (Num.indexOf(\".\") != -1) {\nif (part[1].length > 2) {\n// alert(\"小数点之后只能保留两位,系统将自动截断\"\n);\npart[1] = part[1].substr(0, 2) }\nfor (i = 0; i < part[1].length; i++) {\ntmpnewchar = \"\" perchar = part[1].charAt(i)\nswitch (perchar) {\ncase \"0\":\ntmpnewchar = \"零\" + tmpnewchar;\nbreak;\ncase \"1\":\ntmpnewchar = \"壹\" + tmpnewchar;\nbreak;\ncase \"2\":\ntmpnewchar = \"贰\" + tmpnewchar;\nbreak;\ncase \"3\":\ntmpnewchar = \"叁\" + tmpnewchar;\nbreak;\ncase \"4\":\ntmpnewchar = \"肆\" + tmpnewchar;\nbreak;\ncase \"5\":\ntmpnewchar = \"伍\" + tmpnewchar;\nbreak;\ncase \"6\":\ntmpnewchar = \"陆\" + tmpnewchar;\nbreak;\ncase \"7\": tmpnewchar = \"柒\" + tmpnewchar;\nbreak;\ncase \"8\":\ntmpnewchar = \"捌\" + tmpnewchar;\nbreak;\ncase \"9\":\ntmpnewchar = \"玖\" + tmpnewchar;\nbreak;\n}\nif (i == 0) tmpnewchar = tmpnewchar + \"角\";\nif (i == 1) tmpnewchar = tmpnewchar + \"分\";\nnewchar = newchar + tmpnewchar; } }\n//替换所有无用汉字\nwhile (newchar.search(\"零零\") != -1)\nnewchar = newchar.replace(\"零零\", \"零\");\nnewchar = newchar.replace(\"零亿\", \"亿\");\nnewchar = newchar.replace(\"亿万\", \"亿\");\nnewchar = newchar.replace(\"零万\", \"万\");\nnewchar = newchar.replace(\"零元\", \"元\");\nnewchar = newchar.replace(\"零角\", \"\");\nnewchar = newchar.replace(\"零分\", \"\");\nif (newchar.charAt(newchar.length - 1) == \"元\") {\nnewchar = newchar + \"整\"\n}\nreturn newchar;\n}\n```',6,3,4,5),
(648,'判断一个元素是否在数组中','```js\nexport const contains = (arr, val) => {\n  return arr.indexOf(val) != -1 ? true : false;\n};\n```',6,3,4,7),
(649,'数组排序{type}1:从小到大2:从大到小3:随机','```js\nexport const sort = (arr, type = 1) => {\n  return arr.sort((a, b) => {\n    switch (type) {\n      case 1:\n        return a - b;\n      case 2:\n        return b - a;\n      case 3:\n        return Math.random() - 0.5;\n      default:\n        return arr;\n    }\n  });\n};\n```',6,3,4,7),
(650,'数组去重','```js\nexport const unique = (arr) => {\n  if (Array.hasOwnProperty(''from'')) {\n    return Array.from(new Set(arr));\n  } else {\n    var n = {},\n      r = [];\n    for (var i = 0; i < arr.length; i++) {\n      if (!n[arr[i]]) {\n        n[arr[i]] = true;\n        r.push(arr[i]);\n      }\n    }\n    return r;\n  }\n};\n```',6,3,4,7),
(651,'删除其中一个元素','```js\nexport const remove = (arr, ele) => {\n  var index = arr.indexOf(ele);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n  return arr;\n};\n```',6,3,4,5),
(652,'将类数组转换为数组','```js\nexport const formArray = (ary) => {\n  var arr = [];\n  if (Array.isArray(ary)) {\n    arr = ary;\n  } else {\n    arr = Array.prototype.slice.call(ary);\n  }\n  return arr;\n};\n```',6,3,4,7),
(653,'数组最大值','```js\nexport const max = (arr) => {\n  return Math.max.apply(null, arr);\n};\n```',6,3,4,7),
(654,'数组最小值','```js\nexport const min = (arr) => {\n  return Math.min.apply(null, arr);\n};\n```',6,3,4,7),
(655,'数组求和','```js\nexport const sum = (arr) => {\n  return arr.reduce((pre, cur) => {\n    return pre + cur;\n  });\n};\n```',6,3,4,7),
(656,'数组平均值','```js\nexport const average = (arr) => {\n  return this.sum(arr) / arr.length;\n};\n```',6,3,4,7),
(657,'去除空格','type: 1-所有空格 2-前后空格 3-前空格 4-后空格\n\n```js\nexport const trim = (str, type) => {\n  type = type || 1;\n  switch (type) {\n    case 1:\n      return str.replace(/\\s+/g, '''');\n    case 2:\n      return str.replace(/(^\\s*)|(\\s*$)/g, '''');\n    case 3:\n      return str.replace(/(^\\s*)/g, '''');\n    case 4:\n      return str.replace(/(\\s*$)/g, '''');\n    default:\n      return str;\n  }\n};\n```',6,3,4,10),
(658,'字符转换','type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写\n\n```js\nexport const changeCase = (str, type) => {\n  type = type || 4;\n  switch (type) {\n    case 1:\n      return str.replace(/\\b\\w+\\b/g, function (word) {\n        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();\n      });\n    case 2:\n      return str.replace(/\\b\\w+\\b/g, function (word) {\n        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();\n      });\n    case 3:\n      return str\n        .split('''')\n        .map(function (word) {\n          if (/[a-z]/.test(word)) {\n            return word.toUpperCase();\n          } else {\n            return word.toLowerCase();\n          }\n        })\n        .join('''');\n    case 4:\n      return str.toUpperCase();\n    case 5:\n      return str.toLowerCase();\n    default:\n      return str;\n  }\n};\n```',6,3,4,10),
(659,'检测密码强度','```js\nexport const checkPwd = (str) => {\n  var Lv = 0;\n  if (str.length < 6) {\n    return Lv;\n  }\n  if (/[0-9]/.test(str)) {\n    Lv++;\n  }\n  if (/[a-z]/.test(str)) {\n    Lv++;\n  }\n  if (/[A-Z]/.test(str)) {\n    Lv++;\n  }\n  if (/[\\.|-|_]/.test(str)) {\n    Lv++;\n  }\n  return Lv;\n};\n```',6,3,4,5),
(660,'函数节流器','```js\nexport const debouncer = (fn, time, interval = 200) => {\n  if (time - (window.debounceTimestamp || 0) > interval) {\n    fn && fn();\n    window.debounceTimestamp = time;\n  }\n};\n```',6,3,4,13),
(661,'在字符串中插入新字符串','```js\nexport const insertStr = (soure, index, newStr) => {\n  var str = soure.slice(0, index) + newStr + soure.slice(index);\n  return str;\n};\n```',6,3,4,10),
(662,'判断两个对象是否键值相同','```js\nexport const isObjectEqual = (a, b) => {\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n  return true;\n};\n```\n',6,3,4,14),
(663,'16进制颜色转RGBRGBA字符串','```js\nexport const colorToRGB = (val, opa) => {\n  var pattern = /^(#?)[a-fA-F0-9]{6}$/;\n  //16进制颜色值校验规则\n  var isOpa = typeof opa == ''number'';\n  //判断是否有设置不透明度\n  if (!pattern.test(val)) {\n    //如果值不符合规则返回空字符\n    return '''';\n  }\n  var v = val.replace(/#/, '''');\n  //如果有#号先去除#号\n  var rgbArr = [];\n  var rgbStr = '''';\n  for (var i = 0; i < 3; i++) {\n    var item = v.substring(i * 2, i * 2 + 2);\n    var num = parseInt(item, 16);\n    rgbArr.push(num);\n  }\n  rgbStr = rgbArr.join();\n  rgbStr = ''rgb'' + (isOpa ? ''a'' : '''') + ''('' + rgbStr + (isOpa ? '','' + opa : '''') + '')'';\n  return rgbStr;\n};\n```',6,3,4,10),
(664,'追加 url 参数','```js\nexport const appendQuery = (url, key, value) => {\n  var options = key;\n  if (typeof options == ''string'') {\n    options = {};\n    options[key] = value;\n  }\n  options = $.param(options);\n  if (url.includes(''?'')) {\n    url += ''&'' + options;\n  } else {\n    url += ''?'' + options;\n  }\n  return url;\n};\n```',6,3,4,5),
(665,'字符串首字母大写','该方法用于将英文字符串的首字母大写处理：\n\n```javascript\nconst capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);\n\ncapitalize(''hello world''); // Hello world\n```',6,3,4,10),
(666,'翻转字符串','该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\n```javascript\nconst reverse = (str) => str.split('''').reverse().join('''');\n\nreverse(''hello world''); // ''dlrow olleh''\n```',6,3,4,10),
(667,'随机字符串','该方法用于生成一个随机的字符串：\n\n```javascript\nconst randomString = () => Math.random().toString(36).slice(2);\n\nrandomString();\n```',6,3,4,10),
(668,'截断字符串','该方法可以从指定长度处截断字符串:\n\n```javascript\nconst truncateString = (string, length) => (string.length < length ? string : `${string.slice(0, length - 3)}...`);\n\ntruncateString(''Hi, I should be truncated because I am too loooong!'', 36); // ''Hi, I should be truncated because...''\n```',6,3,4,10),
(669,'去除字符串中的 HTML','该方法用于去除字符串中的 HTML 元素：\n\n```javascript\nconst stripHtml = (html) => new DOMParser().parseFromString(html, ''text/html'').body.textContent || '''';\n```',6,3,4,10),
(670,'从数组中移除重复项','该方法用于移除数组中的重复项：\n\n```javascript\nconst removeDuplicates = (arr) => [...new Set(arr)];\n\nconsole.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n```',6,3,4,7),
(671,'判断数组是否为空','该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\n```javascript\nconst isNotEmpty = (arr) => Array.isArray(arr) && arr.length > 0;\n\nisNotEmpty([1, 2, 3]); // true\n```',6,3,4,7),
(672,'合并两个数组','可以使用下面两个方法来合并两个数组：\n\n```javascript\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n```',6,3,4,7),
(673,'判断一个数是奇数还是偶数','该方法用于判断一个数字是奇数还是偶数：\n\n```javascript\nconst isEven = (num) => num % 2 === 0;\n\nisEven(996);\n```',6,3,4,15),
(674,'获得一组数的平均值','```javascript\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5); // 3\n```',6,3,4,15),
(675,'获取两个整数之间的随机整数','该方法用于获取两个整数之间的随机整数\n\n```javascript\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n```',6,3,4,15),
(676,'指定位数四舍五入','该方法用于将一个数字按照指定位进行四舍五入：\n\n```javascript\nconst round = (n, d) => Number(Math.round(n + ''e'' + d) + ''e-'' + d);\n\nround(1.005, 2); //1.01\nround(1.555, 2); //1.56\n```',6,3,4,15),
(677,'将 RGB 转化为十六机制','该方法可以将一个 RGB 的颜色值转化为 16 进制值：\n\n```javascript\nconst rgbToHex = (r, g, b) => ''#'' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\nrgbToHex(255, 255, 255); // ''#ffffff''\n```',6,3,4,16),
(678,'获取随机十六进制颜色','该方法用于获取一个随机的十六进制颜色值：\n\n```javascript\nconst randomHex = () =>\n  `#${Math.floor(Math.random() * 0xffffff)\n    .toString(16)\n    .padEnd(6, ''0'')}`;\n\nrandomHex();\n```',6,3,4,16),
(679,'复制内容到剪切板','该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：\n\n```javascript\nconst copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\ncopyToClipboard(''Hello World'');\n```',6,3,4,17),
(680,'清除所有 cookie','该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\n```javascript\nconst clearCookies = document.cookie\n  .split('';'')\n  .forEach(\n    (cookie) =>\n      (document.cookie = cookie.replace(/^ +/, '''').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`))\n  );\n```',6,3,4,17),
(681,'获取选中的文本','该方法通过内置的 getSelection 属性获取用户选择的文本：\n\n```javascript\nconst getSelectedText = () => window.getSelection().toString();\n\ngetSelectedText();\n```',6,3,4,17),
(682,'滚动到页面顶部','该方法用于在页面中返回顶部：\n\n```javascript\nconst goToTop = () => window.scrollTo(0, 0);\n\ngoToTop();\n```',6,3,4,17),
(683,'判断当前标签页是否激活','该方法用于检测当前标签页是否已经激活：\n\n```javascript\nconst isTabInView = () => !document.hidden;\n```',6,3,4,17),
(684,'判断当前是否是苹果设备','该方法用于检测当前的设备是否是苹果的设备：\n\n```javascript\nconst isAppleDevice = () => /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n\nisAppleDevice();\n```',6,3,4,17),
(685,'是否滚动到页面底部','该方法用于判断页面是否已经底部：\n\n```javascript\nconst scrolledToBottom = () =>\n  document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n```',6,3,4,17),
(686,'重定向到一个 URL','该方法用于重定向到一个新的 URL：\n\n```javascript\nconst redirect = (url) => (location.href = url);\n\nredirect(''https://www.google.com/'');\n```',6,3,4,17),
(687,'打开浏览器打印框','该方法用于打开浏览器的打印框：\n\n```javascript\nconst showPrintDialog = () => window.print();\n```',6,3,4,17),
(688,'随机布尔值','该方法可以返回一个随机的布尔值，使用 Math.random()可以获得 0-1 的随机数，与 0.5 进行比较，就有一半的概率获得真值或者假值。\n\n```javascript\nconst randomBoolean = () => Math.random() >= 0.5;\n\nrandomBoolean();\n```',6,3,4,5),
(689,'获取变量的类型','该方法用于获取一个变量的类型：\n\n```javascript\nconst trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n\ntrueTypeOf(''''); // string\ntrueTypeOf(0); // number\ntrueTypeOf(); // undefined\ntrueTypeOf(null); // null\ntrueTypeOf({}); // object\ntrueTypeOf([]); // array\ntrueTypeOf(0); // number\ntrueTypeOf(() => {}); // function\n```',6,3,4,5),
(690,'检测对象是否为空','该方法用于检测一个 JavaScript 对象是否为空：\n\n```javascript\nconst isEmpty = (obj) => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;\n```',6,3,4,11),
(691,'截取字符串slice()','slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：\n\n```javascript\nstring.slice(start, end);\n```\n\n该方法有两个参数：\n\n- start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。\n- end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。\n\n上面说了，如果 start 是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：\n\n```javascript\nlet str = ''abcdefg'';\nstr.slice(1, 6); // 输出结果：\"bcdef\"\nstr.slice(1); // 输出结果：\"bcdefg\"\nstr.slice(); // 输出结果：\"abcdefg\"\nstr.slice(-2); // 输出结果：\"fg\"\nstr.slice(6, 1); // 输出结果：\"\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。',6,2,4,10),
(692,'截取字符串substr()','substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：\n\n```javascript\nstring.substr(start, length);\n```\n\n该方法有两个参数：\n\n- start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。\n- length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。\n\n```javascript\nlet str = ''abcdefg'';\nstr.substr(1, 6); // 输出结果：\"bcdefg\"\nstr.substr(1); // 输出结果：\"bcdefg\" 相当于截取[1,str.length-1]\nstr.substr(); // 输出结果：\"abcdefg\" 相当于截取[0,str.length-1]\nstr.substr(-1); // 输出结果：\"g\"\n```',6,2,4,10),
(693,'截取字符串substring()','substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：\n\n```javascript\nstring.substring(from, to);\n```\n\n该方法有两个参数：\n\n- from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。\n- to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。\n\n**注意：** 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。\n\n```javascript\nlet str = ''abcdefg'';\nstr.substring(1, 6); // 输出结果：\"bcdef\" [1,6)\nstr.substring(1); // 输出结果：\"bcdefg\" [1,str.length-1]\nstr.substring(); // 输出结果：\"abcdefg\" [0,str.length-1]\nstr.substring(6, 1); // 输出结果 \"bcdef\" [1,6)\nstr.substring(-1); // 输出结果：\"abcdefg\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。',6,2,4,10),
(694,'箭头函数','箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作**构造函数**。\n\n简洁的函数\n\n```js\nconst addOne = (num) => {\n  return num + 1;\n};\n```\n\n箭头语法对于创建[单行函数](https://www.zhihu.com/search?q=单行函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A440172288})更加简洁友好。\n\n```js\nconst addOne = (num) => num + 1;\n```',16,3,4,13),
(695,'数组转化为用逗号分隔','\n```js\nfunction test(a, b) {\n  console.log(a); // 1\n  console.log(b); // 2\n}\n\nvar arr = [1, 2];\ntest(...arr);\n```',16,3,4,7),
(696,'数组拼接','```js\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = [...arr1, 4, 5, 6];\nconsole.log(arr2); // [1, 2, 3, 4, 4, 5, 6]\n```',16,3,4,7),
(697,'Symbol','基本数据类型 Symbol，表示独一无二的值。它是一种类似于字符串的数据类型，它的特点如下：\n\n- Symbol 的值是唯一的，用来解决命名冲突的问题\n- Symbol 值不能与其他类型数据进行运算\n- Symbol 定义的对象属性不能使用`for...in`遍历循环，但是可以使用`Reflect.ownKeys` 来获取对象的所有键名\n\n```js\nlet s1 = Symbol();\nconsole.log(typeof s1); // \"symbol\"\n\nlet s2 = Symbol(''hello'');\nlet s3 = Symbol(''hello'');\nconsole.log(s2 === s3); // false\n```',16,3,4,5),
(698,'includes','**includes()** 方法用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回 false。该方法不会改变原数组。\n\n```js\narr.includes(searchElement, fromIndex);\n```\n\nsearchElement：必须，需要查找的元素值。\n\nfromIndex：可选，从 fromIndex 索引处开始查找目标值。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。\n\n```js\n[1, 2, 3].includes(2); //  true\n[1, 2, 3].includes(4); //  false\n[1, 2, 3].includes(3, 3); // false\n[1, 2, 3].includes(3, -1); // true\n```\n\n```\nif( [1,2,3,4,5].includes(type) ){\n   //...\n}\n```',16,2,4,7),
(699,'补齐字符串的长度','padStart()和 padEnd()\n\n```js\n''1''.padStart(3, ''0''); // 输出结果： ''001''\n''15''.padStart(3, ''0''); // 输出结果： ''015''\n```',16,3,4,10),
(700,'Object 返回数组','```js\nlet obj = {\n  id: 1,\n  name: ''hello'',\n  age: 18\n};\nconsole.log(Object.keys(obj)); // 输出结果: [''id'', ''name'', ''age'']\nconsole.log(Object.values(obj)); // 输出结果: [1, ''hello'', 18]\nconsole.log(Object.entries(obj)); // 输出结果: [[''id'', 1], [''name'', ''hello''], [''age'', 18]\n```',16,3,4,7),
(701,'for await…of','方法被称为**异步迭代器**，该方法是主要用来遍历异步对象。只能在 `async function`内使用\n\n```js\nfunction Gen(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(function () {\n      resolve(time);\n    }, time);\n  });\n}\n\nasync function test() {\n  let arr = [Gen(2000), Gen(100), Gen(3000)];\n  for await (let item of arr) {\n    console.log(Date.now(), item);\n  }\n}\ntest();\n```',16,3,4,12),
(702,'空值合并运算符（??）','```js\nconst dogName = false;\nconst name = dogName ?? ''default''; // name = false;\n```',16,3,4,8),
(703,'可选链操作符（?.）','```js\nconst name = system?.user?.addr?.province?.name || ''default'';\n```\n\n当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。\n\n```js\na?.[x];\n// 等同于\na == null ? undefined : a[x];\n\na?.b();\n// 等同于\na == null ? undefined : a.b();\n\na?.();\n// 等同于\na == null ? undefined : a();\n```',16,3,4,8),
(704,'String.prototype.replaceAll()','replaceAll()方法会返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。\n\n```javascript\nlet string = ''hello world, hello ES12'';\nstring.replace(/hello/g, ''hi''); // hi world, hi ES12\nstring.replaceAll(''hello'', ''hi''); // hi world, hi ES12\n```',16,3,4,8),
(705,'数字分隔符','数字分隔符可以在数字之间创建可视化分隔符，通过 \\_ 下划线来分割数字，使数字更具可读性，可以放在数字内的任何地方：\n\n```javascript\nconst money = 1_000_000_000;\n//等价于\nconst money = 1000000000;\n```\n\n该新特性同样支持在八进制数中使用：\n\n```javascript\nconst number = 0o123_456;\n//等价于\nconst number = 0o123456;\n```',16,3,4,5),
(706,'.repeat()','\n\n 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。\n\n```js\nconst str = ''DevPoint ''.repeat(3);\nconsole.log(str); // DevPoint DevPoint DevPoint\n```',16,3,4,10),
(707,'.startsWith()','用来判断当前字符串是否以另外一个给定的子字符串开头（区分大小写），并根据判断结果返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.startsWith(''D'');\nconst str2 = ''DevPoint''.startsWith(''d'');\nconsole.log(str); // true\nconsole.log(str2); // false\n```',16,3,4,10),
(708,'.endsWith()','\n 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.endsWith(''t'');\nconsole.log(str); // true\n```',16,3,4,10),
(709,'.includes()','\n 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.includes(''P'');\nconsole.log(str); // true\n```',16,3,4,10),
(710,'.find()   ','返回数组中满足提供的过滤函数的**第一个元素**的值，否则返回 `undefined`。\n\n```js\nconst arrNumbers = [5, 12, 8, 130, 44];\nconst foundNumbers = arrNumbers.find((number) => number > 10);\nconsole.log(foundNumbers); // 12是数组第一个大于10的数\n```',16,3,4,10),
(711,'取值','```js\n//老的取值方式\nconst a = obj.a;\nconst b = obj.b;\nconst c = obj.c;\n\nES6的解构赋值一行就能搞定\nconst {a,b,c} = obj;\n```',16,3,4,5),
(712,'获取对象属性值','在编程的过程中经常会遇到获取一个值并赋给另一个变量的情况，在获取这个值时需要先判断一下这个对象是否存在，才能进行赋值\n\n```ini\nif(obj && obj.name){\n  const name = obj.name\n}\n```\n\nES6 提供了可选连操作符`?.`，可以简化操作\n\n```ini\nconst name = obj?.name;\n```',16,3,4,8),
(713,'反转字符串','将一个字符串进行翻转操作，返回翻转后的字符串\n\n```perl\nconst reverse = str => str.split('''').reverse().join('''');\n\nreverse(''hello world'');   // ''dlrow olleh''\n```',16,3,4,10),
(714,'合并数据','当我们需要合并数据，并且去除重复值时，你是不是要用 for 循环？ ES6 的扩展运算符一行就能搞定！！！\n\n```ini\nconst a = [1,2,3];\nconst b = [1,5,6];\nconst c = [...new Set([...a,...b])];//[1,2,3,5,6]\n```',16,3,4,8),
(715,'判断数组是否为空','判断一个数组是否为空数组，它将返回一个布尔值\n\n```ini\nconst notEmpty = arr => Array.isArray(arr) && arr.length > 0;\n\nnotEmpty([1, 2, 3]);  // true\n```',16,3,4,7),
(716,'交换两个变量','```ini\n//旧写法\nlet a=1;\nlet b=2;\nlet temp;\ntemp=a\na=b\nb=temp\n\n//新写法\n[a, b] = [b, a];\n```',16,3,4,5),
(717,'获取两个数之间的随机整数','```lua\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n```',16,3,4,15),
(718,'检查日期是否为工作日','传入日期，判断是否是工作日\n\n```js\nconst isWeekday = (date) => date.getDay() % 6 !== 0;\nconsole.log(isWeekday(new Date(2021, 11, 11)));\n// false\nconsole.log(isWeekday(new Date(2021, 11, 13)));\n// true\n```',16,3,4,9),
(720,'浏览器是否支持触摸事件','通过判断浏览器是否有`ontouchstart`事件来判断是否支持触摸\n\n```javascript\nconst touchSupported = () => {\n  ''ontouchstart'' in window || (window.DocumentTouch && document instanceof window.DocumentTouch);\n};\nconsole.log(touchSupported());\n```',16,3,4,17),
(721,'集合Set','| size   | 返回集合的元素个数                   |\n| ------ | ------------------------------------ |\n| add    | 增加一个新的元素，返回当前的集合     |\n| delete | 删除元素，返回布尔值                 |\n| has    | 检查集合中是否包含某元素，返回布尔值 |\n| clear  | 清空集合，返回 undefined             |\n\n```js\n//创建一个空集合\nlet s = new Set();\n//创建一个非空集合\nlet s1 = new Set([1,2,3,1,2,3]);\n//返回集合的元素个数\nconsole.log(s1.size);       // 3\n//添加新元素\nconsole.log(s1.add(4));     // {1,2,3,4}\n//删除元素\nconsole.log(s1.delete(1));  //true\n//检测是否存在某个值\nconsole.log(s1.has(2));     // true\n//清空集合\nconsole.log(s1.clear());    //undefined\n```\n',16,3,4,18),
(722,'数组与集合的相互转化','```js\n// Set集合转化为数组\nconst arr = [...mySet];\nconst arr = Array.from(mySet);\n\n// 数组转化为Set集合\nconst mySet = new Set(arr);\n```',6,3,4,5),
(723,'Map','如果需要“ 键值对” 的数据结构， Map 比 Object 更合适。Map 也实现了 iterator 接口，所以可以使用扩展运算符和 for…of 进行遍历。\n\n| size | 返回 Map 的元素个数 |\n| --- | --- |\n| set | 增加一个新的元素，返回当前的 Map |\n| get | 返回键名对象的键值 |\n| has | 检查 Map 中是否包含某元素，返回布尔值 |\n| clear | 清空 Map，返回 undefined |\n\n```js\n//创建一个空 map\nlet m = new Map();\n//创建一个非空 map\nlet m2 = new Map([[''name'', ''hello'']]);\n//获取映射元素的个数\nconsole.log(m2.size); // 1\n//添加映射值\nconsole.log(m2.set(''age'', 6)); // {\"name\" => \"hello\", \"age\" => 6}\n//获取映射值\nconsole.log(m2.get(''age'')); // 6\n//检测是否有该映射\nconsole.log(m2.has(''age'')); // true\n//清除\nconsole.log(m2.clear()); // undefined\n```',16,2,4,19),
(724,'模块化','ES6 中首次引入模块化开发规范 ES Module，让 Javascript 首次支持原生模块化开发。ES Module 把一个文件当作一个模块，每个模块有自己的独立作用域，那如何把每个模块联系起来呢？核心点就是模块的导入与导出。',16,2,4,20),
(725,'export导出模块','- **正常导出：**\n\n```javascript\n// 方式一\nexport var first = ''test'';\nexport function func() {\n  return true;\n}\n\n// 方式二\nvar first = ''test'';\nvar second = ''test'';\nfunction func() {\n  return true;\n}\nexport { first, second, func };\n```\n\n- **as 关键字:**\n\n```javascript\nvar first = ''test'';\nexport { first as second };\n```\n\nas 关键字可以重命名暴露出的变量或方法，经过重命名后同一变量可以多次暴露出去。\n\n- **export default**\n\nexport default 会导出默认输出，即用户不需要知道模块中输出的名字，在导入的时候为其指定任意名字。\n\n```javascript\n// 导出\nexport default function () {\n  console.log(''foo'');\n}\n// 导入\nimport customName from ''./export-default'';\n```\n\n**注意：** 导入默认模块时不需要大括号，导出默认的变量或方法可以有名字，但是对外无效。export default 只能使用一次。',16,2,4,20),
(726,'import 导入模块','- **正常导入：**\n\n```javascript\nimport { firstName, lastName, year } from ''./profile'';\n```\n\n导入模块位置可以是相对路径也可以是绝对路径，.js 可以省略，如果不带路径只是模块名，则需要通过配置文件告诉引擎查找的位置。\n\n- **as 关键字：**\n\n```javascript\nimport { lastName as surname } from ''./profile'';\n```\n\nimport 命令会被提升到模块头部，所以写的位置不是那么重要，但是不能使用表达式和变量来进行导入。\n\n- **加载整个模块（无输出）**\n\n```javascript\nimport ''lodash''; //仅仅是加载而已，无法使用\n```\n\n- **加载整个模块（有输出）**\n\n```javascript\nimport * as circle from ''./circle'';\nconsole.log(''圆面积：'' + circle.area(4));\nconsole.log(''圆周长：'' + circle.circumference(14));\n```\n\n**注意：** import \\* 会忽略 default 输出',16,3,4,20),
(727,'导入导出复合用法','- **先导入后导出**\n\n```javascript\nexport { foo, bar } from ''my_module'';\n// 等同于\nimport { foo, bar } from ''my_module'';\nexport { foo, boo };\n```\n\n- **整体先导入再输出以及 default**\n\n```javascript\n// 整体输出\nexport * from ''my_module'';\n// 导出default，正如前面所说，export default 其实导出的是default变量\nexport { default } from ''foo'';\n// 具名接口改default\nexport { es6 as default } from ''./someModule'';\n```',16,3,4,20),
(728,'模块的继承','```javascript\nexport * from ''circle'';\nexport var e = 2.71828182846;\nexport default function (x) {\n  return Math.exp(x);\n}\n```\n\n**注意：** export \\* 会忽略 default。',16,3,4,20),
(729,'解构语法','解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出，赋值给其他变量。\n\n如果要将对象传递给函数，则可以轻松选择对象的属性，然后使用 ES6 分解语法将它们放在单独的变量中：\n\n```js\nfunction foo({ a, b }) {\n  console.log(a, b); // 1, 2\n}\n\nfoo({ a: 1, b: 2 });\n```\n\n赋值：\n\n```js\nfunction foo(obj) {\n  const { a, b } = obj;\n  console.log(a, b); // 1, 2\n}\n\nor;\nconst { title, text } = res.data[0];\nstate.dataOne = { title, text };\n```\n\n在解构数组时，可以使用 `...` 语法来获取数组中的所有其他项。\n\n```js\nfunction foo([a, b, ...c]) {\n    console.log(c); // [3, 4, 5]\n}\nfoo([1, 2, 3, 4, 5]);\n\n赋值：\nfunction foo(arr) {\n    const [a, b, ...c] = arr;\n    console.log(c); // [3, 4, 5]\n}\nfoo([1, 2, 3, 4, 5]);\n\n//rest操作符也可以单独使用，无需解构：\nfunction foo(...nums) {\n    console.log(nums); // [1, 2, 3, 4, 5]\n}\nfoo(1, 2, 3, 4, 5);\n```\n\nrest 语法 `...` 与另一个 ES6 特性操作符扩展完全相同。\n\n例如，如果要将两个数组合并为一个\n\n```js\nconst a = [1, 2];\nconst b = [3, 4];\nconst c = [...a, ...b];\nconsole.log(c); // [1, 2, 3, 4]\n```\n\n`spread`也适用于对象：\n\n```js\nconst obj = { a: 1, b: 2 };\nconst obj2 = { ...obj, c: 3 };\nconsole.log(obj2); // { a: 1, b: 2, c: 3 }\n```',16,2,4,5),
(730,'KeepAlive','内置组件，可以在动态切换多个组件时视情况缓存组件实例。\n\n- 当组件在 keep-alive 内被切换时组件的 **activated**、**deactivated** 这两个生命周期钩子函数会被执行\n- 被包裹在 keep-alive 中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第 100 条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第 100 条列表处\n- 被 keep-alive 包裹的动态组件或 router-view 会缓存不活动的实例，再次被调用这些被缓存的实例会被再次复用，对于我们的某些不是需要实时更新的页面来说大大减少了性能上的消耗，不需要再次发送 HTTP 请求，但是同样也存在一个问题就是被 keep-alive 包裹的组件我们请求获取的数据不会再重新渲染页面，这也就出现了例如我们使用动态路由做匹配的话页面只会保持第一次请求数据的渲染结果，所以需要我们在特定的情况下强制刷新某些组件',2,2,4,22),
(731,'认识keep-alive','组件切换后，组件会被销毁掉，再次回来时会重新创建组件，所以在离开组件之前所有的数据都会丢失。\n\n我们希望继续保持组件的状态，而不是销毁掉，这个时候就可以使用一个**内置组件：**`keep-alive`。\n\nkeep-alive 有一些属性：\n\n- `include` - string | RegExp | Array。只有名称匹配的组件会被缓存；\n- `exclude` - string | RegExp | Array。任何名称匹配的组件都不会被缓存；\n- `max`- number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；\n\ninclude 和 exclude prop 可以筛选组件地缓存，匹配首先检查组件自身的 name 选项。',2,2,4,22),
(732,'默认缓存','```html\n<router-view class=\"content\" v-slot=\"{ Component }\">\n  <keep-alive>\n    <component :is=\"Component\" />\n  </keep-alive>\n</router-view>\n```',2,3,4,22),
(733,'搭配路由使用','vue3 配合的 slot 插槽使用，使用 is 来绑定对应路由的组件。\n\n```html\n<template>\n  <router-view v-slot=\"{ Component }\">\n    <keep-alive>\n      <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n    </keep-alive>\n    <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n  </router-view>\n</template>\n```\n\nrouter 添加 meta 配置\n\n可以注释哪一页面需要使用缓存，但是也可以不设置，不设置的情况需要将上面的属性都删掉。如果需要更多的缓存限制，可以看底下的参考网站。\n\n```js\nconst routes = [\n  {\n    path: ''/keepalive'',\n    name: ''keepalive'',\n    component: () => import(''../views/keepalive.vue''),\n    meta: {\n      keepAlive: false //是否需要使用缓存\n    }\n  }\n];\n```',2,2,4,22),
(734,'清除缓存组件','```js\n // beforeRouteLeave()钩子\n  beforeRouteLeave(to, from, next) {\n      if (to.path === \"/goods_detail\") {\n        from.meta.keepAlive = true;\n      } else {\n        from.meta.keepAlive = false;\n        // this.$destroy()\n      }\n      next();\n    }\n```',2,3,4,22),
(735,'基本使用','使用特殊的 `<component>` 元素：\n\n```html\n<component :is=\"activeComponent\" />\n```\n\n默认情况下，一个正活跃的组件实例会在切走后被卸载。这会导致它丢失其中所有的状态变化。\n\n在切换时创建新的组件实例通常是有用的行为，但在这个例子中，我们是的确想要组件能在非活跃状态时保留它们的状态。要解决这个问题，我们可以将动态组件用 `<KeepAlive>` 这个内置组件进行包裹：\n\n```html\n<!-- 非活跃状态的组件将会被缓存！ -->\n<KeepAlive>\n  <component :is=\"activeComponent\" />\n</KeepAlive>\n```\n\n现在，在切换时组建的状态也能被保留了',2,2,4,22),
(736,'包含/排除','默认情况下，`<KeepAlive>` 会不作区分地缓存它之中任何组件。但我们可以通过 `include` 和 `exclude` prop 来定制该行为。这两个 prop 的值都是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两个类型的一个数组：\n\n```html\n<!-- 以英文逗号分隔的字符串 -->\n<KeepAlive include=\"a,b\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n\n<!-- 正则表达式（需使用 `v-bind`） -->\n<KeepAlive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n\n<!-- 数组（需使用 `v-bind`）-->\n<KeepAlive :include=\"[''a'', ''b'']\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n```\n\n匹配的根据是组件的`name`选项，所以要想通过 `KeepAlive` 有条件地缓存的组件必须显式声明一个 `name` 选项。',2,2,4,22),
(737,'最大缓存实例','我们可以通过传入 `max` prop 来限制组件缓存的最大数量。当指定了 `max` 时，`<KeepAlive>` 会像一个 LRU 缓存：如果缓存实例的数量即将超过指定的最大数量，最近访问次数最少的缓存实例将被销毁，以便为新的实例腾出空间。\n\n```html\n<KeepAlive :max=\"10\">\n  <component :is=\"activeComponent\" />\n</KeepAlive>\n```',2,2,4,22),
(738,'缓存实例的生命周期','当一个组件实例从 DOM 上移除但因为被 `<KeepAlive>` 缓存而仍作为组件树的一部分时，它将变为**不活跃**状态而不是被卸载。当一个组件实例作为缓存树的一部分插入到 DOM 中时，它就是被重新**恢复活跃**了。\n\n一个持续存在的组件可以通过 `onActivated()` 和 `onDeactivated()`注册相应的两个状态的生命周期钩子：\n\n```html\n<script setup>\nimport { onActivated, onDeactivated } from ''vue''\n\nonActivated(() => {\n  // 在首次挂载、\n  // 以及每次从缓存中重新被插入回 DOM 的时候调用\n})\n\nonDeactivated(() => {\n  // 在从 DOM 上移除、进入缓存\n  // 以及组件卸载时调用\n})\n</script>\n```\n\n请注意：\n\n- `onActivated` 在组件挂载时也会调用，并且 `onDectivated` 在组件卸载时也会调用。\n- 这两个钩子不仅适用于 `<KeepAlive>` 缓存的根组件，也适用于缓存树中的后代组件。',2,2,4,22),
(739,'Teleport传送','元素最好要挂载到#app 的外面，原理其实是解析到 teleport 的时候，需要能获取到 to 指向的 dom 元素。\n\n是 vue3 中的一个内置组件，实现的就是将一个元素传送给指定的 DOM 节点下,把组件进行传送\n\n```html\n<button @click=\"open = true\">打开模态框</button>\n\n<Teleport to=\"body\">\n  <div v-if=\"open\" class=\"modal\">\n    <p>你好！</p>\n    <button @click=\"open = false\">关闭</button>\n  </div>\n</Teleport>\n```\n\n`to` 是目标的地址 `body` , `#XXX` , `.XXX` 这些都是 `css` 选择器为 `<Teleport>` 指定的目标 `to` 期望接收一个 CSS 选择器字符串或者一个真实的 DOM 节点。其实就是让 Vue 去“**传送**这部分模板片段**到 `body`** 标签下”。',2,2,4,23),
(740,'禁用传送门','在某些场景中，你们可能需要视情况禁用 `<Teleport>`。举个例子，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。可以对 `<Teleport>` 动态地传入一个 `disabled` prop 来处理这两种不同情况。\n\n```html\n<Teleport :disabled=\"isMobile\">\n  ...\n</Teleport>\n```\n\n这里的 `isMobile` 状态可以根据媒体查询的不同结果动态地更新。',2,2,4,23),
(741,'同一目标上多个传送门','一个常见的应用场景写一个可重用的 `<Modal>` 组件，可能同时存在多个实例。对于此类场景，多个 `<teleport>` 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。\n\n我们给出下面这样的用例：\n\n```html\n<Teleport to=\"#modals\">\n  <div>A</div>\n</Teleport>\n<Teleport to=\"#modals\">\n  <div>B</div>\n</Teleport>\n```\n\n渲染的结果为：\n\n```html\n<div id=\"modals\">\n  <div>A</div>\n  <div>B</div>\n</div>\n```',2,2,4,23),
(742,'实现模态对话框的组件','#### 定义组件\n\nc-modal-dialog.vue\n\n指向 body dom\n\n```html\n// model\n<template>\n  <teleport to=\"body\">\n    <div v-show=\"visible\" class=\"model-bg\">\n      <div class=\"modal-content\">\n        <button class=\"close\" @click=\"emit(''close-model'')\">X</button>\n        <div class=\"model-title\">{{ title }}</div>\n        <div class=\"model-body\">\n          <slot>第一个对话框</slot>\n        </div>\n      </div>\n    </div>\n  </teleport>\n</template>\n\n<script setup lang=\"ts\">\nconst emit = defineEmits([''close-model'']); // 使用 emit需要把自定义的事件在defineEmits定义，要不会有警告\ndefineProps({\n  title: String, // 标题\n  visible: Boolean // 模态框状态\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.model-bg {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 2000;\n  height: 100%;\n  overflow: auto;\n  background-color: #00000080;\n}\n\n.modal-content {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  z-index: 999;\n  width: 600px;\n  min-height: 300px;\n  background: #fff;\n  border: 1px solid #eee;\n  transform: translate(-50%, -50%);\n\n  .model-title {\n    height: 32px;\n    color: #000;\n    line-height: 32px;\n    text-align: center;\n    background: #eee;\n  }\n\n  .model-body {\n    padding: 40px;\n  }\n\n  .close {\n    position: absolute;\n    top: 5px;\n    right: 10px;\n    padding: 5px;\n    border: none;\n    cursor: pointer;\n  }\n}\n</style>\n```\n\n#### 父组件使用\n\n```html\nconst cliTest = () => {\n  isVisible.value = true\n}\n<a @click=\"cliTest()\">窗体测试</a>\n<c-modal-dialog :visible=\"isVisible\" title=\"用户登录\" @close-model=\"isVisible = false\"></c-modal-dialog>\n```',2,3,4,23),
(743,'指定标签实现','元素最好要挂载到#app 的外面，原理其实是解析到 teleport 的时候，需要能获取到 to 指向的 dom 元素。\n\nVue 是从上到下解析并渲染的，先#test，再 Teleport 标签，再.test1。所以执行到 Teleport 标签时，就能获取到.text 标签了。\n\nc-search.vue\n\n```html\n  import { hSearch } from ''@/hooks/data''\n\n  <teleport v-if=\"hSearch\" to=\"#sear\">\n    <div class=\"model-bg\">\n      <div class=\"modal-content\">\n\n      </div>\n    </div>\n  </teleport>\n```\n\n使用\n\n```html\n import { hSearch, hSearchValue } from ''@/hooks/data''\n <div id=\"sear\"></div>\n <c-search @close-model=\"hSearch = false\"></c-search>\n <button @click=\"hSearch = true\">1</button>\n <button @click=\"hSearch = false\">2</button>\n```',2,3,4,23),
(744,'鼠标事件','### mouseover 和 mouseenter 的区别\n\n- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡过程。对应的移除事件是 mouseout\n  \n- mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡。对应的移除事件是 mouseleave\n  \n\n### 实例\n\n```html\n<template>\n    <div\n        class=\"hover-view\"\n        @mouseover=\"mouseover\"\n        @mouseenter=\"mouseenter\"\n        @mousemove=\"mousemove\"\n        @mouseout=\"mouseout\"\n        @mouseleave=\"mouseleave\"\n        @mousedown=\"mousedown\"\n        @mouseup=\"mouseup\"\n    >鼠标事件</div>\n</template>\n\n<script setup>\nconst mouseover = (event) => {\n    console.log(''当鼠标移入某元素时触发，移入和移出其子元素时也会触发'')\n}\n\nconst mouseenter = () => {\n    console.log(''当鼠标移入某元素时触发'')\n}\n\nconst mousemove = () => {\n    console.log(''鼠标在某元素上移动时触发，即使在其子元素上也会触发'')\n}\n\nconst mouseout = () => {\n    console.log(''当鼠标移出某元素时触发，移入和移出其子元素时也会触发'')\n}\n\nconst mouseleave = () => {\n    console.log(''当鼠标移出某元素时触发'')\n}\n\nconst mousedown = () => {\n    console.log(''鼠标在元素上 按下'')\n}\n\nconst mouseup = () => {\n    console.log(''鼠标在元素上 抬起'')\n}\n</script>\n```',2,2,4,24),
(745,'watch与watchEffect 的区别','- 第一点我们可以从示例代码中看到 watchEffect 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 watch 只能监听指定的属性而做出变更(v3 开始可以同时指定多个)。\n- 第二点就是 watch 可以获取到新值与旧值（更新前的值），而 watchEffect 是拿不到的。\n- 第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与 computed 同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。（watchEffect 是自动执行的）',2,2,4,25),
(746,'watch','- 监听函数,监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调\n- 默认初始时不执行回调, 但可以通过配置`immediate`为`true`, 来指定初始时立即执行第一次\n- 通过配置`deep`为`true`, 来指定深度监视\n\n```js\n<script setup>\n  import { watch, reactive } from ''vue''\n  const state = reactive({\n    count: 1\n  })\n\n  // 声明方法\n  const changeCount = () => {\n    state.count = state.count * 2\n  }\n\n  // 监听count\n  watch(\n    () => state.count,\n    (newVal, oldVal) => {\n      console.log(state.count)\n      console.log(`watch监听变化前的数据：${oldVal}`)\n      console.log(`watch监听变化后的数据：${newVal}`)\n    },\n    {\n      immediate: true, // 立即执行\n      deep: true // 深度监听,深度监听,也就是监听复杂数据类型\n    }\n  )\n</script>\n```',2,2,4,25),
(747,'监听路由','```js\n// 正确方式\nimport { reactive, watch } from ''vue''\nconst route = useRoute()\n\n// 监听路由变化\nwatch(route, () => {\n    console.log(route)\n}, { deep: true })\n\n// 监听 vuex 值变化\nwatch(store.state.routesList, () => {\n    setFilterRoutes()\n}, {\n    deep: true,\n})\n```',2,3,4,25),
(748,'监听响应式数据','```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number: 0\n})\n\nwatch(() => [state.number], (newValue, oldValue) => {\n  console.log(newValue, oldValue)\n}, { deep: true })\n```',2,3,4,25),
(749,'监听多个数据','```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number1: 10,\n      number2: 20\n})\n\nwatch(() => [state.number1, state.number2], (newVal, oldVal) => {\n    console.log(newVal, oldVal); // 打印结果：[100, 200][10, 20]，两个数组，前面的是改变后的值\n}, { deep: true })\n\nsetInterval(() => {\n       state.number1 = 100;\n    state.number2 = 200;\n}, 2000);\n```',2,3,4,25),
(750,'watchEffect','也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些\n\n- 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据\n- 默认初始时就会执行第一次, 从而可以收集需要监视的数据\n- 监视数据发生变化时回调\n\n```js\nlet user = reactive({\n  name: ''小浪'',\n  age: 21\n});\n// 只有 user.name 发生改变这个就会执行\nwatchEffect(() => {\n  console.log(user.name);\n});\n```\n\n#### 清除副作用\n\n- 就是在触发监听之前会调用一个函数可以处理你的逻辑例如防抖\n\n```js\nlet message = ref('''')\nlet message2 = ref('''')\nwatchEffect((oninvalidate) => {\n    //console.log(''message'', message.value);\n    oninvalidate(() => {})\n    console.log(''message2'', message2.value)\n})\n```\n\n#### **停止跟踪 watchEffect 返回一个函数 调用之后将停止更新**\n\n```js\nconst stop = watchEffect(\n    (oninvalidate) => {\n        //console.log(''message'', message.value);\n        oninvalidate(() => {})\n        console.log(''message2'', message2.value)\n    },\n    {\n        flush: ''post'',\n        onTrigger() {},\n    }\n)\nstop()\n```',2,2,4,25),
(751,'组件使用','要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 `ButtonCounter.vue` 的文件中，这个组件将会以默认导出的形式被暴露给外部。\n\n通过 script setup，导入的组件都在模板中直接可用\n\n```tsx\nimport ButtonCounter from ''./ButtonCounter.vue'';\n```\n\n```html\n<template>\n  <h1>这里是一个子组件！</h1>\n  <ButtonCounter />\n</template>\n```',2,2,4,21),
(752,'定义组件名称','用单独的`<script>`块来定义\n\n```javascript\n<script>\n  export default {\n    name: ''ComponentName'',\n  }\n</script>\n```',2,2,4,21),
(753,'通过插槽来分配内容','这可以通过 Vue 的自定义 `<slot>` 元素来实现：\n\n我们使用 `<slot>` 作为一个占位符，之后的内容就会放在这里\n\n```html\n<template>\n  <div class=\"alert-box\">\n    <strong>Error!</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n  .alert-box {\n    /* ... */\n  }\n</style>\n```',2,2,4,3),
(754,'动态组件','有的需求会想要在两个组件间来回切换，比如 Tab 界面：\n\n通过 Vue 的 `<component>` 元素和特殊的 `is` attribute 实现的：\n\n```html\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n```\n\n在上面的例子中，被传给 `:is` 的值可以是以下几种：\n\n- 被注册的组件名\n- 导入的组件对象\n\n你也可以使用 `is` attribute 来创建一般的 HTML 元素。\n\n当使用 `<component :is=\"...\">` 来在多个组件间作切换时，组件会在被切换掉后卸载。我们可以通过组件强制不活跃的组件仍然保持“存活”的状态。',2,2,4,21),
(755,'闭合标签','我们在上面的例子中已经使用过了闭合标签 (self-closing tag)：\n\n```html\n<MyComponent />\n```\n\n这是因为 Vue 的模板解析器将 `/>` 作为标签关闭的标志，无关其类型。\n\n然而在 DOM 模板中，我们必须显式地写出关闭标签：\n\n```html\n<my-component></my-component>\n```\n\n这是由于 HTML 只允许一小部分特殊的元素省略其关闭标签，最常见的就是 `<input>` 和 `<img>`。对于其他的元素来说，如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束，用下面这个代码片段举个例子：\n\n```html\n<my-component />\n<!-- 我们想要在这里关闭标签... -->\n<span>hello</span>\n```\n\nwill be parsed as：\n\n```html\n<my-component>\n  <span>hello</span>\n</my-component>\n<!-- 但浏览器会在这里关闭标签 -->\n```',2,2,4,21),
(756,'全局组件','使用 `app.component()` 方法，让组件在当前 Vue 应用中全局可用。\n\n```js\nimport { createApp } from ''vue'';\n\nconst app = createApp({});\n\napp.component(\n  // 注册的名字\n  ''MyComponent'',\n  // 组件的实现\n  {\n    /* ... */\n  }\n);\n```\n\n如果使用单文件组件，你可以注册被导入的 `.vue` 文件：\n\n```js\nimport MyComponent from ''./App.vue`\n\napp.component(''MyComponent'', MyComponent)\n```\n\n`app.component()` 方法可以被链式调用：\n\n```js\napp.component(''ComponentA'', ComponentA).component(''ComponentB'', ComponentB).component(''ComponentC'', ComponentC);\n```\n\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\n```html\n<!-- 这在当前应用的任意组件中都可用 -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在*彼此内部*使用。',2,2,4,21),
(757,'局部注册','虽然十分方便，但全局注册有以下几个短板：\n\n1. 全局注册使构建系统无法移除未使用的组件(也叫“tree-shaking”)。如果你全局注册了一个组件，却一次都没有使用，它仍然会出现在最终的构建产物中。\n2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，很难定位子组件的实现。这可能会影响未来长期的可维护性，类似于使用过多的全局变量。\n\n局部注册将注册组件的可用性限定在当前组件的范围内。它使依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n`<script setup>`，导入的组件会自动进行局部注册：\n\n```html\n<script setup>\n  import ComponentA from ''./ComponentA.vue'';\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n如果不使用 `<script setup>`，你需要使用 `components` 选项：\n\n```js\nimport ComponentA from ''./ComponentA.js'';\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n};\n```\n\n对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n};\n```',2,2,4,21),
(759,'组件名格式','使用 PascalCase 为组件名：\n\n- PascalCase 是合法的 JavaScript 标识符，同时 IDE 也能提供较好的自动补全。\n\n- `<PascalCase />` 模板中更明显地表明了这是一个 组件，不是原生 HTML 元素。同时也能将组件和自定义元素 (web components) 区分开来。\n\nVue 支持将使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` 引用。这允许我们在不同来源的模板中始终使用同一份 JavaScript 组件注册代码。',2,2,4,21),
(760,'组件模板引用标注类型','### 组件模板引用标注类型\n\n为一个子组件添加一个模板 ref，以便调用它公开的方法。如一个 `MyModal` 子组件，它有一个打开模态框的方法：\n\n```html\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\n  import { ref } from ''vue'';\n  const isContentShown = ref(false);\n  const open = () => (isContentShown.value = true);\n  defineExpose({\n    open\n  });\n</script>\n```\n\n获取 `MyModal` 的类型，需要通过 `typeof` 得到其类型，再使用 TypeScript 内置的 `InstanceType` 工具类型来获取其实例类型：\n\n```html\n<!-- App.vue -->\n<script setup lang=\"ts\">\n  import MyModal from ''./MyModal.vue'';\n\n  const modal = ref<InstanceType<typeof MyModal> | null>(null);\n  const openModal = () => {\n    modal.value?.open();\n  };\n</script>\n```\n\n',2,2,4,5),
(761,'class与style动态绑定(对象)','```html\n<template>\n <!-- <div class=\"text\" :class=\"{类名: 布尔值}\">对象形式</div> -->\n  <div :class=\"{ active: isActive }\"></div>\n  <div :style=\"{ fontSize: fontSize }\">\n\n  <div class=\"text\" :class=\"{active: isActive, ''text-bg'': !isActive}\">对象形式</div>\n  <button @click=\"isActive = !isActive\">点击取反</button>\n</template>\n```\n\n```js\nexport default {\n  data() {\n    return {\n      isActive: true,\n      fontSize: 30\n  }\n}\n```\n\n```css\n.active {\n  height: 30px;\n  background: #42b883aa;\n}\n.text-bg {\n  height: 30px;\n  background: #f10202aa;\n}\n```\n\n',2,3,4,26),
(762,'class与style动态绑定(数组)','```html\n<template>\n  <div :class=\"[activeClass]\"></div>\n  <div :style=\"[styleFontSize]\">\n\n  <div class=\"text\" :class=\"[error,color]\">用数组</div>\n</template>\n```\n\n```js\nexport default {\n  data() {\n    return {\n      activeClass: ''active'',\n      styleFontSize: {\n        fontSize: ''12px''\n      },\n      error: ''text-bg'',\n      color: ''text''\n    };\n  }\n};\n```\n```css\n.text {\n  color: aqua;\n}\n.text-bg {\n  height: 30px;\n  background: #f10202aa;\n}\n```\n',2,3,4,26),
(763,'class三元表达式','### class三元表达式\n\n根据条件切换列表中的 class\n\n始终添加 `errorClass`，但是只有在 `isActive` 为 truthy 时才添加 `activeClass`。\n\n```html\n<div :class=\"[isActive ? activeClass : '''', errorClass]\"></div>\n```\n',2,3,4,5),
(764,'getCurrentInstance封装','Vue3中，在setup中无法通过this获取组件实例，console.log(this)打印出来的值是undefined。\n\n在Vue3中，getCurrentInstance()可以用来获取**当前组件实例**\n\ngetCurrentInstance是一个function方法，getCurrentInstance()是一个对象，proxy也是一个对象。proxy是getCurrentInstance()对象中的一个属性，通过对象的解构赋值方式拿到proxy。 \n\ngetCurrentInstance只能在**setup**或**生命周期钩子**中使用。 \n\nctx和proxy都是getCurrentInstance()对象中的属性，通过解构赋值的方式拿到。可以看到，2者有所区别。ctx是普通对象，proxy是Proxy对象。\n\n```tsx\nimport { ComponentInternalInstance, getCurrentInstance } from ''vue'';\nexport default function useCurrentInstance() {\n  const { appContext } = getCurrentInstance() as ComponentInternalInstance;\n  const proxy = appContext.config.globalProperties;\n  return {\n    proxy\n  };\n}\n```\n\n```tsx\nimport useCurrentInstance from ''@/utils/common/useCurrentInstance'';\nconst { proxy }: any = useCurrentInstance();\nconsole.log(''proxy'', proxy);\n```\n\n#### 通过getCurrentInstance().refs得到ref\n\n```tsx\nimport { getCurrentInstance } from ''vue''\nconst  proxy  = getCurrentInstance()\n```\n\n',2,3,4,5),
(765,'组件通信','组件通信方式：\n\n| 方式             | Vue2       | Vue3                  |\n| ---------------- | ---------- | --------------------- |\n| 父传子           | props      | props                 |\n| 子传父           | $emit      | emits                 |\n| 父传子           | $attrs     | attrs                 |\n| 子传父           | $listeners | 无(合并到 attrs 方式) |\n| 父传子           | provide    | provide               |\n| 子传父           | inject     | inject                |\n| 子组件访问父组件 | $parent    | 无                    |\n| 父组件访问子组件 | $children  | 无                    |\n| 父组件访问子组件 | $ref       | expose&ref            |\n| 兄弟传值         | EventBus   | mitt                  |',2,2,4,21),
(766,'Props','\n\nprops 是组件通信中最常用的通信方式之一。父组件通过 v-bind 传入，子组件通过 props 接收，下面是它的三种实现方式\n\n```js\n// 数组:不建议使用\nprops: [''title'', ''likes'', ''isPublished'', ''commentIds'', ''author'']\n\n//但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：\n// 对象\nprops:{\n inpVal:{\n  type:Number, //传入值限定类型\n  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol\n  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n  required: true, //是否必传\n  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=>[]\n  validator:(value) {\n    // 这个值必须匹配下列字符串中的一个\n    return [''success'', ''warning'', ''danger''].indexOf(value) !== -1\n  }\n }\n}\n```\n\n',2,2,4,27),
(767,'传递props','Prop 是你可以在组件上注册的一些自定义 attribute。为了给博文组件传递内容\n\n```js\n<!-- BlogPost.vue -->\ndefineProps([''title''])\n```\n\n```html\n<h4>{{ title }}</h4>\n```\n\n`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props，因此我们在 JavaScript 中使用\n\n```js\nconst props = defineProps([''title'']);\nconsole.log(props.title);\n```\n\n如果你没有使用 `<script setup>`，props 必须以 `props` 选项的方式声明，props 对象会作为 `setup()` 函数的第一个参数：\n\n```js\nexport default {\n  props: [''title''],\n  setup(props) {\n    console.log(props.title);\n  }\n};\n```\n\n当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：\n\n```js\n<BlogPost title=\"我的 Vue 学习之旅\" />\n<BlogPost title=\"Vue 博客文章总集\" />\n<BlogPost title=\"为什么 Vue 这么有趣\" />\n```\n\n然而在某些应用中，你也许在父组件中有如下的一个博客文章数组：\n\n```js\nconst posts = ref([\n  { id: 1, title: ''My journey with Vue'' },\n  { id: 2, title: ''Blogging with Vue'' },\n  { id: 3, title: ''Why Vue is so fun'' }\n]);\n```\n\n则可以使用 `v-for` 来渲染它们：\n\n```js\n<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n  @click=\"TagSkip(post.id)\"\n />\n```\n',2,2,4,21),
(768,'Props声明','组件需要显式声明 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute\n\n##### 运行时声明1\n\n```js\nconst props = defineProps({\n  foo: { type: String, required: true },\n  bar: Number\n});\nprops.foo; // string\nprops.bar; // number | undefined\n```\n\n##### 使用对象声明\n\n```js\n//<script setup>\ndefineProps({\n  title: String,\n  likes: Number\n});\n//非<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n};\n```\n\n',2,3,4,27),
(774,'CSS简介','你需要具备的知识\n\n在继续学习之前，你需要对下面的知识有基本的了解：\n\n- HTML / XHTML\n\n### 什么是CSS\n\n- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)\n- 样式定义**如何显示** HTML 元素\n- 样式通常存储在**样式表**中\n- 把样式添加到 HTML 4.0 中，是为了**解决内容与表现分离的问题**\n- **外部样式表**可以极大提高工作效率\n- 外部样式表通常存储在 **CSS 文件**中\n- 多个样式定义可**层叠**为一个',8,2,4,5),
(775,'通过#去锚定对应内容','\n\n实现了一个 tab 切换的效果\n\n```html\n<div>\n  <a href=\"#A\">A</a>\n  <a href=\"#B\">B</a>\n</div>\n<div className=\"scroll-ctn\">\n  <div id=\"A\" className=\"scroll-panel\">\n    A\n  </div>\n  <div id=\"B\" className=\"scroll-panel\">\n    B\n  </div>\n</div>\n\n```\n\n为了实现平滑滚动，我们在滚动容器上设置了如下的 CSS\n\n```css\n.scroll-ctn {\n  display: block;\n  width: 100%;\n  height: 300px;\n  overflow-y: scroll;\n  scroll-behavior: smooth;\n  border: 1px solid grey;\n}\n```\n\n1',8,3,4,5),
(776,'父容器固定并占位','- 使用相对定位 relative\n- 参照物：元素偏移前自身的位置\n- 相对定位也通过left,right,top,bottom来决定元素偏移的位置',8,3,4,5),
(777,'网站变灰gray','```\nhtml{\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\''http://www.w3.org/2000/svg\\''><filter id=\\''grayscale\\''><feColorMatrix type=\\''matrix\\'' values=\\''0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\''/></filter></svg>#grayscale\");\n    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n    -webkit-filter: grayscale(1);\n}\n```\n',8,3,4,5),
(778,'div局部滚动','\n\n```\nh-full overflow-y-scroll\n```\n\n但是当元素没有内容时候，设置height:100%，该元素不会被撑开，此时高度为0，\n\n但是设置height:100vh，该元素会被撑开与屏幕高度一致',8,3,4,5),
(779,'input标签居中','对于inline元素的input标签，将其父元素的text-align属性设置为center。\n\n```html\n<div style=\"text-align: center;\">\n  <input type=\"text\" placeholder=\"输入内容\">\n</div>\n```\n\n',8,3,4,5),
(780,'初始化','\n\n在 Vue3 中可以直接放在 `setup` 里，或者放在 `onMounted/onBeforeMount` 里\n\n```vue\n<script setup>\nimport { onMounted } from ''vue''\n\n// 请求接口函数\nconst getData = () => {\n    xxxApi.then(() => { ... })\n}\n\nonMounted(() => {\n    getData()\n})\n</script>\n```',2,2,4,5);
/*!40000 ALTER TABLE `snippet` ENABLE KEYS */;

-- 
-- Definition of video
-- 

DROP TABLE IF EXISTS `video`;
CREATE TABLE IF NOT EXISTS `video` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '链接路径',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL,
  `time_create` datetime NOT NULL COMMENT '时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `video_type_id` (`type_id`),
  KEY `video_user_id` (`user_id`),
  CONSTRAINT `video_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_video_type` (`id`),
  CONSTRAINT `video_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;

-- 
-- Dumping data for table video
-- 

/*!40000 ALTER TABLE `video` DISABLE KEYS */;
INSERT INTO `video`(`id`,`name`,`img`,`url`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(25,'我们的故事，英雄联盟！','https://s1.ax1x.com/2020/11/11/BX2acT.png','//player.bilibili.com/player.html?aid=45028887&bvid=BV1zb411b7JK&cid=78863318&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(26,'故事开始的地方——为你的本命献上弹幕吧！','https://s1.ax1x.com/2020/11/11/BX2N90.jpg','//player.bilibili.com/player.html?aid=25180028&bvid=BV18s411j7CL&cid=42677566&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(27,'用战斗来祭奠这个世界 ！！','https://s1.ax1x.com/2020/11/11/BX2BB4.jpg','//player.bilibili.com/player.html?aid=1328701&bvid=BV1px411N7Yd&cid=2015358&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(28,'前方高能！让世界感受这场视觉盛宴吧！','https://s1.ax1x.com/2020/11/11/BX20uF.jpg','//player.bilibili.com/player.html?aid=50331935&bvid=BV1x441187u5&cid=92865323&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(29,'这才是忍者世界的巅峰战力！','https://s1.ax1x.com/2020/11/11/BX2U3V.jpg','//player.bilibili.com/player.html?aid=71840112&bvid=BV1HE41167kR&cid=124483833&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(30,'这个故事 还没有完结','https://s1.ax1x.com/2020/11/11/BX2JNn.jpg','//player.bilibili.com/player.html?aid=66382748&bvid=BV1J441117u7&cid=115130259&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(31,'感受国服配音的魅力吧！ 你的热血从未结霜！！','https://s1.ax1x.com/2020/11/11/BX2Yhq.jpg','//player.bilibili.com/player.html?aid=18767799&bvid=BV1WW411e7wq&cid=30610512&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(32,'敌人虽众，一击皆斩！','https://s1.ax1x.com/2020/11/11/BX2JNn.jpg','//player.bilibili.com/player.html?aid=22446917&bvid=BV1SW41157WM&cid=37190046&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(33,'【英雄联盟/CG/燃向】 召唤师 如果没有你们 何为英雄 何为联盟','https://s3.ax1x.com/2020/11/13/Dpmoee.jpg','//player.bilibili.com/player.html?aid=78147108&bvid=BV1fJ411v7Q6&cid=133666781&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(34,'【超燃巨作/视听盛宴】我...已被这优雅蒙蔽了双眼... 「英雄联盟系列混剪」','https://s3.ax1x.com/2020/11/13/DpnyX8.jpg','//player.bilibili.com/player.html?aid=49445129&bvid=BV1gb411j7r4&cid=86578090&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(35,'那不屈的嘶吼和永不低头的信念使我们迎难而上','https://s3.ax1x.com/2020/11/13/Dputg0.png','//player.bilibili.com/player.html?aid=49661297&bvid=BV1ib41157zQ&cid=86951456&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(36,'这就是英雄联盟的魅力！','https://s3.ax1x.com/2020/11/13/DpKDL8.jpg','//player.bilibili.com/player.html?aid=47199816&bvid=BV1nb41147HD&cid=82660090&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(37,'【火影忍者百万填词】一袋米要扛几楼','https://s3.ax1x.com/2020/11/13/DpQAN4.jpg','//player.bilibili.com/player.html?aid=56970467&bvid=BV1Px411d7em&cid=99503508&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(38,'『忍び的时代真的结束了吗？』让鸡皮疙瘩和肾上腺素','https://s3.ax1x.com/2020/11/13/DpQxaD.png','//player.bilibili.com/player.html?aid=81848177&bvid=BV1HJ411j771&cid=140045131&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00');
/*!40000 ALTER TABLE `video` ENABLE KEYS */;


/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;


-- Dump completed on 2023-07-17 16:38:36
-- Total time: 0:0:0:0:142 (d:h:m:s:ms)
