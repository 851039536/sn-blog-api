-- MySqlBackup.NET 2.3.5
-- Dump Time: 2024-05-31 19:06:35
-- --------------------------------------
-- Server version 8.0.24 MySQL Community Server - GPL


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;


-- 
-- Definition of article_tag
-- 

DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE IF NOT EXISTS `article_tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标签名称',
  `description` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标签描述',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=62 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table article_tag
-- 

/*!40000 ALTER TABLE `article_tag` DISABLE KEYS */;
INSERT INTO `article_tag`(`id`,`name`,`description`) VALUES
(2,'winfrom','0'),
(3,'类库','类库'),
(4,'文章','文章'),
(5,'axios','axios'),
(6,'刷新','刷新'),
(8,'委托','委托'),
(9,'jwt','jwt'),
(31,'scroll','scroll'),
(34,'swagger','swagger'),
(35,'异常','异常'),
(36,'工具','工具'),
(38,'wpf','wpf'),
(39,'api','api'),
(40,'跨域','跨域'),
(41,'orm',''),
(42,'依赖注入','依赖注入'),
(43,'插件','插件'),
(47,'ini','ini'),
(48,'数据映射',''),
(49,'缓存',''),
(51,'方法','方法'),
(52,'多线程','多线程'),
(53,'配置','配置'),
(54,'类','类'),
(55,'字符串','字符串'),
(56,'单元测试','单元测试'),
(57,'switch','switch'),
(58,'变量','变量'),
(59,'插件','插件'),
(60,'组件','组件'),
(61,'生命周期','生命周期');
/*!40000 ALTER TABLE `article_tag` ENABLE KEYS */;

-- 
-- Definition of article_type
-- 

DROP TABLE IF EXISTS `article_type`;
CREATE TABLE IF NOT EXISTS `article_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '分类名称',
  `description` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin COMMENT '分类描述',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=111 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table article_type
-- 

/*!40000 ALTER TABLE `article_type` DISABLE KEYS */;
INSERT INTO `article_type`(`id`,`name`,`description`) VALUES
(1,'vue','vue'),
(2,'axios','axios'),
(3,'netcore','netcore'),
(4,'vite','vite'),
(103,'mysql','数据库'),
(104,'csharp','语言'),
(105,'windows','windows'),
(106,'markdown','markdown'),
(107,'sqlsugar','sqlsugar'),
(109,'教程','教程'),
(110,'vscode','vscode');
/*!40000 ALTER TABLE `article_type` ENABLE KEYS */;

-- 
-- Definition of diary_type
-- 

DROP TABLE IF EXISTS `diary_type`;
CREATE TABLE IF NOT EXISTS `diary_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC COMMENT='日记分类';

-- 
-- Dumping data for table diary_type
-- 

/*!40000 ALTER TABLE `diary_type` DISABLE KEYS */;
INSERT INTO `diary_type`(`id`,`name`) VALUES
(4,'舔狗日记'),
(5,'毒鸡汤');
/*!40000 ALTER TABLE `diary_type` ENABLE KEYS */;

-- 
-- Definition of interface_type
-- 

DROP TABLE IF EXISTS `interface_type`;
CREATE TABLE IF NOT EXISTS `interface_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table interface_type
-- 

/*!40000 ALTER TABLE `interface_type` DISABLE KEYS */;
INSERT INTO `interface_type`(`id`,`name`) VALUES
(1,'header'),
(2,'sidebar');
/*!40000 ALTER TABLE `interface_type` ENABLE KEYS */;

-- 
-- Definition of interface
-- 

DROP TABLE IF EXISTS `interface`;
CREATE TABLE IF NOT EXISTS `interface` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `path` varchar(80) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '路径',
  `type_id` int NOT NULL COMMENT '类别',
  `user_id` int NOT NULL COMMENT '用户',
  `identity` tinyint(1) NOT NULL COMMENT '显示隐藏',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `type_id` (`type_id`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  CONSTRAINT `interface_ibfk_2` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `type` FOREIGN KEY (`type_id`) REFERENCES `interface_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=136 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table interface
-- 

/*!40000 ALTER TABLE `interface` DISABLE KEYS */;
INSERT INTO `interface`(`id`,`name`,`path`,`type_id`,`user_id`,`identity`) VALUES
(1,'主页','/article/column',2,4,1),
(2,'博客','/qarticle',2,4,1),
(9,'日记','/diary',2,4,1),
(10,'哔哔视频','/video',2,4,1),
(11,'网站导航','/favorite',2,4,1),
(12,'博客导航','/BlogCircles',2,4,1),
(13,'我的书单','/book',2,4,1),
(14,'聚合搜索','/ListContent',2,4,0),
(17,'图册','/Photo',1,4,1),
(18,'代码块','code',1,4,0),
(19,'后台管理','/Admin-index/ArticleTable',2,4,1),
(128,'博客导航','/BlogCircles',2,1,1),
(131,'网站导航','/favorite',2,1,1),
(134,'博客','/qarticle',2,1,1),
(135,'主页','/article/column',2,1,1);
/*!40000 ALTER TABLE `interface` ENABLE KEYS */;

-- 
-- Definition of navigation_type
-- 

DROP TABLE IF EXISTS `navigation_type`;
CREATE TABLE IF NOT EXISTS `navigation_type` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=40 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table navigation_type
-- 

/*!40000 ALTER TABLE `navigation_type` DISABLE KEYS */;
INSERT INTO `navigation_type`(`id`,`name`) VALUES
(1,'npm'),
(2,'网站'),
(3,'vue'),
(4,'net'),
(5,'JavaScript'),
(7,'收藏'),
(8,'博客圈'),
(9,'css'),
(10,'论坛'),
(11,'导航'),
(13,'文档'),
(14,'工具'),
(15,'学习'),
(16,'mysql'),
(17,'在线刷题'),
(18,'图库'),
(19,'前端框架'),
(20,'markdown'),
(21,'uniapp'),
(22,'efcore'),
(23,'docker'),
(24,'vue组件库'),
(26,'vite'),
(27,'常用工具'),
(28,'wpf'),
(29,'orm'),
(30,'cdn'),
(31,'css框架'),
(32,'github'),
(33,'官方文档'),
(34,'博客'),
(35,'图标'),
(36,'软件'),
(37,'框架'),
(38,'gpt'),
(39,'灵感');
/*!40000 ALTER TABLE `navigation_type` ENABLE KEYS */;

-- 
-- Definition of photo_gallery_type
-- 

DROP TABLE IF EXISTS `photo_gallery_type`;
CREATE TABLE IF NOT EXISTS `photo_gallery_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table photo_gallery_type
-- 

/*!40000 ALTER TABLE `photo_gallery_type` DISABLE KEYS */;
INSERT INTO `photo_gallery_type`(`id`,`name`) VALUES
(1,'TEST');
/*!40000 ALTER TABLE `photo_gallery_type` ENABLE KEYS */;

-- 
-- Definition of photo_type
-- 

DROP TABLE IF EXISTS `photo_type`;
CREATE TABLE IF NOT EXISTS `photo_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table photo_type
-- 

/*!40000 ALTER TABLE `photo_type` DISABLE KEYS */;
INSERT INTO `photo_type`(`id`,`name`) VALUES
(1,'test');
/*!40000 ALTER TABLE `photo_type` ENABLE KEYS */;

-- 
-- Definition of sn_comments
-- 

DROP TABLE IF EXISTS `sn_comments`;
CREATE TABLE IF NOT EXISTS `sn_comments` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '评论主键',
  `user_id` int NOT NULL COMMENT '用户id',
  `give` int NOT NULL COMMENT '点赞数',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `time_create` datetime NOT NULL COMMENT '评论日期',
  `time_modified` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_comments
-- 

/*!40000 ALTER TABLE `sn_comments` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_comments` ENABLE KEYS */;

-- 
-- Definition of sn_picture_type
-- 

DROP TABLE IF EXISTS `sn_picture_type`;
CREATE TABLE IF NOT EXISTS `sn_picture_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_picture_type
-- 

/*!40000 ALTER TABLE `sn_picture_type` DISABLE KEYS */;
INSERT INTO `sn_picture_type`(`id`,`name`) VALUES
(1,'article'),
(2,'User'),
(3,'Video');
/*!40000 ALTER TABLE `sn_picture_type` ENABLE KEYS */;

-- 
-- Definition of sn_picture
-- 

DROP TABLE IF EXISTS `sn_picture`;
CREATE TABLE IF NOT EXISTS `sn_picture` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图床名',
  `img_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片地址',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `prcture_type_id` (`type_id`) USING BTREE,
  KEY `pivture_user_id` (`user_id`) USING BTREE,
  CONSTRAINT `pivture_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `prcture_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_picture_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_picture
-- 

/*!40000 ALTER TABLE `sn_picture` DISABLE KEYS */;
INSERT INTO `sn_picture`(`id`,`name`,`img_url`,`type_id`,`user_id`) VALUES
(2,'blog','/img/blog/1.jpg',1,4),
(3,'blog','/img/blog/2.jpg',1,4),
(4,'blog','/img/blog/3.jpg',1,4),
(6,'blog','/img/blog/4.jpg',1,4),
(7,'blog','/img/blog/5.jpg',1,4);
/*!40000 ALTER TABLE `sn_picture` ENABLE KEYS */;

-- 
-- Definition of sn_setblog_type
-- 

DROP TABLE IF EXISTS `sn_setblog_type`;
CREATE TABLE IF NOT EXISTS `sn_setblog_type` (
  `id` int NOT NULL,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_setblog_type
-- 

/*!40000 ALTER TABLE `sn_setblog_type` DISABLE KEYS */;
INSERT INTO `sn_setblog_type`(`id`,`name`) VALUES
(0,'后台设置'),
(1,'主页设置');
/*!40000 ALTER TABLE `sn_setblog_type` ENABLE KEYS */;

-- 
-- Definition of sn_software_type
-- 

DROP TABLE IF EXISTS `sn_software_type`;
CREATE TABLE IF NOT EXISTS `sn_software_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_software_type
-- 

/*!40000 ALTER TABLE `sn_software_type` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_software_type` ENABLE KEYS */;

-- 
-- Definition of sn_software
-- 

DROP TABLE IF EXISTS `sn_software`;
CREATE TABLE IF NOT EXISTS `sn_software` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '标题',
  `img` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '图片路径',
  `type_id` int DEFAULT NULL COMMENT '分类',
  `comment_id` int DEFAULT NULL COMMENT '评论',
  `time_create` datetime DEFAULT NULL COMMENT '时间',
  `time_modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `software_type_id` (`type_id`) USING BTREE,
  CONSTRAINT `software_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_software_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_software
-- 

/*!40000 ALTER TABLE `sn_software` DISABLE KEYS */;

/*!40000 ALTER TABLE `sn_software` ENABLE KEYS */;

-- 
-- Definition of sn_talk_type
-- 

DROP TABLE IF EXISTS `sn_talk_type`;
CREATE TABLE IF NOT EXISTS `sn_talk_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_talk_type
-- 

/*!40000 ALTER TABLE `sn_talk_type` DISABLE KEYS */;
INSERT INTO `sn_talk_type`(`id`,`name`) VALUES
(3,'版本更新'),
(4,'测试'),
(5,'生活');
/*!40000 ALTER TABLE `sn_talk_type` ENABLE KEYS */;

-- 
-- Definition of sn_talk
-- 

DROP TABLE IF EXISTS `sn_talk`;
CREATE TABLE IF NOT EXISTS `sn_talk` (
  `id` int NOT NULL AUTO_INCREMENT,
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `describe` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '简介',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `read` int NOT NULL COMMENT '阅读量',
  `give` int NOT NULL COMMENT '点赞',
  `comment_id` int NOT NULL COMMENT '评论',
  `user_id` int NOT NULL COMMENT '用户',
  `type_id` int NOT NULL,
  `time_create` datetime NOT NULL COMMENT '发表时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  KEY `sn_talk_typeId` (`type_id`) USING BTREE,
  CONSTRAINT `lalk_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `talk_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_talk_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_talk
-- 

/*!40000 ALTER TABLE `sn_talk` DISABLE KEYS */;
INSERT INTO `sn_talk`(`id`,`title`,`describe`,`text`,`read`,`give`,`comment_id`,`user_id`,`type_id`,`time_create`,`time_modified`) VALUES
(3,'Blog-12.18更新','favorite,博客页面样式更新样式更新,内容页面,时间线页面动态加载组件数据提示框更新为骨架框','<h3>1.样式更新</h3><p><span style=\"color: rgb(68, 68, 68);\">favorite</span>,<span style=\"color: rgb(68, 68, 68);\">博客页面样式更新样式更新</span></p><h3>2.内容页改动</h3><p><span style=\"color: rgb(68, 68, 68);\">内容页面,时间线页面动态加载组件数据提示框更新为骨架框</span></p><h3>3.时间线改动</h3><p><span style=\"color: rgb(68, 68, 68);\">增加one日记动态数据时间线增加跳转到页面详情</span></p>',0,0,0,4,3,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(17,'Blog-12.21更新','','<h3>1.增加页面</h3><p>增加日志详情页面-TalkText.vue, OneSidebar.vue 文章侧边栏界面</p><h3>2.Talk页面改动</h3><p>增加页面跳转至TalkText.vue</p><p>About关于界面增加功能跳转</p><p>One文章页面增加 OneSidebar文章侧边栏</p>',0,0,0,4,3,'2020-12-21 00:00:00','2020-12-18 00:00:00'),
(18,'Blog-12.23更新','优化了Indexs,Talk及侧边栏等页面字体样式及抗齿轮,one页面增加点击弹出详情框及更新了css样式','<h3>1.页面优化</h3><ul><li>优化了Indexs,Talk及侧边栏等页面字体样式及抗齿轮</li><li>one页面增加点击弹出详情框及更新了css样式</li><li>OneSidebar侧边栏时间字段格式优化,增加点击弹出详情页</li><li>Snvodeo视频页面及详情页增加时间字段格式优化</li><li>TalkTest页面头部组件更新</li><li>TimeLine时间组件动态字段更新增加(分类,标签,文章,阅读,字段数)</li><li>Sidebarsn css样式更新</li><li>IndexSidebar 站点信息增加动态更新</li></ul><h3>2.新增</h3><ul><li>增加nprogress顶部加载组件</li><li>增加store状态管理</li><li>增加Transfer文章中转站页面</li></ul><p><br></p><h3>3.页面重构</h3><ul><li>app页面js更改为ts方式重写</li></ul><h3>4.其他优化</h3><ul><li>修复Indextext2页面跳转当前页面不刷新</li><li>封装了内容详情(blogs)css样式</li><li>增加视频图片</li></ul>',0,0,0,4,3,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(19,'Blog-12.25更新','','<h3>1.页面改动</h3><p>app.vue 删除背景颜色设定</p><p>com.scss 封装line-ome index.css</p><p>增加响应式设定</p><p>导航页面css调整</p><p>收藏页面增加动态数据分类框(之前是静态)</p><p>one侧边栏动态增加字段,文章数量,阅读显示</p><p>删除日志Talk页面顶部信息框,删除侧边栏图标框 Headers.vue 样式调整</p><h3>2.新增内容</h3><p>增加新字体 font.css并应用页面</p><p>增加响应式断点主页面已完成响应式设定</p><p>新增字体文件 新增移动端状态下显示底部导航框bootom</p>',0,0,0,4,3,'2020-12-25 00:00:00','2020-12-18 00:00:00'),
(20,'展望','','<p>是佛挡杀佛的范德萨发</p>',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00'),
(21,'青春真的结束了吗','','',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00'),
(22,'Blog正式投入使用','','<p>经过接近一个月时间的项目重构(vue2--&gt;vue3+ts),主要部分功能已经完善。</p><p><strong>以下已完成功能</strong></p><p>主页技术方面的文章阅读</p><p>标签页面方面查找对应的文章进行阅读</p><p>时间线</p><p>导航站</p><p>日志-&gt;只做个人文章展示</p><p><strong>娱乐项</strong></p><p>短文仅供一乐(舔狗日志)</p><p>收藏,博客页面分享各路大神技术博客</p><p><strong>待进行功能</strong></p><p>书单--准备进行</p><p>后台-- 后台系统大部分功能已近完善,基本可以投入生产,但是还有很多细节方面没弄好暂不上线</p><p>留言-- 前端已完成,后台api已完成待导入接口</p><p><strong>待优化功能项</strong></p><p>额!!!!!!! 好像都需要优化</p><p>后续增加一个新页面来追踪自己要做什么,做到什么进度。就叫个人项目进度追踪应该也算是新功能了</p><p><strong>项目架构</strong></p><p>前端项目使用到的技术</p><p><span style=\"color: rgb(136, 136, 136);\">VUE3 -- TS -- Router -- Axios -- Store -- AntDesignVue -- TaiwindCss -- animate.css -- marked</span></p><p>后端项目</p><p>NetCore3.1webApi</p><p><strong>本次更新</strong></p><p>1.增加导航侧边栏 FavSidebar.vue</p><p>2.增加书单页面 Book.vue</p><p>3.增加图片视频展示</p><p>4.删除字体(太大了)</p><p>5.Talk.vue 页面进行重构(想好看点)</p><p><br></p>',0,0,0,4,3,'2020-12-26 00:00:00','2020-12-18 00:00:00');
/*!40000 ALTER TABLE `sn_talk` ENABLE KEYS */;

-- 
-- Definition of sn_user_friends
-- 

DROP TABLE IF EXISTS `sn_user_friends`;
CREATE TABLE IF NOT EXISTS `sn_user_friends` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL COMMENT '用户id',
  `user_friends_id` int DEFAULT NULL COMMENT '好友id',
  `user_note` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '好友备注',
  `user_status` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL COMMENT '好友状态',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_user_friends
-- 

/*!40000 ALTER TABLE `sn_user_friends` DISABLE KEYS */;
INSERT INTO `sn_user_friends`(`id`,`user_id`,`user_friends_id`,`user_note`,`user_status`) VALUES
(1,1,2,'小张','在线');
/*!40000 ALTER TABLE `sn_user_friends` ENABLE KEYS */;

-- 
-- Definition of sn_video_type
-- 

DROP TABLE IF EXISTS `sn_video_type`;
CREATE TABLE IF NOT EXISTS `sn_video_type` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_video_type
-- 

/*!40000 ALTER TABLE `sn_video_type` DISABLE KEYS */;
INSERT INTO `sn_video_type`(`id`,`name`) VALUES
(1,'火影'),
(2,'LOL');
/*!40000 ALTER TABLE `sn_video_type` ENABLE KEYS */;

-- 
-- Definition of snippet_tag
-- 

DROP TABLE IF EXISTS `snippet_tag`;
CREATE TABLE IF NOT EXISTS `snippet_tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=816 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table snippet_tag
-- 

/*!40000 ALTER TABLE `snippet_tag` DISABLE KEYS */;
INSERT INTO `snippet_tag`(`id`,`name`) VALUES
(1,'待分配'),
(21,'test'),
(22,'DOM,监听'),
(24,'getCurrentInstance,proxy'),
(25,'全局属性'),
(26,'注释'),
(27,'注释'),
(28,'按键'),
(29,'apply'),
(30,'font-face'),
(31,'响应式'),
(32,'符号'),
(33,'符号'),
(34,'vue3'),
(35,'cursor,点击'),
(36,'居中'),
(37,'div,scroll'),
(38,'变灰'),
(39,'滚动,scroll'),
(40,'relative,相对'),
(41,'简介'),
(42,'Props'),
(43,'script setup'),
(44,'组件传递'),
(45,'组件通信'),
(46,'通讯'),
(47,'格式'),
(48,'注册'),
(49,'全局组件'),
(50,'watchEffect'),
(51,'监听函数'),
(52,'组件实例'),
(53,'class'),
(54,'绑定,class'),
(55,'绑定'),
(56,'标注'),
(57,'标签'),
(58,'动态'),
(59,'插槽'),
(60,'组件名'),
(61,'监听'),
(62,'监听'),
(63,'路由,监听,watch'),
(64,'watch,watchEffect'),
(65,'鼠标'),
(66,'DOM'),
(67,'模态框'),
(68,'清除,cookie'),
(69,'数组,集合'),
(70,'字符,截取'),
(71,'substr'),
(72,'截取'),
(73,'对象'),
(74,'组件,DOM,Teleport'),
(75,'teleport,dom'),
(76,'缓存'),
(77,'component'),
(78,'max'),
(79,'缓存'),
(80,'缓存'),
(81,'插槽,路由'),
(82,'缓存'),
(83,'内置组件'),
(84,'内置组件'),
(85,' 表达式'),
(86,'export,default'),
(87,'export'),
(88,'模块'),
(89,'模块'),
(90,'数据结构'),
(91,'set,元素'),
(92,'箭头函数'),
(93,'触摸'),
(94,'日期'),
(95,'随机数'),
(96,'变量'),
(97,'Array'),
(98,'扩展运算'),
(99,'Transition'),
(100,'reverse,split'),
(101,'值判断'),
(102,'数据绑定'),
(103,'赋值'),
(104,'过滤'),
(105,'包含,includes'),
(106,'endsWith'),
(107,'判断'),
(108,'判断'),
(109,'分隔符'),
(110,'拼接'),
(111,'分隔'),
(112,'去重'),
(113,'null'),
(114,'平均值'),
(115,'v-on'),
(116,'toUpperCase'),
(117,'判断'),
(118,' ISO-8859-1'),
(119,'片段'),
(120,'替换'),
(121,'操作符'),
(122,'异步,遍历,for'),
(123,'Object '),
(124,'fixed'),
(125,'绑定,class'),
(126,'startsWith'),
(127,'repeat'),
(128,'padStart,padEnd'),
(129,'includes,数组'),
(130,'Symbol'),
(131,'toLowerCase'),
(132,'onMounted'),
(133,'bool,随机'),
(134,'print,浏览器'),
(135,'URL'),
(136,'底部'),
(137,'设备'),
(138,'文本,window'),
(139,'标签'),
(140,'window,窗体'),
(141,'copy,剪切板'),
(142,'random,进制,颜色'),
(143,'string'),
(144,'颜色,转换'),
(145,'Number,Math'),
(146,'Math'),
(147,'判断'),
(148,'concat'),
(149,'isArray'),
(150,'移除'),
(151,'html'),
(152,'截断'),
(153,'random'),
(154,'reverse'),
(155,'url '),
(156,'字符,进制'),
(157,'Object'),
(158,'slice'),
(159,'节流'),
(160,'密码'),
(161,'replace'),
(162,'空格'),
(163,'平均'),
(164,'reduce'),
(165,'Math'),
(166,'max'),
(167,'转换'),
(168,'元素'),
(169,'排序'),
(170,'元素'),
(171,'大写'),
(172,'中文'),
(173,'random'),
(174,'js'),
(175,'类型'),
(176,'window'),
(177,'滚动,document'),
(178,'坐标'),
(179,'class'),
(180,'class'),
(181,'class'),
(182,'下载'),
(183,'url'),
(184,'标签'),
(185,'PC'),
(186,'IOS'),
(187,'爬虫'),
(188,'浏览器'),
(189,'浏览器'),
(190,'相邻'),
(191,'Set'),
(192,'Promise'),
(193,'Symbol'),
(194,'对象'),
(195,'正则'),
(196,'数组'),
(197,'函数'),
(198,'boolean'),
(199,'数字'),
(200,'字符串'),
(201,'地址'),
(202,'号码'),
(203,'charAt'),
(204,'max,min'),
(205,'toTimeString'),
(206,'重复'),
(207,'indexOf'),
(208,'条件'),
(209,'find'),
(210,'解构'),
(211,'parseInt,parseFloat'),
(212,'对象'),
(213,'跨行'),
(214,'模板'),
(215,'操作符'),
(216,'undefined'),
(217,'类型'),
(218,'箭头函数'),
(219,'默认'),
(220,'for'),
(221,'switch'),
(222,'function'),
(223,'function'),
(224,'function'),
(225,'for,forEach'),
(226,'if,&&'),
(227,'if,''&&'''),
(228,'if'),
(229,'if'),
(230,'++,--'),
(231,'操作符'),
(232,'赋值'),
(233,'scroll'),
(234,'命名'),
(235,'undefined,null'),
(236,'变量'),
(237,'if else'),
(238,'if'),
(239,'号码'),
(240,'邮箱'),
(241,'const'),
(242,'Array'),
(243,'log'),
(244,'全局'),
(245,'日期,floor'),
(246,'日期,getTime'),
(247,'日期'),
(248,'转换'),
(249,'undefined,null'),
(250,'array'),
(251,'parseInt,parseFloat'),
(252,'if'),
(253,'window'),
(254,'num'),
(255,'location,window'),
(256,'简化'),
(257,'默认值'),
(258,'三元'),
(259,'if'),
(260,'document'),
(261,'forEach'),
(262,'uuid'),
(263,'判断'),
(264,'URL'),
(265,'toUpperCase,toLowerCase'),
(266,'校验'),
(267,'export'),
(268,'window,log'),
(269,'reactive'),
(270,'css'),
(271,'类型转换'),
(272,'Get,then'),
(273,'scroll,smooth'),
(274,'nextTick,ref'),
(275,'属性,scroll'),
(276,'ref,scrollHeight'),
(277,'Transition'),
(278,'keydown,event'),
(279,'mouseover,mouseleave'),
(280,'document'),
(281,'document'),
(282,'async,await'),
(283,'version'),
(284,'form'),
(285,'ref'),
(286,'FIXME,TODO'),
(287,'globalProperties'),
(288,'document,inspect'),
(289,'window,下载'),
(290,'shallowRef,component'),
(291,'HTML'),
(292,'绑定'),
(293,'条码,mes,sn,绑定'),
(294,'工单,mes,途程,料号'),
(295,'控制字符,ASCII'),
(296,'显示字符,ASCII'),
(297,'错误代码'),
(298,'屏蔽箱,232,USB'),
(299,'弹窗,API'),
(300,'模板,图片'),
(301,'ble,灵敏度'),
(302,'api,log'),
(303,'log'),
(304,'dll,led'),
(305,'料号'),
(306,'测试项'),
(307,'条码,绑定'),
(308,'ip'),
(309,'模拟'),
(310,'字典'),
(311,'字典'),
(312,'api,字典'),
(313,'api,字典,bda'),
(314,'api,字典'),
(315,'api,字典,bda'),
(316,'api,字典,绑定'),
(317,'配置'),
(318,'烧录,RT550'),
(319,'路径,path'),
(320,'函数,委托,action'),
(321,'vid,pid,guid'),
(322,'控制台'),
(323,'进度条'),
(324,'path'),
(325,'反转'),
(326,'反转'),
(327,'判断'),
(328,'编码,解码'),
(329,'usb'),
(330,'驱动器'),
(331,'Process'),
(332,'装置,驱动'),
(333,'BD,MES'),
(334,'test'),
(335,'test1'),
(336,'scroll,滚动,vue'),
(337,'hooks,函数'),
(338,'font-face,字体'),
(339,'setInterval'),
(340,'动态组件'),
(341,'Transition'),
(342,'duration,Transition'),
(343,'动态组件'),
(344,'image'),
(345,'scrollTop'),
(346,'deep'),
(347,'defineAsyncComponent'),
(348,'ref'),
(349,'is'),
(350,'path,目录'),
(351,'堆栈'),
(352,'windows'),
(353,'Process'),
(354,'Process'),
(355,'反射'),
(356,'Delete'),
(357,'appear,Transition'),
(358,'Transition'),
(359,'Transition'),
(360,'animation'),
(361,'Delete'),
(362,'genericity'),
(363,'T'),
(364,'file'),
(365,'file'),
(366,'props'),
(367,'slot'),
(368,'slot'),
(369,'slot'),
(370,'slot'),
(371,'Copy'),
(372,'file'),
(373,'Write'),
(374,'Directory'),
(375,'Length'),
(376,'rows'),
(377,'Create'),
(378,'directoryPath'),
(379,'居中'),
(380,'fixed'),
(381,'file'),
(382,'file'),
(383,'file'),
(384,'复制'),
(385,'file'),
(386,'file'),
(387,'file'),
(388,'Animation'),
(389,'Transition'),
(390,'Transition'),
(391,'transition'),
(392,'file'),
(393,'file'),
(394,'file'),
(395,'file'),
(396,'file'),
(397,'file'),
(398,'file'),
(399,'Open'),
(400,'byte,int'),
(401,'byte,string'),
(402,'byte,string'),
(403,'进制'),
(404,'字符'),
(405,'v-bind,style'),
(406,'v-bind'),
(407,'main'),
(408,'partial'),
(409,'partial'),
(410,'let,var,const'),
(411,'let,var,const'),
(412,'const'),
(413,'Number'),
(414,'BigInt'),
(415,'String'),
(416,'String'),
(417,'Boolen'),
(418,'null'),
(419,'undefined'),
(420,'typeof'),
(421,'alert'),
(422,'prompt'),
(423,'confirm'),
(424,'String'),
(425,'Number'),
(426,'Boolean'),
(427,'数学'),
(428,'二元运算符'),
(429,'+'),
(430,'一元运算符'),
(431,'优先级'),
(432,' 赋值'),
(433,'运算符'),
(434,'值'),
(435,'Boolean'),
(436,'string'),
(437,'类型'),
(438,'==='),
(439,'||'),
(440,'&&'),
(441,'非'),
(442,'if'),
(443,'bool'),
(444,'else'),
(445,'else if'),
(446,'运算符'),
(447,'运算符'),
(448,'switch'),
(449,'while'),
(450,'do...while'),
(451,'for'),
(452,'break'),
(453,'continue'),
(454,'break <labelName>'),
(455,'变量'),
(456,'变量'),
(457,'function'),
(458,'function'),
(459,'function'),
(460,'debug'),
(461,'对象'),
(462,'对象'),
(463,'属性'),
(464,'[\"xx\"]'),
(465,'for..in'),
(466,'克隆'),
(467,'克隆'),
(468,'function'),
(469,'对象'),
(470,'symbol'),
(471,'symbol'),
(472,'symbol'),
(473,'number'),
(474,'number'),
(475,'number'),
(476,'number'),
(477,'number'),
(478,'math'),
(479,'math'),
(480,'string'),
(481,'string'),
(482,'string'),
(483,'string'),
(484,'indexOf'),
(485,'includes'),
(486,'slice'),
(487,'substring'),
(488,'substr'),
(489,'utf'),
(490,'utf'),
(491,'Array'),
(492,'Array'),
(493,'Array'),
(494,'Array'),
(495,'Array'),
(496,'Array'),
(497,'Array'),
(498,'Array'),
(499,'Array,slice'),
(500,'array,slice'),
(501,'array,forEach'),
(502,'array,indexOf,includes'),
(503,'array,find'),
(504,'array,filter'),
(505,'array,reverse'),
(506,'array,isArray'),
(507,'array'),
(508,'string'),
(509,'map'),
(510,'map'),
(511,'map'),
(512,'map,forEach,for'),
(513,'map'),
(514,'set'),
(515,'set'),
(516,'set,map'),
(517,'集合'),
(518,'WeakSet'),
(519,'集合'),
(520,'解构'),
(521,'解构'),
(522,'解构'),
(523,'解构'),
(524,'解构'),
(525,'date'),
(526,'json'),
(527,'json'),
(528,'rest'),
(529,'Spread'),
(530,'function'),
(531,'window'),
(532,'MES'),
(533,'UID'),
(534,'计算'),
(535,'dll'),
(536,'委托'),
(537,'压缩'),
(538,'等待函数'),
(539,'进制'),
(540,'窗体'),
(541,'Windows'),
(542,'任务'),
(543,'监测'),
(544,'系统时间'),
(545,'驱动器'),
(546,'ip'),
(547,'修饰符'),
(548,'cmd'),
(549,'编译器'),
(550,'参数'),
(551,'待分配'),
(552,'list'),
(553,'slot'),
(554,'ref'),
(555,'匿名类'),
(556,'缓冲区'),
(557,'条件运算符'),
(558,'简介'),
(559,'类型转换'),
(560,'格式化'),
(561,'TryParse'),
(562,'METest'),
(563,'Insert'),
(564,'null'),
(565,'局部'),
(566,'switch'),
(567,'switch'),
(568,'switch'),
(569,'dynamic'),
(570,'DirectoryInfo'),
(571,'Directory'),
(572,'DirectoryInfo'),
(573,'DirectoryInfo'),
(574,'Directory'),
(575,'Directory'),
(576,'DirectoryInfo'),
(577,'DirectoryInfo'),
(578,'匿名'),
(579,'通讯'),
(580,'{{ msg }}'),
(581,'属性'),
(582,'v-bind'),
(583,'v-bind'),
(584,'v-bind'),
(585,'v-bind'),
(586,'v-bind'),
(587,'v-bind'),
(588,'v-bind'),
(589,'表达式'),
(590,'v-once'),
(591,'v-if'),
(592,'v-if'),
(593,'v-else'),
(594,'v-else-if'),
(595,'v-if'),
(596,'v-show'),
(597,'v-for'),
(598,'v-for'),
(599,'v-for'),
(600,'v-for'),
(601,'v-for'),
(602,'v-for'),
(603,'v-for'),
(604,'v-for'),
(605,'v-for'),
(606,'v-for'),
(607,'v-pre'),
(608,'v-cloak'),
(609,'v-text'),
(610,'v-on'),
(611,'v-on'),
(612,'v-on'),
(613,'v-on'),
(614,'v-on'),
(615,'v-on'),
(616,'v-on'),
(617,'v-on'),
(618,'v-on'),
(619,'v-on'),
(620,'v'),
(621,'v-model'),
(622,'v-model'),
(623,'v-model'),
(624,'v-model'),
(625,'v-model'),
(626,'v-model'),
(627,'props'),
(628,'Props'),
(629,'Props'),
(630,'Props'),
(631,'Props'),
(632,'mitt'),
(633,'defineAsyncComponent'),
(634,'defineAsyncComponent'),
(635,'defineAsyncComponent'),
(636,'defineAsyncComponent'),
(637,'defineAsyncComponent'),
(638,'defineAsyncComponent'),
(639,'focus'),
(640,'钩子函数'),
(641,'全局指令'),
(642,'指令'),
(643,'生命周期'),
(644,'命名'),
(645,'setup'),
(646,'nextTick'),
(647,'lang'),
(648,'scoped'),
(649,'deep'),
(650,'slotted'),
(651,'global'),
(652,'style'),
(653,'useCssModule'),
(654,'tsc'),
(655,'npm'),
(656,'Resize'),
(657,'类型'),
(658,'异步组件'),
(659,'ref'),
(660,'ref'),
(661,'ref'),
(662,'ref'),
(663,'ref'),
(664,'ref'),
(665,'ref'),
(666,'ref'),
(667,'ref'),
(668,'onMounted'),
(669,'onUpdated'),
(670,'onUnmounted'),
(671,'onBeforeMount'),
(672,'onBeforeUpdate'),
(673,'onBeforeUnmount'),
(674,'onErrorCaptured'),
(675,'onRenderTracked'),
(676,'onRenderTriggered'),
(677,'onActivated'),
(678,'onDeactivated'),
(679,'onServerPrefetch'),
(680,'ref'),
(681,'ref'),
(682,'ref'),
(683,'ref'),
(684,'ref'),
(685,'ref'),
(686,'reactive'),
(687,'reactive'),
(688,'reactive'),
(689,'reactive'),
(690,'reactive'),
(691,'reactive'),
(692,'reactive'),
(693,'reactive'),
(694,'computed'),
(695,'computed'),
(696,'computed'),
(697,'computed'),
(698,'slot'),
(699,'slot'),
(700,'slot'),
(701,'slot'),
(702,'slot'),
(703,'slot'),
(704,'slot'),
(705,'provide,inject'),
(706,'provide,inject'),
(707,'Provide'),
(708,'Inject'),
(709,'provide,inject'),
(710,'provide,inject'),
(711,'ref'),
(712,'ref'),
(713,'ref'),
(714,'ref'),
(715,'ref'),
(716,'ref'),
(717,'ref,emit'),
(718,'ref'),
(719,'ref'),
(720,'Transition'),
(721,'Transition'),
(722,'CSS,Transition'),
(723,'透传'),
(724,'透传'),
(725,'透传'),
(726,'透传'),
(727,'透传'),
(728,'透传'),
(729,'透传'),
(730,'透传'),
(731,'setup'),
(732,'vue'),
(733,'nextTick'),
(734,'provide'),
(735,'reactive'),
(736,'watch'),
(737,'watch'),
(738,'watch,watchEffect'),
(739,'watch,watchEffect'),
(740,'v-for'),
(741,'v-for'),
(742,'v-model'),
(743,'钩子'),
(744,'监听'),
(745,'监听'),
(746,'provide,inject'),
(747,'inject'),
(748,'slot'),
(749,'defineAsyncComponent'),
(750,'v-model'),
(751,'v-model'),
(752,'v-model'),
(760,'v-model'),
(761,'use'),
(762,'选项式'),
(763,'Transition'),
(764,'prop'),
(765,'类型'),
(766,'模板ref'),
(767,'vite.config'),
(768,'img'),
(769,'只读'),
(770,'按键'),
(771,'光标'),
(772,'缓冲区'),
(773,'缓冲区'),
(774,'缓冲区'),
(775,'光标'),
(776,'字体'),
(777,'光标'),
(778,'光标'),
(779,'窗口'),
(780,'宽度'),
(781,'Console'),
(782,'唯一元素'),
(783,'字符串元素'),
(784,'字符串集合'),
(785,'有序字典'),
(786,'键值对集合'),
(787,'基础'),
(788,'404'),
(789,'路由'),
(790,'history'),
(791,'Hash'),
(792,'query'),
(793,'路由'),
(794,'路由'),
(795,'前置守卫'),
(796,'独享守卫'),
(797,'onBeforeRouteLeave'),
(798,'link'),
(799,'useRouter,useRoute'),
(800,'刷新'),
(801,'新窗口'),
(802,'go'),
(803,'children'),
(804,'问题点'),
(805,'钩子'),
(806,'解析守卫'),
(807,'守卫'),
(808,'命名'),
(809,'命名'),
(810,'规则'),
(811,'参数校验'),
(812,'兼容性'),
(813,'监听方法'),
(814,'事件'),
(815,'事件');
/*!40000 ALTER TABLE `snippet_tag` ENABLE KEYS */;

-- 
-- Definition of snippet_type
-- 

DROP TABLE IF EXISTS `snippet_type`;
CREATE TABLE IF NOT EXISTS `snippet_type` (
  `id` int NOT NULL,
  `name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table snippet_type
-- 

/*!40000 ALTER TABLE `snippet_type` DISABLE KEYS */;
INSERT INTO `snippet_type`(`id`,`name`) VALUES
(1,'csharp'),
(2,'vue'),
(3,'axios'),
(5,'typescript'),
(6,'javascript'),
(8,'css'),
(9,'vite'),
(10,'scss'),
(11,'eslint'),
(12,'mysql'),
(13,'vscode'),
(14,'windicss'),
(16,'es6'),
(17,'未分类'),
(18,'mech'),
(19,'ascll'),
(20,'unocss');
/*!40000 ALTER TABLE `snippet_type` ENABLE KEYS */;

-- 
-- Definition of snippet_type_sub
-- 

DROP TABLE IF EXISTS `snippet_type_sub`;
CREATE TABLE IF NOT EXISTS `snippet_type_sub` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type_id` int NOT NULL DEFAULT '0',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK_snippet_type_sub_snippet_type` (`type_id`) USING BTREE,
  CONSTRAINT `FK_snippet_type_sub_snippet_type` FOREIGN KEY (`type_id`) REFERENCES `snippet_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=158 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC COMMENT='片段分类下的子类';

-- 
-- Dumping data for table snippet_type_sub
-- 

/*!40000 ALTER TABLE `snippet_type_sub` DISABLE KEYS */;
INSERT INTO `snippet_type_sub`(`id`,`name`,`type_id`) VALUES
(2,'组件',2),
(3,'指令',2),
(4,'全局API',2),
(7,'待分配',17),
(9,'依赖包',1),
(11,'ref',2),
(14,'globalProperties',2),
(16,'片段',13),
(18,'快捷键',13),
(21,'media',10),
(22,'片段',8),
(23,'input',8),
(26,'锚点',8),
(28,'relative',8),
(30,'基础',8),
(31,'Props',2),
(45,'事件',2),
(46,'cookie',6),
(47,'数组',6),
(48,'substring',6),
(53,'片段',6),
(55,'KeepAlive',2),
(57,'解构',16),
(59,'import',16),
(60,'map',16),
(62,'函数',16),
(63,'片段',16),
(64,'数组',16),
(65,'运算符',16),
(71,'字符串',16),
(72,'字符串',6),
(73,'问题点',3),
(76,'字体',10),
(77,'定位',8),
(78,'传送',2),
(79,'循环',16),
(80,'集合',16),
(81,'表达式',2),
(82,'class绑定',2),
(83,'导出',16),
(84,'scroll',6),
(85,'字符串',5),
(86,'选择器',8),
(87,'对象',6),
(88,'函数',5),
(89,'函数',6),
(90,'循环',6),
(91,'判断',6),
(92,'运算符',6),
(93,'滚动',2),
(94,'片段',2),
(96,'函数',2),
(97,'函数',3),
(98,'滚动',8),
(100,'浏览器',2),
(102,'生产问题',18),
(103,'字符',19),
(104,'后台系统',18),
(105,'RF',18),
(106,'数据库',18),
(107,'声学',18),
(108,'模板程序',18),
(109,'HDT657',18),
(110,'片段',1),
(111,'函数',1),
(112,'控制台',1),
(113,'字符串',1),
(114,'文件',1),
(115,'泛型',1),
(117,'插槽',2),
(118,'片段',20),
(119,'数组',1),
(121,'控制台',1),
(122,'部分类',1),
(123,'变量',6),
(124,'数据类型',6),
(125,'类型转换',6),
(126,'调试',6),
(128,'集合',6),
(129,'提案',18),
(130,'winfrom',1),
(131,'多线程',1),
(132,'windows',1),
(133,'修饰符',1),
(134,'集合',1),
(135,'类',1),
(136,'运算符',1),
(137,'单元测试',1),
(138,'整数',1),
(139,'条件语句',1),
(140,'变量',1),
(141,'类库',1),
(142,'生命周期',2),
(143,'编码规范',2),
(144,'scroll',2),
(145,'插件',2),
(146,'hooks',2),
(147,'响应式API',2),
(148,'依赖注入',2),
(150,'attribute',2),
(151,'侦听器',2),
(152,'插件',9),
(153,'内置组件',2),
(154,'字典',1),
(155,'router\r\n',2),
(156,'编码规范',1),
(157,'委托',1);
/*!40000 ALTER TABLE `snippet_type_sub` ENABLE KEYS */;

-- 
-- Definition of snippet_version
-- 

DROP TABLE IF EXISTS `snippet_version`;
CREATE TABLE IF NOT EXISTS `snippet_version` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '标题',
  `text` text CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '内容',
  `snippet_id` int NOT NULL DEFAULT '0' COMMENT '关联片段id',
  `count` int NOT NULL DEFAULT '1' COMMENT '版本变更次数',
  `time_create` datetime NOT NULL DEFAULT (now()) COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=310 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC COMMENT='片段的历史版本表';

-- 
-- Dumping data for table snippet_version
-- 

/*!40000 ALTER TABLE `snippet_version` DISABLE KEYS */;
INSERT INTO `snippet_version`(`id`,`name`,`text`,`snippet_id`,`count`) VALUES
(1,'0','0',0,0),
(43,'version','### version\n\n暴露当前所使用的 Vue 版本。\n\n```js\nimport { version } from ''vue''\n\nconsole.log(version)\n```',821,1),
(44,'testersef','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n123\n\n',869,1),
(45,'指定标签实现','元素最好要挂载到#app 的外面，原理其实是解析到 teleport 的时候，需要能获取到 to 指向的 dom 元素。\n\nVue 是从上到下解析并渲染的，先#test，再 Teleport 标签，再.test1。所以执行到 Teleport 标签时，就能获取到.text 标签了。\n\nc-search.vue\n\n```html\n  import { hSearch } from ''@/hooks/data''\n\n  <teleport v-if=\"hSearch\" to=\"#sear\">\n    <div class=\"model-bg\">\n      <div class=\"modal-content\">\n\n      </div>\n    </div>\n  </teleport>\n```\n\n使用\n\n```html\n import { hSearch, hSearchValue } from ''@/hooks/data''\n <div id=\"sear\"></div>\n <c-search @close-model=\"hSearch = false\"></c-search>\n <button @click=\"hSearch = true\">1</button>\n <button @click=\"hSearch = false\">2</button>\n```\n1',743,1),
(46,'使用@font-face属性','在scss中引入字体包\n\n```css\n@font-face {\n  font-family: PuHuiTi; 字体标题\n  src: url(''/src/assets/fonts/Alibaba_PuHuiTi_2.0_55_Regular.ttf''); 字体包\n}\n```\n\n标签中使用字体\n\n```scss\n@layer base {\n  // html {\n  //   @apply antialiased;\n  // }\n  body {\n    font-family: PuHuiTi;\n  }\n}\n```\n\n',871,1),
(47,'动态切换组件','```html\n<template>\n    <div class=\"dynamicComponent\">\n        <ul>\n            <li v-for=\"(item, index) in tabList\" :key=\"index\" @click=\"change(index)\">{{ item.name }}</li>\n        </ul>\n        <!-- is的值是哪个组件的名称就显示哪个组件 -->\n        <component :is=\"state.com\"></component>\n    </div>\n</template>\n```\n\n```tsx\n//<script setup name=\"funcDynamicComponent\">\nimport A from ''./component/A.vue''\nimport B from ''./component/B.vue''\nimport C from ''./component/C.vue''\n\n// 因为 reactive 是响应式数据 proxy 但是组件确不需要响应式，所有需要使用 markRaw 或者 shallowRef 来避免\nconst tabList = reactive([\n    { name: ''A 组件'', com: markRaw(A) },\n    { name: ''B 组件'', com: markRaw(B) },\n    { name: ''C 组件'', com: markRaw(C) },\n])\nconst state = reactive({\n    com: tabList[0].com,\n})\n\n// 切换组件\nconst change = (index) => {\n    state.com = tabList[index].com\n}\n//</script>\n```\n',534,1),
(48,'过度&动画的使用','```html\n<template>\n  <div id=\"app\">\n    <router-view v-slot=\"{ Component }\">\n      <transition name=\"fade\">\n        <keep-alive>\n          <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n        </keep-alive>\n      </transition>\n      <transition name=\"fade\">\n        <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n      </transition>\n    </router-view>\n  </div>\n</template>\n```\n\n```js\n\n<style lang=\"scss\">\n\n/* 可以为进入和离开动画设置不同的持续时间和动画函数 */\n.fade-enter-active {\n  //进入过程\n  animation: fade-in 0.8s cubic-bezier(0.39, 0.575, 0.565, 1) both;\n}\n.fade-leave-active {\n  //离开过程\n  animation: fade-out 0.3s ease-out both;\n}\n//进入开始和离开结束的状态\n.fade-enter-to {\n  opacity: 0;\n}\n//进入开始和离开结束的状态\n.fade-leave-to {\n  opacity: 0;\n}\n\n@keyframes fade-in {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes fade-out {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n```\n',533,1),
(49,'控制动画时长','就是我们不管CSS中的动画和过渡时长，以标签为准。可以绑定属性`<transition :duration=\"1000\">` 来控制时长，意思是1秒后，结束动画和过渡。',532,1),
(50,'组件间过渡','`<Transition>` 也可以用在动态组件之间：\n\n```html\n<Transition name=\"fade\" mode=\"out-in\">\n  <component :is=\"activeComponent\"></component>\n</Transition>\n```\n\n',530,1),
(51,'出现时过渡','如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 `appear` attribute：\n\n```html\n<Transition appear>\n  ...\n</Transition>\n```\n',527,1),
(52,'可重用过渡','得益于 Vue 的组件系统，过渡是可以被重用的。要创建一个可被重用的过渡，我们需要为 `<Transition>` 组件创建一个包裹组件，并向内传入插槽内容：\n\n```html\n<!-- MyTransitio.vue -->\n<script>\n// JavaScript 钩子逻辑...\n</script>\n\n<template>\n  <!-- 包裹内置的 Transition 组件 -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- 向内传递插槽内容 -->\n  </Transition>\n</tempalte>\n\n<style>\n/*\n  必要的 CSS...\n  注意：避免在这里使用 <style scoped>\n  因为那不会应用到插槽内容上\n*/\n</style>\n```\n\n现在 `MyTransition` 可以在导入后像内置组件那样使用了：\n\n```html\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\n```\n\n',526,1),
(53,'JavaScript钩子','你可以通过监听 `<Transition>` 组件事件的方式在过渡过程中挂上钩子函数：\n\n```html\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\n\n```\n\n```tsx\n// 在元素被插入到 DOM 之前被调用\n// 用这个来设置元素的 \"enter-from\" 状态\nfunction onBeforeEnter(el) {},\n\n// 在元素被插入到 DOM 之后的下一帧被调用\n// 用这个来开始进入动画\nfunction onEnter(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 当进入过渡完成时调用。\nfunction onAfterEnter(el) {}\nfunction onEnterCancelled(el) {}\n\n// 在 leave 钩子之前调用\n// 大多数时候，你应该只会用到 leave 钩子\nfunction onBeforeLeave(el) {}\n\n// 在离开过渡开始时调用\n// 用这个来开始离开动画\nfunction onLeave(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 在离开过渡完成、\n// 且元素已从 DOM 中移除时调用\nfunction onAfterLeave(el) {}\n\n// 仅在 v-show 过渡中可用\nfunction leaveCancelled(el) {}\n```\n\n这些钩子可以与 CSS 过渡/动画结合使用，也可以单独使用。\n\n在使用仅由 JavaScript 执行的动画时，最好是添加一个 `:css=\"false\"` prop。这显式地向 Vue 表明跳过 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡。\n\n```html\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n```\n\n在有了 `:css=\"false\"` 后，我们就全权自己负责控制什么时候过渡结束了。这种情况下对于 `@enter` 和 `@leave` 钩子来说，回调函数 `done` 就是必须的。否则，钩子将被同步调用，过渡将立即完成。',525,1),
(54,'同时使用Transition和Animation','Vue 需要附加事件侦听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。如果你仅仅使用二者其中之一，Vue 可以自动探测到正确的类型。\n\n然而在某些场景中，你或许想要在同一个元素上同时使用它们两个，举个例子，触发了一个 CSS 动画的同时，由于副作用触发了另一个 CSS 过渡。此时你需要显式地传入 `type` prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`：\n\n```html\n<Transition type=\"animation\">...</Transition>\n```\n',523,1),
(55,'自定义过渡类','你也可以向 `<Transition>` 传递以下的 props 来指定自定义的过渡类：\n\n- `enter-from-class`\n- `enter-active-class`\n- `enter-to-class`\n- `leave-from-class`\n- `leave-active-class`\n- `leave-to-class`\n\n你传入的这些类会覆盖相应阶段的默认类名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如Animate.css\n\n```html\n<!-- 假设你已经引入了 Animate.css -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n',522,1),
(56,'slot搭配路由使用','vue3 配合的 slot 插槽使用，使用 is 来绑定对应路由的组件。\n\n```html\n<template>\n  <router-view v-slot=\"{ Component }\">\n    <keep-alive>\n      <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n    </keep-alive>\n    <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n  </router-view>\n</template>\n```\n\nrouter 添加 meta 配置\n\n可以注释哪一页面需要使用缓存，但是也可以不设置，不设置的情况需要将上面的属性都删掉。如果需要更多的缓存限制，可以看底下的参考网站。\n\n```js\nconst routes = [\n  {\n    path: ''/keepalive'',\n    name: ''keepalive'',\n    component: () => import(''../views/keepalive.vue''),\n    meta: {\n      keepAlive: false //是否需要使用缓存\n    }\n  }\n];\n```',733,1),
(57,'通过插槽来分配内容','这可以通过 Vue 的自定义 `<slot>` 元素来实现：\n\n我们使用 `<slot>` 作为一个占位符，之后的内容就会放在这里\n\n```html\n<template>\n  <div class=\"alert-box\">\n    <strong>Error!</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n  .alert-box {\n    /* ... */\n  }\n</style>\n```',753,1),
(58,'具名作用域插槽(slot)','具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 `v-slot` 指令的值被访问到：`v-`。当使用缩写时是这样：\n\n```html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ headerProps }}\n  </template>\n</MyComponent>\n```\n\n向具名插槽中传入 props：\n\n```html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\n注意插槽上的 `name` 是由 Vue 保留的，不会作为 props 传递给插槽。因此最终 `headerProps` 的结果是 `{ message: ''hello'' }`。',506,1),
(59,'如何使用插槽slot','- 定义插槽slot：\n\n- - 插槽的使用过程其实是抽取共性、预留不同；\n  - 将共同的元素、内容依然在组件内进行封装；\n  - 同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素；\n\n- 如何使用slot呢？\n\n- - Vue中将 <slot> 元素作为承载分发内容的出口；\n  - 在封装组件中，使用特殊的元素<slot>就可以为封装组件开启一个插槽；\n  - 该插槽插入什么内容取决于父组件如何使用；',516,1),
(60,'CSS中的Animation','原生 CSS 动画和 CSS trasition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。\n\n对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` 类下面声明它们。下面是一个示例：\n\n```html\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    你好！你会看到这里正在跳跃！\n  </p>\n</Transition>\n```\n\n```css\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n',521,1),
(61,'Transition搭配CSS','`<Transition>` 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 `transition` CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n\n下面是一个更高级的例子，使用不同的持续时间和速度曲线来过渡多个属性：\n\n```html\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n\n\n\n### CSS的animation',520,1),
(62,'为过渡命名','可以通过一个 `name` prop 来声明一种过渡：\n\n```html\n<Transition name=\"fade\">\n  ...\n</Transition>\n```\n\n对于一个有名字的过渡，它的过渡相关 CSS 类会以其名字而不是 `v` 作为前缀。举个例子，上面被应用的 CSS 类将会是 `fade-enter-active` 而不是 `v-enter-active`。这个“fade”过渡的 CSS 类将会是这样：\n\n```css\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n```\n',519,1),
(63,'Transition组件','vue提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',517,1),
(64,'绑定一个对象(v-bind)','我们希望将一个对象的所有属性，绑定到元素上的所有属性，非常简单，可以直接使用 v-bind 绑定一个 对象；\n这种写法在高阶组件中常用。\n案例：info对象会被拆解成div的各个属性\n\n```html\n<div v-bind=\"cos\">属性直接绑定一个对象</div>\n<!-- \n这里是数据：\ncos: {\n    name: ''wang'',\n    age: 28,\n    job: ''web'',\n},\n-->\n```\n',514,1),
(65,'数组语法(v-bind)','1- 数组语法：`[''rose'', ''abc'']`\n2- 三元运算： `[''rose'', ''abc'', isActive ? ''active'': '''']`\n3- 数组中添加对象： `[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]`,这里其实写三元有点复杂，所以数组语法中也支持嵌套对象语法。\n\n```html\n<template id=\"my-app\">\n  <div class=\"cos\" :class=\"[''rose'', ''abc'']\">数组语法1</div>\n  <div class=\"cos\" :class=\"[''rose'', ''abc'', isActive ? ''active'': '''']\">\n    三元运算\n  </div>\n  <div\n       class=\"cos\"\n       :class=\"[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]\"\n       >\n    数组中添加对象\n  </div>\n</template>\n```\n\n```tsx\n<script>\n  const App = {\n    template: \"#my-app\",\n    data() {\n      return {\n        isActive: false,\n        classObj: { active: true, rose: true },\n      };\n    },\n  };\n  Vue.createApp(App).mount(\"#app\");\n</script>\n```\n',513,1),
(66,' 赋值运算符','```js\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\n`=` 是一个运算符 , 在 JavaScript 中，所有运算符都会返回一个值。这对于 `+` 和 `-` 来说是显而易见的，但对于 `=` 来说也是如此。\n\n语句 `x = value` 将值 `value` 写入 `x` **然后返回 value**。\n\n',945,1),
(67,'每两个字符为一组进行反转','\n12345678 => 78 56 34 12\n\n```csharp\n/// <summary>\n/// 将一个字符串中的字符按照每两个字符为一组进行反转\n/// </summary>\n/// <param name=\"str\"></param>\n/// <returns></returns>\npublic string Reverse(string str)\n{\n  //string NewStr = \"\";\n  //for (int i = str.Length - 2 ; i >= 0 ; i -= 2) {\n  //    NewStr += $\"{str.Substring(i,2)}\";\n  //}\n  //使用StringBuilder代替字符串拼接，避免了频繁的内存分配和拷贝，提高了代码的效率\n  StringBuilder newStr = new StringBuilder();\n  // 从字符串的倒数第二个字符开始循环，每次减少2个字符\n  for(int i = str.Length - 2; i >= 0; i -= 2)\n  {\n    // 将每两个字符添加到新字符串变量中\n    newStr.Append(str.Substring(i, 2));\n  }\n  return newStr.ToString();\n}\n```\n\n为了提高代码的可复用性，我们可以将代码封装成一个静态方法，以便在其他地方调用\n\n```csharp\npublic static class StringUtil\n{\n    public static string Reverse(string str)\n    {\n        StringBuilder newStr = new StringBuilder();\n        for (int i = str.Length - 2; i >= 0; i -= 2)\n        {\n            newStr.Append(str.Substring(i, 2));\n        }\n        return newStr.ToString();\n    }\n}\n```',858,1),
(68,'变量的注意事项','- 一个变量应该只被声明一次\n- 变量名称必须仅包含字母、数字、符号 `$` 和 `_`\n- 首字符必须非数字\n- `let` — 现代的变量声明方式\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它',925,1),
(69,'变量的注意事项','- 一个变量应该只被声明一次\n- 变量名称必须仅包含字母、数字、符号 `$` 和 `_`\n- 首字符必须非数字\n- `let` — 现代的变量声明方式\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它',925,2),
(70,'对象的文本和属性','创建对象的时候，立即将一些属性以键值对的形式放到 `{...}` 中。\n\n```javascript\nlet user = {     // 一个对象\n  name: \"John\",  // 键 \"name\"，值 \"John\"\n  age: 30        // 键 \"age\"，值 30\n};\n```\n\n属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 `\":\"` 的前面，值在冒号的右边。\n\n在 `user` 对象中，有两个属性：\n\n1. 第一个的键是 `\"name\"`，值是 `\"John\"`。\n2. 第二个的键是 `\"age\"`，值是 `30`。',977,1),
(71,'使用slice查找字符','#### 使用slice查找字符\n\n```\nstr.slice(start [, end])\n```\n\n返回字符串从 `start` 到（但不包括）`end` 的部分。\n\n例如：\n\n```javascript\nlet str = \"stringify\";\nalert( str.slice(0, 5) ); // ''strin''，从 0 到 5 的子字符串（不包括 5）\nalert( str.slice(0, 1) ); // ''s''，从 0 到 1，但不包括 1，所以只有在 0 处的字符\n```\n\n如果没有第二个参数，`slice` 会一直运行到字符串末尾：\n\n```javascript\nlet str = \"stringify\";\nalert( str.slice(2) ); // 从第二个位置直到结束\n```\n\n`start/end` 也有可能是负值。它们的意思是起始位置从字符串结尾计算：\n\n```javascript\nlet str = \"stringify\";\n\n// 从右边的第四个位置开始，在右边的第一个位置结束\nalert( str.slice(-4, -1) ); // ''gif''\n```\n\n',1001,1),
(72,'集合总结','`Map` —— 是一个带键的数据项的集合。\n\n方法和属性如下：\n\n- `new Map([iterable])` —— 创建 map，可选择带有 `[key,value]` 对的 `iterable`（例如数组）来进行初始化。\n- `map.set(key, value)` —— 根据键存储值，返回 map 自身。\n- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。\n- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。\n- `map.delete(key)` —— 删除指定键对应的值，如果在调用时 `key` 存在，则返回 `true`，否则返回 `false`。\n- `map.clear()` —— 清空 map 。\n- `map.size` —— 返回当前元素个数。\n\n与普通对象 `Object` 的不同点：\n\n- 任何键、对象都可以作为键。\n- 有其他的便捷方法，如 `size` 属性。\n\n`Set` —— 是一组唯一值的集合。\n\n方法和属性：\n\n- `new Set([iterable])` —— 创建 set，可选择带有 `iterable`（例如数组）来进行初始化。\n- `set.add(value)` —— 添加一个值（如果 `value` 存在则不做任何修改），返回 set 本身。\n- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。\n- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。\n- `set.clear()` —— 清空 set。\n- `set.size` —— 元素的个数。\n\n在 `Map` 和 `Set` 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。',1031,1),
(73,'函数型ref','`ref` attribute 还可以绑定为函数，每次组件更新时被调用。函数接受该元素引用作为第一个参数：\n\n```html\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\n```\n\n如果使用一个动态的 `:ref` 绑定，也可以传一个函数。当元素卸载时，这个 `el` 参数会是 `null`。你当然也可以使用一个方法而不是内联函数。',495,1),
(74,'集合类的声明','**声明一个List**\n```c#\nList<string> list = new List<string>();\nlist.Add(\"a一\");\nlist.Add(\"b二\");\n\n//语法糖\nList<string> list = new List<string> {\"def\",\"OK\"};\n```\n\n**遍历集合中的项：**\n\n```c#\nforeach (string item in list)\n{\n  Console.WriteLine(item);\n}\n//语法糖\nlist.ForEach(a => Console.WriteLine(a));\n```\n',31,1),
(75,'NULL条件运算符','```csharp\n//使用代码\nCustomer customer = new Customer();\nstring name = customer?.Name;\n\n//编译代码\nCustomer customer = new Customer();\nif (customer != null)\n{\n    string name = customer.Name;\n}\n//和??组合起来使用\nif (customer?.Face()??false)\n还可以两个一起组合来使用\nint? contactNameLen = contact?.Name?.Length; \n```\n\n在对象使用前检查是否为null。如对象空，则赋值给变量为空值，所以例子中需要一个为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。',128,1),
(76,'CSS简介','层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现[HTML](https://baike.baidu.com/item/HTML)（[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言/6805073)的一个应用）或[XML](https://baike.baidu.com/item/XML)（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 [1] \n\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。',48,1),
(77,'C#类型转换','| 序号 | 方法 & 描述                                                  |\n| ---- | ------------------------------------------------------------ |\n| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |\n| 2    | **ToByte** 把类型转换为字节类型。                            |\n| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |\n| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |\n| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |\n| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |\n| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |\n| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |\n| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |\n| 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |\n| 11   | **ToSingle** 把类型转换为小浮点数类型。                      |\n| 12   | **ToString** 把类型转换为字符串类型。                        |\n| 13   | **ToType** 把类型转换为指定类型。                            |\n| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |\n| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |\n| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |',47,1),
(78,'字符串格式化','String.Format:使用{0}占位符、必须顺序来格式化\n\n```csharp\n    var contactInfo = string.Format(\"Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}\", \n    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);\n\n    //新的语法\n    var contactInfo2 = $\"Id:{contact.Id} Name:{contact.Name} EmailAddr:\n    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n\n    //新格式化方式还支持任何表达式的直接赋值：\n    var contactInfo = $\"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? \"Frank\" : \n    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n',129,1),
(79,'int.TryParse()','```csharp\npublic static bool TryParse(string s, out Int32 result);\n```\n\n转换成功返回true,否则返回false\n\n```c#\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n',121,1),
(80,'字符串转整数类型','将字符串转换为整数类型。为了方便，C#提供了一个内置的方法`TryParse`来实现这个功能\n\n- 字符串（String）：表示一串字符的数据类型。\n- 整数（Integer）：表示不带小数点的数字。\n- 解析（Parsing）：将字符串转换为其他数据类型的过程。\n\n###  TryParse\n\n`TryParse`方法是一个静态方法，可以直接通过类名调用。它的代码结构如下：\n\n```csharp\npublic static bool TryParse(string s, out Int32 i);\n```\n\n示例代码\n\n转换成功返回true,否则返回false\n\n```csharp\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n\n',121,2),
(81,'组件名格式','使用 PascalCase 为组件名：\n\n- PascalCase 是合法的 JavaScript 标识符，同时 IDE 也能提供较好的自动补全。\n\n- `<PascalCase />` 模板中更明显地表明了这是一个 组件，不是原生 HTML 元素。同时也能将组件和自定义元素 (web components) 区分开来。\n\nVue 支持将使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` 引用。这允许我们在不同来源的模板中始终使用同一份 JavaScript 组件注册代码。',759,1),
(82,'组件模板引用标注类型','### 组件模板引用标注类型\n\n为一个子组件添加一个模板 ref，以便调用它公开的方法。如一个 `MyModal` 子组件，它有一个打开模态框的方法：\n\n```vue\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\n  import { ref } from ''vue'';\n  const isContentShown = ref(false);\n  const open = () => (isContentShown.value = true);\n  defineExpose({\n    open\n  });\n</script>\n```\n\n获取 `MyModal` 的类型，需要通过 `typeof` 得到其类型，使用 TypeScript 内置的 `InstanceType` 工具类型来获取实例类型：\n\n```vue\n<!-- App.vue -->\n<script setup lang=\"ts\">\n  import MyModal from ''./MyModal.vue'';\n\n  const modal = ref<InstanceType<typeof MyModal> | null>(null);\n  const openModal = () => {\n    modal.value?.open();\n  };\n</script>\n```\n\n',760,1),
(83,'组件通信','组件通信方式：\n\n| 方式             | Vue2       | Vue3                  |\n| ---------------- | ---------- | --------------------- |\n| 父传子           | props      | props                 |\n| 子传父           | $emit      | emits                 |\n| 父传子           | $attrs     | attrs                 |\n| 子传父           | $listeners | 无(合并到 attrs 方式) |\n| 父传子           | provide    | provide               |\n| 子传父           | inject     | inject                |\n| 子组件访问父组件 | $parent    | 无                    |\n| 父组件访问子组件 | $children  | 无                    |\n| 父组件访问子组件 | $ref       | expose&ref            |\n| 兄弟传值         | EventBus   | mitt                  |',765,1),
(84,'绑定属性(v-bind)','```html\n<img v-bind:src=\"imgUrl\"/>\n```\n',130,1),
(85,'动态绑定(v-bind)','在某些情况下，我们属性的名称可能也不是固定的：\n如果属性名称不是固定的，我们可以使用 `:[属性名]=''值''` 的格式来定义\n这种绑定的方式，我们称之为动态绑定属性；\n```js\nconst objectOfAttrs = {\n  id: ''container'',\n  class: ''wrapper''\n}\n//通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\n<div v-bind=\"objectOfAttrs\"></div>\n```\n\n\n',131,1),
(86,'绑定一个对象','我们希望将一个对象的所有属性，绑定到元素上的所有属性，非常简单，可以直接使用 v-bind 绑定一个 对象；\n这种写法在高阶组件中常用。\n案例：info对象会被拆解成div的各个属性\n\n```html\n<div v-bind=\"cos\">属性直接绑定一个对象</div>\n<!-- \n这里是数据：\ncos: {\n    name: ''wang'',\n    age: 28,\n    job: ''web'',\n},\n-->\n```\n',514,2),
(87,'数组语法绑定','1- 数组语法：`[''rose'', ''abc'']`\n2- 三元运算： `[''rose'', ''abc'', isActive ? ''active'': '''']`\n3- 数组中添加对象： `[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]`,这里其实写三元有点复杂，所以数组语法中也支持嵌套对象语法。\n\n```html\n<template id=\"my-app\">\n  <div class=\"cos\" :class=\"[''rose'', ''abc'']\">数组语法1</div>\n  <div class=\"cos\" :class=\"[''rose'', ''abc'', isActive ? ''active'': '''']\">\n    三元运算\n  </div>\n  <div\n       class=\"cos\"\n       :class=\"[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]\"\n       >\n    数组中添加对象\n  </div>\n</template>\n```\n\n```tsx\n<script>\n  const App = {\n    template: \"#my-app\",\n    data() {\n      return {\n        isActive: false,\n        classObj: { active: true, rose: true },\n      };\n    },\n  };\n  Vue.createApp(App).mount(\"#app\");\n</script>\n```\n',513,2),
(88,'绑定style(v-bind)','CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n-  绑定style对象语法\n```\n:style=\"包含css样式的对象\"\n:style=\"{属性名: ''属性值''}\"\n```\n​      1- {color: ''red''} 这里需要注意属性值必须添加'''', 如果没有引号会将red当做变量去数据中寻找\n​      2- { fontSize: ''24px''} ,这里也可以写成烤串命名法，但是需要用''''包起来，否则会报错\n​      3- {fontSize: `${finalFontSize}px`} 也可以写成字符串拼接\n​      4- :style=\"finalStyleObj\" 也可以直接绑定对象\n​      5- 也可以写在方法或者计算属性中\n``` html\n  <!-- <h2 :style=\"{key(属性名):value(属性值)}\">{{massage}}</h2> -->\n  <!-- 这里要加'' ''要不然vue会去解析50px这个变量然后报错 -->\n  :style=\"{fontSize: ''50px''}\">{{massage}}\n  <!-- finalSize当成一个变量在使用 -->\n  :style=\"{fontSize: finalSize}\">{{massage}}\n  <!-- 也可以拼接 -->\n   :style=\"{fontSize: finalSize + ''px'',color:finalColor}\">{{massage}}\n  <!-- 数组语法 -->\n  :style=\"[baseStyle,baseStyle1]\">{{massage}}\n\n\nconst app = new Vue({\n	el: \"#app\",\n	data: {	\n        finalSize: 100,\n        finalColor: ''red'',\n        baseStyle:{color:''red''},\n        baseStyle1:{fontSize:''75px''}\n		}})\n\n```\n\n',132,1),
(89,'调用函数(v-bind)','可以在绑定的表达式中使用一个组件暴露的方法：\n```html\n<span :title=\"toTitleDate(date)\">\n  {{ formatDate(date) }}\n</span>\n```\n\n',134,1),
(90,'布尔型Attribute','```html\n<button :disabled=\"isButtonDisabled\">\n  Button\n</button>\n```\n',456,1),
(91,'动态参数(v-bind)','```html\n<a v-bind:[attributeName]=\"url\"> ... </a>\n<!-- 简写 -->\n<a :[attributeName]=\"url\"> ... </a>\n这里的 attributeName 会作为一个 JS 表达式被动态执行\n```\n',457,1),
(92,'JavaScript表达式','```js\n{{ number + 1 }}\n{{ ok ? ''YES'' : ''NO'' }}\n{{ message.split('''').reverse().join('''') }\n<div :id=\"`list-${id}`\"></div>\n```\n\n这些表达式都会被作为 JavaScript ，以组件为作用域解析执行。\n\n在 vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中',133,1),
(93,'v-once','- v-once 用于指定元素或者组件只渲染一次\n- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；\n- 该指令可以用于性能优化；\n- 如果是子节点，也是只会渲染一次\n\n```html\n<span v-once>这个将不会改变: {{ msg }}</span>\n```\n',151,1),
(94,'v-if','用于按条件渲染一个区块。\n`v-if` 是“真实的”按条件渲染，因为它确保了条件区块内的事件监听器和子组件都会在切换时被销毁与重建。\n\n`v-if` 也是**懒加载**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块会直到条件首次变为 true 时才渲染。\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n',152,1),
(95,'v-if','用于按条件渲染一个区块。\n`v-if` 是“真实的”按条件渲染，因为它确保了条件区块内的事件监听器和子组件都会在切换时被销毁与重建。\n\n`v-if` 也是懒加载的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块会直到条件首次变为 true 时才渲染。\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n',152,2),
(96,'v-else','v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则将不会识别它\n```html\n<h1 v-else>Oh no </h1>\n```\n',153,1),
(97,'v-else-if','```html\n<div v-if=\"type === ''A''\">\n  A\n</div>\n<div v-else-if=\"type === ''B''\">\n  B\n</div>\n<div v-else-if=\"type === ''C''\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n',319,1),
(98,'template上的v-if','`v-if` 是一个指令，他必须依附某个元素。但想要切换不只一个元素呢？在这种情况下我们可以在一个 `<template>` 元素上使用 `v-if`，这只是一个不可见的包裹元素，最后渲染的结果并不会包含这个 `<template>` 元素。\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。',154,1),
(99,'v-show','按条件显示一个元素\n\n`v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的CSS 属性。\n`v-show` 不支持在 `<template>` 元素上使用，也没有 `v-else` 来配合。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n',155,1),
(100,'v-for','v-for的基本格式是 \"item in 数组\nv-for也支持遍历对象，并且支持有一二三个参数\n\n一个参数： \"value in object\";\n二个参数： \"(value, key) in object\";\n三个参数： \"(value, key, index) in object\";\n\nv-for同时也支持数字的遍历',156,1),
(101,'定义数组渲染列表(v-for)','```js\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n```html\n<li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n</li>\n```\n',157,1),
(102,'可选参数(v-for)','在 `v-for` 块中可以完整地访问父作用域内的属性。`v-for` 也支持使用可选的第二个参数，表示当前项的位置索引。\n\n```js\nconst parentMessage = ref(''Parent'')\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n\n```html\n<li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n',158,1),
(103,'循环指定次数(v-for)','```html\n<a-button type=\"primary\" shape=\"round\" @click=\"GetMonth(index)\" \n          v-for=\"index of 12\" :key=\"index\">{{ index }}月\n</a-button>\n```\n\n\n\n',169,1),
(104,'变量别名解构(v-for)','```html\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- 有 index 索引时 -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\n',159,1),
(105,'用of替代in分隔符(v-for)','```html\n<div v-for=\"item of items\"></div>\n```\n',160,1),
(106,'对象(v-for)','遍历一个对象的所有属性。\n```vue\n  <li v-for=\"value in myObject\">\n    {{ value }}\n  </li>\n```\n```js\nconst myObject = reactive({\n  title: ''如何在 Vue 中渲染列表'',\n  author: ''王小明'',\n})\n```\n提供第二个的参数为 property 名称 (键名)\n```html\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n```\n用第三个参数作为索引\n```html\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n```\n唯一key\n```html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n',161,1),
(107,'使用值范围(v-for)','`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n```html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n 在template使用\n```html\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n```\n',162,1),
(108,'组件上使用(v-for)','```html\n<my-component v-for=\"item in items\" :key=\"item.id\">\n</my-component>\n```\n\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还是应该使用 props：\n\n```html\n<my-component\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n></my-component>\n```\n\n',163,1),
(109,'for&if同时使用','当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 <template> 中\n\n```html\n//1\n<template v-for=\"(item, index) in ResultList\" :key=\"index\">\n   <a @click=\"onk(item.path)\" v-if=\"item.identity\">\n    {{item.title}}\n   </a>\n</template>\n//2\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n',164,1),
(110,'v-pre','- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签\n- 跳过不需要编译的节点，加快编译的速度\n```html\n<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->\n```\n\n',166,1),
(111,'v-cloak','保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。',167,1),
(112,'v-text','都是用于将数据显示在界面中，但是通常只接受一个string类型\n用于更新元素的 textContent\n```html\n<div v-text=\"message\"></div>\n<div v-text=\"msg\"></div> 等价于 <div>{{msg}}</div>\n```\n',165,1),
(113,'内联事件处理器(v-on:click)','\n```js\nconst count = ref(0)\n```\n```js\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n',135,1),
(114,'方法事件处理器(v-on:click)','`v-on` 也可以接受一个方法名或对某个方法的调用。\n\n```js\nconst name = ref(''Vue.js'')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` 是 DOM 原生事件\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\n<!-- `greet` 是上面定义过的方法名 -->\n<button @click=\"greet\">Greet</button>\n```\n\n通过被触发事件的 `event.target.tagName` 访问到该 DOM 元素。',136,1),
(115,'内联处理器中调用方法(v-on:click)','除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：\n\n```js\nfunction say(message) {\n  alert(message)\n}\n<button @click=\"say(''hello'')\">Say hello</button>\n<button @click=\"say(''bye'')\">Say bye</button>\n```\n',137,1),
(116,'内联事件处理器中访问事件参数(v-on:click)','有时需要在内联事件处理器中访问原生 DOM 事件。可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数：\n```js\nfunction warn(message, event) {\n  // `这里可以访问 DOM 原生事件`\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n```\n```html\n<!-- 使用特殊的 $event 变量 -->\n<button @click=\"warn(''Form cannot be submitted yet.'', $event)\">\n  Submit\n</button>\n\n<!-- 使用内联箭头函数 -->\n<button @click=\"(event) => warn(''Form cannot be submitted yet.'', event)\">\n  Submit\n</button>\n```\n',138,1),
(117,'多事件处理器(v-on:click)','事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n\n```html\n<button @click=\"one($event), two($event)\">Submit</button>\n```\n\n```js\n  one(event) {\n    // 第一个事件处理器逻辑...\n  },\n  two(event) {\n   // 第二个事件处理器逻辑...\n  }\n```\n',139,1),
(118,'事件修饰符(v-on:click)','在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n```html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n<!-- 点击事件将只会触发一次 -->\n<a v-on:click.once=\"doThis\"></a\n    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n',140,1),
(119,'按键修饰符','在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。\n\n```html\n<!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` -->\n<input @keyup.enter=\"submit\" />\n\n<!--仅会在 $event.key 为 ''PageDown'' 时调用事件处理。 -->\n<input @keyup.page-down=\"onPageDown\" />\n```\n\n',141,1),
(120,'.exact修饰符','\n修饰符允许你控制由精确的系统修饰符组合触发的事件\n```html\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n',142,1),
(121,'系统按键修饰符','你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n```html\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n<!-- Ctrl + 点击 -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n',143,1),
(122,'事件处理器标注类型','在处理原生 DOM 事件时，应该为我们传递给事件处理器的参数正确地标注类型\n\n```js\nfunction handleChange(event) {\n  // `event` 隐式地标注为 `any` 类型\n  console.log(event.target.value)\n}\n```\n\n```html\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个 `event` 参数会隐式地标注为 `any` 类型。这也会在 `tsconfig.json` 中配置了 `\"strict\": true` 或 `\"noImplicitAny\": true` 时报出一个 TS 错误。因此，建议显式地为事件处理器的参数标注类型。此外，你可能需要显式地强制转换 `event` 上的 property：\n\n```js\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n```\n',144,1),
(123,'自定义指令','注册一个全局指令 v-focus, 指令的功能在页面加载时，元素获得焦点：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n\n<script>\nconst app = Vue.createApp({})\n// 注册一个全局自定义指令 `v-focus`\napp.directive(''focus'', {\n  // 当被绑定的元素挂载到 DOM 中时……\n  mounted(el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\napp.mount(''#app'')\n</script>\n```\n\n我们也可以在实例使用 directives 选项来注册局部指令，这样指令只能在这个实例中使用：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n<script>\nconst app = {\n   data() {return {}},\n   directives: {\n      focus: {\n         // 指令的定义\n         mounted(el) {\n            el.focus()\n         }\n      }\n   }\n}\nVue.createApp(app).mount(''#app'')\n```',168,1),
(124,'v-model','在处理表单时，常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。v-model 在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n#### 基本使用\n```html\n<input v-model=\"text\">\n```\n#### 多行文本\n```html\n<textarea v-model=\"message\"></textarea>\n```\n',243,1),
(125,'复选框(v-model)','单一的复选框，绑定的是布尔类型值：\n\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\n```\n',244,1),
(126,'多个复选框(v-model)','绑定同一个数组：\n```js\nconst checkedNames = ref([])\n```\n```html\n<div>选择的名字有：{{ checkedNames }}</div>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n```\n',245,1),
(127,'多个复选框(v-model)','绑定同一个数组：\n```js\nconst checkedNames = ref([])\n```\n```html\n<div>选择的名字有：{{ checkedNames }}</div>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n```\n',245,2),
(128,'选择框(v-model)','单选时：\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\">\n  <option disabled value=\"\">请选择</option>\n  <option>A</option>\n  <option>B</option>\n</select\n```\n\n多选时 (绑定到一个数组)：\n\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n</select>\n```\n\n用 `v-for` 渲染的动态选项：\n\n```html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<div>选择的是：{{ selected }}</div>\n```\n\n```js\nconst selected = ref(''A'')\nconst options = ref([\n  { text: ''One'', value: ''A'' },\n  { text: ''Two'', value: ''B'' },\n])\n```',246,1),
(129,'值绑定(v-model)','对于单选按钮，复选框和选择器选项，`v-model` 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：\n\n```html\n<!-- `picked` 在被选择时是字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` 只会为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` 在第一项被选中时为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select\n```\n',247,1),
(130,'修饰符(v-model)','.lazy：默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：\n```html\n<!-- 在 \"change\" 事件后同步更新而不是 \"input\" -->\n<input v-model.lazy=\"msg\" />\n```\n.number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n```html\n<input v-model.number=\"age\" />\n```\n.trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n```html\n<input v-model.trim=\"msg\" />\n```\n',248,1),
(131,'Props','props 是组件通信中最常用的通信方式之一。父组件通过 v-bind 传入，子组件通过 props 接收，下面是它的三种实现方式\n\n```js\n// 数组:不建议使用\nprops: [''title'', ''likes'', ''isPublished'', ''commentIds'', ''author'']\n\n//但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：\n// 对象\nprops:{\n inpVal:{\n  type:Number, //传入值限定类型\n  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol\n  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n  required: true, //是否必传\n  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=>[]\n  validator:(value) {\n    // 这个值必须匹配下列字符串中的一个\n    return [''success'', ''warning'', ''danger''].indexOf(value) !== -1\n  }\n }\n}\n```\n\n',766,1),
(132,'组件通信方式','组件通信方式：\n\n| 方式             | Vue2       | Vue3                  |\n| ---------------- | ---------- | --------------------- |\n| 父传子           | props      | props                 |\n| 子传父           | $emit      | emits                 |\n| 父传子           | $attrs     | attrs                 |\n| 子传父           | $listeners | 无(合并到 attrs 方式) |\n| 父传子           | provide    | provide               |\n| 子传父           | inject     | inject                |\n| 子组件访问父组件 | $parent    | 无                    |\n| 父组件访问子组件 | $children  | 无                    |\n| 父组件访问子组件 | $ref       | expose&ref            |\n| 兄弟传值         | EventBus   | mitt                  |',765,2),
(133,'Props声明','组件需要显式声明 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute\n\n##### 运行时声明\n\n```js\nconst props = defineProps({\n  foo: { type: String, required: true },\n  bar: Number\n});\nprops.foo; // string\nprops.bar; // number | undefined\n```\n\n##### 使用对象声明\n\n```js\n//<script setup>\ndefineProps({\n  title: String,\n  likes: Number\n});\n//非<script setup>\nexport default {\n  props: {\n    title: String,\n    likes: Number\n  }\n};\n```\n\n',768,1),
(134,'闭合标签','我们在上面的例子中已经使用过了闭合标签 (self-closing tag)：\n\n```html\n<MyComponent />\n```\n\n这是因为 Vue 的模板解析器将 `/>` 作为标签关闭的标志，无关其类型。\n\n然而在 DOM 模板中，我们必须显式地写出关闭标签：\n\n```html\n<my-component></my-component>\n```\n\n这是由于 HTML 只允许一小部分特殊的元素省略其关闭标签，最常见的就是 `<input>` 和 `<img>`。对于其他的元素来说，如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束，用下面这个代码片段举个例子：\n\n```html\n<my-component />\n<!-- 我们想要在这里关闭标签... -->\n<span>hello</span>\n```\n\nwill be parsed as：\n\n```html\n<my-component>\n  <span>hello</span>\n</my-component>\n<!-- 但浏览器会在这里关闭标签 -->\n```',755,1),
(135,'组件模板引用标注类型','为一个子组件添加一个模板 ref，以便调用它公开的方法。如一个 `MyModal` 子组件，它有一个打开模态框的方法：\n\n```vue\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\n  import { ref } from ''vue'';\n  const isContentShown = ref(false);\n  const open = () => (isContentShown.value = true);\n  defineExpose({\n    open\n  });\n</script>\n```\n\n获取 `MyModal` 的类型，需要通过 `typeof` 得到其类型，使用 TypeScript 内置的 `InstanceType` 工具类型来获取实例类型：\n\n```vue\n<!-- App.vue -->\n<script setup lang=\"ts\">\n  import MyModal from ''./MyModal.vue'';\n\n  const modal = ref<InstanceType<typeof MyModal> | null>(null);\n  const openModal = () => {\n    modal.value?.open();\n  };\n</script>\n```\n\n',760,2),
(136,'vue3生命周期','onBeforeMount -> onMounted -> onBeforeUpdate -> onUpdated -> onBeforeUnmount -> onUnmounted -> onErrorCaptured \n\n跟 options api 混用时 onBeforeMount 在 beforeMount 之前，onMounted 在 mounted 之前\n\n| vue3              | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| setup()           | 开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method |\n| //挂载阶段        |                                                              |\n| onBeforeMount()   | 组件挂载到节点上之前执行的函数。                             |\n| onMounted()       | 组件挂载完成后执行的函数。                                   |\n| //更新            |                                                              |\n| onBeforeUpdate()  | 组件更新之前执行的函数。                                     |\n| onUpdated()       | 组件更新完成之后执行的函数。                                 |\n| //销毁            |                                                              |\n| onBeforeUnmount() | 组件卸载(销毁)之前执行的函数。                               |\n| onUnmounted()     | 组件卸载(销毁)完成后执行的函数                               |\n| onActivated()     | 被包含在 keep-alive 中的组件，会多出两个生命周期钩子函数。被激活时执行。 |\n| onDeactivated()   | 比如从 A 组件，切换到 B 组件，A 组件消失时执行。             |\n| onErrorCaptured() | 当捕获一个来自子孙组件的异常时激活钩子函数                   |',26,1),
(137,'项目目录对照','``` bash\n.\n├── vue.config.js/                      # webpack 配置文件；\n├── config/                     # 与项目构建相关的常用的配置选项；\n│   ├── index.js                # 主配置文件\n│   ├── dev.env.js              # 开发环境变量\n│   ├── prod.env.js             # 生产环境变量\n│   └── test.env.js             # 测试环境变量\n│\n├── src/\n│   ├── main.js                 # 的入口文件；\n│   ├── assets/                 # 共用的代码以外的资源，如：图片、图标、视频 等；\n│   ├── api/                    # 网络模块，如：接口；\n│   ├── router/                 # 路由模块\n│   ├── I18n/                   # 国际化模块\n│   ├── pages/                  # 单页页面\n│   ├── vuex/                   # 组件共享状态\n│   ├── components/             # 共用的组件；； 这里的存放的组件应该都是展示组件\n│   │   ├── base/               # 基本组件，如：共用的弹窗组件，loading加载组件，提示组件。\n│   │   ├── common/             # 共用的全局组件，封装的导航条，底部组件等等\n│   │   ├── temp/               # 模板组件，如：相同的页面封装成一个组件。\n│   │   ├── UItemp/             # UI组件，如：项目中特定的按钮，消息数字，等等一些样式可以封装成组件的。\n│   ├── common/                 # 共用的资源，如：常用的图片、图标，共用的组件、模块、样式，常量文件等等；\n│   │   ├── compatible/         # 兼容模块，如：适合App和微信各种接口的模块；\n│   │   ├── extension/          # 已有类的扩展模块，如：对 Array 类型进行扩展的模块；\n│   │   ├── libraries/          # 存放自己封装的或者引用的库；\n│   │   ├── tools/              # 自己封装的一些工具\n│   │   ├── constant.js         # 存放js的常量；\n│   │   ├── constant.scss       # 存放scss的常量；\n│   │   └── ...\n│   └── app/                    # 存放项目业务代码；\n│       ├── App.vue             # app 的根组件；\n├── public/                     # 纯静态资源，该目录下的文件不会被webpack处理，该目录会被拷贝到输出目录下；\n├── .babelrc                    # babel 的配置文件\n├── .editorconfig               # 编辑器的配置文件；可配置如缩进、空格、制表类似的参数；\n├── .eslintrc.js                # eslint 的配置文件\n├── .eslintignore               # eslint 的忽略规则\n├── .gitignore                  # git的忽略配置文件\n├── .postcssrc.js               # postcss 的配置文件\n├── CHAGNELOG.md                # 版本更新变更release\n├── index.html                  # HTML模板\n├── package.json                # npm包配置文件，里面定义了项目的npm脚本，依赖包等信息\n└── README.md                   # 项目信息文档\n```\n',145,1),
(138,'version','暴露当前所使用的 Vue 版本。\n\n```js\nimport { version } from ''vue''\nconsole.log(version)\n```',821,2),
(139,'script setup','## script setup\n\nscript setup可以和script同时存在,  script setup中的顶层的导入和变量声明都将自动地在该组件的模板上可用。\n\n``` js\n<script>\n  export const name = 1\n</script>\n\n<script setup>\n  import { ref } from ''vue''\n  const count = ref(0)\n</script>\n```\n',39,1),
(140,'nextTick','## nextTick\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM\n\n```ts\nimport { nextTick } from ''vue'';\n\nfunction increment() {\n  count.value++\n  nextTick(() => {\n    // 访问更新后的 DOM\n  })\n}\n\n// 还可以使用 async/await\nasync () => {\n    await nextTick()\n    // ....\n}\n```\n',40,1),
(141,'深度选择器.','处于 `scoped` 样式中的选择器如果想要做更“深度”的选择，也即：影响到子组件，可以使用 `:deep()` 这个伪类：\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\n',1103,1),
(142,'监听节点是否到底部','```tsx\n// 创建节点 ref\nconst scrollContainer = ref()\n\n// 定义触发底部函数\nconst handleScroll = () => {\n  const containerEl = scrollContainer.vlue\n  if (containerEl) {\n    const isAtBottom = containerEl.scrollHeight - containerEl.scrollTop === containerEl.clientHeight\n    console.log(isAtBottom)\n    if (isAtBottom) {\n      GetAll()\n    }\n  }\n}\n// 监听函数\nwatchEffect(() => {\n  handleScroll()\n})\n```\n\n```html\n <div ref=\"scrollContainer\" @scroll=\"handleScroll\"</div>\n```',877,1),
(143,'异步组件封装','封装前调用\n\n```js\nconst ArticleSideSearchModule = defineAsyncComponent(() => {\n  return import(''./components/sidebar/ArticleSideSearch.vue'')\n})\n```\n\n封装调用\n\n```js\n// 定义异步组件函数\nconst AsyncComponent = (name: any) => {\n  return defineAsyncComponent(() => {\n    return import(/* @vite-ignore */`./components/sidebar/${name}.vue`)\n  })\n}\n\n// 定义异步组件\nconst ArticleSideInputModule = AsyncComponent(''ArticleSideInput'')\nconst ArticleSideInputModule = AsyncComponent(''ArticleSideInput'')\n```',876,1),
(144,'滚动顶部','```js\n// 创建节点 ref\nconst scrollContainer = ref()\n\nconst onScroll = (type: any) => {\n  //下一次 DOM 更新周期时再执行\n  nextTick(() => {\n    //根据 type 参数的值计算出要滚动到的位置  确保在模板中将其赋值给对应的 DOM 元素，如 <div ref=\"snippetRef\"></div>。\n    const distance = type === ''top'' ? 0 : scrollContainer.value.scrollHeight\n    scrollContainer.value.scrollTop = distance\n  })\n}\n\n//调用\nonScroll(''top'')\n```\n\n```html\n<div ref=\"scrollContainer\"></div>\n```\n\n',874,1),
(145,'样式穿透','```scss\n.class2::v-deep {\n    /* 修改样式,已弃用 */\n}\n  \n<style>\n:deep(.class){\n}\n</style>\n\n//在父元素的class后加上:deep()\n<style>\n.父元素class :deep(.class){\n}\n</style>\n\n//在scss下的父元素里用:deep()语法\n<style lang=scss>\n.父元素{\n 	:deep(.class){\n	}\n}\n</style>\n```',875,1),
(146,'vue-tsc','```\n//安装\nnpm i vue-tsc -D\n//用法\nvue-tsc --noEmit && vite build\n```\n\nvue3 命令行类型检查工具基于 IDE 插件 [Volar](https://github.com/johnsoncodehk/volar)。\n\n```\n//类型检查：\nvue-tsc --noEmit\n//构建 dts\nvue-tsc --declaration --emitDeclarationOnly\n```\n',249,1),
(147,'normalize','统一浏览器的初始样式\n\n```js\n//安装\nnpm install --save normalize.css\n\n//main中引入\nimport ''normalize.css/normalize.css''\n```\n\n',250,1),
(148,'ref属性','虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素\n\n```html\n<input ref=\"input\">\n```\n\n',489,1),
(149,'访问模板(ref)','### 访问模板(ref)\n\n利用`ref`函数获取组件中的标签元素。\n\n声明一个同名的 ref：\n\n```html\n<script setup>\nimport { ref, onMounted } from ''vue''\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n注意，你只可以**在组件挂载后**才能访问 ref。如果你想在模板中的表达式上访问 `$refs.input`，在初次渲染时会是 `null`\n\n如果你正试图观察一个模板 ref 的变化，确保考虑到 ref 的值为 `null` 的情况：\n\n```tsx\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // 此时还未挂载，或此元素已经被卸载（例如经过 v-if 控制）\n  }\n})\n```\n\n利用`ref`函数获取组件中的标签元素。\n\n```html\n<template>\n  <input type=\"text\" ref=\"inputRef\">\n</template>\n\n<script>\nimport { onMounted, ref } from ''vue''\nexport default {\n  setup() {\n    // 定义dom元素\n    const inputRef = ref<HTMLElement|null>(null)\n    // 自动获取焦点\n    onMounted(() => {\n      inputRef.value && inputRef.value.focus()\n    })\n\n    return {\n      inputRef\n    }\n  },\n}\n</script>\n```\n\n',490,1),
(150,'设置窗口高度(ref)','### 设置窗口高度(ref)\n\n**template**\n\n```html\n<template>\n    <div class=\"demo1-container\">\n        <p>通过ref直接拿到dom</p>\n        <div ref=\"sectionRef\" class=\"ref-section\"></div>\n        <button @click=\"higherAction\" class=\"btn\">变高</button>\n    </div>\n</template>\n```\n\n**script setup**\n\n```tsx\nimport {ref} from ''vue''\nconst sectionRef = ref()\nlet height = 100;\nconst higherAction = () => {\n    height += 50;\n    sectionRef.value.style = `height: ${height}px`;\n}\n```\n\n',491,1),
(151,'ref()','- ref接受一个内部值，返回一个ref 对象，这个对象是响应式的、可更改的，且只有一个指向其内部值的属性 .value。\n- 当引用的值发生变化时，相关的组件将自动重新渲染。\n- 当ref的值为对象类型时，会用 reactive() 自动转换它的 .value',1111,1),
(152,'CSS变量注入','```tsx\n<template>\n  <span>变量注入</span>  \n</template>\n<script lang=\"ts\" setup>\n  import { ref } from ''vue''\n  const color = ref(''red'')\n</script>\n<style scoped>\n  span {\n    /* 使用v-bind绑定组件中定义的变量 */\n    color: v-bind(''color'');\n  }  \n</style>\n```\n',543,1),
(153,'使用ref设置窗口高度','```html\n<template>\n    <div class=\"demo1-container\">\n        <p>通过ref直接拿到dom</p>\n        <div ref=\"sectionRef\" class=\"ref-section\"></div>\n        <button @click=\"higherAction\" class=\"btn\">变高</button>\n    </div>\n</template>\n```\n\n```tsx\nimport {ref} from ''vue''\nconst sectionRef = ref()\nlet height = 100;\nconst higherAction = () => {\n    height += 50;\n    sectionRef.value.style = `height: ${height}px`;\n}\n```\n\n',491,2),
(154,'使用ref访问模板','### 访问模板(ref)\n\n利用`ref`函数获取组件中的标签元素。\n\n声明一个同名的 ref：\n\n```html\n<script setup>\nimport { ref, onMounted } from ''vue''\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n注意，你只可以**在组件挂载后**才能访问 ref。如果你想在模板中的表达式上访问 `$refs.input`，在初次渲染时会是 `null`\n\n如果你正试图观察一个模板 ref 的变化，确保考虑到 ref 的值为 `null` 的情况：\n\n```tsx\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // 此时还未挂载，或此元素已经被卸载（例如经过 v-if 控制）\n  }\n})\n```\n\n利用`ref`函数获取组件中的标签元素。\n\n```html\n<template>\n  <input type=\"text\" ref=\"inputRef\">\n</template>\n\n<script>\nimport { onMounted, ref } from ''vue''\nexport default {\n  setup() {\n    // 定义dom元素\n    const inputRef = ref<HTMLElement|null>(null)\n    // 自动获取焦点\n    onMounted(() => {\n      inputRef.value && inputRef.value.focus()\n    })\n\n    return {\n      inputRef\n    }\n  },\n}\n</script>\n```\n\n',490,2),
(155,'ref问底层DOM元素','虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素\n\n```html\n<input ref=\"input\">\n```\n\n',489,2),
(156,'defineAsyncComponent','特性可以让我们延迟加载组件。这意味着它们仅在需要时从服务器加载。\n\n这是一个改善初始页面加载的好方法，因为我们的应用程序将以较小的块加载，而不必在页面加载时加载每个组件。\n\n### 简单用法\n\n```js\nimport { defineAsyncComponent } from ''vue''\n\n// 简单用法\nconst ArticleList = defineAsyncComponent(() =>\n  import(''@/components/ArticleList.vue'')\n)\n```\n\n### 配置参数\n\n```js\nconst AsyncPopup = defineAsyncComponent({\n  loader: () => import(''./ArticleList.vue''),\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n  // 加载失败时使用的组件\n  errorComponent: ErrorComponent\n  // 在显示加载组件之前延迟。默认值：200ms。\n  delay: 1000,\n  // 超过给定时间，则会显示错误组件。默认值：Infinity。\n  timeout: 3000\n})\n```\n\n',1110,1),
(157,'computed()','`computed`方法会自动推导出类型,使用**计算属性**来描述依赖响应式状态的复杂逻辑\n\n`computed`函数有两种用法，都是用来监听数据的变化。',1143,1),
(158,'插槽(slot)','向一个组件传递内容，可使用插槽。通过插槽来分发内容，即插槽作为分发内容的出口。使用`<slot>`作为想要插入内容的占位符。\n\n插槽 `slot` 通常用于两个父子组件之间，最常见的应用就是我们使用一些 `UI` 组件库中的弹窗组件时，弹窗组件的内容是可以让我们自定义的，这就是使用了插槽的原理。\n\n- `slot` 是 `Vue3` 中的内置标签。\n- `slot` 相当于给子组件挖出了一个槽，可以用来填充内容。\n- 父组件中调用子组件时，子组件标签之间的内容元素就是要放置的内容，它会把 `slot` 标签替换掉。',497,1),
(159,'插槽slot','向一个组件传递内容，可使用插槽。通过插槽来分发内容，即插槽作为分发内容的出口。使用`<slot>`作为想要插入内容的占位符。\n\n插槽 `slot` 通常用于两个父子组件之间，最常见的应用就是我们使用一些 `UI` 组件库中的弹窗组件时，弹窗组件的内容是可以让我们自定义的，这就是使用了插槽的原理。\n\n- `slot` 是 `Vue3` 中的内置标签。\n- `slot` 相当于给子组件挖出了一个槽，可以用来填充内容。\n- 父组件中调用子组件时，子组件标签之间的内容元素就是要放置的内容，它会把 `slot` 标签替换掉。',497,2),
(160,'插槽简写(slot)','`v-slot` 有对应的简写 `#`，\n\n向 `<BaseLayout>` 传递内容的代码，指令均使用的是缩写形式：\n\n```html\n<BaseLayout>\n  <template #header>\n    <h1>这里是一个页面标题</h1>\n  </template>\n\n  <template #default>\n    <p>一个文章内容的段落</p>\n    <p>另一个段落</p>\n  </template>\n\n  <template #footer>\n    <p>这里有一些联系方式</p>\n  </template>\n</BaseLayout>\n```\n\n',503,1),
(161,'作用域插槽(slot)','在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时利用父组件域内和子组件域内的数据。要做到这一点，我们需要让子组件将一部分数据在渲染时提供给插槽。\n\n而我们确实也有办法这么做！我们可以像对组件传递 props 那样，向一个插槽的插口上传递 attribute：\n\n```html\n<!-- <MyComponent> 的模板 -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽 props 时，一般的默认插槽和具名插槽的使用方式有了一些小小的区别。下面我们将会展示是怎样的不同，首先是一个默认插槽，通过子组件标签上的 `v-slot` 指令，直接接收到了一个插槽 props 对象：\n\n```html\n<MyComonent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n<MyComponent>\n```\n\n子组件传入插槽的 props 作为了 `v-slot` 指令的值，可以在插槽内的表达式中访问。\n\n可以将作用于插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\n\n```tsx\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = ''hello''\n  return (\n    `<div>${\n      // 在插槽函数调用时传入 props\n      slots.default({ text: greetingMessage, count: 1 })\n    }</div>`\n  )\n}\n```\n\n实际上，这已经和作用域插槽的最终的代码编译结果、以及手动地调用渲染函数的方式非常类似了。\n\n`v-slot=\"slotProps\"` 可以类比这里的函数签名，和函数的参数类似，我们也可以在 `v-slot` 使用：\n\n```tsx\n<MyComonent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n<MyComponent>\n```\n\n',505,1),
(162,'渲染作用域(slot)','插槽内容可以访问到父组件的数据，因为插槽内容本身也是在父组件模板的一部分。\n\n```html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\n这里的两个 `{{ message }}` 插值表达式渲染的内容都是一样的。\n\n插槽内容**无法访问**子组件的数据，请牢记一条规则：\n\n> 任何父组件模板中的东西都是被编译到父组件的作用域中；而任何子组件模板中的东西都只被编译到子组件的作用域中',500,1),
(163,'基本使用(slot)','在子组件放置插槽\n\n子组件**child.vue**\n\n```html\n<template>\n  // 匿名插槽\n  <slot/>\n  // 具名插槽\n  <slot name=''title''/>\n  // 作用域插槽\n  <slot name=\"footer\" :scope=\"state\" />\n</template>\n```\n\n父组件\n\n```html\n<template>\n  <child>\n    // 匿名插槽\n    <span>我是默认插槽</span>\n    // 具名插槽\n    <template #title>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n    </template>\n    // 作用域插槽\n    <template #footer=\"{ scope }\">\n      <footer>作用域插槽——姓名：{{ scope.name }}，年龄{{ scope.age }}</footer>\n    </template>\n  </child> \n</template>\n<script setup>\n  // 引入子组件\n  import child from ''./child.vue''\n</script>\n```\n',498,1),
(164,'默认插槽(slot)','### 默认插槽(slot)\n\n经常会遇到外部没有提供任何内容的情况，此时可能会为插槽提供一个默认的内容来渲染。 SubmitButton组件\n\n```html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\n如果外部没有提供任何插槽内容，我们可能想在 `<button>` 中渲染“提交”这两个字。要让这两个字成为默认内容，需要写在 `<slot>` 标签之间：\n\n```html\n<button type=\"submit\">\n  <slot>\n    提交 <!-- 默认内容 -->\n  </slot>\n</button>\n```\n\n当在父组件中使用 `<submit-button>` 但不提供任何插槽内容：\n\n```html\n<SubmitButton />\n```\n\n那么将渲染出下面这样的 DOM 结构，包含默认的“提交”二字：\n\n```html\n<button type=\"submit\">提交</button>\n```\n\n如果提供了别的内容给插槽,那么渲染的 DOM 中会选择使用提供的插槽内容',501,1),
(165,'多个插槽(slot)','有时一个组件中可能会有多个插槽的插口。\n\n```html\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n对于这种场景，`<slot>` 元素可以有一个特殊的 attribute `name`，可以是一个独一无二的标识符，用来区分各个插槽，确定每一处最终会渲染的内容：\n\n```html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n没有提供 `name` 的 `<slot>` 插口会隐式地命名为“default”。\n\n在父组件中使用到 `<BaseLayout>` 时，我们需要给各个插槽传入内容，为了模板片段让各入各门、各寻其所。此时就需要用到**具名插槽**了：\n\n要为具名插槽传入内容，我们需要使用一个含 `v-slot` 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：\n\n```html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n',502,1),
(166,'动态插槽名(slot)','动态指令参数在 `v-slot` 上也是有效的，即可以定义下面这样的动态插槽名：\n\n插槽可以是一个变量名 const name = ref(''header'')\n\n```html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- 缩写为 -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n注意这里的表达式和动态指令参数受相同的语法限制',504,1),
(167,'具名作用域插槽','具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 `v-slot` 指令的值被访问到：`v-`。当使用缩写时是这样：\n\n```html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ headerProps }}\n  </template>\n</MyComponent>\n```\n\n向具名插槽中传入 props：\n\n```html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\n注意插槽上的 `name` 是由 Vue 保留的，不会作为 props 传递给插槽。因此最终 `headerProps` 的结果是 `{ message: ''hello'' }`。',506,2),
(168,'provide/inject','### provide/inject\n\n提供 和 注入 是很简单理解的\n\n> 实现跨层级组件(祖孙)间通信\n\n在多层嵌套组件中使用，不需要将数据一层一层地向下传递,可以实现跨层级组件通信\n\n **父组件**\n\n```tsx\nconst info = reactive({\n   title: ''Vue3学习''\n })\n//提供的数据名，数据值\nprovide(''info'', info)\n```\n\n**子组件**\n\n```js\n//获取对应数据的值\nconst color = inject(''info'')\n```\n\n',507,1),
(169,'应用层Provide','要为组件后代供给数据，需要使用到 `provide()`函数：\n\n```tsx\nimport { provide } from ''vue''\nprovide(/* 注入名 */ ''message'', /* 值 */ ''hello!'')\n```\n\n接收两个参数。第一个参数被称为**注入名**，\n\n第二个参数是供给的值，值可以是任意类型，包括响应式的状态，比如一个 ref：\n\n```tsx\nimport { ref, provide } from ''vue''\n\nconst count = ref(0)\nprovide(''key'', count)\n```\n\n供给的响应式状态使后代组件可以由此和供给者建立响应式的联系。',508,1),
(170,'Inject(注入)','要注入祖先组件供给的数据，需使用 `inject()`函数：\n\n```tsx\nimport { inject } from ''vue''\nconst message = inject(''message'')\n```\n\n如果供给的值是一个 ref，注入进来的就是它本身，而**不会**自动解套。这使得被注入的组件保持了和供给者的响应性链接。\n\n同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 同步调用：\n\n```tsx\nimport { inject } from ''vue''\nexport default {\n  setup() {\n    const message = inject(''message'')\n    return { message }\n  }\n}\n```\n\n',509,1),
(171,'provide/inject标注类型','provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型， Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：\n\n```tsx\nimport { provide, inject, InjectionKey } from ''vue''\n\nconst key = Symbol() as InjectionKey<string>\n      \nprovide(key, ''foo'') // 若提供的是非字符串值会导致错误\n\nconst foo = inject(key) // foo 的类型：string | undefined\n```\n\n建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。\n\n当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明：\n\n```tsx\nconst foo = inject<string>(''foo'') // 类型：string | undefined\n```\n\n注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。\n\n当提供了一个默认值后，这个 `undefined` 类型就可以被移除：\n\n```tsx\nconst foo = inject<string>(''foo'', ''bar'') // 类型：string\n```\n\n如果你确定该值将始终被提供，则还可以强制转换该值：\n\n```tsx\nconst foo = inject(''foo'') as string\n```\n\n',510,1),
(172,'provide/inject传递函数','```tsx\n// 获取歌手详情\nconst getArtistDetail = async () => {\n    let params = {\n        id: route.query.id\n    }\n    await artistDetail(params).then(res => {\n        state.list = res.data.data\n        state.artistName = state.list.artist.name\n    })\n}\n// 获取歌手名称，使用 provide 传递给孙子组件使用\nconst getArtistName = () => {\n    return state.artistName\n}\n// provide 传值\nprovide(\"getArtistName\", getArtistName())\n```\n',511,1),
(173,'通过子组件emit传递ref','template\n```html\n<template>\n    <div ref=\"cellRef\" @click=\"cellAction\" class=\"cell-item\">\n        <span>{{item}}</span>\n    </div>\n</template>\n```\n\nscript setup\n\n```tsx\nimport {ref} from ''vue'';\n\nconst props = defineProps({\n    item: Number\n})\nconst emit = defineEmits([''cellTap'']);\nconst cellRef = ref();\nconst cellAction = () => {\n    emit(''cellTap'', cellRef.value);\n}\n```\n\n',493,1),
(174,'v-for中的ref','当 `ref` 在 `v-for` 中使用时，相应的 ref 中包含的值是一个数组，它将在元素被挂载后填充：\n\ntemplate\n\n```html\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\nscript setup\n\n```tsx\nimport { ref, onMounted } from ''vue''\n\nconst list = ref([\n  /* ... */\n])\nconst itemRefs = ref([])\nonMounted(() => console.log(itemRefs.value))\n```\n\n应该注意的是，ref 数组**不能**保证与源数组相同的顺序。',494,1),
(175,'函数型ref','`ref` attribute 还可以绑定为函数，每次组件更新时被调用。函数接受该元素引用作为第一个参数：\n\n```html\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\n```\n\n如果使用一个动态的 `:ref` 绑定，也可以传一个函数。当元素卸载时，这个 `el` 参数会是 `null`。你当然也可以使用一个方法而不是内联函数。',495,2),
(176,'组件上的ref','#### 组件上的ref\n\n 也可以被用在一个子组件上\n\nscript setup\n\n```tsx\nimport { ref, onMounted } from ''vue''\nimport Child from ''./Child.vue''\n\nconst child = ref(null)\nonMounted(() => {\n  // child.value 为 <Child /> 这个组件实例\n})\n```\n\n```html\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，意味着父组件对子组件每个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，应该只在绝对需要时才使用组件引用。多数情况下，应该使用标准的 props 和 emit 接口来实现父子组件交互。\n\n有一个例外的情况，使用了 `<script setup>` 的组件时**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\nscript setup\n\n```tsx\nimport { ref } from ''vue''\nconst a = 1\nconst b = ref(2)\ndefineExpose({\n  a,\n  b\n})\n```\n\n当父组件通过模板 ref 获取到了该组件的实例，得到的实例类型为 `{ a: number, b: number }` (ref 都会自动解套，和一般的实例一样)。',496,1),
(177,'Transition组件','vue提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',517,2),
(178,'Transition搭配CSS','`<Transition>` 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 `transition` CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n\n下面是一个更高级的例子，使用不同的持续时间和速度曲线来过渡多个属性：\n\n```html\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n\n\n\n### CSS的animation',520,2),
(179,'布尔型Attribute','```html\n<button :disabled=\"isButtonDisabled\">\n  Button\n</button>\n```\n',456,2),
(180,'DOM更新时机','更改响应式状态后，DOM会自动更新。然而要注意 DOM 的更新并**不是同步的**。相反，Vue 将缓冲它们直到更新周期的“next tick”执行，以确保无论你进行了多少次状态更改，每个**组件**都只需要**更新一次**。\n\n若要等待一个状态改变后的 DOM 更新完成，你可以使用`nextTick()`这个全局 API：\n\n```js\nimport { nextTick } from ''vue''\n\nfunction increment() {\n  count.value++\n  nextTick(() => {\n    // 访问更新后的 DOM\n  })\n}\n```\n\n\n\n',1165,1),
(181,'watch','- 监听函数,监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调\n- 默认初始时不执行回调, 但可以通过配置`immediate`为`true`, 来指定初始时立即执行第一次\n- 通过配置`deep`为`true`, 来指定深度监视\n\n```js\n<script setup>\n  import { watch, reactive } from ''vue''\n  const state = reactive({\n    count: 1\n  })\n\n  // 声明方法\n  const changeCount = () => {\n    state.count = state.count * 2\n  }\n\n  // 监听count\n  watch(\n    () => state.count,\n    (newVal, oldVal) => {\n      console.log(state.count)\n      console.log(`watch监听变化前的数据：${oldVal}`)\n      console.log(`watch监听变化后的数据：${newVal}`)\n    },\n    {\n      immediate: true, // 立即执行\n      deep: true // 深度监听,深度监听,也就是监听复杂数据类型\n    }\n  )\n</script>\n```',746,1),
(182,'监听路由','```js\n// 正确方式\nimport { reactive, watch } from ''vue''\nconst route = useRoute()\n\n// 监听路由变化\nwatch(route, () => {\n    console.log(route)\n}, { deep: true })\n\n// 监听 vuex 值变化\nwatch(store.state.routesList, () => {\n    setFilterRoutes()\n}, {\n    deep: true,\n})\n```',747,1),
(183,'监听响应式数据','```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number: 0\n})\n\nwatch(() => [state.number], (newValue, oldValue) => {\n  console.log(newValue, oldValue)\n}, { deep: true })\n```',748,1),
(184,'监听多个数据','```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number1: 10,\n      number2: 20\n})\n\nwatch(() => [state.number1, state.number2], (newVal, oldVal) => {\n    console.log(newVal, oldVal); // 打印结果：[100, 200][10, 20]，两个数组，前面的是改变后的值\n}, { deep: true })\n\nsetInterval(() => {\n       state.number1 = 100;\n    state.number2 = 200;\n}, 2000);\n```',749,1),
(185,'watchEffect','也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些\n\n- 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据\n- 默认初始时就会执行第一次, 从而可以收集需要监视的数据\n- 监视数据发生变化时回调\n\n```js\nlet user = reactive({\n  name: ''小浪'',\n  age: 21\n});\n// 只有 user.name 发生改变这个就会执行\nwatchEffect(() => {\n  console.log(user.name);\n});\n```\n\n#### 清除副作用\n\n- 就是在触发监听之前会调用一个函数可以处理你的逻辑例如防抖\n\n```js\nlet message = ref('''')\nlet message2 = ref('''')\nwatchEffect((oninvalidate) => {\n    //console.log(''message'', message.value);\n    oninvalidate(() => {})\n    console.log(''message2'', message2.value)\n})\n```\n\n#### **停止跟踪 watchEffect 返回一个函数 调用之后将停止更新**\n\n```js\nconst stop = watchEffect(\n    (oninvalidate) => {\n        //console.log(''message'', message.value);\n        oninvalidate(() => {})\n        console.log(''message2'', message2.value)\n    },\n    {\n        flush: ''post'',\n        onTrigger() {},\n    }\n)\nstop()\n```',750,1),
(186,'watch与watchEffect区别','- 第一点我们可以从示例代码中看到 watchEffect 不需要指定监听的属性，他会自动的收集依赖， 只要我们回调中引用到了 响应式的属性， 那么当这些属性变更的时候，这个回调都会执行，而 watch 只能监听指定的属性而做出变更(v3 开始可以同时指定多个)。\n- 第二点就是 watch 可以获取到新值与旧值（更新前的值），而 watchEffect 是拿不到的。\n- 第三点是 watchEffect 如果存在的话，在组件初始化的时候就会执行一次用以收集依赖（与 computed 同理），而后收集到的依赖发生变化，这个回调才会再次执行，而 watch 不需要，因为他一开始就指定了依赖。（watchEffect 是自动执行的）',745,1),
(187,'watchEffect','也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些\n\n- 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据\n- 默认初始时就会执行第一次, 从而可以收集需要监视的数据\n- 监视数据发生变化时回调\n\n```js\nlet user = reactive({\n  name: ''test'',\n  age: 21\n});\n// 只有 user.name 发生改变这个就会执行\nwatchEffect(() => {\n  console.log(user.name);\n});\n```\n\n#### 清除副作用\n\n- 就是在触发监听之前会调用一个函数可以处理你的逻辑例如防抖\n\n```js\nlet message = ref('''')\nlet message2 = ref('''')\nwatchEffect((oninvalidate) => {\n    //console.log(''message'', message.value);\n    oninvalidate(() => {})\n    console.log(''message2'', message2.value)\n})\n```\n\n#### **停止跟踪 watchEffect 返回一个函数 调用之后将停止更新**\n\n```js\nconst stop = watchEffect(\n    (oninvalidate) => {\n        //console.log(''message'', message.value);\n        oninvalidate(() => {})\n        console.log(''message2'', message2.value)\n    },\n    {\n        flush: ''post'',\n        onTrigger() {},\n    }\n)\nstop()\n```',750,2),
(188,'绑定style','CSS property 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名\n-  绑定style对象语法\n```\n:style=\"包含css样式的对象\"\n:style=\"{属性名: ''属性值''}\"\n```\n​      1- {color: ''red''} 这里需要注意属性值必须添加'''', 如果没有引号会将red当做变量去数据中寻找\n​      2- { fontSize: ''24px''} ,这里也可以写成烤串命名法，但是需要用''''包起来，否则会报错\n​      3- {fontSize: `${finalFontSize}px`} 也可以写成字符串拼接\n​      4- :style=\"finalStyleObj\" 也可以直接绑定对象\n​      5- 也可以写在方法或者计算属性中\n``` html\n  <!-- <h2 :style=\"{key(属性名):value(属性值)}\">{{massage}}</h2> -->\n  <!-- 这里要加'' ''要不然vue会去解析50px这个变量然后报错 -->\n  :style=\"{fontSize: ''50px''}\">{{massage}}\n  <!-- finalSize当成一个变量在使用 -->\n  :style=\"{fontSize: finalSize}\">{{massage}}\n  <!-- 也可以拼接 -->\n   :style=\"{fontSize: finalSize + ''px'',color:finalColor}\">{{massage}}\n  <!-- 数组语法 -->\n  :style=\"[baseStyle,baseStyle1]\">{{massage}}\n\n\nconst app = new Vue({\n	el: \"#app\",\n	data: {	\n        finalSize: 100,\n        finalColor: ''red'',\n        baseStyle:{color:''red''},\n        baseStyle1:{fontSize:''75px''}\n		}})\n\n```\n\n',132,2),
(189,'for中的变量别名解构','```html\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- 有 index 索引时 -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\n\n\n',159,2),
(190,'for&if同时使用','当它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 <template> 中\n\n```html\n//1\n<template v-for=\"(item, index) in ResultList\" :key=\"index\">\n   <a @click=\"onk(item.path)\" v-if=\"item.identity\">\n    {{item.title}}\n   </a>\n</template>\n//2\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n',164,2),
(191,'组件上使用v-for','```html\n<my-component v-for=\"item in items\" :key=\"item.id\">\n</my-component>\n```\n\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，我们还是应该使用 props：\n\n```html\n<my-component\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n></my-component>\n```\n\n',163,2),
(192,'v-on:click','使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件和运行 JavaScript \n#### 基本语法\n```html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\">...</a>\n<!-- 缩写 -->\n<a @click=\"doSomething\">...</a>\n<!-- 动态参数的缩写 -->\n<a @[event]=\"doSomething\"> ... </a>\n<!-- 动态的事件名绑定处理函数 -->\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n```\n事件处理器的值：\n1. 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似) 。\n2. 方法事件处理器：一个组件的属性名、或对某个方法的访问。',36,1),
(193,'内联事件处理器','\n```js\nconst count = ref(0)\n```\n```js\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n',135,2),
(194,'事件修饰符','在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n```html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n<!-- 点击事件将只会触发一次 -->\n<a v-on:click.once=\"doThis\"></a\n    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n',140,2),
(195,'按键修饰符','在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。\n\n```html\n<!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` -->\n<input @keyup.enter=\"submit\" />\n\n<!--仅会在 $event.key 为 ''PageDown'' 时调用事件处理。 -->\n<input @keyup.page-down=\"onPageDown\" />\n```\n\n',141,2),
(196,'复选框中使用v-model','单一的复选框，绑定的是布尔类型值：\n\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\n```\n',244,2),
(197,'选择框中使用v-model','单选时：\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\">\n  <option disabled value=\"\">请选择</option>\n  <option>A</option>\n  <option>B</option>\n</select\n```\n\n多选时 (绑定到一个数组)：\n\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n</select>\n```\n\n用 `v-for` 渲染的动态选项：\n\n```html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<div>选择的是：{{ selected }}</div>\n```\n\n```js\nconst selected = ref(''A'')\nconst options = ref([\n  { text: ''One'', value: ''A'' },\n  { text: ''Two'', value: ''B'' },\n])\n```',246,2),
(198,'修饰符v-model','.lazy：默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。你可以添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：\n```html\n<!-- 在 \"change\" 事件后同步更新而不是 \"input\" -->\n<input v-model.lazy=\"msg\" />\n```\n.number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n```html\n<input v-model.number=\"age\" />\n```\n.trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n```html\n<input v-model.trim=\"msg\" />\n```\n',248,2),
(199,'组合式API','使用 Composition API，可以使用导入的 API 函数来描述组件逻辑。在单文件组件中，组合式 API 通常会与`<script setup>`搭配使用。这个`setup`attribute 是一个标识，告诉 Vue 需要在编译时进行转换，来减少使用组合式 API 时的样板代码。例如，`<script setup>`中的导入和顶层变量/函数都能够在模板中直接使用。\n\n下面是使用了组合式 API 与`<script setup>`改造后和上面的模板完全一样的组件：\n\n```vue\n<script setup>\nimport { ref, onMounted } from ''vue''\n\n// 响应式状态\nconst count = ref(0)\n\n// 用来修改状态、触发更新的函数\nfunction increment() {\n  count.value++\n}\n\n// 生命周期钩子\nonMounted(() => {\n  console.log(`The initial count is ${count.value}.`)\n})\n</script>\n\n<template>\n  <button @click=\"increment\">Count is: {{ count }}</button>\n</template>\n```\n\n',1163,1),
(200,'vue组件定义','使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的`.vue`文件中，这被叫做单文件组件（Single-File Component，简称 SFC）：\n\n```vue\n<script setup>\nimport { ref } from ''vue''\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">点击了 {{ count }} 次</button>\n</template>\n```\n\n',1163,2),
(201,'组件使用','要使用一个子组件，我们需要在父组件中导入它。假设我们把计数器组件放在了一个叫做 `ButtonCounter.vue` 的文件中，这个组件将会以默认导出的形式被暴露给外部。\n\n通过 script setup，导入的组件都在模板中直接可用\n\n```tsx\nimport ButtonCounter from ''./ButtonCounter.vue'';\n```\n\n```html\n<template>\n  <h1>这里是一个子组件！</h1>\n  <ButtonCounter />\n</template>\n```',751,1),
(202,'单文件组件','在大多数启用了构建工具的 Vue 项目中，我们可以使用一种类似 HTML 格式的文件来书写 Vue 组件，它被称为单文件组件(也被称为**.vue*文件，英文 Single-File Components，缩写为**SFC**)。顾名思义，Vue 的单文件组件会将一个组件的逻辑（JavaScript），模板（HTML）和样式（CSS）封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\"> Count is: {{ count }} </button>\n</templat>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n```\n\n单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。\n\n',1164,1),
(203,'动态组件','有的需求会想要在两个组件间来回切换，比如 Tab 界面：\n\n通过 Vue 的 `<component>` 元素和特殊的 `is` attribute 实现的：\n\n```html\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n```\n\n在上面的例子中，被传给 `:is` 的值可以是以下几种：\n\n- 被注册的组件名\n- 导入的组件对象\n\n你也可以使用 `is` attribute 来创建一般的 HTML 元素。\n\n当使用 `<component :is=\"...\">` 来在多个组件间作切换时，组件会在被切换掉后卸载。我们可以通过组件强制不活跃的组件仍然保持“存活”的状态。',754,1),
(204,'全局组件应用','使用 `app.component()` 方法，让组件在当前 Vue 应用中全局可用。\n\n```js\nimport { createApp } from ''vue'';\n\nconst app = createApp({});\n\napp.component(\n  // 注册的名字\n  ''MyComponent'',\n  // 组件的实现\n  {\n    /* ... */\n  }\n);\n```\n\n如果使用单文件组件，你可以注册被导入的 `.vue` 文件：\n\n```js\nimport MyComponent from ''./App.vue`\n\napp.component(''MyComponent'', MyComponent)\n```\n\n`app.component()` 方法可以被链式调用：\n\n```js\napp.component(''ComponentA'', ComponentA).component(''ComponentB'', ComponentB).component(''ComponentC'', ComponentC);\n```\n\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\n```html\n<!-- 这在当前应用的任意组件中都可用 -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在*彼此内部*使用。',756,1),
(205,'局部注册','虽然十分方便，但全局注册有以下几个短板：\n\n1. 全局注册使构建系统无法移除未使用的组件(也叫“tree-shaking”)。如果你全局注册了一个组件，却一次都没有使用，它仍然会出现在最终的构建产物中。\n2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，很难定位子组件的实现。这可能会影响未来长期的可维护性，类似于使用过多的全局变量。\n\n局部注册将注册组件的可用性限定在当前组件的范围内。它使依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n`<script setup>`，导入的组件会自动进行局部注册：\n\n```html\n<script setup>\n  import ComponentA from ''./ComponentA.vue'';\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n如果不使用 `<script setup>`，你需要使用 `components` 选项：\n\n```js\nimport ComponentA from ''./ComponentA.js'';\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n};\n```\n\n对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n};\n```',757,1),
(206,'provide/inject的使用','inject与provide其实就是祖孙组件传值,provide用于祖组件传,inject用于孙组件接\n\n提供 和 注入 是很简单理解的\n\n> 实现跨层级组件(祖孙)间通信\n\n在多层嵌套组件中使用，不需要将数据一层一层地向下传递,可以实现跨层级组件通信\n\n### 基本使用\n\n **父组件**\n\n```tsx\nconst info = reactive({\n   title: ''Vue3学习''\n })\n//提供的数据名，数据值\nprovide(''info'', info)\n```\n\n**子组件**\n\n```js\n//获取对应数据的值\nconst color = inject(''info'')\n```\n\n',507,2),
(207,'provide/inject示例','顶级组件：\n\n```vue\n<template>\n  <div>\n    <son />\n  </div>\n</template>\n\n<script setup>\nimport son from \"./son.vue\";\nimport { provide } from \"vue\";\nprovide(\"abc\", \"123\");\n</script>\n```\n\n子组件：\n\n```vue\n<template>\n  <div>\n    <grandson />\n  </div>\n</template>\n\n<script setup>\nimport grandson from \"./grandson.vue\";\n</script>\n```\n\n孙组件：\n\n```vue\n<template>\n  <div>我是孙子</div>\n</template>\n\n<script setup>\nimport { inject } from \"vue\";\nconst abc = inject(\"abc\");\nconsole.log(abc);\n</script>\n```\n\n',1147,1),
(208,'应用层Provide','要为组件后代供给数据，需要使用到 `provide()`函数：\n\n```tsx\nimport { provide } from ''vue''\nprovide(/* 注入名 */ ''message'', /* 值 */ ''hello!'')\n```\n\n接收两个参数。第一个参数被称为**注入名**，\n\n第二个参数是供给的值，值可以是任意类型，包括响应式的状态，比如一个 ref：\n\n```tsx\nimport { ref, provide } from ''vue''\n\nconst count = ref(0)\nprovide(''key'', count)\n```\n\n供给的响应式状态使后代组件可以由此和供给者建立响应式的联系。',508,2),
(209,'注入Inject','要注入祖先组件供给的数据，需使用 `inject()`函数：\n\n```tsx\nimport { inject } from ''vue''\nconst message = inject(''message'')\n```\n\n如果供给的值是一个 ref，注入进来的就是它本身，而**不会**自动解套。这使得被注入的组件保持了和供给者的响应性链接。\n\n同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 同步调用：\n\n```tsx\nimport { inject } from ''vue''\nexport default {\n  setup() {\n    const message = inject(''message'')\n    return { message }\n  }\n}\n```\n\n',509,2),
(210,'provide/inject标注类型','provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型， Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：\n\n```tsx\nimport { provide, inject, InjectionKey } from ''vue''\n\nconst key = Symbol() as InjectionKey<string>\n      \nprovide(key, ''foo'') // 若提供的是非字符串值会导致错误\n\nconst foo = inject(key) // foo 的类型：string | undefined\n```\n\n建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。\n\n当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明：\n\n```tsx\nconst foo = inject<string>(''foo'') // 类型：string | undefined\n```\n\n注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。\n\n当提供了一个默认值后，这个 `undefined` 类型就可以被移除：\n\n```tsx\nconst foo = inject<string>(''foo'', ''bar'') // 类型：string\n```\n\n如果你确定该值将始终被提供，则还可以强制转换该值：\n\n```tsx\nconst foo = inject(''foo'') as string\n```\n\n',510,2),
(211,'provide/inject传递函数','```tsx\n// 获取歌手详情\nconst getArtistDetail = async () => {\n    let params = {\n        id: route.query.id\n    }\n    await artistDetail(params).then(res => {\n        state.list = res.data.data\n        state.artistName = state.list.artist.name\n    })\n}\n// 获取歌手名称，使用 provide 传递给孙子组件使用\nconst getArtistName = () => {\n    return state.artistName\n}\n// provide 传值\nprovide(\"getArtistName\", getArtistName())\n```\n',511,2),
(212,'具名作用域插槽slot','具名作用域插槽的工作方式也是类似的，插槽 props 可以作为 `v-slot` 指令的值被访问到：`v-`。当使用缩写时是这样：\n\n```html\n<MyComponent>\n  <template #header=\"headerProps\">\n    {{ headerProps }}\n  </template>\n\n  <template #default=\"defaultProps\">\n    {{ defaultProps }}\n  </template>\n\n  <template #footer=\"footerProps\">\n    {{ headerProps }}\n  </template>\n</MyComponent>\n```\n\n向具名插槽中传入 props：\n\n```html\n<slot name=\"header\" message=\"hello\"></slot>\n```\n\n注意插槽上的 `name` 是由 Vue 保留的，不会作为 props 传递给插槽。因此最终 `headerProps` 的结果是 `{ message: ''hello'' }`。',506,3),
(213,'作用域插槽slot','在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时利用父组件域内和子组件域内的数据。要做到这一点，我们需要让子组件将一部分数据在渲染时提供给插槽。\n\n而我们确实也有办法这么做！我们可以像对组件传递 props 那样，向一个插槽的插口上传递 attribute：\n\n```html\n<!-- <MyComponent> 的模板 -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽 props 时，一般的默认插槽和具名插槽的使用方式有了一些小小的区别。下面我们将会展示是怎样的不同，首先是一个默认插槽，通过子组件标签上的 `v-slot` 指令，直接接收到了一个插槽 props 对象：\n\n```html\n<MyComonent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n<MyComponent>\n```\n\n子组件传入插槽的 props 作为了 `v-slot` 指令的值，可以在插槽内的表达式中访问。\n\n可以将作用于插槽类比为一个传入子组件的函数。子组件会将相应的 props 作为参数传给它：\n\n```tsx\nMyComponent({\n  // 类比默认插槽，将其想成一个函数\n  default: (slotProps) => {\n    return `${slotProps.text} ${slotProps.count}`\n  }\n})\n\nfunction MyComponent(slots) {\n  const greetingMessage = ''hello''\n  return (\n    `<div>${\n      // 在插槽函数调用时传入 props\n      slots.default({ text: greetingMessage, count: 1 })\n    }</div>`\n  )\n}\n```\n\n实际上，这已经和作用域插槽的最终的代码编译结果、以及手动地调用渲染函数的方式非常类似了。\n\n`v-slot=\"slotProps\"` 可以类比这里的函数签名，和函数的参数类似，我们也可以在 `v-slot` 使用：\n\n```tsx\n<MyComonent v-slot=\"{ text, count }\">\n  {{ text }} {{ count }}\n<MyComponent>\n```\n\n',505,2),
(214,'异步组件','父组件中，子组件的加载一般是按照先后顺序加载的，子组件加载后才会加载父组件。\n\n一个页面的子组件很多，由于会先加载子组件，那么父组件可能会出现比较长的白屏等待时间\n\n大型项目，可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件Vue 提供`defineAsyncComponent`方法：\n\n```js\nimport { defineAsyncComponent } from ''vue'';\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */);\n  });\n});\n```\n\n',1090,1),
(215,'使用import导入异步组件','得到的 `AsyncComp` 是一个包裹组件，仅在页面需要它渲染时才调用加载函数。另外，它还会将 props 传给内部的组件，所以你可以使用这个异步的包裹组件无缝地替换原始组件，同时实现延迟加载\n\n```js\nimport { defineAsyncComponent } from ''vue'';\n\nconst AsyncComp = defineAsyncComponent(() => import(''./components/MyComponent.vue''));\n```\n\n',1091,1),
(216,'处理异步组件加载与错误的状态','异步操作不可避免地会涉及到加载和错误状态，因此 `defineAsyncComponent()` 也支持在高级选项中处理这些状态：\n\n```js\nconst AsyncComp = defineAsyncComponent({\n  // 加载函数 需要返回一个Promise，可以使用动态import的方式，也可以自己new Promise()\n  loader: () => import(''./Foo.vue''),\n  // 加载异步组件时使用的组件，该组件会在异步组件加载时显示，如果异步组件加载很快，可能不会出现loading组件\n  loadingComponent: LoadingComponent,\n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n  // 加载失败后展示的组件，可以通过Promise的reject来测试\n  errorComponent: ErrorComponent,\n  // 如果提供了一个 timeout 时间限制，并超时了\n  // 也会显示这里配置的报错组件，默认值是：Infinity\n  timeout: 3000\n});\n```\n\n如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得太快，导致最终组件的替换可能看起来像是闪烁。\n\n如果提供了一个报错组件，当加载器函数返回的 Promise 被 reject 时，它将被显示出来。你还可以指定一个超时时间，在请求耗时过长时显示报错组件。',1092,1),
(217,'testersef','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,2),
(218,'自定义指令生命周期','指令的生命周期和组件的生命周期类似：\n\n```js\napp.directive(''focus'', {\n  created() {\n    console.log(''created'');\n  },\n  beforeMount() {\n    console.log(''beforeMount'');\n  },\n  mounted() {\n    console.log(''mounted'');\n  },\n  beforeUpdate() {\n    console.log(''beforeUpdate'');\n  },\n  updated() {\n    console.log(''updated'');\n  },\n  beforeUnmount() {\n    console.log(''beforeUnmount'');\n  },\n  unmounted() {\n    console.log(''unmounted'');\n  }\n})\ncreated：在绑定元素的属性前，或者事件监听器应用前调用\nbeforeMount：在元素被插入到DOM前调用，例如我们想要实现输入框的自动聚焦，就不能在beforeMount钩子中实现\nmounted：在绑定元素的父组件以及自己的所有子节点都挂载完毕后调用，这个时候DOM已经渲染出来，我们实现输入框自动聚焦也是在这个钩子函数中实现\nbeforeUpdate：绑定元素的父组件更新前调用\nupdated：在绑定元素的父组件以及自己的所有子节点都更新完毕后调用\nbeforeUnmount：绑定元素的父组件卸载前调用\nunmounted：绑定元素的父组件卸载后调用\n```\n\n',1100,1),
(219,'Transition组件','vue提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',517,3),
(220,'Transition','- `<Transition>` 会在一个元素或组件进入和离开 DOM 时应用动画。\n- `<TransitionGroup>` 会在一个元素或组件被插入到 `v-for` 列表中，或是被移动或从其中移除时应用动画。\n\n除了这两个组件，也可以通过其他技术手段来应用动画，如切换 CSS 类或用状态绑定样式来驱动动画。\n\n',1154,1),
(221,'transition上下滑动','```vue\n<transition name=\"slide-fade\">\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 1s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 1s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translatey(500px);\n  opacity: 1;\n}\n```\n',815,1),
(222,'过度&动画的使用','```html\n<template>\n  <div id=\"app\">\n    <router-view v-slot=\"{ Component }\">\n      <transition name=\"fade\">\n        <keep-alive>\n          <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n        </keep-alive>\n      </transition>\n      <transition name=\"fade\">\n        <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n      </transition>\n    </router-view>\n  </div>\n</template>\n```\n\n```js\n\n<style lang=\"scss\">\n\n/* 可以为进入和离开动画设置不同的持续时间和动画函数 */\n.fade-enter-active {\n  //进入过程\n  animation: fade-in 0.8s cubic-bezier(0.39, 0.575, 0.565, 1) both;\n}\n.fade-leave-active {\n  //离开过程\n  animation: fade-out 0.3s ease-out both;\n}\n//进入开始和离开结束的状态\n.fade-enter-to {\n  opacity: 0;\n}\n//进入开始和离开结束的状态\n.fade-leave-to {\n  opacity: 0;\n}\n\n@keyframes fade-in {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes fade-out {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n```\n',533,2),
(223,'控制动画时长','就是我们不管CSS中的动画和过渡时长，以标签为准。可以绑定属性`<transition :duration=\"1000\">` 来控制时长，意思是1秒后，结束动画和过渡。',532,2),
(224,'动态过渡','`<Transition>` 的 props (比如 `name`) 也可以是动态的！这让我们可以根据状态变化动态地应用不同类型的过渡：\n\n```html\n<Transition :name=\"transitionName\">\n  <!-- ... -->\n</Transition>\n```\n\n当你使用 Vue 的过渡类约定规则定义了 CSS 过渡/动画，并想在它们之间切换时，这可能很有用。\n\n你也可以根据你的组件的当前状态在 JavaScript 过渡钩子中应用不同的行为。在此篇的最后，我们可以得出结论，创建动态过渡的终极方式是创建可重用的过渡组件，这些组件接受 prop 来改变过渡的性质。现在在编写动画时，就只有你想不到，没有做不到的了。',531,1),
(225,'出现时过渡','如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 `appear` attribute：\n\n```html\n<Transition appear>\n  ...\n</Transition>\n```\n',527,2),
(226,'可重用过渡','得益于 Vue 的组件系统，过渡是可以被重用的。要创建一个可被重用的过渡，我们需要为 `<Transition>` 组件创建一个包裹组件，并向内传入插槽内容：\n\n```html\n<!-- MyTransitio.vue -->\n<script>\n// JavaScript 钩子逻辑...\n</script>\n\n<template>\n  <!-- 包裹内置的 Transition 组件 -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- 向内传递插槽内容 -->\n  </Transition>\n</tempalte>\n\n<style>\n/*\n  必要的 CSS...\n  注意：避免在这里使用 <style scoped>\n  因为那不会应用到插槽内容上\n*/\n</style>\n```\n\n现在 `MyTransition` 可以在导入后像内置组件那样使用了：\n\n```html\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\n```\n\n',526,2),
(227,'JavaScript钩子','你可以通过监听 `<Transition>` 组件事件的方式在过渡过程中挂上钩子函数：\n\n```html\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\n\n```\n\n```tsx\n// 在元素被插入到 DOM 之前被调用\n// 用这个来设置元素的 \"enter-from\" 状态\nfunction onBeforeEnter(el) {},\n\n// 在元素被插入到 DOM 之后的下一帧被调用\n// 用这个来开始进入动画\nfunction onEnter(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 当进入过渡完成时调用。\nfunction onAfterEnter(el) {}\nfunction onEnterCancelled(el) {}\n\n// 在 leave 钩子之前调用\n// 大多数时候，你应该只会用到 leave 钩子\nfunction onBeforeLeave(el) {}\n\n// 在离开过渡开始时调用\n// 用这个来开始离开动画\nfunction onLeave(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 在离开过渡完成、\n// 且元素已从 DOM 中移除时调用\nfunction onAfterLeave(el) {}\n\n// 仅在 v-show 过渡中可用\nfunction leaveCancelled(el) {}\n```\n\n这些钩子可以与 CSS 过渡/动画结合使用，也可以单独使用。\n\n在使用仅由 JavaScript 执行的动画时，最好是添加一个 `:css=\"false\"` prop。这显式地向 Vue 表明跳过 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡。\n\n```html\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n```\n\n在有了 `:css=\"false\"` 后，我们就全权自己负责控制什么时候过渡结束了。这种情况下对于 `@enter` 和 `@leave` 钩子来说，回调函数 `done` 就是必须的。否则，钩子将被同步调用，过渡将立即完成。',525,2),
(228,'同时使用Transition和Animation','Vue 需要附加事件侦听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。如果你仅仅使用二者其中之一，Vue 可以自动探测到正确的类型。\n\n然而在某些场景中，你或许想要在同一个元素上同时使用它们两个，举个例子，触发了一个 CSS 动画的同时，由于副作用触发了另一个 CSS 过渡。此时你需要显式地传入 `type` prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`：\n\n```html\n<Transition type=\"animation\">...</Transition>\n```\n',523,2),
(229,'自定义过渡类','你也可以向 `<Transition>` 传递以下的 props 来指定自定义的过渡类：\n\n- `enter-from-class`\n- `enter-active-class`\n- `enter-to-class`\n- `leave-from-class`\n- `leave-active-class`\n- `leave-to-class`\n\n你传入的这些类会覆盖相应阶段的默认类名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如Animate.css\n\n```html\n<!-- 假设你已经引入了 Animate.css -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n',522,2),
(230,'CSS中的Animation','原生 CSS 动画和 CSS trasition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。\n\n对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` 类下面声明它们。下面是一个示例：\n\n```html\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    你好！你会看到这里正在跳跃！\n  </p>\n</Transition>\n```\n\n```css\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n',521,2),
(231,'Transition搭配CSS','`<Transition>` 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 `transition` CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n\n下面是一个更高级的例子，使用不同的持续时间和速度曲线来过渡多个属性：\n\n```html\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n',520,3),
(232,'为过渡命名','可以通过一个 `name` prop 来声明一种过渡：\n\n```html\n<Transition name=\"fade\">\n  ...\n</Transition>\n```\n\n对于一个有名字的过渡，它的过渡相关 CSS 类会以其名字而不是 `v` 作为前缀。举个例子，上面被应用的 CSS 类将会是 `fade-enter-active` 而不是 `v-enter-active`。这个“fade”过渡的 CSS 类将会是这样：\n\n```css\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n```\n',519,2),
(233,'unplugin-vue-components','自动引入组件\n```\nnpm unplugin-vue-components -D\n```\n```js\n// vite.config.js\nimport Components from ''unplugin-vue-components/vite''\nimport { AntDesignVueResolver } from ''unplugin-vue-components/resolvers''\n  Components({\n    dts: true, // ts支持\n    dirs: [''src/components'', ''src/views''], // 自定义路径按需导入\n    resolvers: [AntDesignVueResolver()] // antd直接使用组件,无需在任何地方导入组件\n  }),\n```\n\n',251,1),
(234,'Transition组件','vue提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡:\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',517,4),
(235,'ref()','- ref接受一个内部值，返回一个ref 对象，这个对象是响应式的、可更改的，且只有一个指向其内部值的属性 .value。\n- 当引用的值发生变化时，相关的组件将自动重新渲染。\n- 当ref的值为对象类型时，会用 reactive() 自动转换它的 .value',1111,2),
(236,'reactive()','用于创建一个响应式对象。它接收一个普通对象作为参数，并返回一个响应式的代理对象。当代理对象的属性发生变化时，相关的组件将自动重新渲染。\n\n提示：不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同\n\n- reactive 是响应式数据对象\n\n* 作用是定义多个数据的响应式\n\n* 接收一个普通对象然后返回该普通对象的响应式代理器对象\n\n* 响应式转换是“深层的”：会影响对象内部所有嵌套的属性\n\n* 内部基于 ES6 的 `Proxy` 实现，通过代理对象操作源对象内部数据都是响应式的\n',1135,1),
(237,'isProxy()','检查一个对象是否是由 `reactive`、`readonly`、`shallowReactive` 或 `shallowReadonly` 创建的代理。\n\n```html\n<script>\n  import { ref, reactive, isProxy } from ''vue'';\n  export default {\n    setup() {\n      const name = ref(''test'');\n      const person = reactive({});\n      const age = 18;\n\n      console.log(isProxy(name)); // false\n      console.log(isProxy(person)); // true\n      console.log(isProxy(age)); // false\n    }\n  };\n</script>\n```\n\n',1153,1),
(238,'isReactive()','检查一个对象是否是由 `reactive` 或 shallowReactive 创建的代理。\n\n```html\n<script>\n  import { ref, reactive, isReactive } from ''vue'';\n  export default {\n    setup() {\n      const name = ref(''test'');\n      const person = reactive({});\n      console.log(isReactive(name)); // false\n      console.log(isReactive(person)); // true\n    }\n  };\n</script>\n```\n\n',1152,1),
(239,'toRefs()   ','解构响应式对象\n\n`toRef` 的批量操作，它的主要作用:\n\n- 将 `reactive` 创建的响应对象中每个属性变成单独的 `ref`。\n- 结合 `ES6` 的解构，可以使 `reactive` 对象的属性在模板中直接被使用，再也不需要通过 `xx.属性` 的形式。\n\n> 需要注意的是，若直接对 `reactive` 创建的对象解构，会失去响应式！\n\n```html\n<script>\n  import { reactive, toRef, toRefs } from ''vue'';\n  const person1 = reactive({\n    name: ''test''\n  });\n  const person2 = reactive({\n    age: 18\n  });\n\n  function update() {\n    person1.name = ''YDYDYDQ'';\n    person2.age = 20;\n  }\n\n  return {\n    ...toRefs(person1),\n    ...person2, // 直接解构, 会失去响应式\n    add\n  };\n</script>\n```\n\n',1151,1),
(240,'toRef()','toRef 是函数，转换**响应式对象**中**某个**属性为单独响应式数据，并且**值是关联的**\n\n把 `reactive` 创建的响应对象中的某个属性变成一个单独的 `ref` ，但这个新 `ref` 与原对象是保持响应式连接的。\n\n响应式变量 = toRef(响应式对象, \"属性名\")- 值是相关联的\n\n```js\nimport { reactive, toRef } from ''vue'';\nconst person = reactive({\n  name: ''test'',\n  age: 18\n});\nconst newAge = toRef(person, ''age'');\n\nfunction update() {\n  newAge.value = 20;\n}\n```\n\n',1150,1),
(241,'unref()','如果参数是`ref`，则返回内部值，否则返回参数本身。 这是 `val = isRef(val) ? val.value : val` 计算的一个语法糖。\n\n```vue\n<script>\nimport { ref, unref } from ''vue''\nexport default {\n  setup() {\n    const name = ref(''test'');\n    const age = 18;\n    console.log(unref(name)); // test\n    console.log(unref(age)); // 18\n  }\n}\n</script>\n```\n\n可以认为 name.value === unref(name)\n\n',1149,1),
(242,'isRef()','用于检查值是否为一个 ref 对象。\n\n```js\n  const num = ref(10)\n  const num1 = 20\n  const num2 = reactive({ data: 30 })\n  \n  console.log(isRef(num)) //true\n  console.log(isRef(num1)) //false\n  console.log(isRef(num2)) //false\n```\n\n',1148,1),
(243,'StringCollection','用于存储和操作字符串元素的集合\n\n```csharp\nclass test {\n\n    // Driver code\n    public static void Main()\n    {\n\n        // 创建一个名为myCol的StringCollection对象\n        StringCollection myCol = new StringCollection();\n\n        // 在指定的索引位置插入元素到字符串集合中\n        myCol.Insert(0, \"A\");\n        myCol.Insert(1, \"B\");\n        myCol.Insert(2, \"F\");\n        myCol.Insert(3, \"L\");\n        myCol.Insert(4, \"Y\");\n        myCol.Insert(5, \"Z\");\n\n        // 使用foreach循环显示StringCollection中的元素\n        foreach(Object obj in myCol)\n        {\n            Console.WriteLine(obj);\n        }\n    }\n}\n\n```\n\n',1209,1),
(244,'vue-router','vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。\n\n### 功能包括\n\n- 嵌套路由映射\n- 动态路由选择\n- 模块化、基于组件的路由配置\n- 路由参数、查询、通配符\n- 展示由 Vue.js 的过渡系统提供的过渡效果\n- 细致的导航控制\n- 自动激活 CSS 类的链接\n- HTML5 history 模式或 hash 模式\n- 可定制的滚动行为\n- URL 的正确编码\n\n```\nnpm install vue-router@4\nor\nyarn add vue-router@4\n```\n\n### 配置index\n\n```js\nimport { createRouter, createWebHistory, RouteRecordRaw, _RouteRecordBase } from ''vue-router''\nimport NProgress from ''nprogress''\n\ndeclare module ''vue-router'' {\n  interface _RouteRecordBase {\n    hidden?: boolean | string | number\n  }\n}\nconst routes: RouteRecordRaw[] = [\n  {\n\n    path: ''/'',\n    name: ''homes'',\n    meta: {\n      keepAlive: true\n    },\n    component: () => {\n      return import(''@/components/MyHome.vue'')\n    }\n  },\n  {\n    path: ''/home'',\n    name: ''home'',\n    meta: {\n      keepAlive: true\n    },\n    component: () => {\n      return import(''@/components/MyHome.vue'')\n    }\n  },\n  {\n    path: ''/article'',\n    name: ''article'',\n    component: () => {\n      return import(''@/views/page/article/Index.vue'')\n    },\n    children: [\n      // 添加子路由\n      {\n        path: ''column'',\n        name: ''column'',\n        meta: {\n          keepAlive: true\n        },\n        component: () => {\n          return import(''@/views/page/article/components/column/ArticleColumn.vue'')\n        }\n      },\n    ]\n  },\n]\n\n// createWebHashHistory createWebHistory\nconst router = createRouter({\n  history: createWebHistory(), // HTML5模式\n  routes\n})\n// 页面切换之前取消上一个路由中未完成的请求\nrouter.beforeEach((_to, _from, next) => {\n  NProgress.start()\n  next()\n})\nrouter.afterEach(() => {\n  // 进度条\n  NProgress.done()\n})\n\nexport default router\n```\n\n```tsx\n//main.ts引入\nimport router from ''./router/index''\nconst app = createApp(App)\napp.use(router)\n```\n',264,1),
(245,'404页面','\\* 代表通配符，若放在任意路由前，会被先匹配，导致跳转到 404 页面，所以需将如下配置置于最后。\n\n```js\n{\n  path: ''*'',\n  name: ''404''\n  component: () => import(''./404.vue'')  \n}\n```\n\n',291,1),
(246,'404页面','修改router/routes.ts\n\n\\* 代表通配符，若放在任意路由前，会被先匹配，导致跳转到 404 页面，所以需将如下配置置于最后。\n\n```js\nconst routes = [\n  ...//添加（放在最后）\n  {\n    path: \"/:pathMatch(.*)*\",\n    component: () => import(\"@/pages/notFound.vue\"),\n  },\n  {\n  path: ''*'',\n  name: ''404''\n  component: () => import(''./404.vue'')  \n  }\n];\n```\n\n',291,2),
(247,'路由导航流程','1. 导航被触发\n2. 在失活的组件里调用  beforeRouteLeave 守卫\n3. 调用全局 beforeEach 前置守卫\n4. 重用的组件调用 beforeRouteUpdate 守卫（2.2+）\n5. 路由配置调用 beforeEnter\n6. 解析异步路由组件\n7. 在被激活的组件里调用 beforeRouteEnter 守卫\n8. 调用全局的 beforeResolve 守卫（2.5+）\n9. 导航被确认\n10. 调用全局的 afterEach\n11. 触发 DOM 更新\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入',265,1),
(248,'history路由模式','history:用 `createWebHistory()` 创建 HTML5 模式，推荐使用这个模式不会有历史，不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHistory } from ''vue-router''\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n',267,1),
(249,'Hash路由模式','hash 历史模式是用 `createWebHashHistory()` 创建的不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHashHistory } from ''vue-router''\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n',266,1),
(250,'基础跳转','```js\nimport { useRoute, useRouter } from ''vue-router''\nconst route = useRoute() // 参数的获取  this.$route\nconst router = useRouter() // 方法使用  this.$router\nrouter.push({\n  path: num,\n  query: {\n    t: +new Date()\n  }\n})\n```\n\n',284,1),
(251,'无参跳转','```js\n// 字符串\nrouter.push(''home'')\n// 对象\nrouter.push({ path: ''home'' })\n```\n\n',285,1),
(252,'带参跳转','```js\n/**\n * 传值跳转\n * @param path 路径\n * @param value 值\n */\nconst routerId = async (path: string, value: number | string) => {\n  await router.push({\n    path: path,\n    query: {\n      id: value,\n      t: +new Date()\n    }\n  })\n}\n```\n获取跳转过来的参数\n\n```tsx\nimport { useRoute } from ''vue-router''\n const route = useRoute()\n const state = reactive({\n      id: route.query.id,\n })\n```\n',286,1),
(253,'全局前置守卫','在路由跳转前触发，可在执行 next 方法前做一些身份登录验证的逻辑。\n\n```js\nconst router = new createRouter({})\n//to: 即将要进入的目标 用一种标准化的方式\n//from: 当前导航正要离开的路由 用一种标准化的方式\nrouter.beforeEach((to, from, next) => {\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n  // 返回 false 以取消导航\n  return false\n})\n```\n\n',278,1),
(254,'路由独享守卫','可在路由配置上直接定义 beforeEnter\n\n```js\nconst routes = [\n  {\n    path: ''/users/:id'',\n    component: UserDetails,\n    beforeEnter: (to, from) => {\n      // reject the navigation\n      return false\n    },\n  },\n]\n```\n\n',281,1),
(255,'组件内的守卫','组件内可直接定义如下路由导航守卫\n\n```js\nconst Foo = {\n  template: `...`,\n  beforeRouteEnter(to, from) {\n    // 不能获取组件实例 this\n    // 当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate(to, from) {\n    // 当前路由改变，但是组件被复用时调用\n    // 可访问实例 this\n  },\n  beforeRouteLeave(to, from) {\n    // 导航离开组件时被调用\n  }\n}\n```\n\n',282,1),
(256,'router-link to=\"xxx\"','表示目标路由的链接。 被点击后，会立刻把 to 的值传到 router.push()，这个值可以是字符串或者是描述目标位置的对象。\n\n```html\n<!-- 字符串 -->\n<router-link to=\"home\">Home</router-link>\n\n<!-- 使用 v-bind 的 JS 表达式 -->\n<router-link v-bind:to=\"''home''\">Home</router-link>\n\n<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->\n<router-link :to=\"''home''\">Home</router-link>\n\n<!-- 同上 -->\n<router-link :to=\"{ path: ''home'' }\">Home</router-link>\n\n<!-- 命名的路由 -->\n<router-link :to=\"{ name: ''user'', params: { userId: 123 }}\">User</router-link>\n\n<!-- 带查询参数，下面的结果为 /register?plan=private -->\n<router-link :to=\"{ path: ''register'', query: { plan: ''private'' }}\">Register</router-link>\n```\n',268,1),
(257,'useRoute/useRouter','```html\n<script setup>\n  import { useRoute, useRouter } from ''vue-router''\n  const route = useRoute()  // 路由信息\n  console.log(route.query)\n  const router = useRouter()// 路由跳转\n  router.push(''/newPage'')\n</script>\n```\n\n',276,1),
(258,'刷新当前路由','```js\n//+new Date()保证每次点击路由的query项都是不一样的，确保会重新刷新view\nconst routers = async (path: string) => {\n  await router.push({\n    path: path,\n    query: {\n      t: +new Date()\n    }\n  })\n}\n```\n\n',287,1),
(259,'跳转新窗口','```ts\n/**\n * @description: 跳转新页面\n * @param {string} url\n * @return {*}\n */\nfunction winUrl(url: string): any {\n  window.open(url)\n}\n\nasync function resolveId(path: string, id: number) {\n  const { href } = resolve(path, id)\n  await winUrl(href)\n}\n```\n',488,1),
(260,'router.go(n)','这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。\n\n```js\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n// 前进 3 步记录\nrouter.go(3)\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n',289,1),
(261,'子路由','```html\n<a-menu-item key=\"1\" @click=\"Routers(''/Admin-index/ArticleTable'')\">\n文章列表</a-menu-item>\n<router-view></router-view>\n```\n\n路由配置\n\n```tsx\n{\n  path: ''/Admin-index'',\n  name: ''Admin-index'',\n  component: () => import(''@/views/admin/index/index.vue''),\n  children: [   // 添加子路由\n    {\n      path: ''ArticleTable'',\n      name: ''ArticleTable'',\n      component: () => import(''@/views/admin/article/ArticleTable.vue''),\n    },\n  ]\n},\n```\n\n',290,1),
(262,'路由对象/属性类型报错','引入 _RouteRecordBase 定义 hidden\n\n```js\nimport {\n    createRouter,\n    createWebHashHistory,\n    RouteRecordRaw,\n    _RouteRecordBase \n} from ''vue-router''\n\ndeclare module ''vue-router''{\n    interface _RouteRecordBase {\n        hidden?: boolean | string | number\n    }\n}\n\nconst routes: Array<RouteRecordRaw> = [\n {\n        path: ''/'',\n        redirect: ''/login'',\n    },\n    {\n        path: ''/login'',\n        name:''login'',\n       	hidden: false,\n        component: () => import(''@/views/login.vue''), // 懒加载组件\n    }\n]\n\n```\n',292,1),
(263,'全局后置钩子','和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身。它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n\n```js\nrouter.afterEach((to, from) => {\n  // ...\n})\n```\n\n',280,1),
(264,'全局解析守卫','与 beforeEach 类似，也是路由跳转前触发，区别是还需在`所有组件内守卫和异步路由组件被解析之后`，也就是在组件内 beforeRouteEnter 之后被调用。\n\n```js\nrouter.beforeResolve((to, from, next) => {\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n})\n```\n',279,1),
(265,'路由导航守卫','```html\n<script setup>\n  import { onBeforeRouteLeave, onBeforeRouteUpdate } from ''vue-router''\n\n  // 添加一个导航守卫，在当前组件将要离开时触发。\n  onBeforeRouteLeave((to, from, next) => {\n    next()\n  })\n\n  // 添加一个导航守卫，在当前组件更新时触发。\n  // 在当前路由改变，但是该组件被复用时调用。\n  onBeforeRouteUpdate((to, from, next) => {\n    next()\n  })\n</script>\n```\n\n',277,1),
(266,'全局前置守卫','在路由跳转前触发，可在执行 next 方法前做登录判断，未登陆用户跳转到登录页\n\n```js\nconst router = new createRouter({})\n//to: 即将要进入的目标 用一种标准化的方式\n//from: 当前导航正要离开的路由 用一种标准化的方式\nrouter.beforeEach((to, from, next) => {\n    if (to.path === ''/login'') {\n      //在登录页做清除操作，如清除token等\n    }\n    \n    if (!localStorage.getItem(''token'') && to.path !== ''/login'') {\n      // 未登陆且访问的不是登录页，重定向到登录页面\n      return ''/login'';\n    }\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n  // 返回 false 以取消导航\n  return false\n})\n```\n\n',278,2),
(267,'vue组件定义','使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的`.vue`文件中，这被叫做单文件组件（Single-File Component，简称 SFC）：\n组合式api:\n```vue\n<script setup>\nimport { ref } from ''vue''\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">点击了 {{ count }} 次</button>\n</template>\n```\n\n',1163,3),
(268,'命名基本约定','\n| **标识符** | **大小写** | **示例**                                 |\n| ---------- | ---------- | ---------------------------------------- |\n| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |\n| 类型       | Pascal     | public class DevsList                    |\n| 接口       | Pascal     | public interface ITableModel             |\n| 方法       | Pascal     | public void UpdateData()                 |\n| 属性       | Pascal     | Public int Length{…}                     |\n| 事件       | Pascal     | public event EventHandler Changed;       |\n| 私有字段   | Camel      | private string fieldName;                |\n| 非私有字段 | Pascal     | public string FieldName；                |\n| 枚举值     | Pascal     | FileMode{Append}                         |\n| 参数       | Camel      | public void UpdateData(string fieldName) |\n| 局部变量   | Camel      | string fieldName;                        |',30,1),
(269,'命名规范','- Pascal法：首字母大写，连接词的首字母也都大写\n  →GetInfo\n- Camel：第一个单词的首字母小写\n  →getInfo\n- MENTIONS:\n\n1. 成员变量最好加一个“_”\n2. 接口的名称前加前缀“*I*”',123,1),
(270,'代码编写规则','- 尽量使用接口\n- 局部变量尽量在最接近的地方使用\n- 不要使用goto系列语句（除非是在跳出深层循环时）\n- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型\n- switch语句要有**default**来处理意外情况',124,1),
(271,'vue组件定义','将 Vue 组件定义在一个单独的`.vue`文件中，这被叫做单文件组件（Single-File Component，简称 SFC）\n\n```vue\n<script setup>\nimport { ref } from ''vue''\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">点击了 {{ count }} 次</button>\n</template>\n```\n\n',1163,4),
(272,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,3),
(273,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,4),
(274,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,5),
(275,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,6),
(276,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,7),
(277,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,8),
(278,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,9),
(279,'FormClosed','FormClosed事件 是在 关闭窗体后发生，可以在该事件中处理保存窗口的一些信息等操作，不能取消窗口关闭。\n\n在窗口真正关闭之前，会引发 Closed，这时无法阻止窗口关闭。\n\n```csharp\nprivate void Form2_FormClosed(object sender, FormClosingEventArgs e)\n{\n  Application.Exit();\n}\n```\n\n',1217,1),
(280,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,10),
(281,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,11),
(282,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,12),
(283,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,13),
(284,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,14),
(285,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,15),
(286,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,16),
(287,'test','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,17),
(288,'test1','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,18),
(289,'test12','#### 定义函数3\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,19),
(290,'test1222','#### 定义函数322\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,20),
(291,'test1','#### 定义函数322\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,21),
(292,'test1','#### 定义函数3222\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,22),
(293,'test1','#### 定义函数3222\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,23),
(294,'test1','#### 定义函数3222\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,24),
(295,'test1','#### 定义函数3222\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,25),
(296,'test1','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,26),
(297,'test1','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,27),
(298,'test1','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,28),
(299,'test1','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,29),
(300,'test1','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,30),
(301,'test1e','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,31),
(302,'test1e','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,32),
(303,'test1e2','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,33),
(304,'test1e2','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,34),
(305,'test1e2','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,35),
(306,'test1e2','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,36),
(307,'test1e2','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,37),
(308,'test1e222e','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,38),
(309,'test1e222ee','#### 定义函数3222y\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;e\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',869,39);
/*!40000 ALTER TABLE `snippet_version` ENABLE KEYS */;

-- 
-- Definition of article
-- 

DROP TABLE IF EXISTS `article`;
CREATE TABLE IF NOT EXISTS `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题 ',
  `sketch` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容简述',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '博客内容',
  `read` smallint NOT NULL COMMENT '阅读次数',
  `give` smallint NOT NULL COMMENT '点赞',
  `img` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `comment_id` smallint NOT NULL COMMENT '评论',
  `tag_id` int NOT NULL COMMENT '标签外键',
  `type_id` int NOT NULL COMMENT '分类外键',
  `user_id` int NOT NULL COMMENT '用户外键id',
  `time_create` datetime NOT NULL COMMENT '发表时间',
  `time_modified` datetime NOT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `user_id` (`user_id`) USING BTREE,
  KEY `article_labelsId` (`tag_id`) USING BTREE,
  KEY `article_sortId` (`type_id`) USING BTREE,
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`tag_id`) REFERENCES `article_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `tyoeId` FOREIGN KEY (`type_id`) REFERENCES `article_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `userId` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=496 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table article
-- 

/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article`(`id`,`name`,`sketch`,`text`,`read`,`give`,`img`,`comment_id`,`tag_id`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(437,'c#中使用NAudio','在网上找了很多类似录音教程效果都不好，或根本不能录音，代码由网上借鉴修改（完整实现录音播放功能）','在网上找了很多类似录音教程效果都不好，或根本不能录音，代码由网上借鉴修改（完整实现录音播放功能）\n\n### NAudio\n\nNAudio为.NET平台下的开源库，采用ML-PL协议，开源地址：https://github.com/naudio/NAudio。\n\nNAudio功能强大，且其入门容易。\n强大在于：它支持许多音频操作，可实现多种API播放与录制、多种不同音频格式、音频格式转换（重采样、位深、声道等）、音频编码、多通道播放、音频效果处理等等（详细介绍可以看Github readme）。\n\n### 基本使用\n\n基本代码示例\n\n```csharp\n// 创建WaveIn实例 它将用于录制音频。你可以指定音频的采样率、通道数和位深度。\nvar waveIn = new WaveIn();\n\n// 设置录音参数\nwaveIn.WaveFormat = new WaveFormat(44100, 16, 1);\n\n// 设置录音事件处理函数\nwaveIn.DataAvailable += OnDataAvailable;\n\n// 创建WaveFileWriter实例 它将用于将录制的音频写入文件\nvar writer = new WaveFileWriter(\"output.wav\", waveIn.WaveFormat);\n\n// 开始录音\nwaveIn.StartRecording();\n\n// 停止录音\nwaveIn.StopRecording();\nwriter.Close();\n\n// 录音事件处理函数\nprivate void OnDataAvailable(object sender, WaveInEventArgs e)\n{\n    writer.Write(e.Buffer, 0, e.BytesRecorded);\n}\n```\n\n\n\n### 实例\n\n####  新建一个类\n\nRecordController.cs\n\n```js\npublic class RecordController\n{\n  public WaveIn mWavIn;\n  public WaveFileWriter mWavWriter;\n  /// <summary>\n  /// 开始录音\n  /// </summary>\n  /// <param name=\"filePath\">录音文件路径</param>\n  public void StartRecord(string filePath)\n    {\n      //录音文件路径\n      mWavIn = new WaveIn();\n      // 添加DataAvailable事件处理程序\n      mWavIn.DataAvailable += MWavIn_DataAvailable;\n      // mWavIn.RecordingStopped += MWavIn_RecordingStopped; 有冲突\n      // 创建WaveFileWriter对象\n      mWavWriter = new WaveFileWriter(filePath, mWavIn.WaveFormat);\n      // 开始录音\n      mWavIn.StartRecording();\n    }\n    /// <summary>\n    /// 停止录音\n    /// </summary>\n  public void StopRecord()\n    {\n      // 停止录音\n      mWavIn ? .StopRecording();\n      // 释放WaveIn对象\n      mWavIn ? .Dispose();\n      mWavIn = null;\n      // 关闭WaveFileWriter对象\n      mWavWriter ? .Close();\n      mWavWriter = null;\n    }\n    // 这个方法在调用关闭时会有冲突，暂时注释掉\n    //private void MWavIn_RecordingStopped(object sender, StoppedEventArgs e)\n    //{\n    //    mWavIn?.Dispose();\n    //    mWavIn = null;\n    //    mWavWriter?.Close();\n    //    mWavWriter = null;\n    //}\n    /// <summary>\n    /// DataAvailable事件处理程序\n    /// </summary>\n    /// <param name=\"sender\"></param>\n    /// <param name=\"e\"></param>\n  private void MWavIn_DataAvailable(object sender, WaveInEventArgs e)\n  {\n    // 写入录音数据\n    mWavWriter.Write(e.Buffer, 0, e.BytesRecorded);\n    // 计算已录制的秒数\n    int secondsRecorded = (int) mWavWriter.Length / mWavWriter.WaveFormat.AverageBytesPerSecond;\n  }\n}\n```\n\n在StartRecord方法中，创建了WaveIn对象和WaveFileWriter对象，分别用于录制音频数据和将音频数据写入文件。添加了DataAvailable事件处理程序，用于在录音过程中将音频数据写入文件。在StopRecord方法中，停止录音并释放WaveIn对象和WaveFileWriter对象。\n\n在MWavIn_DataAvailable方法中，将音频数据写入文件，并计算已录制的秒数。注释中说明了MWavIn_RecordingStopped方法存在冲突，暂时注释掉了该方法\n\n#### 方法调用\n\n```csharp\nRecordController record = new RecordController();\n```\n\n```js\n/// <summary>\n/// 测试\n/// </summary>\n/// <param name=\"i\"></param>\npublic void Sidetone(int i)\n{\n  // 获取ListView中的行\n  string[] row = getlistviewitem(i);\n  // 开始录音\n  record.StartRecord(\"e:\\rec.wav\");\n    \n  // 如果用户选择不播放录音，则停止录音并将错误标志设置为false\n  if(MessageBox.Show(\"正在录音，点击是播放录音\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.No)\n  {\n    record.StopRecord();\n    ErrorFlag = false;\n    row[6] = \"FAIL\";\n  }\n  else\n  {\n    // 停止录音并播放录音\n    record.StopRecord();\n    string path = \"e:\\rec.wav\";\n    //.wav音频文件路径\n    System.Media.SoundPlayer player = new System.Media.SoundPlayer(path);\n    player.Play();\n      \n    // 如果用户选择没有录音，则将错误标志设置为false\n    if(MessageBox.Show(\"是否有录音\", \"提示\", MessageBoxButtons.YesNo, MessageBoxIcon.Information) == DialogResult.No)\n    {\n      ErrorFlag = false;\n      row[6] = \"FAIL\";\n    }\n    else\n    {\n      // 如果用户选择有录音，则将错误标志设置为true，并将行的第5列设置为“OK”，第6列设置为“PASS”\n      ErrorFlag = true;\n      row[5] = \"OK\";\n      row[6] = \"PASS\";\n    }\n  }\n  // 更新ListView中的行\n  listupdate(row, i);\n}\n```\n\n`Sidetone`的函数，它接受一个整数参数`i`，用于录音并播放录音，然后根据用户的响应更新ListView控件中指定索引位置的行数据。',133,0,'20.jpg',0,3,104,4,'2023-07-18 12:26:34','2023-07-18 12:26:34'),
(438,'C#中的时间类','DateTime类是C#中最常用的时间类之一，它表示一个日期和时间。可以使用DateTime.Now属性获取当前时间，也可以使用DateTime.Parse方法将字符串转换为DateTime对象。','### DateTime类\n\nDateTime类是C#中最常用的时间类之一，它表示一个日期和时间。可以使用DateTime.Now属性获取当前时间，也可以使用DateTime.Parse方法将字符串转换为DateTime对象。\n\n```csharp\n// 获取当前时间\nDateTime now = DateTime.Now;\n// 将字符串转换为DateTime对象\nDateTime dateTime = DateTime.Parse(\"2022-01-01 12:00:00\");\n// 获取当前时间的年份\nint year = now.Year;\n// 获取当前时间的月份\nint month = now.Month;\n// 获取当前时间的日期\nint day = now.Day;\n// 获取当前时间的小时数\nint hour = now.Hour;\n// 获取当前时间的分钟数\nint minute = now.Minute;\n// 获取当前时间的秒数\nint second = now.Second;\n// 获取当前时间的毫秒数\nint millisecond = now.Millisecond;\n```\n\nDateTime类还提供了一些常用的方法和属性，例如：\n\n- DateTime.AddDays(double value)：将当前DateTime对象的日期加上指定的天数。\n- DateTime.AddHours(double value)：将当前DateTime对象的时间加上指定的小时数。\n- DateTime.AddMinutes(double value)：将当前DateTime对象的时间加上指定的分钟数。\n- DateTime.AddSeconds(double value)：将当前DateTime对象的时间加上指定的秒数。\n- DateTime.Year：获取当前DateTime对象的年份。\n- DateTime.Month：获取当前DateTime对象的月份。\n- DateTime.Day：获取当前DateTime对象的日期。\n- DateTime.Hour：获取当前DateTime对象的小时数。\n- DateTime.Minute：获取当前DateTime对象的分钟数。\n- DateTime.Second：获取当前DateTime对象的秒数。\n\n### TimeSpan类\n\nTimeSpan类表示时间间隔，可以用来计算两个日期之间的时间差。可以使用TimeSpan.FromDays、TimeSpan.FromHours、TimeSpan.FromMinutes、TimeSpan.FromSeconds等方法创建TimeSpan对象。\n\n```csharp\n// 创建一个表示1天的TimeSpan对象\nTimeSpan oneDay = TimeSpan.FromDays(1);\n\n// 创建一个表示2小时的TimeSpan对象\nTimeSpan twoHours = TimeSpan.FromHours(2);\n\n// 创建一个表示30分钟的TimeSpan对象\nTimeSpan thirtyMinutes = TimeSpan.FromMinutes(30);\n\n// 创建一个表示10秒的TimeSpan对象\nTimeSpan tenSeconds = TimeSpan.FromSeconds(10);\n```\n\nTimeSpan类还提供了一些常用的方法和属性，例如：\n\n- TimeSpan.TotalDays：获取TimeSpan对象表示的总天数。\n- TimeSpan.TotalHours：获取TimeSpan对象表示的总小时数。\n- TimeSpan.TotalMinutes：获取TimeSpan对象表示的总分钟数。\n- TimeSpan.TotalSeconds：获取TimeSpan对象表示的总秒数。\n\n### DateTimeOffset类\n\nDateTimeOffset类表示一个日期和时间，同时包含时区信息。可以使用DateTimeOffset.Now属性获取当前时间，也可以使用DateTimeOffset.Parse方法将字符串转换为DateTimeOffset对象。\n\n```csharp\n// 获取当前时间\nDateTimeOffset now = DateTimeOffset.Now\n\n// 将字符串转换为DateTimeOffset对象\nDateTimeOffset dateTimeOffset = DateTimeOffset.Parse(\"2022-01-01 12:00:00 +08:00\");\n```\n\nDateTimeOffset类还提供了一些常用的方法和属性，例如：\n\n- DateTimeOffset.ToLocalTime()：将当前DateTimeOffset对象转换为本地时间。\n- DateTimeOffset.ToUniversalTime()：将当前DateTimeOffset对象转换为协调世界时（UTC）时间。\n\n### 静态类的封装\n\n```c#\nusing System;\nnamespace ToolBox.DateTimeTool\n{\n    public static class DateTimeExtend\n    {\n        /// <summary>\n        /// 获取本日开始时间（0点0分0秒）\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetDayStart(this DateTime dateTime)\n        {\n            return dateTime.Date;\n        }\n\n        /// <summary>\n        /// 获取本日结束时间（23点59分59秒）\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetDayEnd(this DateTime dateTime)\n        {\n            return dateTime.Date.AddDays(1).AddMilliseconds(-1);\n        }\n\n        /// <summary>\n        /// 获取本周开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetWeekStart(this DateTime dateTime)\n        {\n            return dateTime.AddDays(-(int)dateTime.DayOfWeek + 1).GetDayStart();\n        }\n\n        /// <summary>\n        /// 获取本周结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetWeekEnd(this DateTime dateTime)\n        {\n            return dateTime.AddDays(7 - (int)dateTime.DayOfWeek).GetDayEnd();\n        }\n\n        /// <summary>\n        /// 获取本月开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetMonthStart(this DateTime dateTime)\n        {\n            return new DateTime(dateTime.Year, dateTime.Month, 1, 0, 0, 0, 0);\n        }\n\n        /// <summary>\n        /// 获取本月结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetMonthEnd(this DateTime dateTime)\n        {\n            return GetMonthStart(dateTime).AddMonths(1).AddMilliseconds(-1);\n        }\n\n        /// <summary>\n        /// 获取本季度开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetSeasonStart(this DateTime dateTime)\n        {\n            var time = dateTime.AddMonths(0 - ((dateTime.Month - 1) % 3));\n            return DateTime.Parse(time.AddDays(-time.Day + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n        }\n\n        /// <summary>\n        /// 获取本季度结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetSeasonEnd(this DateTime dateTime)\n        {\n            var time = dateTime.AddMonths((3 - ((dateTime.Month - 1) % 3) - 1));\n            return DateTime.Parse(time.AddMonths(1).AddDays(-time.AddMonths(1).Day + 1).AddDays(-1).ToString(\"yyyy/MM/dd 23:59:59\"));\n        }\n\n        /// <summary>\n        /// 获取本年开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetYearStart(this DateTime dateTime)\n        {\n            return DateTime.Parse(dateTime.AddDays(-dateTime.DayOfYear + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n        }\n\n        /// <summary>\n        /// 获取本年结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetYearEnd(this DateTime dateTime)\n        {\n            var time2 = dateTime.AddYears(1);\n            return DateTime.Parse(time2.AddDays(-time2.DayOfYear).ToString(\"yyyy/MM/dd 23:59:59\"));\n        }\n\n        /// <summary>\n        /// 北京时间转换成unix时间戳(10位/秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long BeijingTimeToUnixTimeStamp10(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalSeconds;\n        }\n\n        /// <summary>\n        /// 格林威治时间转换成unix时间戳(10位/秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long UtcTimeToUnixTimeStamp10(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;\n        }\n\n        /// <summary>\n        /// 北京时间转换成unix时间戳(13位/毫秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long BeijingTimeToUnixTimeStamp13(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalMilliseconds;\n        }\n\n        /// <summary>\n        /// 格林威治时间转换成unix时间戳(13位/毫秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long UtcTimeToUnixTimeStamp13(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 0, 0, 0)).TotalMilliseconds;\n        }\n\n        /// <summary>\n        /// 10位unix时间戳转换成北京时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp10ToBeijingTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 8, 0, 0).AddSeconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 10位unix时间戳转换成格林威治\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp10ToUtcTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 0, 0, 0).AddSeconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 13位unix时间戳转换成北京时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp13ToBeijingTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 8, 0, 0).AddMilliseconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 13位unix时间戳转换成格林威治\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp13ToUtcTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 0, 0, 0).AddMilliseconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 当前日期所在月份第一个指定星期几的日期\n        /// </summary>\n        /// <param name=\"date\">给定日期</param>\n        /// <param name=\"dayOfWeek\">星期几</param>\n        /// <returns>所对应的日期</returns>\n        public static DateTime GetFirstWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n        {\n            var dt = date.GetMonthStart();\n            while (dt.DayOfWeek != dayOfWeek)\n                dt = dt.AddDays(1);\n\n            return dt;\n        }\n\n        /// <summary>\n        /// 当前日期所在月份最后1个指定星期几的日期\n        /// </summary>\n        /// <param name=\"date\">给定日期</param>\n        /// <param name=\"dayOfWeek\">星期几</param>\n        /// <returns>所对应的日期</returns>\n        public static DateTime GetLastWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n        {\n            var dt = date.GetMonthEnd();\n            while (dt.DayOfWeek != dayOfWeek)\n                dt = dt.AddDays(-1);\n\n            return dt;\n        }\n\n        /// <summary>\n        /// 判断是否比指定之间早\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <param name=\"other\"></param>\n        /// <returns></returns>\n        public static bool IsBefore(this DateTime date, DateTime other)\n        {\n            return date < other;\n        }\n\n        /// <summary>\n        /// 判断是否比指定时间晚\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <param name=\"other\"></param>\n        /// <returns></returns>\n        public static bool IsAfter(this DateTime date, DateTime other)\n        {\n            return date > other;\n        }\n\n        /// <summary>\n        /// 给定日期所在月份共有多少天\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static int GetCountDaysOfMonth(this DateTime date)\n        {\n            return date.GetMonthEnd().Day;\n        }\n\n        /// <summary>\n        /// 当前日期与给定日期是否是同一天\n        /// </summary>\n        /// <param name=\"date\">当前日期</param>\n        /// <param name=\"dateToCompare\">给定日期</param>\n        /// <returns></returns>\n        public static bool IsDateEqual(this DateTime date, DateTime dateToCompare)\n        {\n            return date.Date == dateToCompare.Date;\n        }\n\n        /// <summary>\n        /// 是否是周未\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsWeekend(this DateTime date)\n        {\n            return date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday;\n        }\n\n        /// <summary>\n        /// 是否是工作日\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsWeekDay(this DateTime date)\n        {\n            return !date.IsWeekend();\n        }\n\n        /// <summary>\n        /// 判断是否为今天\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsToday(this DateTime date)\n        {\n            return date.Date == DateTime.Now.Date;\n        }\n\n        /// <summary>\n        /// 判定公历闰年遵循的一般规律为：四年一闰，百年不闰，四百年再闰。\n        /// 公历闰年的精确计算方法：（按一回归年365天5小时48分45.5秒）\n        /// 普通年能被4整除而不能被100整除的为闰年。 （如2004年就是闰年，1900年不是闰年）\n        /// 世纪年能被400整除而不能被3200整除的为闰年。 (如2000年是闰年，3200年不是闰年)\n        /// 对于数值很大的年份能整除3200,但同时又能整除172800则又是闰年。(如172800年是闰年，86400年不是闰年）\n        /// 公元前闰年规则如下：\n        /// 非整百年：年数除4余数为1是闰年，即公元前1、5、9……年；\n        /// 整百年：年数除400余数为1是闰年，年数除3200余数为1，不是闰年,年数除172800余1又为闰年，即公元前401、801……年。\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static bool IsLeap(this DateTime dateTime)\n        {\n            var year = dateTime.Year;\n            if ((year % 400 == 0 && year % 3200 != 0)\n               || (year % 4 == 0 && year % 100 != 0)\n               || (year % 3200 == 0 && year % 172800 == 0))\n                return true;\n            else\n                return false;\n        }\n\n        /// <summary>\n        /// 获取当前年天数\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static int GetDaysByYear(this DateTime dateTime)\n        {\n            return (new DateTime(dateTime.Year + 1, 1, 1) - new DateTime(dateTime.Year, 1, 1)).Days;\n        }\n\n        /// <summary>\n        /// 获取当前年天数\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static int GetWeekCountByYear(this DateTime dateTime)\n        {\n            //找到今年的第一天是周几\n            int firstWeekend = Convert.ToInt32(DateTime.Parse(dateTime.Year + \"-1-1\").DayOfWeek);\n\n            //获取第一周的差额,如果是周日，则firstWeekend为0，第一周也就是从周天开始的。\n            int weekDay = firstWeekend == 0 ? 1 : (7 - firstWeekend + 1);\n\n            //获取今天是一年当中的第几天\n            int currentDay = dateTime.DayOfYear;\n\n            //（今天 减去 第一周周末）/7 等于 距第一周有多少周 再加上第一周的1 就是今天是今年的第几周了\n            //    刚好考虑了惟一的特殊情况就是，今天刚好在第一周内，那么距第一周就是0 再加上第一周的1 最后还是1\n            int current_week = Convert.ToInt32(Math.Ceiling((currentDay - weekDay) / 7.0)) + 1;\n            return current_week;\n        }\n\n    }\n}\n```\n\n',59,0,'11.jpg',0,3,104,4,'2023-07-18 13:46:29','2023-07-18 13:46:29'),
(439,'c#中的扩展方法','扩展方法它可以让我们在不修改原始类的情况下，为其添加新的方法。','### 扩展声明\n\n扩展方法它可以让我们在不修改原始类的情况下，为其添加新的方法。\n\n并不是任何方法都能作为扩展方法使用 , 必须具有以下特征：\n它必须在一个非嵌套的、非泛型的静态类中（所以必须是一个静态方法）\n\n至少要有一个参数；\n\n- 第一个参数必须是要扩展的类型，使用this关键字进行标记\n- 第一个参数不能有其他任何修饰符（比如out或ref）；\n- 第一个参数的类型不能是指针类型。  \n\n### 注意事项\n\n注意的地方：\n\n1. 扩展方法不能和调用的方法放到同一个类中\n2. 第一个参数必须要，并且必须是this，这是扩展方法的标识，可以在后面追加参数。\n3. 最好保证扩展方法和调用方法在同一个命名空间下\n\n### 实例1\n\n给string 类型增加一个Add方法，该方法的作用是给字符串增加一个字母a\n\n```c#\n       //必须是静态类才可以添加扩展方法\n       Static class Program\n       {\n        static void Main(string[] args)\n        {\n            string str = \"quzijing\";\n            //注意调用扩展方法,必须用对象来调用 \n            string Newstr = str.Add();\n            Console.WriteLine(Newstr);\n            Console.ReadKey();\n        }\n        //声明扩展方法\n        //扩展方法必须是静态的，Add有三个参数\n        //this 必须有，string表示我要扩展的类型，stringName表示对象名\n        //三个参数this和扩展的类型必不可少，对象名可以自己随意取如果需要传递参数，//再增加一个变量即可\n\n        public static  string  Add(this string stringName)\n        {\n            return stringName+\"a\";\n        }\n}\n```\n\n\n\n### 实例2\n\n使用对象的扩展方法\n\n```c#\n public class Person\n {\n   public string Name\n   {\n     set;\n     get;\n   }\n   public int Age\n   {\n     set;\n     get;\n   }\n }\n```\n\n```c#\n//必须是静态类才可以添加扩展方法\n//Person的扩展方法，根据年龄判断是否是成年人\npublic static bool GetBIsChild(this Person oPerson)\n{\n  if(oPerson.Age >= 18) return false;\n  else return true;\n}\n```\n\nMain方法里面调用：\n\n```c#\nvar oPerson1 = new Person();\noPerson1.Age = 20;\nvar bIsChild = oPerson1.GetBIsChild();        \n```\n\n### 实例3\n\n泛型对象的扩展\n\n```c#\npublic static class DataContractExtensions\n{\n  //必须是静态类才可以添加扩展方法\n  //测试方法\n  public static T Test < T > (this T instance) where T: Test2\n  {\n    T Res =\n      default(T);\n    try\n    {\n      Res.AttrTest = instance.AttrTest.Substring(0, 2);\n      //其他复杂逻辑...\n    }\n    catch\n    {}\n    return Res;\n  }\n}\npublic class Test2\n{　　\n  public string AttrTest\n  {\n    set;\n    get;\n  }\n}\n```\n\n### 实例4\n\n集合扩展方法\n\n```c#\n public static void ShowItems < T > (this IEnumerable < T > _al)\n {\n   foreach(var item in _al)\n   {\n     Console.WriteLine(item);\n   }\n }\n```\n\n```c#\n static void Main(string[] args)\n {\n   //调用集合的扩展方法\n   str.ShowItems < char > ();\n }\n```\n\n',20,0,'13.jpg',0,51,104,4,'2023-07-18 13:53:04','2023-07-18 13:53:04'),
(440,'winfrom界面库(CSkin) ','使用步骤\n\n1.工具箱右键-新建项-命名CSkin。\n\n2.将CSkin.dll拖到新建的工具箱栏里。','下载地址:[CSkin](http://www.cskin.net/)\n\n博客地址:[kin](http://bbs.cskin.net/)\n\n### 使用步骤\n\n1.工具箱右键-新建项-命名CSkin。\n\n2.将CSkin.dll拖到新建的工具箱栏里。\n\n3.控件添加完毕，控件拖拽到界面即可使用和引用。\n\n4.窗体美化需要继承CCSkinMain。\n\n###  主题美化\n\n```c#\n public partial class FrmMain : Form\n```\n\n 改成：\n\n```c#\n public partial class FrmMain : CCSkinMain\n```\n\n**窗体还可以继承以下等多种主题：**\n\n```csharp\nSkin_Color，\nSkin_DevExpress，\nSkin_Mac， Skin_Metro，\nSkin_VS\n```\n\n### 控件导入\n\n1. 在工具箱的里面鼠标右键单击新建的选项卡，点击选择项。\n2. 直接点击浏览，选中要添加的CSkin.dll，最新版是18年的。\n   注意：工具箱CSkin.dll版本要和项目引用的dll版本相同，否则会冲突。项目引用也需要引用CSkin，不然会报错。\n3. 找到下载好的CSkin.dll，选中确定。\n4. 查看是否加载控件完毕，继续确定或直接回车Enter。\n5. 到这里CSkin的控件就成功加入到工具箱了，看看是否有类似Skin开头的控件，可拖控件使用即可。\n\n\n\n',26,0,'12.jpg',0,3,104,4,'2023-07-18 14:02:49','2023-07-18 14:02:49'),
(441,'vite+vue3+ts搭建','基础搭建教程，仅供参考','### 安装\n\n```\nnpm init @vitejs/app`\nor\nyarn create @vitejs/app\n```\n\n选择vue- vue-ts\n\n安装依赖\n\n```\nnpm install\n```\n\n启动项目\n\n```\nnpm run dev\n```\n\n### 修改Vite配置\n\n```tsx\nimport { defineConfig } from ''vite''\nimport vue from ''@vitejs/plugin-vue''\nimport { resolve } from ''path''\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      ''@'': resolve(''./src'')\n    }\n  },\n  base: ''./'', // 打包路径\n  server: {\n    port: 4000, // 服务端口号\n    open: true, // 服务启动时是否自动打开浏览器\n    cors: true // 允许跨域\n  }\n})\n\n```\n\n### 配置文件\n\n如果使用 TS ，则需要先安装类型声明文件。\n\n```\nnpm install --save-dev @types/node\n```\n\n```tsx\n/// <reference types=\"vite/client\" />\ndeclare module ''*.vue'' {\n  import { DefineComponent } from ''vue''\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/ban-types\n  const component: DefineComponent<{}, {}, any>\n  export default component\n}\n// declare module ''axios'';\n```\n\n### 集成router\n\n```\nnpm i vue-router@4\n```\n\n创建 `src/router/index.ts` 文件\n\n```tsx\nimport { createRouter, createWebHashHistory, RouteRecordRaw } from ''vue-router''\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: ''/home'',\n    name: ''Home'',\n    component: () => import(/* webpackChunkName: \"Home\" */ ''../views/Home/Home.vue'')\n  },\n  { path: ''/'', redirect: { name: ''Home'' } }\n]\n\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes\n})\n\nexport default router\n```\n\nmain.ts 文件中挂载\n\n```ts\nimport { createApp } from ''vue''\nimport App from ''@/App.vue''\n\nimport router from ''@/router/index''\ncreateApp(App).use(router).mount(''#app'')\n```\n\n### 集成Vuex\n\n1. `npm i vuex@next`\n2. 创建 `src/store/index.ts` 文件\n\n```tsx\nimport {\n  createStore\n} from ''vuex''\n\nexport default createStore({\n  state: {\n    token: \"test\",\n    //设置页面是否新窗口打开\n    SetPage: false\n  },\n  mutations: {\n  },\n  actions: {},\n  modules: {}\n})\n```\n\nmain.ts 文件挂载\n\n```tsx\nimport { createApp } from ''vue''\nimport App from ''@/App.vue''\n\nimport router from ''@/router/index''\nimport store from ''@/store/index''\ncreateApp(App).use(router).use(store).mount(''#app'')\n```\n\n### 集成 Axios\n\n1. `npm i axios`\n2. 配置 `Axios`\n\n```ts\nimport axios from ''axios''\nimport qs from \"qs\";\nimport store from \"../store/index\";\nimport router from ''../router'';\n//''http://129.204.92.64:8081/'' 腾讯服务器\n// axios.defaults.baseURL = ''https://localhost:44367/'',\naxios.defaults.baseURL = process.env.VUE_APP_API_URL,\n  axios.defaults.timeout = 12000;\n// axios.defaults.headers.common[''token''] =  AUTH_TOKEN\naxios.defaults.headers.post[''Content-Type''] = ''application/json;charset=UTF-8'';\naxios.defaults.headers.post[\"Access-Control-Allow-Origin-Type\"] = \"*\"; // 允许跨域\n\naxios.interceptors.request.use(function (config: any) {\n  // 在发送请求之前做某件事\n  if (\n    config.method === \"post\" ||\n    config.method === \"put\" ||\n    config.method === \"delete\"\n  ) {\n    // 序列化\n    config.data = qs.parse(config.data);\n    // console.log(\"qs:\" + config.data);\n  }\n  // 若是有做鉴权token , 就给头部带上token\n  if (store.state.token) {\n    config.headers.Authorization = store.state.token;\n    // console.log(\"token:\" + store.state.token);\n  }\n  return config;\n}, (error: { data: { error: { message: any; }; }; }) => {\n  // Message({\n  //   //  饿了么的消息弹窗组件,类似toast\n  //   showClose: true,\n  //   message: error,\n  //   type: \"error.data.error.message\"\n  // });\n  return Promise.reject(error.data.error.message);\n})\n\naxios.interceptors.response.use(function (config: any) {\n  if (config.status === 200 || config.status === 204) {\n    return Promise.resolve(config);\n  } else {\n    return Promise.reject(config);\n  }\n  // return config;\n},\n  function (error: { response: { status: any; }; }) {\n    // return Promise.reject(error)\n    if (error.response.status) {\n      switch (error.response.status) {\n        // 401: 未登录\n        // 未登录则跳转登录页面，并携带当前页面的路径\n        // 在登录成功后返回当前页面，这一步需要在登录页操作。                \n        case 401:\n          router.replace({\n            path: ''/login'',\n            query: {\n              // redirect: router.currentRoute.fullPath\n            }\n          });\n          break;\n        // 403 token过期              \n        case 403:\n          // 清除token\n          store.dispatch(''FedLogOut'').then(() => {\n            // 跳转登录页面，并将要浏览的页面fullPath传过去，登录成功后跳转需要访问的页面 \n            router.replace({\n              path: ''/login'',\n              query: {\n                // redirect: router.currentRoute.fullPath\n              }\n            })\n          })\n          break;\n        // 404请求不存在\n        case 404:\n          break;\n        // 其他错误，直接抛出错误提示\n        default:\n      }\n      return Promise.reject(error.response);\n    } else {\n      // 处理断网的情况\n      // eg:请求超时或断网时，更新state的network状态\n      // network状态在app.vue中控制着一个全局的断网提示组件的显示隐藏\n      // 关于断网组件中的刷新重新获取数据，会在断网组件中说明\n      store.commit(''changeNetwork'', false);\n    }\n  }\n)\nexport default axios\n```\n\n**挂载**\n\n```tsx\nimport axios from ''./api/axios''\n// 全局ctx(this) 上挂载 $axios\napp.config.globalProperties.$api = axios\n```\n\n### 集成CSS预编译器\n\n```\nnpm i sass -D\n```\n\n### 环境变量配置\n\n#### .env.development\n\n```javascript\n// .env.development\n//测试环境地址\nNODE_ENV = development\nVITE_API_DOMAIN = ''https://localhost:5001/''\n```\n\n#### .env.production\n\n```javascript\nNODE_ENV = production\nVITE_API_DOMAIN = ''http://8081/''//正式环境地址\n```\n\n#### 在页面中使用\n\n```typescript\nconsole.log(import.meta.env.VITE_APP_WEB_URL)\n```\n\n#### 在 `package.json `中使用\n\n```json\n\"scripts\":{\n  \"build:dev\": \"vite build --mode development\",\n  \"build:pro\": \"vite build --mode production\"\n}\n```\n\n#### env.d.ts\n\n```ts\ninterface ImportMetaEnv {\n  VITE_API_DOMAIN: string,\n}\n```\n\n###  Tailwind CSS\n\n```\nnpm install -D tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9\n```\n\n创建配置文件\n\n```\nnpx tailwindcss init -p\n```\n\n```js\nmodule.exports = {\n  // purge: [''./src/**/*.{vue,js,ts,jsx,tsx}''], //删除未使用的CSS\n  purge: {\n    enabled: true,\n    content: [''./src/**/*.{vue,js,ts,jsx,tsx}''],\n  },\n  darkMode: false, // or ''media'' or ''class''\n  theme: {\n    screens: {\n\n      ''cx'': {\n        ''max'': ''575px''\n      },\n      ''xp'': {\n        ''min'': ''375px'',\n        ''max'': ''667px''\n      },\n    },\n    extend: {},\n  },\n  variants: {\n    extend: {},\n  },\n  // add DaisyUI plugin\n  plugins: [\n    require(''daisyui''),\n  ],\n\n  // config (optional)\n  daisyui: {\n    styled: true,\n    themes: false,\n    base: false,\n    utils: true,\n    logs: true,\n    rtl: false,\n  },\n}\n```\n\n```js\n// postcss.config.js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n}\n```\n\nVite 默认为您生成的 ./src/index.css 文件 \n\n```css\n/* ./src/index.css */\n\n/*! @import */\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n\n```js\n// src/main.js\nimport ''./index.css''\n```\n\n### 整合代码规范插件eslint,prettier\n\n#### 安装依赖\n\n```js\nyarn add babel-eslint -D\nyarn add @vue/eslint-config-prettier -D\nyarn add eslint -D\nyarn add eslint-plugin-prettier -D\nyarn add eslint-plugin-vue -D\nyarn add prettier -D\n复制代码\n```\n\n#### 根目录建 `.eslintrc.js`\n\n```js\n//.eslintrc.js\nmodule.exports = {\n  root: true,\n  env: {\n    node: true,\n  },\n  extends: [''plugin:vue/vue3-essential'', ''eslint:recommended''],\n  parserOptions: {\n    parser: ''babel-eslint'',\n  },\n  rules: {\n    //在此处写规则\n    ''no-unused-vars'': 0, // 定义未使用的变量\n  },\n};\n复制代码\n```\n\n####  根目录建 `.prettierrc.json`\n\n```js\n//.prettierrc.json\n{\n  //此处填写规则\n  \"singleQuote\": true,//单引号\n  \"seme\": true,//分号\n  \"tabWidth\": 2,//缩进\n  \"TrailingCooma\": \"all\",//尾部元素有逗号\n  \"bracketSpacing\": true,//对象中的空格\n}\n复制代码\n```\n\n#### `vscode` 自动格式化\n\n```js\n //settings.json\n\"editor.formatOnSave\": true,//保存时格式化\n\"files.autoSave\": \"onFocusChange\", //失去焦点时保存\n\"editor.codeActionsOnSave\": {\n  \"source.fixAll.eslint\": true\n},\n\"eslint.validate\": [\n  \"javascript\",\n  \"javascriptreact\",\n  \"typescript\"\n],  \n```\n\n### 配置GZIP压缩\n\n安装依赖\n\n```js\nyarn add vite-plugin-compression -D\n```\n\n修改 `vite.config.js`\n\n```js\n//vite.config.js\n\nimport viteCompression from ''vite-plugin-compression''\nplugins:[\n  ...\n  viteCompression({\n      verbose: true,\n      disable: false,\n      threshold: 10240,\n      algorithm: ''gzip'',\n      ext: ''.gz''\n  })\n]\n```\n\n### webpack代理配置\n\n配置 `vite.config.ts` 文件\n\n```typescript\nserver: {\n    host: ''0.0.0.0'',\n    port: 3000,\n    open: true,\n    https: false,\n    proxy: {}\n},\n```\n\n### 生产环境移除console\n\n配置 `vite.config.ts` 文件\n\n```typescript\nbuild:{\n  ...\n  terserOptions: {\n      compress: {\n        drop_console: true,\n        drop_debugger: true\n      }\n  }\n}\n```',22,0,'17.jpg',0,4,1,4,'2023-07-18 15:55:51','2023-07-18 15:55:51'),
(442,'vue2封装js','基础教程，仅供参考','\n\n### 新建index.js\n\n```js\nimport Vue from \"vue\";\n    /**\n     * 回到顶部功能实现过程：\n     * 1. 获取页面当前距离顶部的滚动距离（虽然IE不常用了，但还是需要考虑一下兼容性的）\n     * 2. 计算出每次向上移动的距离，用负的滚动距离除以5，因为滚动的距离是一个正数，想向上移动就是做一个减法\n     * 3. 用当前距离加上计算出的距离，然后赋值给当前距离，就可以达到向上移动的效果\n     * 4. 最后记得在移动到顶部时，清除定时器\n     */\n   const backtops= {\n        backtop: function () {\n\n            {\n                var timer = setInterval(function () {\n                    let osTop = document.documentElement.scrollTop || document.body.scrollTop;\n                    let ispeed = Math.floor(-osTop / 5);\n                    document.documentElement.scrollTop = document.body.scrollTop = osTop + ispeed;\n                    this.isTop = true;\n                    if (osTop === 0) {\n                        clearInterval(timer);\n                    }\n                }, 30)\n\n            }\n        }\n    }\nVue.prototype.backtops = backtops;\n\nexport default {};\n```\n\n### main导入js\n\n```js\nimport ''./components/common/backtop/index''\n```\n\n### 调用\n\n```\n this.backtops.backtop(); \n```\n\n',17,0,'8.jpg',0,51,1,4,'2023-07-18 17:05:47','2023-07-18 17:05:47'),
(443,' vue3实现登录和token验证','1. 登录成功返回 token\n2.  拿到token，将token存储到localStorage或store中，并跳转路由页面\n3.  跳转路由，就判断 localStroage 中有无 token','参考：[https://www.cnblogs.com/web-record/p/9876916.html]:\n\n### 登录过程\n\n1. 登录成功返回 token\n2.  拿到token，将token存储到localStorage或store中，并跳转路由页面\n3.  跳转路由，就判断 localStroage 中有无 token\n4.  调后端接口，都要在请求头中加token\n5. 前端拿到状态码为401，就清除token信息并跳转到登录页面\n\n### localStroage封装\n\n```js\n/**\n * 封装操作localstorage本地存储的方法\n */\nexport const storage = {\n  // 存储\n  set(key: string, value: any) {\n    localStorage.setItem(key, JSON.stringify(value))\n  },\n  // 取出数据\n  get<T>(key: string) {\n    const value = localStorage.getItem(key)\n    if (value && value !== ''undefined'' && value !== ''null'') {\n      return <T>JSON.parse(value)\n    }\n    return key\n  },\n  // 删除数据\n  remove(key: string) {\n    localStorage.removeItem(key)\n  }\n}\n\n/**\n * 封装操作sessionStorage本地存储的方法\n */\nexport const sessionStorage = {\n  /**\n   * 存储\n   * @param key\n   * @param value\n   */\n  set(key: string, value: any) {\n    window.sessionStorage.setItem(key, JSON.stringify(value))\n  },\n  /**\n   * 取出数据\n   * @param key\n   */\n  get(key: string) {\n    const value = window.sessionStorage.getItem(key)\n    if (value && value !== ''undefined'' && value !== ''null'') {\n      return JSON.parse(value)\n    }\n    return null\n  },\n  // 删除数据\n  remove(key: string) {\n    window.sessionStorage.removeItem(key)\n  }\n}\n```\n\n### 进行登录赋值\n\n#### 用户信息\n\n配置用户默认标识和清除用户信息\n\n```js\n//userInfo.ts\nimport { storage } from ''@/utils/storage/storage''\n\n/**\n * 用户信息\n */\nexport enum userInfo {\n  ROLE = ''role'',\n  TOKEN = ''token'',\n  ID = ''id'',\n  NAME = ''name''\n}\n/**\n * 清除用户storage信息\n */\nexport const removeUserStorage = () => {\n  storage.remove(userInfo.ROLE)\n  storage.remove(userInfo.ID)\n  storage.remove(userInfo.NAME)\n  storage.remove(userInfo.TOKEN)\n}\n```\n\n#### 登录页面\n\n```js\nimport { storage } from ''@/utils/storage/storage''\n\nconst state = reactive({\n  name: '''',\n  pwd: ''''\n})\nfunction login() {\n  UserApi.login(state.name, state.pwd).then(res => {\n    const ret = res.data\n    removeUserStorage() //清除登录信息\n    storage.set(userInfo.ROLE, ret.nickname) // 角色名\n    storage.set(userInfo.TOKEN, `Bearer ${ret.token}`) // token\n    storage.set(userInfo.ID, ret.id) // 用户主键\n    storage.set(userInfo.NAME, ret.name) // 用户名\n    message.success(''登录成功'')\n    routers(rRouter.articleTable) //进行跳转\n  })\n}\n```\n\n### axios加token\n\n```js\n// 请求拦截器 \nservice.interceptors.request.use(\n    (config: AxiosRequestConfig) => {\n      const { method, data, headers } = config\n      removePending(config)\n      cancel.cancel_request && addPending(config)\n\n      if ([''post'', ''put'', ''delete''].includes(method as string)) {\n        config.data = qs.parse(data) //序列化\n      }\n      // 若是有做鉴权token , 就给此处头部带上token \n      if (storage.get(''token'')) {\n        if (headers) {\n          headers.Authorization = storage.get(''token'') as string\n        }\n      }\n      return config\n    },\n    error => {\n      return Promise.reject(error.data.error.message)\n    }\n  )\n```\n\n',44,0,'18.jpg',0,4,1,4,'2023-07-18 17:27:08','2023-07-18 17:27:08'),
(444,'vue2使用vuex','vuex 是一个专门为vue.js应用程序开发的状态管理模式。','vuex 是一个专门为vue.js应用程序开发的状态管理模式。\n\nvuex中，有默认的五种基本的对象：\n\n- **state**：存储状态（变量）\n- **getters**：对数据获取之前的再次编译，可以理解为state的计算属性。我们在组件中使用 $sotre.getters.fun()\n- **mutations**：修改状态，并且是同步的。在组件中使用$store.commit('''',params)。这个和我们组件中的自定义事件类似。\n- **actions**：异步操作。在组件中使用是$store.dispath('''')\n- **modules**：store的子模块，为了开发大型项目，方便状态管理而使用的。这里我们就不解释了，用起来和上面的一样。\n\n### 安装vuex\n\n```\nnpm install vuex --save\n```\n\n### store.js\n\n新建store/store.js文件，引入vuex\n\n```js\nimport Vue from ''vue''\nimport Vuex from ''vuex''\nVue.use(Vuex)\nconst state = {\n  count: 1\n}\nconst mutations = {\n  increment (state) {\n    state.count++\n  }\n}\nexport default new Vuex.Store({\n  state,\n  mutations\n})\n```\n\n引入store\n\n```js\n//main.js\nimport store from ''./store/store''\nnew Vue({\n  el: ''#app'',\n  router,\n  store,\n  components: { App },\n  template: ''<App/>''\n})\n```\n\n页面调用count状态\n\n```js\n{{ $store.state.count }}\n```\n\n用mutations和actions 继续操作store状态\n\n```js\n<button @click=\"add()\">add</button>\nmethods: {\n    add () {\n     this.$store.commit(''increment'') //普通提交封装\n    }\n  }\n```\n\n###  mutations携带参数\n\n```js\n<button @click=\"add(10)\">add</button>\n methods: {\n    add (count) {\n    //  this.$store.commit(''increment'',count)\n       this.$store.commit({ //对象提交封装\n       type:''increment'',\n       count\n     })\n    }\n  }\nstore.js文件:\nconst mutations = {\n  increment (state,count) {\n    state.counter+=count\n  }\n}\n //对象提交count更改 payload\n   increment (state) {\n   state.counter+=payload.count\n}\n```\n\n### actions异步操作\n\n```js\nconst actions = { // 异步操作\n  acincrement (context) {\n    state.count++\n  }\n```\n\n使用dispath来触发\n\n```js\n this.$store.dispatch(''acincrement'')\n```\n\n### getters\n\n```js\nconst getters = {\n  getterCount(state, n = 0) {\n    return (state.count += n)\n  }\n}\nexport default new Vuex.Store({\n  state,\n  mutations,\n  actions,\n  getters\n})\n```\n\n属性调用：\n\n```\n{{ $store.getters.getterCount }}\n```\n\n### getters传参\n\n```js\n{ $store.getters.getterid(10) }}\ngetterid(state){\n\nreturn age = >{\nreturn //需要判断的数值\n}\n}\n```\n\n ',26,0,'7.jpg',0,43,1,4,'2023-07-18 17:31:37','2023-07-18 17:31:37'),
(445,'vue2刷新','在使用Vue框架开发时，在函数中改变了页面中的某个值，在函数中查看是修改成功了，但在页面中没有及时刷新改变后的值；','在使用Vue框架开发时，在函数中改变了页面中的某个值，在函数中查看是修改成功了，但在页面中没有及时刷新改变后的值；\n\n### 路由刷新\n\n这种方法页面会一瞬间的白屏\n\n```js\nthis.$router.go(0)\n```\n\n### location刷新\n\n这种也是一样，画面一闪\n\n```js\nlocation.reload()\n```\n\n以上整个浏览器进行了重新加载，闪烁，体验不好\n\n### provide/inject\n\n允许一个祖先组件向其所有子孙后代注入一个依赖，**不论组件层次有多深**，并在起上下游关系成立的时间里始终生效。\n\n```\nprovide：选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。\ninject：一个字符串数组，或一个对象，对象的 key 是本地的绑定名\n```\n\n搭配provide、inject使用,首先在主页面 app.vue\n\n```html\n <keep-alive include=\"GjTable\">\n      <router-view v-if=\"isRouterAlive\"></router-view\n  ></keep-alive>\n```\n\n```js\nexport default {\n provide () {\n    return {\n      reload: this.reload\n    },\n  data () {\n    return {\n      isRouterAlive: true\n    }\n  },\n methods: {\n    reload () {\n      this.isRouterAlive = false\n      this.$nextTick(function () {\n        this.isRouterAlive = true\n      })\n    }\n  }\n}\n```\n\n在页面注入app.vue组件提供（provide）的 reload 依赖，在逻辑完成之后（删除或添加...）,直接this.reload()调用，即可刷新当前页面\n\n```js\ninject: [''reload''],\n //调用刷新： \n // 此页面加了缓存需要重新加载数据 \n this.getgjtype(''vue'')  \n this.reload() // 刷新页面 \n```\n\n\n\n ',15,0,'14.jpg',0,6,1,4,'2023-07-18 17:35:12','2023-07-18 17:35:12'),
(446,'解决vue2设置缓存刷新无效','内容仅供参考','### provide/inject\n\n搭配`provide、inject`使用\n\n首先在主页面 `app.vue`\n\n#### Home.vue\n\n```csharp\n    <keep-alive>\n      <!--//当前进入的路由 meta里面 keepAlive为true时走这里-->\n      <router-view v-if=\"$route.meta.keepAlive\" class=\"home-router\"></router-view>\n    </keep-alive>\n    <!--当前进入的路由 meta里面 keepAlive为false时走这里 下面 if 判断进行了取反处理-->\n    <router-view v-if=\"!$route.meta.keepAlive\"></router-view>\n```\n\n#### App.vue\n\n```vue\n<template>\n  <div id=\"app\">\n    <!-- <router-view v-if=\"isRouterAlive\"></router-view> -->\n    <home v-if=\"isRouterAlive\"></home>\n  </div>\n</template>\n\n<script>\n  import Home from ''./views/Home.vue'';\n  export default {\n    name: \"app\",\n    components: {\n      Home\n    },\n    provide() {\n      //父组件中通过provide来提供变量，在子组件中通过inject来注入变量。\n      return {\n        reload: this.reload\n      };\n    },\n    data() {\n      return {\n        isRouterAlive: true //控制视图是否显示的变量\n      };\n    },\n    methods: {\n      reload() {\n        this.isRouterAlive = false; //先关闭，\n        this.$nextTick(function () {\n          this.isRouterAlive = true; //再打开\n        });\n      }\n    }\n  };\n</script>\n```\n\n#### 在需要刷新的页面导入` inject: [''reload''],`\n\n调用\n\n```js\nexport default {inject: [\"reload\"] }\n   \nthis.reload()// 刷新页面\n```\n\n### 回退缓存问题\n\n在router/index.js中添加路由元信息，设置需要缓存的页面\n\n```js\nmeta: {\n  title:''trade.tradeTitle'',\n  keepAlive: true, // 此组件需要被缓存\n  isBack:false, //用于判断上一个页面是哪个\n}\n```\n\n#### 钩子函数执行顺序\n\n**不使用keep-alive**\n\n```vue\nbeforeRouteEnter --> created --> mounted --> destroyed\n```\n\n**使用keep-alive**\n\n```\nbeforeRouteEnter --> created --> mounted --> activated --> deactivated\n```\n\n再次进入缓存的页面，只会触发beforeRouteEnter -->activated --> deactivated 。created和mounted不会再执行。我们可以利用不同的钩子函数，做不同的事。务必理解上述钩子函数的执行时机和执行顺序，本教程的核心就依赖于此钩子函数\nactivated和deactivated是使用keep-alive后\n\n#### beforeRouteEnter\n\n在缓存的页面通过**beforeRouteEnter**钩子函数中判断是从哪个页面过来的\n\n```js\n    beforeRouteLeave(to, from, next) {\n      // 路由导航钩子，此时还不能获取组件实例 `this`，所以无法在data中定义变量（利用vm除外）\n      // 所以，利用路由元信息中的meta字段设置变量，方便在各个位置获取。这就是为什么在meta中定义isBack\n      if (from.path === ''/SnNavigationUp'') {\n        //判断是从哪个路由过来的，\n        //刷新数据\n        to.meta.isBack = false;\n      } else {\n        //不刷新\n        to.meta.isBack = true;\n      }\n      next();\n    },\n```\n\n#### data\n\ndata中定义变量**isFirstEnter**用来判断是否第一次进入，或是否刷新了页面，默认false\n\n```c#\n data() {\n    return {\n      isFirstEnter:false,\n    };\n  },\n```\n\n#### created\n\ncreated中把isFirstEnter变为true，说明是第一次进入或刷新了页面\n\n```js\n      this.isFirstEnter = true;\n      // 只有第一次进入或者刷新页面后才会执行此钩子函数\n      // 使用keep-alive后（2+次）进入不会再执行此钩子函数\n      this.$nextTick(() => {\n        this.getall();\n      });\n```\n\n#### activated\n\nactivated中增加判断条件\n\n```js\n   activated() {\n      if (this.$route.meta.isBack || !this.isFirstEnter) {\n        // 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据\n        // 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据\n        this.$nextTick(() => {\n          this.getall();\n        });\n      } else {\n        this.$route.meta.isBack = false\n        this.isFirstEnter = false;\n      }\n    }\n```\n\n直接写上也可以解决以上问题\n\n```js\nactivated() {\n    this.getall();\n}\n```\n\n### 参考 https://blog.csdn.net/weixin_41164499/article/details/90718155\n\n',42,0,'5.jpg',0,6,1,4,'2023-07-18 17:42:37','2023-07-18 17:42:37'),
(447,'vue2封装marked','内容仅供参考','### 封装marked\n\n```js\nconst highlight = require(\"highlight.js\");\nconst marked = require(\"marked\");\nconst tocObj = {\n  add: function (text, level) {\n    var anchor = `#toc${level}${++this.index}`;\n    this.toc.push({\n      anchor: anchor,\n      level: level,\n      text: text\n    });\n    return anchor;\n  },\n\n  toHTML: function () {\n    let levelStack = [];\n    let result = \"\";\n    const addStartUL = () => {\n      result += ''<ul class=\"anchor-ul\" id=\"anchor-fix\">'';\n    };\n    const addEndUL = () => {\n      result += \"</ul>\\n\";\n    };\n    const addLI = (anchor, text) => {\n      result +=\n        ''<li><a class=\"toc-link\" href=\"#'' + anchor + ''\">'' + text + \"<a></li>\\n\";\n    };\n\n    this.toc.forEach(function (item) {\n      let levelIndex = levelStack.indexOf(item.level);\n      // 没有找到相应level的ul标签，则将li放入新增的ul中\n      if (levelIndex === -1) {\n        levelStack.unshift(item.level);\n        addStartUL();\n        addLI(item.anchor, item.text);\n      } // 找到了相应level的ul标签，并且在栈顶的位置则直接将li放在此ul下\n      else if (levelIndex === 0) {\n        addLI(item.anchor, item.text);\n      } // 找到了相应level的ul标签，但是不在栈顶位置，需要将之前的所有level出栈并且打上闭合标签，最后新增li\n      else {\n        while (levelIndex--) {\n          levelStack.shift();\n          addEndUL();\n        }\n        addLI(item.anchor, item.text);\n      }\n    });\n    // 如果栈中还有level，全部出栈打上闭合标签\n    while (levelStack.length) {\n      levelStack.shift();\n      addEndUL();\n    }\n    // 清理先前数据供下次使用\n    this.toc = [];\n    this.index = 0;\n    return result;\n  },\n  toc: [],\n  index: 0\n};\n\nclass MarkUtils {\n  constructor() {\n    this.rendererMD = new marked.Renderer();\n    this.rendererMD.heading = function (text, level) {\n      var anchor = tocObj.add(text, level);\n      return `<h${level} id=${anchor}>${text}</h${level}>\\n`;\n    };\n    highlight.configure({\n      useBR: true\n    });\n    marked.setOptions({\n      renderer: this.rendererMD,\n      headerIds: false,\n      gfm: true,\n      tables: true,\n      breaks: false,\n      pedantic: false,\n      sanitize: false,\n      smartLists: true,\n      smartypants: false,\n      highlight: function (code) {\n        return highlight.highlightAuto(code).value;\n      }\n    });\n  }\n\n  async marked(data) {\n    if (data) {\n      let content = await marked(data); // 文章内容\n      let toc = tocObj.toHTML(); // 文章目录\n      return {\n        content: content,\n        toc: toc\n      };\n    } else {\n      return null;\n    }\n  }\n}\n\nconst markdown = new MarkUtils();\n\nexport default markdown;\n```\n\n### 导入\n\n```vue\n import markdown from \"@/utils/markdown.js\";\n```\n\n### 使用\n\n```js\n// 使用 marked 转换\nconst article = markdown.marked(state.article_String.text);\narticle.then((response: any) =>\n{\n    state.blog = response.content;\n});\n```\n\n',34,0,'13.jpg',0,4,1,4,'2023-07-18 17:46:53','2023-07-18 17:46:53'),
(448,'vue3中使用qs库','qs是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object,帮助我们查询字符串解析和序列化字符串。','  qs是一个流行的查询参数序列化和解析库。可以将一个普通的object序列化成一个查询字符串，或者反过来将一个查询字符串解析成一个object,帮助我们查询字符串解析和序列化字符串。\n\n### 使用\n\n```js\nnpm install qs or yarn add qs\n\n//导入\nimport qs from ''qs''\n//序列化 \nconfig.data = qs.parse(config.data);\n```\n\n### 将对象转换为查询字符串\n\n```js\n//将对象转换为查询字符串\nconst params = { name: ''John'', age: 30 };\nconst queryString = qs.stringify(params);\nconsole.log(queryString); // 输出: \"name=John&age=30\"\n```\n\n### 将查询字符串解析为对象\n\n```js\nconst queryString = ''name=John&age=30'';\nconst params = qs.parse(queryString);\nconsole.log(params); // 输出: { name: ''John'', age: ''30'' }\n```\n\n### axios中使用\n\n```js\n  // 请求拦截器\n  service.interceptors.request.use(\n    (config: AxiosRequestConfig) => {\n      const { method, data, headers } = config\n      removePending(config)\n      cancel.cancel_request && addPending(config)\n\n      if ([''post'', ''put'', ''delete''].includes(method as string)) {\n        config.data = qs.parse(data) //序列化,将查询字符串解析为对象\n      }\n      return config\n    },\n    error => {\n      message.error(error.data.error.message)\n      return Promise.reject(error.data.error.message)\n    }\n  )\n```\n\n',22,0,'20.jpg',0,3,1,4,'2023-07-18 17:57:07','2023-07-18 17:57:07'),
(449,'vue3自定义无限滚动','最初使用的vue3-infinite-scroll-better插件进行滚动加载,打包部署后插件滚动功能失效了也不报错很难查找问题出现在哪个部分,只好自己写一个相对简单的功能','最初使用的vue3-infinite-scroll-better插件进行滚动加载,打包部署后插件滚动功能失效了也不报错很难查找问题出现在哪个部分,只好自己写一个相对简单的功能\n\n### 主窗体滚动\n\n使用的vueuse\n\n```tsx\nimport { useWindowScroll } from ''@vueuse/core''\n//他是响应式的\nconst { y } = useWindowScroll()\n```\n\n#### 定义监听\n\n```tsx\nconst scDisabled = computed(() => {\n  //数据长度小于等于总数返回true\n  return rArticle.value.length <= state.count\n})\n//默认50触发加载内容\nconst cheight = ref(50)\n//对窗体高度进行监听\nwatch(\n  () => {\n    return [y] \n  },\n  async () => {\n    if (scDisabled.value) {\n      if (y.value > cheight.value) {\n        console.log(''触发加载'')\n        cheight.value += 400 //高度\n        state.pagesize += 3 //每次加载3行数据\n        await GetFy() //加载数据\n      }\n    }\n  },\n  { deep: true }\n)\n```\n\n当窗体高度大于cheight字段就加载数据内容\n\n### 局部滚动\n\n以上只能在主窗口监听滚动状态，如果在某个节点去加载就失效了\n\n#### 监听DIV局部滚动\n\n给div绑定事件，设置height: 100%; overflow-y: scroll;\n\n```html\n  <section ref=\"aRef\" class=\"article-columns\" @scroll=\"scrollEvent\">\n    <div v-for=\"r in articleData\" :key=\"r.id\" class=\"article-column\">\n       <div class=\"content-div-frame-1\" @click=\"routerId(''/article/content'', r.id)\">\n        {{ r.name }}   \n      </div>\n    </div>\n  </section>\n\n\n<style lang=\"scss\" scoped>\n.article-columns {\n  @apply h-[100%] overflow-y-scroll;\n\n  scroll-behavior: smooth;\n}\n</style>\n```\n\n#### 创建监听方法\n\n```js\nconst cheight = ref(2)\nconst xxxRef: any = ref(0)\nasync function scrollEvent() {\n  const scrollTop = aRef.value.scrollTop\n  console.log(scrollTop)\n  if (scrollTop) {\n    if (scrollTop > cheight.value) {\n      console.log(''触发加载'')\n      cheight.value += 300\n      paging.pagesize += 4\n      await QPaging()\n    }\n  }\n}\n```\n\n',36,0,'8.jpg',0,4,1,4,'2023-07-18 18:09:32','2023-07-18 18:09:32'),
(450,'test','test','![](http://rxzvlzwfh.hn-bkt.clouddn.com/blog/navigation/17.jpg)',11,0,'7.jpg',0,49,1,4,'2023-07-19 10:19:17','2023-07-19 11:28:30'),
(451,'WebAPI约定','约定在控制器生成前运行，可以修改默认的约定，如可以向控制器统一添加路由前缀','约定在控制器生成前运行，可以修改默认的约定，如可以向控制器统一添加路由前缀\n\n## 默认约定\n\n集将应用于 ContactsConventionController 中的所有操作：\n\n```c#\n[ApiController]\n[ApiConventionType(typeof(DefaultApiConventions))]\n[Route(\"api/[controller]\")]\npublic class ContactsConventionController : ControllerBase\n{\n```\n\n默认的约定集将应用于程序集中的所有操作：\n\n```c#\n[assembly: ApiConventionType(typeof(DefaultApiConventions))]\nnamespace ApiConventions\n{\n    public class Startup\n    {\n```\n\n## 创建约定\n\n如果默认 API 约定不能满足需要，请创建自己的约定。 约定是：\n\n- 带有方法的静态类型。\n- 能够对操作定义[响应类型](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/advanced/conventions?view=aspnetcore-3.1#response-types)和[命名要求](https://docs.microsoft.com/zh-cn/aspnet/core/web-api/advanced/conventions?view=aspnetcore-3.1#naming-requirements)。\n\n### 响应类型\n\n这些方法使用 `[ProducesResponseType]` 或 `[ProducesDefaultResponseType]` 属性进行批注。 例如：\n\n```csharp\npublic static class MyAppConventions\n{\n    [ProducesResponseType(StatusCodes.Status200OK)]\n    [ProducesResponseType(StatusCodes.Status404NotFound)]\n    public static void Find(int id)\n    {\n    }\n}\n```\n\n如果没有更具体的元数据属性，则将此约定应用于程序集可强制实现以下内容：\n\n- 该约定方法应用于所有名为 `Find` 的操作。\n- `id` 操作上存在名为 `Find` 的参数。\n\n### 命名要求\n\n`[ApiConventionNameMatch]` 和 `[ApiConventionTypeMatch]` 属性可应用于约定方法，确定它们所要应用的操作。 例如：\n\n```csharp\n[ProducesResponseType(StatusCodes.Status200OK)]\n[ProducesResponseType(StatusCodes.Status404NotFound)]\n[ApiConventionNameMatch(ApiConventionNameMatchBehavior.Prefix)]\npublic static void Find(\n    [ApiConventionNameMatch(ApiConventionNameMatchBehavior.Suffix)]\n    int id)\n{ }\n```\n\n在上面示例中：\n\n- 应用于该方法的 `Microsoft.AspNetCore.Mvc.ApiExplorer.ApiConventionNameMatchBehavior.Prefix` 选项表示该约定可匹配前缀是“Find”的任何操作。 匹配的操作可以是 `Find`、`FindPet` 和 `FindById`。\n- 应用于该参数的 `Microsoft.AspNetCore.Mvc.ApiExplorer.ApiConventionNameMatchBehavior.Suffix` 表示该约定可匹配带有唯一以标识符作为后缀结尾的参数的方法。 示例包括 `id` 或 `petId` 等参数。 与此类似，可将 `ApiConventionTypeMatch` 应用于类型，以约束参数类型。 `params[]` 参数指示无需显式匹配的剩余参数。',26,0,'25.jpg',0,4,104,4,'2023-07-19 12:13:25','2023-07-19 12:13:25'),
(452,'SqlSugar仓储','SqlSugar5.0仓储模式可以让你的方法更加的规范，需要什么方法都封装到仓储中，下次就能重复使用，并且能很好的和你业务拆分开, 这种设计模式简单粗暴用起来也方便 ','### 仓储说明\n\nSqlSugar5.0仓储模式可以让你的方法更加的规范，需要什么方法都封装到仓储中，下次就能重复使用，并且能很好的和你业务拆分开, 这种设计模式简单粗暴用起来也方便 \n\n官方文档：[仓储定义 - SqlSugar 5x - .NET果糖网 (donet5.com)](https://www.donet5.com/home/Doc?typeId=1228)\n\n### 仓储方法\n\n仓储有一套自带的数据库操作方法，比起 db.xx.xxx来说可能更简便些满足一些常用需求, 复杂的功能还是用 db.xxx.xxx\n\n```csharp\n//查询\nvar data1 = base.GetById(1); //根据id查询\nvar data2 = base.GetList(); //查询所有\nvar data3 = base.GetList(it => it.Id == 1); //TOP1条件\nvar data4 = base.GetSingle(it => it.Id == 1); //查询单条记录，结果集不能超过1，不然会提示错误\nvar data = base.GetFirst(it => it.Id == 1); //查询第一条记录\nvar p = new PageModel()\n{\n    PageIndex = 1, PageSize = 2\n};\nvar data5 = base.GetPageList(it => it.Name == \"xx\", p);\nConsole.Write(p.PageCount);\nvar data6 = base.GetPageList(it => it.Name == \"xx\", p, it => it.Name, OrderByType.Asc);\nConsole.Write(p.PageCount);\nList < IConditionalModel > conModels = new List < IConditionalModel > ();\nconModels.Add(new ConditionalModel()\n{\n    FieldName = \"id\", ConditionalType = ConditionalType.Equal, FieldValue = \"1\"\n}); //id=1\nvar data7 = base.GetPageList(conModels, p, it => it.Name, OrderByType.Asc);\nvar data8 = base.AsQueryable()\n    .Where(x => x.Id == 1)\n    .ToList(); //使用Queryable\n//插入\nbase.Insert(insertObj);\nbase.InsertRange(InsertObjs);\nvar id = base.InsertReturnIdentity(insertObj); //插入返回自增\nvar SnowflakeId = InsertReturnSnowflakeId(insertObj); //插入返回雪花ID\nbase.AsInsertable(insertObj)\n    .ExecuteCommand(); //复杂功能使用Insertable\n//删除\nbase.Delete(T); //实体删除 需要有主键\nbase.Delete(List < T > ); //集合删除 需要有主键\nbase.DeleteById(1);\nbase.DeleteByIds(new object[]\n{\n    1\n    , 2\n}); //数组带是 ids方法 ，封装传 object [] 类型\n//技巧 int [] 转换成 object[]  写法：ids.Cast<object>().ToArray()\nbase.Delete(it => it.Id == 1);\nbase.AsDeleteable()\n    .Where(it => it.Id == 1)\n    .ExecuteCommand(); //复杂功能用 Deleteable\n//更新\nbase.Update(insertObj);\nbase.UpdateRange(InsertObjs);\nbase.Update(it => new Order()\n{\n    Name = \"a\" /*可以多列*/\n}, it => it.Id == 1); //只更新name 并且id=1\nbase.AsUpdateable(insertObj)\n    .UpdateColumns(it => new\n    {\n        it.Name\n    })\n    .ExecuteCommand(); //复杂功能用 Updateable \n//高级操作\nbase.AsSugarClient // 获取完整的db对象\nbase.AsTenant // 获取多库相关操作\n//切换仓储\nbase.ChangeRepository < Repository < OrderItem >> () //支持多租户和扩展方法，使用SqlSugarScope单例（或者SqlSugarClient Scope注入）\nbase.Change < OrderItem > () //只支持自带方法和单库\n\n```\n\n### 仓储定义\n\n定义 After.Repository 类库\n\n定义的Repository是公用类\n\n```c#\nusing After.Generic;\nusing SqlSugar;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nnamespace After.Repository.Repository\n{\n    public class Repository < T >: SimpleClient < T > where T: class, new()\n    {\n        public Repository(ISqlSugarClient context = null): base(context) //注意这里要有默认值等于null\n        {\n            if (context == null)\n            {\n                string[] sqlText = Type2.SqlText();\n                base.Context = new SqlSugarClient(new ConnectionConfig()\n                {\n                    //DbType = SqlSugar.DbType.SqlServer,\n                    DbType = (DbType) Convert.ToSByte(sqlText[1])\n                        , InitKeyType = InitKeyType.Attribute\n                        , IsAutoCloseConnection = true\n                        , ConnectionString = sqlText[0]\n                });\n            }\n        }\n        /// <summary>\n        /// 扩展方法，自带方法不能满足的时候可以添加新方法\n        /// </summary>\n        /// <returns></returns>\n        public List < T > CommQuery(string json)\n        {\n            //base.Context.Queryable<T>().ToList();可以拿到SqlSugarClient 做复杂操作\n            return null;\n        }\n    }\n}\n\n```\n\n### 定义IService Service类\n\n**IConfigService.cs**\n\n```c#\nusing After.Model;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nnamespace After.IService.IService\n{\n    public interface IConfigService\n    {\n        Task < List < config >> GetAllAsync();\n    }\n}\n```\n\n**ConfigService.cs**\n\n```csharp\nusing After.IService.IService;\nusing After.Model;\nusing After.Repository.Repository;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nnamespace After.Service\n{\n    public class ConfigService: Repository < config > , IConfigService\n    {\n        public ConfigService()\n        {}\n        /// <summary>\n        /// 查询全部\n        /// </summary>\n        /// <returns></returns>\n        public async Task < List < config >> GetAllAsync()\n        {\n            return await base.GetListAsync();\n        }\n    }\n}\n```\n\n### 使用\n\n```csharp\n//创建实例\nConfigService configService = new ConfigService();\nvar date = configService.GetAllAsync();\nforeach(var item in date.Result)\n{\n    MessageBox.Show(item.ConfigText);\n}\n```\n\n\n\n',12,0,'23.jpg',0,4,107,4,'2023-07-19 12:22:49','2023-07-19 12:22:49'),
(453,'netCore使用依赖注入','依赖注入是一种常用的设计模式，用于解耦组件之间的依赖关系。通过依赖注入，我们可以将一个组件所依赖的其他组件的创建和管理工作交给容器来完成，从而实现组件之间的解耦和灵活性','依赖注入是一种常用的设计模式，用于解耦组件之间的依赖关系。通过依赖注入，我们可以将一个组件所依赖的其他组件的创建和管理工作交给容器来完成，从而实现组件之间的解耦和灵活性\n\n.NET Core提供了内置的依赖注入容器，使我们能够轻松地实现依赖注入。下面是使用依赖注入的步骤：\n\n### 定义接口\n\n定义一个接口\n\n**ICacheUtil**\n\n```csharp\nnamespace Snblog.Cache.CacheUtil\n{\n    public interface ICacheUtil\n    {\n        public T CacheNumber<T>(string key, T value);\n        public T CacheString<T>(string key, T value);\n    }\n}\n```\n\n### 接口实现类\n\n**CacheUtil**\n\n```csharp\nusing Snblog.Cache.Cache;\n\nnamespace Snblog.Cache.CacheUtil\n{\n    public class CacheUtil:ICacheUtil\n    {\n\n        public T CacheNumber<T>(string key, T value)\n        {\n          // 实现具体的逻辑\n        }\n\n\n        public T CacheString<T>(string key, T value)\n        {\n          // 实现具体的逻辑\n        }\n    }\n}\n\n```\n\n### 注册服务\n\n接下来，需要在依赖注入容器中注册服务。这样，当我们需要使用该服务时，容器将自动创建并提供相应的实例。\n\n.NET Core中，在`Startup.cs`文件的`ConfigureServices`方法中进行服务注册。例如，我们可以将`IMyService`接口和`MyService`实现类注册为服务：\n\n**ConfigureServices**\n\n```csharp\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddScoped<ICacheUtil,CacheUtil>();\n}\n```\n\n### 使用依赖注入\n\n```csharp\nprivate readonly CacheUtil _cacheUtil;\npublic SnArticleService(ICacheUtil cacheUtil)\n{\n    _cacheUtil = (CacheUtil) cacheUtil;\n}\npublic IActionResult Index()\n{\n    _cacheUtil.CacheString(\"Teset\");\n    return View();\n}\n```\n\n### 属性注入\n\n```csharp\n[Inject]\nprivate readonly CacheUtil _cacheUtil;\npublic IActionResult Index()\n{\n    _cacheUtil.CacheString(\"Teset\");\n    return View();\n}\n```\n\n### 生命周期\n\n.NET Core DI 为我们提供的实例生命周期包括三种：\n\n- Transient： 每一次GetService都会创建一个新的实例\n- Scoped： 在同一个Scope内只初始化一个实例 ，可以理解为（ 每一个request级别只创建一个实例，同一个http request会在一个 scope内）\n- Singleton ：整个应用程序生命周期以内只创建一个实例 ',10,0,'19.jpg',0,42,3,4,'2023-07-19 14:41:41','2023-07-19 14:41:41'),
(454,'wp2vite','一个webpack转换vite2的工具','一个webpack转换vite2的工具\n\n### 安装\n\n```\nnpm install -g wp2vite\nor\nyarn global add wp2vite\n```\n\n### 启动wp2vite\n\n项目目录下启动wp2vite\n\n```js\n// 执行wp2vite的命令行\nwp2vite \n// 安装依赖\nnpm install\n\n// 启动项目\nnpm run dev // 如果原先你的项目有dev script，请执行下面的命令\nor\nnpm run vite-start\n```\n\n### 配置\n\n```js\n//vite.config.ts\nimport {\n  defineConfig,\n} from ''vite''\nimport vue from ''@vitejs/plugin-vue''\nimport styleImport from ''vite-plugin-style-import''\nimport {\n  resolve\n} from ''path''\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue(),\n    styleImport({\n      libs: [{\n        libraryName: ''ant-design-vue'',\n        esModule: true,\n        resolveStyle: (name) => {\n          return `ant-design-vue/es/${name}/style/index`\n        }\n      }]\n    }),\n  ],\n  resolve: {\n    alias: {\n      ''@'': resolve(''./src''),\n    }\n  },\n  build: {\n   //\n  },\n  css: {\n    preprocessorOptions: {\n      less: {\n        },\n        javascriptEnabled: true\n      }\n    }\n  },\n  base: ''./'', // 打包路径\n  server: {\n    host: ''0.0.0.0'',\n    port: 4000, // 服务端口号\n    open: false, // 服务启动时是否自动打开浏览器\n    https: false,\n    cors: true, // 允许跨域\n  }\n})\n```\n\n### .env.development\n\n```\nNODE_ENV = development\nVITE_API_DOMAIN = ''https://localhost:5001/''\n```\n\n### .env.production\n\n```\nNODE_ENV = production\nVITE_API_DOMAIN =  ''http://localhost:8087/''\n```\n\n### 问题点\n\n**global is not defined**\n\nindex.html页面加入 global\n\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n<body>\n    <script>\n     global = globalThis\n	</script>\n</body>\n</html>\n```\n\n**require is not defined**\n\n```js\nloading: require(logo)\n //改\nlazyPlugin.install(app, {\n  loading: ''@/assets/img/blog/2.jpg'',\n  error: ''@/assets/img/blog/1.jpg''\n})\n\n<img v-lazy=\"require(''/src/assets/img/'' + res.img)\" />\n //改\n<img v-lazy=\"''/src/assets/img/'' + res.img\" />\n```\n\n',3,0,'25.jpg',0,4,1,4,'2023-07-19 14:51:57','2023-07-19 14:51:57'),
(455,'netCore中Swagger版本控制','test','### 添加枚举类型\n\n定义版本号\n\n```c#\n /// <summary>\n /// 版本控制\n /// </summary>\n public enum ApiVersion\n {\n     /// <summary>\n     /// v1版本\n     /// </summary>\n     V1 = 1,\n         /// <summary>\n         /// v2版本\n         /// </summary>\n         V2 = 2\n }\n```\n\n### 注册服务\n\n在ConfigureServices方法中添加Swagger的服务\n\n```c#\nservices.AddSwaggerGen(c =>\n{\n    //添加文档信息\n    //遍历版本信息\n    typeof(ApiVersion).GetEnumNames().ToList().ForEach(version =>\n    {\n        c.SwaggerDoc(version, new OpenApiInfo\n        {\n            Title = \"SN blog API\", //标题\n                Description = \"EFCore数据操作 ASP.NET Core Web API\", //描述\n                TermsOfService = new Uri(\"https://example.com/terms\"), //服务条款\n                Contact = new OpenApiContact\n                {\n                    Name = \"kai ouyang\", //联系人\n                        Email = string.Empty, //邮箱\n                        Url = new Uri(\"https://twitter.com/spboyer\"), //网站\n                },\n                License = new OpenApiLicense\n                {\n                    Name = \"Use under LICX\", //协议\n                        Url = new Uri(\"https://example.com/license\"), //协议地址\n                }\n        });\n    });\n});\n```\n\n### **启用Swagger**\n\n在Configure方法中，我们需要启用Swagger中间件\n\n```c#\napp.UseSwaggerUI(c =>\n{\n    typeof(ApiVersion).GetEnumNames().ToList().ForEach(version =>\n    {\n        c.IndexStream = () => GetType().GetTypeInfo().Assembly.GetManifestResourceStream(\"Snblog.index.html\");\n        ////设置首页为Swagger\n        c.RoutePrefix = string.Empty;\n        //自定义页面 集成性能分析\n        c.SwaggerEndpoint($ \"/swagger/{version}/swagger.json\", version);\n        ////设置为none可折叠所有方法\n        c.DocExpansion(DocExpansion.None);\n        ////设置为-1 可不显示models\n        c.DefaultModelsExpandDepth(-1);\n    });\n});\n```\n\n### 使用\n\nApiExplorerSettings 标记\n\n```c#\n[ApiExplorerSettings(GroupName = \"V1\")]\n[ApiExplorerSettings(GroupName = \"V2\")]\n```\n\n在上面的代码中，我们使用ApiVersion特性来标记不同版本的API，并在路由中使用版本号',11,0,'10.jpg',0,34,3,4,'2023-07-19 15:28:15','2023-07-19 15:28:15'),
(456,'vite动态加载图片','根据官网的提示, 就是在将asset 前面加上src','[参考CSDN](https://blog.csdn.net/weixin_44717047/article/details/119846671?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link)\n\n### 方法一\n\n根据官网的提示, 就是在将asset 前面加上src\n\n```html\n<img v-if=\"post.welcomeScreen\" :src=\"`/src/assets/blogPhotos/${name}.jpg`\" alt=\"\" />\n```\n\n### 方法二\n\n关于第二个方法，官网说：“实际上，Vite 并不需要在开发阶段处理这些代码！在生产构建时，Vite 才会进行必要的转换保证 URL 在打包和资源哈希后仍指向正确的地址。”\n\n因此，以下的方法开发阶段不需要了解。\n\n首先把给src绑定一个函数，然后把需要图片名字传给函数。\n\n\n\n```js\n<img :src=\"\" alt=\"getImageUrl(name)\" />\n//or\n<img v-lazy=\"getImageUrl(res.img)\" />\n```\n\n```js\nfunction getImageUrl(name) {\n    return new URL(`../assets/blogPhotos/${name}.jpg`, import.meta.url).href;\n//or\nfunction getImageUrl(name) {\n    return new URL(`/src/assets/img/${name}`, import.meta.url).href\n  }\n```\n\n### import.meta\n\n`import.meta` 对象包含关于当前模块的信息。\n\n它的内容取决于其所在的环境。在浏览器环境中，它包含当前脚本的 URL，或者如果它是在 HTML 中的话，则包含当前页面的 URL。\n\n',38,0,'3.jpg',0,4,4,4,'2023-07-19 18:08:50','2023-07-19 18:08:50'),
(457,'vue3使用Moment','moment.js是一个JavaScript 日期处理类库。','moment.js是一个JavaScript 日期处理类库。\n\n由于用ant design日期组件取得的值是moment类型，而往数据库中保存需要的是字符串类型.这里就用到了moment日期转换\n\nMoment.js官网:http://momentjs.cn/\n\n安装插件\n\n```\nnpm install moment\n```\n\nformat就是格式化函数，参数’YYYY-MM-DD HH:mm:ss’定义了返回日期的格式\n\n### 转换示例\n\n#### 日期格式化\n\n```js\nmoment().format(''MMMM Do YYYY, h:mm:ss a''); // 十月 22日 2021, 3:05:48 下午\nmoment().format(''dddd'');                    // 星期五\nmoment().format(\"MMM Do YY\");               // 10月 22日 21\nmoment().format(''YYYY [escaped] YYYY'');     // 2021 escaped 2021\nmoment().format();                          // 2021-10-22T15:05:48+08:00\n```\n\n#### 相对时间\n\n```js\nmoment(\"20111031\", \"YYYYMMDD\").fromNow(); // 10 年前\nmoment(\"20120620\", \"YYYYMMDD\").fromNow(); // 9 年前\nmoment().startOf(''day'').fromNow();        // 15 小时前\nmoment().endOf(''day'').fromNow();          // 9 小时内\nmoment().startOf(''hour'').fromNow();       // 6 分钟前\n```\n\n#### 日历时间\n\n```js\nmoment().subtract(10, ''days'').calendar(); // 2021/10/12\nmoment().subtract(6, ''days'').calendar();  // 上星期六15:05\nmoment().subtract(3, ''days'').calendar();  // 上星期二15:05\nmoment().subtract(1, ''days'').calendar();  // 昨天15:05\nmoment().calendar();                      // 今天15:05\nmoment().add(1, ''days'').calendar();       // 明天15:05\nmoment().add(3, ''days'').calendar();       // 下星期一15:05\nmoment().add(10, ''days'').calendar();      // 2021/11/01\n```\n\n#### 多语言支持\n\n```js\nmoment.locale();         // zh-cn\nmoment().format(''LT'');   // 15:05\nmoment().format(''LTS'');  // 15:05:48\nmoment().format(''L'');    // 2021/10/22\nmoment().format(''l'');    // 2021/10/22\nmoment().format(''LL'');   // 2021年10月22日\nmoment().format(''ll'');   // 2021年10月22日\nmoment().format(''LLL'');  // 2021年10月22日下午3点05分\nmoment().format(''lll'');  // 2021年10月22日 15:05\nmoment().format(''LLLL''); // 2021年10月22日星期五下午3点05分\nmoment().format(''llll''); // 2021年10月22日星期五 15:05\n```\n\n### antdesign\n\n```js\nimport moment from ''moment''\nasync function getTitle() {\n  \n  await article.getTitles(1, 1000, true, false).then((result: any) => {\n  //遍历日期\n    result.data.forEach((res: any) => {\n      res.timeCreate = moment(res.timeCreate).format(''YYYY-MM-DD'')\n      res.timeModified = moment(res.timeModified).format(''YYYY-MM-DD'')\n    })\n    state.dataResult = result.data\n  })\n}\n```\n\n### 函数封装\n\n```js\n//封装momentData\nfunction momentData(result: any) {\n  result.data.forEach((res: any) => {\n    res.timeCreate = moment(res.timeCreate).format(''YYYY-MM-DD'')\n    res.timeModified = moment(res.timeModified).format(''YYYY-MM-DD'')\n  })\n}\n//调用\nmomentData(result)\n```\n\n',7,0,'14.jpg',0,3,1,4,'2023-07-21 12:05:10','2023-07-21 12:05:10'),
(458,'SqlSugar','SqlSugar是一个轻量级ORM框架，专为.NET Core开发人员设计。它提供了简单、高效的方式来处理数据库操作，使开发人员能够更轻松地与数据库进行交互。','SqlSugar是一个轻量级ORM框架，专为.NET Core开发人员设计。它提供了简单、高效的方式来处理数据库操作，使开发人员能够更轻松地与数据库进行交互。\n\n[官方文档：http://www.codeisbug.com/Doc/8]()\n\n## Nuget安装\n\nSqlSugar是.NET版本，SqlSugarCore是.NET CORE版本，根据你的项目选择你的引用dll\n\n`Install-Package sqlSugar `\n\n`Install-Package sqlSugarCore`\n\n**优点**\n\n1、高性能 ,不夸张的说，去掉Sql在数据库执行的时间，SqlSugar是EF数倍性能，另外在批量操作和一对多查询上也有不错的SQL优化\n\n2、高扩展性 ，支持自定义拉姆达函数解析、扩展数据类型、支持自定义实体特性，外部缓存等\n\n## **定义DbContext**\n\n```c#\n  public DbContext()\n        {\n            Db = new SqlSugarClient(new ConnectionConfig()\n            {\n                ConnectionString = \"server=localhost;uid=root;pwd=woshishui;database=test\",\n                DbType = DbType.MySql,\n                InitKeyType = InitKeyType.Attribute,//从特性读取主键和自增列信息\n                IsAutoCloseConnection = true,//开启自动释放模式和EF原理一样我就不多解释了\n\n            });\n            //调式代码 用来打印SQL \n            Db.Aop.OnLogExecuting = (sql, pars) =>\n            {\n                Console.WriteLine(sql + \"\\r\\n\" +\n                    Db.Utilities.SerializeObject(pars.ToDictionary(it => it.ParameterName, it => it.Value)));\n                Console.WriteLine();\n            };\n\n        }\n        //注意：不能写成静态的，不能写成静态的\n        public SqlSugarClient Db;//用来处理事务多表查询和复杂的操作\n        public SimpleClient<User> Userdb { get { return new SimpleClient<User>(Db); } }//用来处理Student表的常用操作\n       // public SimpleClient<School> SchoolDb { get { return new SimpleClient<School>(Db); } }//用来处理School表的常用操作\n```\n\n## 使用DbContext增删查改\n\nDemoManager\n\n```c#\n  public class DemoManager : DbContext//继承DbContext\n    {\n        public void query()\n        {\n          \n            var data2 = Userdb.GetList();//查询所有\n            var data1 = Userdb.GetById(1);//根据ID查询\n        }\n\n        public void SearchDemo()\n        {\n\n          \n            var data2 = Userdb.GetList();//查询所有\n            var data3 = Userdb.GetList(it => it.id == 1);  //根据条件查询  \n            var data4 = Userdb.GetSingle(it => it.id == 1);//根据条件查询一条\n\n            var p = new PageModel() { PageIndex = 1, PageSize = 2 };// 分页查询\n            var data5 = Userdb.GetPageList(it => it.用户 == \"xx\", p);\n            Console.Write(p.PageCount);//返回总数\n\n\n            // 分页查询加排序\n            var data6 = Userdb.GetPageList(it => it.用户 == \"xx\", p, it => it.用户, OrderByType.Asc);\n            Console.Write(p.PageCount);//返回总数\n\n\n            //组装条件查询作为条件实现 分页查询加排序\n            List<IConditionalModel> conModels = new List<IConditionalModel>();\n            conModels.Add(new ConditionalModel() { FieldName = \"id\", ConditionalType = ConditionalType.Equal, FieldValue = \"1\" });//id=1\n            var data7 = Userdb.GetPageList(conModels, p, it => it.用户, OrderByType.Asc);\n\n            //4.9.7.5支持了转换成queryable,我们可以用queryable实现复杂功能\n            Userdb.AsQueryable().Where(x => x.id == 1).ToList();\n        }\n\n\n        //插入例子\n        public void InsertDemo()\n        {\n\n            var student = new User() { 用户 = \"jack\" };\n            var studentArray = new User[] { student };\n\n            Userdb.Insert(student);//插入\n\n            Userdb.InsertRange(studentArray);//批量插入\n\n            var id = Userdb.InsertReturnIdentity(student);//插入返回自增列\n\n            //4.9.7.5我们可以转成 Insertable实现复杂插入\n           // Userdb.AsInsertable(insertObj).ExecuteCommand();\n        }\n\n\n        //更新例子\n        public void UpdateDemo()\n        {\n            var student = new User() { id = 1, 用户 = \"jack\" };\n            var studentArray = new User[] { student };\n\n            Userdb.Update(student);//根据实体更新\n\n            Userdb.UpdateRange(studentArray);//批量更新\n\n           // Userdb.Update(it => new User() { 用户 = \"a\", CreateTime = DateTime.Now }, it => it.Id == 1);// 只更新Name列和CreateTime列，其它列不更新，条件id=1\n\n            //支持Userdb.AsUpdateable(student)\n        }\n\n        //删除例子\n        public void DeleteDemo()\n        {\n            var student = new User() { id = 1, 用户 = \"jack\" };\n\n            Userdb.Delete(student);//根据实体删除\n            Userdb.DeleteById(1);//根据主键删除\n            Userdb.DeleteById(new int[] { 1, 2 });//根据主键数组删除\n            Userdb.Delete(it => it.id == 1);//根据条件删除\n\n            //支持Userdb.AsDeleteable()\n        }\n\n        //使用事务的例子\n        public void TranDemo()\n        {\n\n            var result = Db.Ado.UseTran(() =>\n            {\n                //这里写你的逻辑\n            });\n            if (result.IsSuccess)\n            {\n                //成功\n            }\n            else\n            {\n                Console.WriteLine(result.ErrorMessage);\n            }\n        }\n\n        //多表查询\n        public void JoinDemo()\n        {\n\n            var list = Db.Queryable<User, User>((st, sc) => new object[] {\n            JoinType.Left,\n            st.用户==sc.用户\n        }).Select<User>().ToList();\n        }\n    }\n```\n\n## 实体类\n\n```c#\n [SugarTable(\"user\")]\n    public class User\n    {\n        //指定主键和自增列，当然数据库中也要设置主键和自增列才会有效\n        [SugarColumn(IsPrimaryKey = true, IsIdentity = true)]\n        public int id { get; set; }\n        public string 用户 { get; set; }\n        public string 密码 { get; set; }\n        public int 权限 { get; set; }\n    }\n```\n\n##  使用\n\n```csharp\nDemoManager demo = new DemoManager();\ndemo.query();\n```\n\n',9,0,'12.jpg',0,41,107,4,'2023-07-21 12:10:19','2023-07-21 12:10:19'),
(459,'# win10配置FTP','在win10中使用**IIS管理器管理控制台**','### 搭建FTP站点\n\n在windows10中使用**IIS管理器管理控制台**\n\n1.控制面板里面打开**程序**功能里面的启用或关闭Windows程序\n\n <img src=\"http://rxzvlzwfh.hn-bkt.clouddn.com/typora/image-20230721121737173.png\" alt=\"image-20230721121737173\" style=\"zoom:80%;\" />\n\n\n\n2.找到Internet Information Services 。打开里面的`FTP服务器`和web管理工具里的`IIS管理控制台`。![image-20230721121841245](http://rxzvlzwfh.hn-bkt.clouddn.com/typora/image-20230721121841245.png)\n\n\n\n\n\n### IIS控制台\n\n在你的开始菜单里面找到IIS管理器管理控制台。或者使用`win+R`键，然后输入`Inetmgr`也可以打开。\n\n打开之后，在网站那里右键添加一个FTP站点。\n\n ![image-20230721122037790](http://rxzvlzwfh.hn-bkt.clouddn.com/typora/image-20230721122037790.png)\n\n### 设置FTP站点\n\n添加完FTP站点会自动给进入设置向导，首先设置的是里的FTP站点的名称，和FTP站点文件存储的路径\n\n <img src=\"http://rxzvlzwfh.hn-bkt.clouddn.com/typora/image-20230721122143556.png\" alt=\"image-20230721122143556\" style=\"zoom: 67%;\" />\n\n然后接下来是是里FTP站点的ip地址，也就是你本机的ip地址，还有SSL证书以及是否自启动FTP站点。如果你没有SSL证书，就选无，然后把自启动FTP站点也勾选上，这样不用每次开机都要手动去启动FTP站点。\n\n ![image-20230721122301328](http://rxzvlzwfh.hn-bkt.clouddn.com/typora/image-20230721122301328.png)\n\n### 浏览器访问\n\n在浏览器上输入`ftp://**.**.**.**`（填你自己的ftp地址）。你就可以看到你ftp目录里面的东西了，\n\n\n\n### 文件管理器访问\n\n在你的文件管理器的地址栏中同样输入你的FTP站点的地址，就能访问FTP站点里面的数据。你可以对里面的文件进行删除、重命名或者新建文件夹，上传文件，下载文件等操作。\n\n上传文件只需要把里面的文件复制下来或者直接拖拽出来即可，同样上传文件可以把文件复制进行也可以把文件直接拖拽进去十分方便。\n\n\n\n\n\n### 设置防火墙应用\n\n打开防火墙设置，选择允许的应用，把ftp服务器勾选上、然后再点击允许其它应用\n\n选择C:\\Windows\\System32目录下面的svchost.exe这个软件\n把这个应该添加到防火墙允许的应用里面\n\n\n\n\n\n## winfrom发布程序\n\n点击发布向导\n\n发布应用位置  ftp://xx.xx.xx.xxx/  iis 搭建ftp\n\n下一步\n\n从哪个路径进行程序安装 http://xxxx/指向目录iis搭建FTP路径\n\n\n\n',6,0,'3.jpg',0,36,104,4,'2023-07-21 13:45:52','2023-07-21 13:45:52'),
(460,'使用unplugin-vue-components','开发应用程序时，我们通常会使用许多第三方组件库。然而，这些组件库通常包含大量的代码，而我们只需要其中的一小部分。这就导致了应用程序的体积变得非常大，加载时间变长。为了解决这个问题，我们可以使用unplugin-vue-components插件来实现按需引入','开发应用程序时，我们通常会使用许多第三方组件库。然而，这些组件库通常包含大量的代码，而我们只需要其中的一小部分。这就导致了应用程序的体积变得非常大，加载时间变长。为了解决这个问题，我们可以使用unplugin-vue-components插件来实现按需引入\n\nvite 使用 unplugin-vue-components 插件可以实现在开发过程中自动按需引入组件，减少打包体积\n\n### 安装依赖\n\n```\nnpm i unplugin-vue-components -D\n```\n\n-  开箱即用的 Vue 2 和 Vue 3。\n-  同时支持组件和指令。\n-  支持 Vite、Webpack、Vue CLI、Rollup、esbuild 等，由 [unplugin](https://github.com/unjs/unplugin) 提供支持。\n-  可树可切换，仅注册您使用的组件。\n-  文件夹名称作为命名空间。\n-  完整的 TypeScript 支持。\n-  适用于常用 UI 库的[内置解析器](https://github.com/antfu/unplugin-vue-components#importing-from-ui-libraries)。\n-  与[不插入图标](https://github.com/antfu/unplugin-icons)完美配合。\n\n### 配置插件\n\n在 `vite.config.js` 中配置插件\n\n```js\nimport Components from ''unplugin-vue-components/vite''\nimport { AntDesignVueResolver } from ''unplugin-vue-components/resolvers''\n\nexport default defineConfig({\n  plugins: [\n    Components({\n      dts: true, //ts支持\n      dirs: [''src/views'', ''src/components''], // 自定义路径按需导入\n      resolvers: [AntDesignVueResolver()] // antd直接使用组件,无需在任何地方导入组件\n    })\n  ],\n})\n```\n\n### 命名冲突\n\n[unplugin-vue-components] 的 naming conflicts\n\n```js\nComponents({\n      resolvers: [AntDesignVueResolver()],\n      // 加上下面这一行作为配置项即可\n      directoryAsNamespace: true,\n    }),\n```\n\n#### tsconfig.json配置\n\n项目根目录自动生成一个`components.d.ts`文件;\n\n```json\n// tsconifg.json\n{\n    \"include\": [\n        \"src/**/*.ts\",\n        \"src/**/*.d.ts\",\n        \"src/**/*.tsx\",\n        \"src/**/*.vue\",\n        \"./auto-imports.d.ts\",\n        \"./components.d.ts\"\n      ]\n}\n```\n\n',3,0,'27.jpg',0,43,1,4,'2023-07-21 14:10:46','2023-07-21 14:10:46'),
(461,'netCore封装efcore仓储模式','netCore封装efcore仓储模式','\n\n# netCore封装efcore仓储模式\n\n参考：[三层框架项目搭建教程](https://www.cnblogs.com/han1982/p/11058788.html)\n\n### 安装依赖包\n\n```ruby\nInstall-Package MySql.Data.EntityFrameworkCore -Pre\nInstall-Package Pomelo.EntityFrameworkCore.MySql\nInstall-Package Microsoft.EntityFrameworkCore.Tools\nInstall-Package Microsoft.VisualStudio.Web.CodeGeneration.Design\n```\n\n### 管理器控制台\n\n输入以下代码\n\n```csharp\nScaffold-DbContext \"server=localhost;userid=root;pwd=1;port=3306;database=syerp;sslmode=none;\" Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force\n```\n\n> 自动生成所有类模型文件，数据库上下文自动创建好了\n\n```ruby\n-OutputDir  实体文件所存放的文件目录\n-ContextDir DbContext文件存放的目录\n-Context  DbContext文件名\n-Schemas  需要生成实体数据的数据表所在的模式\n-Tables  需要生成实体数据的数据表的集合\n-DataAnnotations\n-UseDatabaseNames  直接使用数据库中的表名和列名（某些版本不支持）\n-Force   强制执行，重写已经存在的实体文件\n```\n\n> 链接： [asp.net core3.1 实战开发（EF+Mysql 从数据库生成实体类到项目）](https://www.cnblogs.com/jiamiemie/p/12683369.html)\n\n\n\n## 封装仓储模式\n\n###  IRepositorys接口\n\n```c#\nusing System.Data;\nusing System.Data.Common;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.Threading.Tasks;\n\nnamespace Snblog.IRepository.IRepository\n{\n    public interface IRepositorys<T> : IDisposable where T : class\n    {\n        # region 显式开启数据上下文事务\n        /// <summary>\n        /// 显式开启数据上下文事务\n        /// </summary>\n        /// <param name=\"isolationLevel\">指定连接的事务锁定行为</param>\n        void BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.Unspecified);\n        # endregion\n\n        # region 提交事务的更改\n        /// <summary>\n        /// 提交事务的更改\n        /// </summary>\n        void Commit();\n        # endregion\n\n        # region 显式回滚事务，仅在显式开启事务后有用\n        /// <summary>\n        /// 显式回滚事务，仅在显式开启事务后有用\n        /// </summary>\n        void Rollback();\n        #endregion\n\n        #region 提交当前单元操作的更改\n        /// <summary>\n        /// 提交当前单元操作的更改\n        /// </summary>\n        int SaveChanges();\n        #endregion\n\n        #region 提交当前单元操作的更改\n        /// <summary>\n        /// 提交当前单元操作的更改\n        /// </summary>\n        /// <returns></returns>\n        Task<int> SaveChangesAsync();\n        #endregion\n\n        #region 获取 当前实体类型的查询数据集，数据将使用不跟踪变化的方式来查询，当数据用于展现时，推荐使用此数据集，如果用于新增，更新，删除时，请使用<see cref=\"TrackEntities\"/>数据集\n        /// <summary>\n        /// 获取 当前实体类型的查询数据集，数据将使用不跟踪变化的方式来查询，当数据用于展现时，推荐使用此数据集，如果用于新增，更新，删除时，请使用<see cref=\"TrackEntities\"/>数据集\n        /// </summary>\n        IQueryable<T> Entities { get; }\n        #endregion\n\n        #region 获取 当前实体类型的查询数据集，当数据用于新增，更新，删除时，使用此数据集，如果数据用于展现，推荐使用<see cref=\"Entities\"/>数据集\n        /// <summary>\n        /// 获取 当前实体类型的查询数据集，当数据用于新增，更新，删除时，使用此数据集，如果数据用于展现，推荐使用<see cref=\"Entities\"/>数据集\n        /// </summary>\n        IQueryable<T> TrackEntities { get; }\n        #endregion\n\n        #region 插入 - 通过实体对象添加\n        /// <summary>\n        /// 插入 - 通过实体对象添加\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        /// <param name=\"isSave\">是否执行</param>\n        /// /// <returns></returns>\n        T Add(T entity, bool isSave = true);\n        Task<T> AddAsync(T entity, bool isSave = true);\n        /// <summary>\n        /// 批量插入 - 通过实体对象集合添加\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void AddRange(IEnumerable<T> entitys, bool isSave = true);\n        bool Insert(T entity, bool isSaveChange);\n        Task<bool> InsertAsync(T entity, bool isSaveChange);\n        bool Insert(List<T> entitys, bool isSaveChange = true);\n        Task<bool> InsertAsync(List<T> entitys, bool isSaveChange);\n\n        #endregion\n\n        #region 删除(删除之前需要查询)\n\n        bool Delete(List<T> entitys, bool isSaveChange);\n        Task<bool> DeleteAsync(T entity, bool isSaveChange);\n        Task<bool> DeleteAsync(List<T> entitys, bool isSaveChange = true);\n        /// <summary>\n        /// 删除 - 通过实体对象删除\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(T entity, bool isSave = true);\n\n        /// <summary>\n        /// 批量删除 - 通过实体对象集合删除\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(bool isSave = false, params T[] entitys);\n\n        /// <summary>\n        /// 删除 - 通过主键ID删除\n        /// </summary>\n        /// <param name=\"id\">主键ID</param>\n        Task<int> DelAsync(object id);\n        /// <summary>\n        /// 批量删除 - 通过条件删除\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"isSave\">是否执行</param>\n        void Delete(Expression<Func<T, bool>> @where, bool isSave = true);\n        #endregion\n\n        #region 修改数据\n        bool Update(T entity, bool isSaveChange, List<string> updatePropertyList);\n        Task<bool> UpdateAsync(T entity, bool isSaveChange, List<string> updatePropertyList);\n        /// <summary>\n        /// 更新单个字段\n        /// </summary>\n        /// <param name=\"entity\">实体类</param>\n        /// <param name=\"isSaveChange\">是否更新</param>\n        /// <param name=\"updatePropert\">更新的字段</param>\n        /// <returns></returns>\n        Task<bool> UpdateAsync1(T entity, bool isSaveChange, string updatePropert);\n        bool Update(List<T> entitys, bool isSaveChange);\n        Task<bool> UpdateAsync(List<T> entitys, bool isSaveChange);\n\n        /// <summary>\n        /// 修改 - 通过实体对象修改\n        /// </summary>\n        /// <param name=\"entity\">实体对象</param>\n        Task<int> UpdateAsync(T entity);\n        int Update(T entity);\n        /// <summary>\n        /// 批量修改 - 通过实体对象集合修改\n        /// </summary>\n        /// <param name=\"entitys\">实体对象集合</param>\n        void Update(params T[] entitys);\n        #endregion\n\n        #region 查找数据\n\n        /// <summary>\n        /// 是否满足条件\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        bool Any(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 返回总条数\n        /// </summary>\n        /// <returns></returns>\n        int Count();\n        Task<int> CountAsync();\n        /// <summary>\n        /// 返回总条数 - 通过条件过滤\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        int Count(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 返回总条数 - 通过条件过滤\n        /// </summary>\n        /// <param name=\"where\"></param>\n        /// <returns></returns>\n        Task<int> CountAsync(Expression<Func<T, bool>> @where);\n        /// <summary>\n        /// 返回第一条记录\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        T FirstOrDefault(Expression<Func<T, bool>> @where);\n        /// <summary>\n        /// 返回第一条记录 - 通过条件过滤\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        T FirstOrDefault<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n        /// <summary>\n        /// 去重查询\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        IQueryable<T> Distinct(Expression<Func<T, bool>> @where);\n\n\n        /// <summary>\n        /// 条件查询\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        IQueryable<T> Where(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 条件查询\n        /// </summary>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        Task<IQueryable<T>> WhereAsync(Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 条件查询 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n\n        /// <summary>\n        /// 条件分页查询 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"count\">返回总条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        IEnumerable<T> WherePage<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc);\n        /// <summary>\n        /// \n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        /// <returns></returns>\n\n        Task<IEnumerable<T>> WherePageAsync<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, bool isDesc);\n\n        /// <summary>\n        /// 条件分页查询 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"count\">返回总条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        /// <returns></returns>\n        IEnumerable<T> Where<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc = false);\n\n        /// <summary>\n        /// 条件分页查询 - 支持排序 - 支持Select导航属性查询\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"where\">过滤条件</param>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"pageIndex\">当前页码</param>\n        /// <param name=\"pageSize\">每页记录条数</param>\n        /// <param name=\"count\">返回总条数</param>\n        /// <param name=\"isDesc\">是否倒序</param>\n        /// <returns></returns>\n        IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, int pageIndex, int pageSize, out int count, bool isDesc = false);\n\n        /// <summary>\n        /// 获取所有数据\n        /// </summary>\n        /// <returns></returns>\n        IQueryable<T> GetAll();\n\n        /// <summary>\n        /// 查询所有\n        /// </summary>\n        /// <returns></returns>\n        Task<List<T>> GetAllAsync();\n\n        /// <summary>\n        /// 获取所有数据 - 支持排序\n        /// </summary>\n        /// <typeparam name=\"TOrder\">排序约束</typeparam>\n        /// <param name=\"order\">排序条件</param>\n        /// <param name=\"isDesc\">排序方式</param>\n        /// <returns></returns>\n        IQueryable<T> GetAll<TOrder>(Expression<Func<T, TOrder>> order, bool isDesc = false);\n\n        /// <summary>\n        /// 根据ID查询\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"id\">主键ID</param>\n        /// <returns></returns>\n        T GetById<TType>(TType id);\n\n        /// <summary>\n        /// 根据ID查询\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"id\">主键</param>\n        /// <returns></returns>\n        Task<T> GetByIdAsync<TType>(TType id);\n        /// <summary>\n        /// 获取最大值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <returns></returns>\n        TType Max<TType>(Expression<Func<T, TType>> column);\n\n        /// <summary>\n        /// 获取最大值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Max<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 获取最小值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <returns></returns>\n        TType Min<TType>(Expression<Func<T, TType>> column);\n\n        /// <summary>\n        /// 获取最小值\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"column\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Min<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where);\n\n        /// <summary>\n        /// 获取总数\n        /// </summary>\n        /// <typeparam name=\"TType\">字段类型</typeparam>\n        /// <param name=\"selector\">字段条件</param>\n        /// <param name=\"where\">过滤条件</param>\n        /// <returns></returns>\n        TType Sum<TType>(Expression<Func<T, TType>> selector, Expression<Func<T, bool>> @where) where TType : new();\n        #endregion\n\n        #region 执行Sql语句\n#pragma warning disable CS0693 // 类型参数与外部类型中的类型参数同名\n        void BulkInsert<T>(List<T> entities);\n#pragma warning restore CS0693 // 类型参数与外部类型中的类型参数同名\n        //int ExecuteSql(string sql);\n        //Task<int> ExecuteSqlAsync(string sql);\n        //int ExecuteSql(string sql, List<DbParameter> spList);\n        //Task<int> ExecuteSqlAsync(string sql, List<DbParameter> spList);\n        DataTable GetDataTableWithSql(string sql);\n        DataTable GetDataTableWithSql(string sql, List<DbParameter> spList);\n        #endregion\n    }\n}\n```\n\n### Repositorys类\n\nCRUD功能的封装\n\n```c#\nnamespace Snblog.Repository.Repository\n{\n    // Repository.cs仓储类，它是一个泛型类，并且拥有一个带有参数的构造方法，通过构造方法获得当前DbContext上下文对象，\n    //泛型类为指定Model类型，通过DbContext.Set<T>()方法最终得到相应的DbSet<T>对象来操作工作单元。\n    //实现了CRUD基本功能的封装\n    public class Repositorys<T> : IRepositorys<T> where T : class\n    {\n        private readonly snblogContext _dbContext;\n        private readonly DbSet<T> _dbSet;\n        private readonly string _connStr;\n\n        public Repositorys(IConcardContext mydbcontext)\n        {\n            _dbContext = mydbcontext as snblogContext;\n            if (_dbContext == null)\n            {\n                return;\n            }\n\n            _dbSet = _dbContext.Set<T>();\n            _connStr = _dbContext.Database.GetDbConnection().ConnectionString;\n        }\n\n        public void BeginTransaction(IsolationLevel isolationLevel = IsolationLevel.Unspecified)\n        {\n            if (_dbContext.Database.CurrentTransaction == null)\n            {\n                _dbContext.Database.BeginTransaction(isolationLevel);\n            }\n        }\n\n        public void Commit()\n        {\n            var transaction = this._dbContext.Database.CurrentTransaction;\n            if (transaction != null)\n            {\n                try\n                {\n                    transaction.Commit();\n                }\n                catch (Exception)\n                {\n                    transaction.Rollback();\n                    throw;\n                }\n            }\n        }\n\n        public void Rollback()\n        {\n            _dbContext.Database.CurrentTransaction?.Rollback();\n        }\n\n        public int SaveChanges()\n        {\n            return _dbContext.SaveChanges();\n        }\n        public async Task<int> SaveChangesAsync()\n        {\n            return await _dbContext.SaveChangesAsync();\n        }\n\n\n        public IQueryable<T> Entities\n        {\n            get { return _dbSet.AsNoTracking(); }\n        }\n\n        public IQueryable<T> TrackEntities\n        {\n            get { return _dbSet; }\n        }\n\n        public T Add(T entity, bool isSave = true)\n        {\n\n            _dbSet.Add(entity);\n            if (isSave)\n            {\n                SaveChanges();\n            }\n            return entity;\n        }\n\n        public async Task<T> AddAsync(T entity, bool isSave = true)\n        {\n            await _dbSet.AddAsync(entity);\n            if (isSave)\n            {\n                await SaveChangesAsync();\n            }\n            return entity;\n        }\n\n        public void AddRange(IEnumerable<T> entitys, bool isSave = true)\n        {\n            _dbSet.AddRange(entitys);\n            if (isSave)\n            {\n                SaveChanges();\n            }\n        }\n\n        public void Delete(T entity, bool isSave = true)\n        {\n            this._dbSet.Remove(entity);\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        public void Delete(bool isSave = true, params T[] entitys)\n        {\n            this._dbSet.RemoveRange(entitys);\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        /// <summary>\n        /// 删除\n        /// </summary>\n        /// <param name=\"id\">主键</param>\n        /// <returns>-1 || 1</returns>\n        public async Task<int> DelAsync(object id)\n        {\n            var result = await _dbSet.FindAsync(id);\n            if (result == null) return -1;\n            _dbSet.Remove(result);\n            return  SaveChanges();\n        }\n\n        public void Delete(Expression<Func<T, bool>> @where, bool isSave = true)\n        {\n            T[] entitys = this._dbSet.Where(@where).ToArray();\n            if (entitys.Length > 0)\n            {\n                this._dbSet.RemoveRange(entitys);\n            }\n            if (isSave)\n            {\n                this.SaveChanges();\n            }\n        }\n\n        public async Task<int> UpdateAsync(T entity)\n        {\n            var en = _dbContext.Entry(entity);\n            if (en.State == EntityState.Detached) en.State = EntityState.Modified;\n            return await Task.Run(SaveChangesAsync);\n        }\n\n        public int Update(T entity)\n        {\n\n            var entry = _dbContext.Entry(entity);\n            if (entry.State == EntityState.Detached)\n            {\n                entry.State = EntityState.Modified;\n            }\n            var da = SaveChanges();\n            return da;\n        }\n        public void Update(params T[] entitys)\n        {\n            var entry = this._dbContext.Entry(entitys);\n            if (entry.State == EntityState.Detached)\n            {\n                entry.State = EntityState.Modified;\n            }\n            SaveChanges();\n        }\n\n        public bool Any(Expression<Func<T, bool>> @where)\n        {\n            return _dbSet.AsNoTracking().Any(@where);\n        }\n\n        public int Count()\n        {\n            return _dbSet.AsNoTracking().Count();\n        }\n\n        public int Count(Expression<Func<T, bool>> @where)\n        {\n            return _dbSet.AsNoTracking().Count(@where);\n        }\n\n        public T FirstOrDefault(Expression<Func<T, bool>> @where)\n        {\n            return _dbSet.AsNoTracking().FirstOrDefault(@where);\n        }\n\n        public T FirstOrDefault<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.AsNoTracking().OrderByDescending(order).FirstOrDefault(@where);\n            }\n            else\n            {\n                return this._dbSet.AsNoTracking().OrderBy(order).FirstOrDefault(@where);\n            }\n        }\n\n        public IQueryable<T> Distinct(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.AsNoTracking().Where(@where).Distinct();\n\n        }\n\n\n        public IQueryable<T> Where(Expression<Func<T, bool>> @where)\n        {\n            return this._dbSet.Where(@where);\n        }\n\n        public IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order);\n            }\n        }\n\n\n        public IEnumerable<T> WherePage<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc)\n        {\n            count = Count();\n            if (isDesc)\n            {\n\n                return _dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n        }\n        public async Task<IEnumerable<T>> WherePageAsync<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, bool isDesc)\n        {\n            if (isDesc)\n            {\n                return await Task.Run(() => _dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize));\n            }\n            else\n            {\n                return await Task.Run(() => _dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize));\n            }\n        }\n\n        public IEnumerable<T> Where<TOrder>(Func<T, bool> @where, Func<T, TOrder> order, int pageIndex, int pageSize, out int count, bool isDesc = false)\n        {\n            count = Count();\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n        }\n\n        public IQueryable<T> Where<TOrder>(Expression<Func<T, bool>> @where, Expression<Func<T, TOrder>> order, int pageIndex, int pageSize, out int count, bool isDesc = false)\n        {\n            count = Count();\n            if (isDesc)\n            {\n                return this._dbSet.Where(@where).OrderByDescending(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n            else\n            {\n                return this._dbSet.Where(@where).OrderBy(order).Skip((pageIndex - 1) * pageSize).Take(pageSize);\n            }\n        }\n\n        public IQueryable<T> GetAll()\n        {\n            return _dbSet.AsNoTracking();\n        }\n\n        public IQueryable<T> GetAll<TOrder>(Expression<Func<T, TOrder>> order, bool isDesc = false)\n        {\n            if (isDesc)\n            {\n                return this._dbSet.AsNoTracking().OrderByDescending(order);\n            }\n            else\n            {\n                return this._dbSet.AsNoTracking().OrderBy(order);\n            }\n        }\n\n        public T GetById<TType>(TType id)\n        {\n            return this._dbSet.Find(id);\n        }\n        public async Task<T> GetByIdAsync<TType>(TType id)\n        {\n            return await _dbSet.FindAsync(id);\n        }\n\n\n        public TType Max<TType>(Expression<Func<T, TType>> column)\n        {\n            if (this._dbSet.AsNoTracking().Any())\n            {\n                return this._dbSet.AsNoTracking().Max(column);\n            }\n            return default;\n        }\n\n        public TType Max<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where)\n        {\n            if (this._dbSet.AsNoTracking().Any(@where))\n            {\n                return this._dbSet.AsNoTracking().Where(@where).Max(column);\n            }\n            return default;\n        }\n\n        public TType Min<TType>(Expression<Func<T, TType>> column)\n        {\n            if (this._dbSet.AsNoTracking().Any())\n            {\n                return this._dbSet.AsNoTracking().Min(column);\n            }\n            return default;\n        }\n\n        public TType Min<TType>(Expression<Func<T, TType>> column, Expression<Func<T, bool>> @where)\n        {\n            if (this._dbSet.AsNoTracking().Any(@where))\n            {\n                return this._dbSet.AsNoTracking().Where(@where).Min(column);\n            }\n            return default;\n        }\n\n        public TType Sum<TType>(Expression<Func<T, TType>> selector, Expression<Func<T, bool>> @where) where TType : new()\n        {\n            object result = 0;\n\n            if (new TType().GetType() == typeof(decimal))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, decimal>>);\n            }\n            if (new TType().GetType() == typeof(decimal?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, decimal?>>);\n            }\n            if (new TType().GetType() == typeof(double))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, double>>);\n            }\n            if (new TType().GetType() == typeof(double?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, double?>>);\n            }\n            if (new TType().GetType() == typeof(float))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, float>>);\n            }\n            if (new TType().GetType() == typeof(float?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, float?>>);\n            }\n            if (new TType().GetType() == typeof(int))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, int>>);\n            }\n            if (new TType().GetType() == typeof(int?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, int?>>);\n            }\n            if (new TType().GetType() == typeof(long))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, long>>);\n            }\n            if (new TType().GetType() == typeof(long?))\n            {\n                result = this._dbSet.AsNoTracking().Where(where).Sum(selector as Expression<Func<T, long?>>);\n            }\n            return (TType)result;\n        }\n\n        public void Dispose()\n        {\n            _dbContext.Dispose();\n        }\n\n\n        # region 插入数据\n\n        /// <summary>\n        /// 插入数据\n        /// </summary>\n        /// <param name=\"entity\"></param>\n        /// <param name=\"isSaveChange\"></param>\n        /// <returns></returns>\n        public bool Insert(T entity, bool isSaveChange = true)\n        {\n            _dbSet.Add(entity);\n            if (isSaveChange)\n            {\n                return SaveChanges() > 0;\n            }\n            return false;\n        }\n\n        /// <summary>\n        /// 异步插入\n        /// </summary>\n        /// <param name=\"entity\"></param>\n        /// <param name=\"isSaveChange\"></param>\n        /// <returns></returns>\n        public async Task<bool> InsertAsync(T entity, bool isSaveChange = true)\n        {\n            _dbSet.Add(entity);\n            if (isSaveChange)\n            {\n                return await SaveChangesAsync() > 0;\n            }\n            return false;\n        }\n\n\n        public bool Insert(List<T> entitys, bool isSaveChange = true)\n        {\n            _dbSet.AddRange(entitys);\n            if (isSaveChange)\n            {\n                return SaveChanges() > 0;\n            }\n            return false;\n        }\n\n        public async Task<bool> InsertAsync(List<T> entitys, bool isSaveChange = true)\n        {\n            _dbSet.AddRange(entitys);\n            if (isSaveChange)\n            {\n                return await SaveChangesAsync() > 0;\n            }\n            return false;\n        }\n        #endregion\n\n        #region 删除\n        public bool Delete(List<T> entitys, bool isSaveChange = true)\n        {\n            entitys.ForEach(entity =>\n            {\n                _dbSet.Attach(entity);\n                _dbSet.Remove(entity);\n            });\n            return isSaveChange && SaveChanges() > 0;\n        }\n\n        public virtual async Task<bool> DeleteAsync(T entity, bool isSaveChange = true)\n        {\n            _dbSet.Attach(entity);\n            _dbSet.Remove(entity);\n            return isSaveChange && await SaveChangesAsync() > 0;\n        }\n        public virtual async Task<bool> DeleteAsync(List<T> entitys, bool isSaveChange = true)\n        {\n            entitys.ForEach(entity =>\n            {\n                _dbSet.Attach(entity);\n                _dbSet.Remove(entity);\n            });\n            return isSaveChange && await SaveChangesAsync() > 0;\n        }\n        #endregion\n\n        #region 更新数据\n        public bool Update(T entity, bool isSaveChange = true, List<string> updatePropertyList = null)\n        {\n            if (entity == null)\n            {\n                return false;\n            }\n            _dbSet.Attach(entity);\n            var entry = _dbContext.Entry(entity);\n            if (updatePropertyList == null)\n            {\n                entry.State = EntityState.Modified;//全字段更新\n            }\n            else\n            {\n\n                updatePropertyList.ForEach(c =>\n                {\n                    entry.Property(c).IsModified = true; //部分字段更新的写法\n                });\n\n\n            }\n            if (isSaveChange)\n            {\n                return SaveChanges() > 0;\n            }\n            return false;\n        }\n        public bool Update(List<T> entitys, bool isSaveChange = true)\n        {\n            if (entitys == null || entitys.Count == 0)\n            {\n                return false;\n            }\n            entitys.ForEach(c =>\n            {\n                Update(c, false);\n            });\n            if (isSaveChange)\n            {\n                return SaveChanges() > 0;\n            }\n            return false;\n        }\n        public async Task<bool> UpdateAsync(T entity, bool isSaveChange, List<string> updatePropertyList)\n        {\n            if (entity == null)\n            {\n                return false;\n            }\n            _dbSet.Attach(entity);\n            var entry = _dbContext.Entry<T>(entity);\n            if (updatePropertyList == null)\n            {\n                entry.State = EntityState.Modified;//全字段更新\n            }\n            else\n            {\n                updatePropertyList.ForEach(c =>\n                {\n                    entry.Property(c).IsModified = true; //部分字段更新的写法\n                });\n\n            }\n            if (isSaveChange)\n            {\n                return await SaveChangesAsync() > 0;\n            }\n            return false;\n        }\n        public async Task<bool> UpdateAsync(List<T> entitys, bool isSaveChange = true)\n        {\n            if (entitys == null || entitys.Count == 0)\n            {\n                return false;\n            }\n            entitys.ForEach(c =>\n            {\n                _dbSet.Attach(c);\n                _dbContext.Entry(c).State = EntityState.Modified;\n            });\n            if (isSaveChange)\n            {\n                return await SaveChangesAsync() > 0;\n            }\n            return false;\n        }\n\n\n        #endregion\n\n        #region SQL语句\n#pragma warning disable CS0693 // 类型参数“T”与外部类型“Repositorys<T>”中的类型参数同名\n        public virtual void BulkInsert<T>(List<T> entities)\n#pragma warning restore CS0693 // 类型参数“T”与外部类型“Repositorys<T>”中的类型参数同名\n        { }\n\n        // [Obsolete]\n        //public int ExecuteSql(string sql)\n        //{\n        //    return _dbContext.Database.ExecuteSqlCommand(sql);\n        //}\n\n        //[Obsolete]\n        //public Task<int> ExecuteSqlAsync(string sql)\n        //{\n        //    return _dbContext.Database.ExecuteSqlCommandAsync(sql);\n        //}\n\n        //[Obsolete]\n        //public int ExecuteSql(string sql, List<DbParameter> spList)\n        //{\n        //    return _dbContext.Database.ExecuteSqlCommand(sql, spList.ToArray());\n        //}\n\n        //[Obsolete]\n        //public Task<int> ExecuteSqlAsync(string sql, List<DbParameter> spList)\n        //{\n        //    return _dbContext.Database.ExecuteSqlCommandAsync(sql, spList.ToArray());\n        //}\n\n\n        public virtual DataTable GetDataTableWithSql(string sql)\n        {\n            throw new NotImplementedException();\n        }\n\n        public virtual DataTable GetDataTableWithSql(string sql, List<DbParameter> spList)\n        {\n            throw new NotImplementedException();\n        }\n\n\n\n        IQueryable<T> IRepositorys<T>.GetAll()\n        {\n            return _dbSet.AsNoTracking();\n        }\n\n        public async Task<List<T>> GetAllAsync()\n        {\n            return await _dbSet.AsNoTracking().ToListAsync();\n        }\n\n#pragma warning disable CS1998 // 此异步方法缺少 \"await\" 运算符，将以同步方式运行。请考虑使用 \"await\" 运算符等待非阻止的 API 调用，或者使用 \"await Task.Run(...)\" 在后台线程上执行占用大量 CPU 的工作。\n        public async Task<IQueryable<T>> WhereAsync(Expression<Func<T, bool>> where)\n#pragma warning restore CS1998 // 此异步方法缺少 \"await\" 运算符，将以同步方式运行。请考虑使用 \"await\" 运算符等待非阻止的 API 调用，或者使用 \"await Task.Run(...)\" 在后台线程上执行占用大量 CPU 的工作。\n        {\n            return _dbSet.Where(@where);\n        }\n\n        public async Task<bool> UpdateAsync1(T entity, bool isSaveChange, string updatePropert)\n        {\n            if (entity == null)\n            {\n                return false;\n            }\n            _dbSet.Attach(entity);\n            var entry = _dbContext.Entry(entity);\n            if (updatePropert == null)\n            {\n                entry.State = EntityState.Modified;//全字段更新\n            }\n            else\n            {\n                entry.Property(updatePropert).IsModified = true; //部分字段更新的写法\n            }\n            if (isSaveChange)\n            {\n                return await SaveChangesAsync() > 0;\n            }\n            return false;\n        }\n\n        public async Task<int> CountAsync()\n        {\n            return await _dbSet.AsNoTracking().CountAsync();\n        }\n\n        public async Task<int> CountAsync(Expression<Func<T, bool>> where)\n        {\n            return await _dbSet.AsNoTracking().CountAsync(@where);\n        }\n        #endregion\n\n\n\n    }\n}\n```\n\n\n\n## 创建实例\n\n添加RepositoryFactory类和IRepositoryFactory接口\n\n### IRepositoryFactory接口：\n\n```c#\npublic interface IRepositoryFactory\n{\n    IRepositorys < T > CreateRepository < T > (IconcardContext mydbcontext) where T: class;\n}\n```\n\n### RepositoryFactory类：\n\n```c#\npublic class RepositoryFactory: IRepositoryFactory\n{\n    public IRepositorys < T > CreateRepository < T > (IconcardContext mydbcontext) where T: class\n    {\n        return new Repositorys < T > (mydbcontext);\n    }\n}\n```\n\n## Service层\n\n添加BaseService类和IBaseService接口\n\n### IBaseService\n\n```c#\npublic interface IBaseService\n{\n    IRepositorys < T > CreateService < T > () where T: class, new();\n}\n```\n\n### BaseService\n\n```c#\npublic class BaseService: IBaseService\n{\n    private IRepositoryFactory _repositoryFactory;\n    private IconcardContext _mydbcontext;\n    public BaseService(IRepositoryFactory repositoryFactory, IconcardContext mydbcontext)\n    {\n        this._repositoryFactory = repositoryFactory;\n        this._mydbcontext = mydbcontext;\n    }\n    public IRepositorys < T > CreateService < T > () where T: class, new()\n    {\n        return _repositoryFactory.CreateRepository < T > (_mydbcontext);\n    }\n}\n```\n\n添加Service模块xxxService类和IxxxService接口，xxxService类继承父类BaseService，生成构造函数。\n\n```c#\n//构造函数 自动生成\npublic TypechoService(IRepositoryFactory repositoryFactory, IconcardContext mydbcontext) : base(repositoryFactory, mydbcontext)\n        {\n        }\n```\n\n## 依赖注入\n\n### 注册DbContext\n\n```c#\nservices.AddDbContext < typechoContext > (options => options.UseMySql(Configuration.GetConnectionString(\"DefaultConnection\")));\\\\\nappsettings.json \"ConnectionStrings\":\n{\n    \"DefaultConnection\": \"Server=localhost;database=typecho;uid=root;pwd=woshishui;\"\n}\n```\n\n```c#\nservices.AddScoped < IconcardContext, typechoContext > (); //dbc\nservices.AddScoped < IRepositoryFactory, RepositoryFactory > (); //泛型工厂\nservices.AddScoped < ITypechoTestService, TypechoService > (); //ioc\n```\n\n## UI层调用\n\n```c#\npublic class ReSnArticleService: BaseService, IReSnArticleService\n    {\n        private readonly CacheUtil _cache;\n        private int _resultInt;\n        private List < Article > _resultList;\n        public ReSnArticleService(ICacheUtil cacheUtil, IRepositoryFactory repositoryFactory, IConcardContext myDbcontext): base(repositoryFactory, myDbcontext)\n        {\n            _cache = (CacheUtil) cacheUtil;\n        }\n        public async Task < int > CountAsync()\n        {\n            _resultInt = _cache.CacheNumber1(\"CountAsync\", _resultInt);\n            if(_resultInt == 0)\n            {\n                _resultInt = await CreateService < Article > ().CountAsync();\n                _cache.CacheNumber1(\"CountAsync\", _resultInt);\n            }\n            return _resultInt;\n        }\n```\n\n\n\n',6,0,'17.jpg',0,41,3,4,'2023-07-27 16:40:52','2023-07-27 16:40:52'),
(467,'Axios','Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中进行HTTP请求,它提供了一种简单而强大的方式来发送异步请求，并处理响应数据。','# axios -未上片段\n\nAxios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中进行HTTP请求,它提供了一种简单而强大的方式来发送异步请求，并处理响应数据。\n\n```\nnpm install axios\n```\n\n## axios基础\n\n### 基本方法\n\n```csharp\naxios.request(config)\n//获取数据，请求指定的信息，返回实体对象\naxios.get(url[, config]) \n//请求服务器删除指定的数据\naxios.delete(url[, config])\naxios.head(url[, config])\naxios.options(url[, config])\n//向指定资源提交数据（例如表单提交或文件上传）\naxios.post(url[, data[, config]])\n//更新数据，从客户端向服务器传送的数据取代指定的文档的内容\naxios.put(url[, data[, config]])\n//更新数据，是对put方法的补充，用来对已知资源进行局部更新\naxios.patch(url[, data[, config]])\n```\n\n### 请求配置项\n\n下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。\n\n```js\n{\n  // 是用于请求的服务器URL\n  url: \"/user\",\n\n  // 是创建请求时使用的方法\n  method: \"get\", // 默认是 get\n\n  // 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。\n  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL\n  baseURL: \"https://some-domain.com/api/\",\n\n  // 允许在向服务器发送前，修改请求数据\n  // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法\n  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream\n  transformRequest: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  // 在传递给 then/catch 前，允许修改响应数据\n  transformResponse: [function (data) {\n    // 对 data 进行任意转换处理\n    return data;\n  }],\n\n  //是即将被发送的自定义请求头\n  headers: {\"X-Requested-With\": \"XMLHttpRequest\"},\n\n  //是即将与请求一起发送的 URL 参数\n  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象\n  params: {\n    ID: 12345\n  },\n\n  // 是一个负责 `params` 序列化的函数\n  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)\n  paramsSerializer: function(params) {\n    return Qs.stringify(params, {arrayFormat: \"brackets\"})\n  },\n\n  // 是作为请求主体被发送的数据\n  // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\"\n  // 在没有设置 `transformRequest` 时，必须是以下类型之一：\n  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams\n  // - 浏览器专属：FormData, File, Blob\n  // - Node 专属： Stream\n  data: {\n    firstName: \"Fred\"\n  },\n\n  // 指定请求超时的毫秒数(0 表示无超时时间)\n  // 如果请求花费了超过 `timeout` 的时间，请求将被中断\n  timeout: 1000,\n\n  // 表示跨域请求时是否需要使用凭证\n  withCredentials: false, // 默认的\n\n  // 允许自定义处理请求，以使测试更轻松\n  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).\n  adapter: function (config) {\n    /* ... */\n  },\n\n  // 表示应该使用 HTTP 基础验证，并提供凭据\n  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头\n  auth: {\n    username: \"janedoe\",\n    password: \"s00pers3cret\"\n  },\n\n  // 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\"\n  responseType: \"json\", // 默认的\n\n  // 是用作 xsrf token 的值的cookie的名称\n  xsrfCookieName: \"XSRF-TOKEN\", // default\n\n  // 是承载 xsrf token 的值的 HTTP 头的名称\n  xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的\n\n  // 允许为上传处理进度事件\n  onUploadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // 允许为下载处理进度事件\n  onDownloadProgress: function (progressEvent) {\n    // 对原生进度事件的处理\n  },\n\n  // 定义允许的响应内容的最大尺寸\n  maxContentLength: 2000,\n\n  // 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte\n  validateStatus: function (status) {\n    return status >= 200 && status < 300; // 默认的\n  },\n\n  // 定义在 node.js 中 follow 的最大重定向数目\n  // 如果设置为0，将不会 follow 任何重定向\n  maxRedirects: 5, // 默认的\n\n  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：\n  // `keepAlive` 默认没有启用\n  httpAgent: new http.Agent({ keepAlive: true }),\n  httpsAgent: new https.Agent({ keepAlive: true }),\n\n  // 定义代理服务器的主机名称和端口\n  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据\n  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。\n  proxy: {\n    host: \"127.0.0.1\",\n    port: 9000,\n    auth: : {\n      username: \"mikeymike\",\n      password: \"rapunz3l\"\n    }\n  },\n\n  // 指定用于取消请求的 cancel token\n  // （查看后面的 Cancellation 这节了解更多）\n  cancelToken: new CancelToken(function (cancel) {\n  })\n}\n```\n\n### 响应结构\n\naxios请求的响应包含以下信息：\n\n```js\n{\n  // 由服务器提供的响应\n  data: {},\n  // HTTP 状态码\n  status: 200,\n  // 来自服务器响应的 HTTP 状态信息\n  statusText: \"OK\",\n  // 服务器响应的头\n  headers: {},\n  // 是为请求提供的配置信息\n  config: {}\n}\n```\n\n使用 then 时，会接收下面这样的响应：\n\n```js\naxios.get(''/user/12345'').then(function (response) {\n  console.log(response.data);\n  console.log(response.status);\n  console.log(response.statusText);\n  console.log(response.headers);\n  console.log(response.config);\n});\n```\n\n### 配置默认值\n\n你可以指定将被用在各个请求的配置默认值。\n\n全局的 axios 默认值：\n\n```js\naxios.defaults.baseURL = ''https://api.example.com'';\naxios.defaults.headers.common[''Authorization''] = AUTH_TOKEN;\naxios.defaults.headers.post[''Content-Type''] = ''application/x-www-form-urlencoded'';\n```\n\n自定义实例默认值：\n\n```js\n// 创建实例时设置配置的默认值\nvar instance = axios.create({\n  baseURL: ''https://api.example.com''\n});\n\n// 在实例已创建后修改默认值\ninstance.defaults.headers.common[''Authorization''] = AUTH_TOKEN;\n```\n\n### 配置优先顺序\n\n配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：\n\n```js\n// 使用由库提供的配置的默认值来创建实例\n// 此时超时配置的默认值是 `0`\nvar instance = axios.create();\n\n// 覆写库的超时默认值\n// 现在，在超时前，所有请求都会等待 2.5 秒\ninstance.defaults.timeout = 2500;\n\n// 为已知需要花费很长时间的请求覆写超时设置\ninstance.get(''/longRequest'', {\n  timeout: 5000\n});\n```\n\n### 拦截器\n\n在请求或响应被 then 或 catch 处理前拦截它们。\n\n```js\n// 添加请求拦截器\naxios.interceptors.request.use(\n  function (config) {\n    // 在发送请求之前做些什么\n    return config;\n  },\n  function (error) {\n    // 对请求错误做些什么\n    return Promise.reject(error);\n  }\n);\n\n// 添加响应拦截器\naxios.interceptors.response.use(\n  function (response) {\n    // 对响应数据做点什么\n    return response;\n  },\n  function (error) {\n    // 对响应错误做点什么\n    return Promise.reject(error);\n  }\n);\n```\n\n如果你想在稍后移除拦截器，可以这样：\n\n```js\nvar myInterceptor = axios.interceptors.request.use(function () {\n  /*...*/\n});\naxios.interceptors.request.eject(myInterceptor);\n```\n\n可以为自定义 axios 实例添加拦截器。\n\n```js\nvar instance = axios.create();\ninstance.interceptors.request.use(function () {\n  /*...*/\n});\n```\n\n错误处理：\n\n```js\naxios.get(''/user/12345'').catch(function (error) {\n  if (error.response) {\n    // 请求已发出，但服务器响应的状态码不在 2xx 范围内\n    console.log(error.response.data);\n    console.log(error.response.status);\n    console.log(error.response.headers);\n  } else {\n    // Something happened in setting up the request that triggered an Error\n    console.log(''Error'', error.message);\n  }\n  console.log(error.config);\n});\n```\n\n使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。\n\n```js\naxios.get(''/user/12345'', {\n  validateStatus: function (status) {\n    return status < 500; // 状态码在大于或等于500时才会 reject\n  }\n});\n```\n\n### 取消请求\n\n使用 cancel token 取消请求。\n\nAxios 的 cancel token API 基于[cancelable promises proposal](https://github.com/tc39/proposal-cancelable-promises)\n\n可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：\n\n```js\nvar CancelToken = axios.CancelToken;\nvar source = CancelToken.source();\n\naxios\n  .get(''/user/12345'', {\n    cancelToken: source.token\n  })\n  .catch(function (thrown) {\n    if (axios.isCancel(thrown)) {\n      console.log(''Request canceled'', thrown.message);\n    } else {\n      // 处理错误\n    }\n  });\n\n// 取消请求（message 参数是可选的）\nsource.cancel(''Operation canceled by the user.'');\n```\n\n还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：\n\n```js\nvar CancelToken = axios.CancelToken;\nvar cancel;\n\naxios.get(''/user/12345'', {\n  cancelToken: new CancelToken(function executor(c) {\n    // executor 函数接收一个 cancel 函数作为参数\n    cancel = c;\n  })\n});\n\n// 取消请求\ncancel();\n```\n\n**注意**：可以使用同一个 cancel token 取消多个请求。\n\n### 请求时使用application/x-www-form-urlencoded\n\naxios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。\n\n**浏览器**\n\n在浏览器环境，你可以使用 URLSearchParams API：\n\n```js\nconst params = new URLSearchParams();\nparams.append(''param1'', ''value1'');\nparams.append(''param2'', ''value2'');\naxios.post(''/foo'', params);\n```\n\n\n\n## 封装axios\n\n### axios\n\n```tsx\n// import axios from ''axios''\nimport qs from ''qs''\nimport { message } from ''ant-design-vue''\nimport router from ''@/router/index''\nimport { useUiSetStore } from ''@store/modules/uiSettings''\n\nimport { storage } from ''@/utils/storage/storage''\nimport { removePending, addPending } from ''./pending''\nimport { removeUserStorage } from ''@/utils/user/user-info''\nimport { AxiosRequestConfig, AxiosResponse } from ''axios''\n\n// 全局配置\nconst apiUrl = import.meta.env.VITE_API_DOMAIN\naxios.defaults.withCredentials = false\naxios.defaults.headers.post[''Content-Type''] = ''application/json;charset=UTF-8''\n// 允许跨域\naxios.defaults.headers.post[''Access-Control-Allow-Origin''] = ''*''\nlet uiSettings: any = ref()\nfunction myAxios(axiosConfig: any, customOptions: any, loadings: any): Promise<AxiosResponse> {\n  const { timeout = 8000 } = customOptions\n  const service = axios.create({\n    baseURL: apiUrl, // 设置统一的请求前缀\n    timeout // 设置统一的超时时长\n  })\n\n  // 是否开启/取消重复请求\n  const cancel = {\n    cancel_request: false,\n    ...customOptions\n  }\n\n  // 是否开启loading, 默认为 false\n  const loading = {\n    loading: loadings.loading\n  }\n  // 请求拦截器\n  service.interceptors.request.use(\n    (config: AxiosRequestConfig) => {\n      const { method, data, headers } = config\n      removePending(config)\n      cancel.cancel_request && addPending(config)\n\n      if ([''post'', ''put'', ''delete''].includes(method as string)) {\n        config.data = qs.parse(data) //序列化\n      }\n      // 若是有做鉴权token , 就给头部带上token\n      if (storage.get(''token'')) {\n        if (headers) {\n          headers.Authorization = storage.get(''token'') as string\n        }\n      }\n      // 请求之前发送loading\n      if (loading.loading) {\n        uiSettings.uiLoadingVisible = true\n      }\n      return config\n    },\n    error => {\n      message.error(error.data.error.message)\n      return Promise.reject(error.data.error.message)\n    }\n  )\n  // 响应拦截器\n  service.interceptors.response.use(\n    (res: AxiosResponse<any>) => {\n      //挂载 不然报错\n      uiSettings = useUiSetStore()\n      // 在请求结束后，移除本次请求\n      removePending(res)\n      // 请求之后关闭loading\n      if (loading.loading) {\n        setTimeout(function () {\n          uiSettings.uiLoadingVisible = false\n        }, 500)\n      }\n      // 对响应数据进行处理，例如检查统一的字段（如 statusCode)\n      if (res.status === 200 || res.data.statusCode === 200) {\n        return Promise.resolve(res)\n      }\n      return Promise.reject(res)\n    },\n    error => {\n      uiSettings.uiLoadingVisible = false\n\n      const statusTextMap: Record<number, string> = {\n        400: ''发出的请求有错误，服务器没有进行新建或修改数据的操作'',\n        401: ''登录失效，请重新登录'',\n        403: ''用户得到授权，但是访问是被禁止的'',\n        404: ''网络请求不存在'',\n        406: ''请求的格式不可得'',\n        410: ''请求的资源被永久删除，且不会再得到的'',\n        422: ''当创建一个对象时，发生一个验证错误'',\n        500: ''服务器发生错误，请检查服务器'',\n        502: ''网关错误'',\n        503: ''服务不可用，服务器暂时过载或维护'',\n        504: ''网关超时''\n      }\n\n      if (error.response && error.response.status) {\n        const statusText = statusTextMap[error.response.status] ?? ''其他错误''\n        message.error(`${statusText}(${error.response.status})`)\n        if (error.response.status === 401) {\n          removeUserStorage()\n          router.replace({\n            path: ''/Login''\n          })\n        }\n        return Promise.reject(error)\n      }\n\n      return Promise.reject(new Error(''网络请求失败，请稍后重试''))\n    }\n  )\n  return service(axiosConfig)\n}\nexport default myAxios\n```\n\n### 重复请求\n\npending.ts\n\n```js\nimport qs from ''qs''\n\n// 声明一个 Map 用于存储每个请求的标识 和 取消函数\nconst pending = new Map()\n/**\n * 添加请求\n * @param {Object} res\n */\nexport const addPending = (res: any) => {\n  const url = [res.method, res.url, qs.stringify(res.params), qs.stringify(res.data)].join(''&'')\n  res.cancelToken =\n    res.cancelToken ||\n    new axios.CancelToken(cancel => {\n      if (!pending.has(url)) {\n        // 如果 pending 中不存在当前请求，则添加进去\n        pending.set(url, cancel)\n        // console.log(''[ 添加请求 ]=>'', url)\n      }\n    })\n}\n/**\n * 移除请求\n * @param {Object} config\n */\nexport const removePending = (config: any) => {\n  const url = [config.method, config.url, qs.stringify(config.params), qs.stringify(config.data)].join(''&'')\n  if (pending.has(url)) {\n    // 如果在 pending 中存在当前请求标识，需要取消当前请求，并且移除\n    const cancel = pending.get(url)\n    cancel(url)\n    pending.delete(url)\n    // console.log(''[ 移除请求 ]=>'', url)\n  }\n}\n/**\n * 清空 pending 中的请求（在路由跳转时调用）\n */\nexport const clearPending = () => {\n  // eslint-disable-next-line no-restricted-syntax\n  for (const [url, cancel] of pending) {\n    cancel(url)\n    // console.log(''[ 清空请求 ]=>'', url)\n  }\n  pending.clear()\n}\n\n```\n\n### 封装增删改查\n\n```js\nimport { AxiosRequestConfig } from ''axios''\nimport request from ''@/api/http/axios''\n\n/**\n * request method types\n */\nexport enum REQUEST_METHODS {\n  GET = ''GET'',\n  PUT = ''PUT'',\n  UPDATE = ''PUT'',\n  upPost = ''POST'',\n  POST = ''POST'',\n  ADD = ''POST'',\n  DELETE = ''DELETE'',\n  REMOVE = ''DELETE''\n}\n\n\nexport async function get(url: string, params?: any, loading?: boolean) {\n  const result = await request(\n    {\n      url,\n      method: REQUEST_METHODS.GET,\n      params\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n  return result\n}\n\nexport function gets<T = any>(config: AxiosRequestConfig) {\n  return request(config, false, true).then(res => {\n    return (res.data.data || res.data) as T\n  })\n}\n\n\nexport function add(url: string, data: any, loading?: boolean) {\n  return request(\n    {\n      url,\n      method: REQUEST_METHODS.ADD,\n      data\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n}\n\nexport function pot(url: string, loading?: boolean) {\n  return request(\n    {\n      url,\n      method: REQUEST_METHODS.POST\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n}\n\n\nexport function update(url: string, data: any, loading?: boolean) {\n  return request(\n    {\n      url,\n      method: REQUEST_METHODS.UPDATE,\n      data\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n}\n\nexport function upPost(url: string, data: any, loading?: boolean) {\n  return request(\n    {\n      url,\n      method: REQUEST_METHODS.upPost,\n      data\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n}\n\n\nexport function del(url: string, data?: any, loading?: boolean) {\n  return request(\n    {\n      url,\n      method: REQUEST_METHODS.DELETE,\n      data\n    },\n    {\n      cancel_request: false\n    },\n    {\n      loading\n    }\n  )\n}\n\n```\n\n### 接口调用\n\n```tsx\nimport { IArticle } from ''@/api/data/InterData''\nimport { Tool } from ''@/utils/common/common-tool''\nimport { get, add, update, del } from ''@/api/http/funApi''\n\nexport class ArticleApi {\n\n  /**\n   * @description: 主键查询\n   * @param {number} id\n   * @param {boolean} cache\n   */\n  static getById(id: number, cache = false) {\n    return get(`/article/byid?id=${id}&cache=${cache}`, false, true)\n  }\n\n  /**\n   * @description: 新增数据\n   * @param {IArticle} entity\n   */\n  static add(entity: IArticle) {\n    return add(''/article/add'', entity)\n  }\n\n  /**\n   * @description: 更新数据\n   * @param {IntArticle} entity\n   */\n  static update(entity: IArticle) {\n    return update(`/article/edit`, entity)\n  }\n\n  /**\n   * @description: 删除\n   * @param {number} id\n   */\n  static del(id: number) {\n    return del(`/article/del?id=${id}`, false)\n  }\n}\n\n```\n\n### 并发请求\n\n处理并发请求的助手函数\n\naxios.all(iterable)\n\naxios.spread(callback)\n\n```js\n//示例:\nimport { article } from ''@/api/index'';\nimport { blogsList } from \"./components/data\";\nimport axios from ''@/utils/http/axios''\nclass methods {\n  static async GetFySortTitle() {\n    await article.GetFySortTitleAsync(blogsList.page, blogsList.pagesize, true).then((res: any) => {\n      blogsList.dataResult = res.data;\n    });\n  }\n  static async ConutSort() {\n    await article.ConutSort(7).then((result: any) => {\n      blogsList.count = result.data;\n    });\n  }\n}\n  axios.all([await methods.ConutSort(), await methods.GetFySortTitle()])\n\nawait axios.all([await classify.GetAll(), await tags.GetAll(),\n  await method.ClassTypeFy(0, state.typeStr, 1, state.pagesize),\n  await method.GetFy(0, ''null'')])\n    .then(axios.spread((res1: any, res2: any) => {\n      resClassify.value = res1.data.data,\n        resTag.value = res2.data.data\n    }))\n}\n\nexport {\n  methods,\n  QueryAll\n}\n```\n\n## loading\n\n### 定义组件\n\n**SAspin.vue**\n\n```html\n<script lang=\"ts\" setup>\nimport { loadingVisible } from ''@/utils/common/visible-data''\nloadingVisible.value = true\n</script>\n<template>\n  <div v-show=\"loadingVisible\" class=\"spinner\">\n    <div class=\"cube1\"></div>\n    <div class=\"cube2\"></div>\n  </div>\n</template>\n\n<style lang=\"scss\" scoped>\nsection {\n  @apply top-0 left-0 z-3000 fixed;\n  @apply h-full w-full;\n\n  div {\n    @apply top-5/10 left-5/10 absolute;\n  }\n}\n\n.spinner {\n  @apply top-0 left-0 bottom-0 right-0 m-auto z-3000 fixed;\n  @apply w-5 h-5;\n}\n\n.cube1,\n.cube2 {\n  @apply absolute top-0 left-0 w-3 h-3 bg-blue-300;\n\n  animation: sk-cubemove 1.8s infinite ease-in-out;\n}\n\n.cube2 {\n  animation-delay: -0.9s;\n}\n\n@keyframes sk-cubemove {\n  25% {\n    transform: translateX(20px) rotate(-90deg) scale(0.5);\n  }\n\n  50% {\n    transform: translateX(20px) translateY(20px) rotate(-180deg);\n  }\n\n  75% {\n    transform: translateX(0) translateY(20px) rotate(-270deg) scale(0.5);\n  }\n\n  100% {\n    transform: rotate(-360deg);\n  }\n}\n\n@keyframes sk-cubemove {\n  25% {\n    transform: translateX(20px) rotate(-90deg) scale(0.5);\n  }\n\n  50% {\n    transform: translateX(20px) translateY(20px) rotate(-179deg);\n  }\n\n  50.1% {\n    transform: translateX(20px) translateY(20px) rotate(-180deg);\n  }\n\n  75% {\n    transform: translateX(0) translateY(20px) rotate(-270deg) scale(0.5);\n  }\n\n  100% {\n    transform: rotate(-360deg);\n  }\n}\n</style>\n\n```\n\n**data.ts**\n\n```js\n/**\n * 是否展示加载框\n */\nexport const loading = ref(false)\n```\n\n### App.vue 中引入\n\n```html\n<template>\n  <div id=\"app\">\n    <router-view> </router-view>\n    <base-aspin></base-aspin>\n  </div>\n</template>\n```\n\n### 调用loading\n\n```js\n// 请求拦截器\naxios.interceptors.request.use(config = >{\n    if (config.loading) {\n      config.loading.value = true\n    }\n})\n// 响应拦截器\naxios.interceptors.response.use(\n    response => {\n        if (response.config.loading) {\n            res.config.loading.value = false\n        }\n    },\n    error => {\n        if (error.config.loading) {\n            config.loading.value = false\n        }\n    }\n)\n```\n\n\n\n## 请求重试\n\n安装 [axios-retry](https://link.juejin.cn/?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Faxios-retry)，可以让你的 Axios请求失败后自动重试\n\n```\nnpm install axios-retry\n```\n\n\n\n```js\n//axios.ts\nimport axiosRetry from ''axios-retry''\n\nconst client = Axios.create({\n  // 你的配置\n})\n\n  // 安装 retry 插件\n  // 当请求失败后，自动重新请求，只有3次失败后才真正失败\n  axiosRetry(service, {\n    retries: 3, // 设置自动发送请求次数\n    retryDelay: () => {\n      return 300\n    }, // 重新请求的间隔\n    shouldResetTimeout: true //  重置超时时间\n  })\n\nexport async function request(url: string, config?: AxiosRequestConfig) {\n  const response = await client.request({ url, ...config })\n  const result = response.data\n  // 你的业务判断逻辑\n  return result\n}\n\n// 只有3次失败后才真正失败\nconst data = request(''http://example.com/test'')\n```\n\n## URI版本控制\n\n有开发 Web API 经验的人都会遇到一个问题，如果 API 出现重大变更的时候，如何保证旧版可用的情况下，发布新的 API?\n\n这种情况在服务端开发场景中，其实并不罕见，尤其是对外公开的 API，如: 豆瓣 API (已失效)。\n\n当前主流的支持 3 种类型的版本控制：\n\n| 类型                  | 描述                              |\n| --------------------- | --------------------------------- |\n| URI Versioning        | 版本将在请求的 URI 中传递（默认） |\n| Header Versioning     | 自定义请求标头将指定版本          |\n| Media Type Versioning | Accept 请求的标头将指定版本       |\n\n**URI 版本控制** 是指在请求的 URI 中传递的版本，例如 `https://example.com/v1/route` 和 `https://example.com/v2/route`。\n\n```ts\nimport Axios, { AxiosRequestConfig } from ''axios'';\n\nconst client = Axios.create({\n  // 你的配置\n});\n\nclient.interceptors.request.use((config) => {\n  // 最简单的方案\n  config.url = config.url.replace(''{version}'', ''v1'');\n  return config;\n});\n\n// GET /api/v1/users\nrequest(''/api/{version}/users'');\n```\n\n\n\n## 问题解决\n\n### 头信息中存在中文\n\nAXIOS String contains non ISO-8859-1 code point.\n\n**原因**\n\n在头信息中存在中文，需要对其进行编码。\n\n**解决方法**\n\n使用 encodeURIComponent()对中文信息进行编码即可。\n\n```tsx\nif (storage.get(store.state.Roles)) {\n  req.headers.Authorization = encodeURIComponent(storage.get(store.state.Roles)) as string;\n}\n```\n\n### 请求超时\n\n我们更改 node 服务延时响应来制造超时效果\n\n```js\n// app.js\napp.get(''/api/list'', (req, res) => {\n  setTimeout(() => {\n    res.end();\n  }, 150000);\n});\n```\n\n### 提示 Object is possibly ‘null‘\n\n```tsx\nlet table = document.querySelector(''body'');\nif (table) {\n  table.setAttribute(''style'', ''background-color:#f7f7f7'');\n}\n// document\n//   .querySelector(\"body\")\n//   .setAttribute(\"style\", \"background-color:#f7f7f7\");\n```\n\n',7,0,'21.jpg',0,4,109,4,'2023-08-01 17:59:39','2023-08-01 18:07:42'),
(468,'csharp','csharp','## 编码规范\n\n#### 命名基本约定\n\n| **标识符** | **大小写** | **示例**                                 |\n| ---------- | ---------- | ---------------------------------------- |\n| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |\n| 类型       | Pascal     | public class DevsList                    |\n| 接口       | Pascal     | public interface ITableModel             |\n| 方法       | Pascal     | public void UpdateData()                 |\n| 属性       | Pascal     | Public int Length{…}                     |\n| 事件       | Pascal     | public event EventHandler Changed;       |\n| 私有字段   | Camel      | private string fieldName;                |\n| 非私有字段 | Pascal     | public string FieldName；                |\n| 枚举值     | Pascal     | FileMode{Append}                         |\n| 参数       | Camel      | public void UpdateData(string fieldName) |\n| 局部变量   | Camel      | string fieldName;                        |\n\n#### 命名规范\n\n- Pascal法：首字母大写，连接词的首字母也都大写\n  →GetInfo\n- Camel：第一个单词的首字母小写\n  →getInfo\n- MENTIONS:\n\n1. 成员变量最好加一个“_”\n2. 接口的名称前加前缀“*I*”\n\n#### 代码编写规则\n\n- 尽量使用接口\n- 局部变量尽量在最接近的地方使用\n- 不要使用goto系列语句（除非是在跳出深层循环时）\n- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型\n- switch语句要有**default**来处理意外情况\n\n## 基础知识\n\n### 访问修饰符\n\n- public:公有访问，不受任何限制。\n- private:私有访问，只限于本类成员访问。\n- protected:受保护的，只限于本类和子类访问。\n- internal:内部访问，只限于本项目内访问，其他的不能访问\n- protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问\n\n### 集合类的声明 \n\n声明一个List\n\n```c#\nList<string> list = new List<string>();\nlist.Add(\"a一\");\nlist.Add(\"b二\");\n\n//语法糖\nList<string> list = new List<string> {\"def\",\"OK\"};\n```\n\n遍历集合中的项：\n\n```c#\nforeach (string item in list)\n{\n  Console.WriteLine(item);\n}\n//语法糖\nlist.ForEach(a => Console.WriteLine(a));\n```\n\n1\n\n### using等于try finally\n\n使用完释放资源，经常要用using，using实质上就是try fiannaly的一个语法糖\n\n```c#\nStreamWriter sw = null;\ntry\n{\n    sw = new StreamWriter(\"d:\\abc.txt\");\n    sw.WriteLine(\"test\");\n}\nfinally {\n    if(sw!= null) sw.Dispose();\n}\n```\n\n简化为：\n\n```c#\nusing (var sw = new StreamWriter(\"d:\\abc.txt\")) {\n    sw.WriteLine(\"test\");\n}\n```\n\n### 问号的演变\n\n表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值\n\n```c#\nstring a = null;\nvar b = a??””;\n```\n\n### 类型实例化\n\n```c#\npublic class Abc\n{\n    public int ID {get; set; }\n    public string Name { get; set; }\n}\n\npublic static void Main(string[] args)\n{\n  var abc = new Abc\n  {\n    ID = 1,\n    Name = \"yukaizhao\",\n  };\n}\n```\n\n### 匿名类\n\n匿名类在linq to sql或者entity framework中返回查询数据时很好用。\n\n```csharp\nvar a = new {\n    ID = 1,\n    Name=”yukaizhao”,\n};\n```\n\n### NULL条件运算符\n\n```csharp\n//使用代码\nCustomer customer = new Customer();\nstring name = customer?.Name;\n\n//编译代码\nCustomer customer = new Customer();\nif (customer != null)\n{\n    string name = customer.Name;\n}\n//和??组合起来使用\nif (customer?.Face()??false)\n还可以两个一起组合来使用\nint? contactNameLen = contact?.Name?.Length; \n```\n\n在对象使用前检查是否为null。如对象空，则赋值给变量为空值，所以例子中需要一个为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。\n\n### 字符串格式化\n\nString.Format，使用{0}占位符、必须顺序来格式化、这点容易出错。\n\n```csharp\n    var contactInfo = string.Format(\"Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}\", \n    contact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);\n\n    //新的语法\n    var contactInfo2 = $\"Id:{contact.Id} Name:{contact.Name} EmailAddr:\n    {contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n\n    //新格式化方式还支持任何表达式的直接赋值：\n    var contactInfo = $\"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? \"Frank\" : \n    contact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n\n\n\n## 类型转换\n\n| 序号 | 方法 & 描述                                                  |\n| ---- | ------------------------------------------------------------ |\n| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |\n| 2    | **ToByte** 把类型转换为字节类型。                            |\n| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |\n| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |\n| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |\n| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |\n| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |\n| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |\n| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |\n| 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |\n| 11   | **ToSingle** 把类型转换为小浮点数类型。                      |\n| 12   | **ToString** 把类型转换为字符串类型。                        |\n| 13   | **ToType** 把类型转换为指定类型。                            |\n| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |\n| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |\n| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |\n\n###  int.TryParse()\n\n```csharp\npublic static bool TryParse(string s, out Int32 result);\n```\n\n转换成功返回true,否则返回false\n\n```csharp\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n\n### string转换枚举类型\n\n枚举 字段 = （枚举）Enum.Pares(typeof(枚举)，转换的字段)；\n\n```csharp\n QQ state = (QQ) Enum.Pares(typeof(QQ )，str);\n```\n\n\n\n## 工具类\n\n### c#时间工具类\n\n```csharp\nusing System;\nnamespace ToolBox.DateTimeTool\n{\n    public static class DateTimeExtend\n    {\n        /// <summary>\n        /// 获取本日开始时间（0点0分0秒）\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetDayStart(this DateTime dateTime)\n        {\n            return dateTime.Date;\n        }\n\n        /// <summary>\n        /// 获取本日结束时间（23点59分59秒）\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetDayEnd(this DateTime dateTime)\n        {\n            return dateTime.Date.AddDays(1).AddMilliseconds(-1);\n        }\n\n        /// <summary>\n        /// 获取本周开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetWeekStart(this DateTime dateTime)\n        {\n            return dateTime.AddDays(-(int)dateTime.DayOfWeek + 1).GetDayStart();\n        }\n\n        /// <summary>\n        /// 获取本周结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetWeekEnd(this DateTime dateTime)\n        {\n            return dateTime.AddDays(7 - (int)dateTime.DayOfWeek).GetDayEnd();\n        }\n\n        /// <summary>\n        /// 获取本月开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetMonthStart(this DateTime dateTime)\n        {\n            return new DateTime(dateTime.Year, dateTime.Month, 1, 0, 0, 0, 0);\n        }\n\n        /// <summary>\n        /// 获取本月结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetMonthEnd(this DateTime dateTime)\n        {\n            return GetMonthStart(dateTime).AddMonths(1).AddMilliseconds(-1);\n        }\n\n        /// <summary>\n        /// 获取本季度开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetSeasonStart(this DateTime dateTime)\n        {\n            var time = dateTime.AddMonths(0 - ((dateTime.Month - 1) % 3));\n            return DateTime.Parse(time.AddDays(-time.Day + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n        }\n\n        /// <summary>\n        /// 获取本季度结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetSeasonEnd(this DateTime dateTime)\n        {\n            var time = dateTime.AddMonths((3 - ((dateTime.Month - 1) % 3) - 1));\n            return DateTime.Parse(time.AddMonths(1).AddDays(-time.AddMonths(1).Day + 1).AddDays(-1).ToString(\"yyyy/MM/dd 23:59:59\"));\n        }\n\n        /// <summary>\n        /// 获取本年开始时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetYearStart(this DateTime dateTime)\n        {\n            return DateTime.Parse(dateTime.AddDays(-dateTime.DayOfYear + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n        }\n\n        /// <summary>\n        /// 获取本年结束时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime GetYearEnd(this DateTime dateTime)\n        {\n            var time2 = dateTime.AddYears(1);\n            return DateTime.Parse(time2.AddDays(-time2.DayOfYear).ToString(\"yyyy/MM/dd 23:59:59\"));\n        }\n\n        /// <summary>\n        /// 北京时间转换成unix时间戳(10位/秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long BeijingTimeToUnixTimeStamp10(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalSeconds;\n        }\n\n        /// <summary>\n        /// 格林威治时间转换成unix时间戳(10位/秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long UtcTimeToUnixTimeStamp10(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 0, 0, 0)).TotalSeconds;\n        }\n\n        /// <summary>\n        /// 北京时间转换成unix时间戳(13位/毫秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long BeijingTimeToUnixTimeStamp13(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalMilliseconds;\n        }\n\n        /// <summary>\n        /// 格林威治时间转换成unix时间戳(13位/毫秒)\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static long UtcTimeToUnixTimeStamp13(this DateTime dateTime)\n        {\n            return (long)(dateTime - new DateTime(1970, 1, 1, 0, 0, 0)).TotalMilliseconds;\n        }\n\n        /// <summary>\n        /// 10位unix时间戳转换成北京时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp10ToBeijingTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 8, 0, 0).AddSeconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 10位unix时间戳转换成格林威治\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp10ToUtcTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 0, 0, 0).AddSeconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 13位unix时间戳转换成北京时间\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp13ToBeijingTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 8, 0, 0).AddMilliseconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 13位unix时间戳转换成格林威治\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static DateTime UnixTimeStamp13ToUtcTime(this long unixTimeStamp)\n        {\n            return new DateTime(1970, 1, 1, 0, 0, 0).AddMilliseconds(unixTimeStamp);\n        }\n\n        /// <summary>\n        /// 当前日期所在月份第一个指定星期几的日期\n        /// </summary>\n        /// <param name=\"date\">给定日期</param>\n        /// <param name=\"dayOfWeek\">星期几</param>\n        /// <returns>所对应的日期</returns>\n        public static DateTime GetFirstWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n        {\n            var dt = date.GetMonthStart();\n            while (dt.DayOfWeek != dayOfWeek)\n                dt = dt.AddDays(1);\n\n            return dt;\n        }\n\n        /// <summary>\n        /// 当前日期所在月份最后1个指定星期几的日期\n        /// </summary>\n        /// <param name=\"date\">给定日期</param>\n        /// <param name=\"dayOfWeek\">星期几</param>\n        /// <returns>所对应的日期</returns>\n        public static DateTime GetLastWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n        {\n            var dt = date.GetMonthEnd();\n            while (dt.DayOfWeek != dayOfWeek)\n                dt = dt.AddDays(-1);\n\n            return dt;\n        }\n\n        /// <summary>\n        /// 判断是否比指定之间早\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <param name=\"other\"></param>\n        /// <returns></returns>\n        public static bool IsBefore(this DateTime date, DateTime other)\n        {\n            return date < other;\n        }\n\n        /// <summary>\n        /// 判断是否比指定时间晚\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <param name=\"other\"></param>\n        /// <returns></returns>\n        public static bool IsAfter(this DateTime date, DateTime other)\n        {\n            return date > other;\n        }\n\n        /// <summary>\n        /// 给定日期所在月份共有多少天\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static int GetCountDaysOfMonth(this DateTime date)\n        {\n            return date.GetMonthEnd().Day;\n        }\n\n        /// <summary>\n        /// 当前日期与给定日期是否是同一天\n        /// </summary>\n        /// <param name=\"date\">当前日期</param>\n        /// <param name=\"dateToCompare\">给定日期</param>\n        /// <returns></returns>\n        public static bool IsDateEqual(this DateTime date, DateTime dateToCompare)\n        {\n            return date.Date == dateToCompare.Date;\n        }\n\n        /// <summary>\n        /// 是否是周未\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsWeekend(this DateTime date)\n        {\n            return date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday;\n        }\n\n        /// <summary>\n        /// 是否是工作日\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsWeekDay(this DateTime date)\n        {\n            return !date.IsWeekend();\n        }\n\n        /// <summary>\n        /// 判断是否为今天\n        /// </summary>\n        /// <param name=\"date\"></param>\n        /// <returns></returns>\n        public static bool IsToday(this DateTime date)\n        {\n            return date.Date == DateTime.Now.Date;\n        }\n\n        /// <summary>\n        /// 判定公历闰年遵循的一般规律为：四年一闰，百年不闰，四百年再闰。\n        /// 公历闰年的精确计算方法：（按一回归年365天5小时48分45.5秒）\n        /// 普通年能被4整除而不能被100整除的为闰年。 （如2004年就是闰年，1900年不是闰年）\n        /// 世纪年能被400整除而不能被3200整除的为闰年。 (如2000年是闰年，3200年不是闰年)\n        /// 对于数值很大的年份能整除3200,但同时又能整除172800则又是闰年。(如172800年是闰年，86400年不是闰年）\n        /// 公元前闰年规则如下：\n        /// 非整百年：年数除4余数为1是闰年，即公元前1、5、9……年；\n        /// 整百年：年数除400余数为1是闰年，年数除3200余数为1，不是闰年,年数除172800余1又为闰年，即公元前401、801……年。\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static bool IsLeap(this DateTime dateTime)\n        {\n            var year = dateTime.Year;\n            if ((year % 400 == 0 && year % 3200 != 0)\n               || (year % 4 == 0 && year % 100 != 0)\n               || (year % 3200 == 0 && year % 172800 == 0))\n                return true;\n            else\n                return false;\n        }\n\n        /// <summary>\n        /// 获取当前年天数\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static int GetDaysByYear(this DateTime dateTime)\n        {\n            return (new DateTime(dateTime.Year + 1, 1, 1) - new DateTime(dateTime.Year, 1, 1)).Days;\n        }\n\n        /// <summary>\n        /// 获取当前年天数\n        /// </summary>\n        /// <param name=\"dateTime\"></param>\n        /// <returns></returns>\n        public static int GetWeekCountByYear(this DateTime dateTime)\n        {\n            //找到今年的第一天是周几\n            int firstWeekend = Convert.ToInt32(DateTime.Parse(dateTime.Year + \"-1-1\").DayOfWeek);\n\n            //获取第一周的差额,如果是周日，则firstWeekend为0，第一周也就是从周天开始的。\n            int weekDay = firstWeekend == 0 ? 1 : (7 - firstWeekend + 1);\n\n            //获取今天是一年当中的第几天\n            int currentDay = dateTime.DayOfYear;\n\n            //（今天 减去 第一周周末）/7 等于 距第一周有多少周 再加上第一周的1 就是今天是今年的第几周了\n            //    刚好考虑了惟一的特殊情况就是，今天刚好在第一周内，那么距第一周就是0 再加上第一周的1 最后还是1\n            int current_week = Convert.ToInt32(Math.Ceiling((currentDay - weekDay) / 7.0)) + 1;\n            return current_week;\n        }\n\n    }\n}\n```\n\n',3,0,'21.jpg',0,4,109,4,'2023-08-01 18:11:08','2023-08-01 18:12:01'),
(469,'VS2019快捷键大全','快捷键大全','### 较常用快捷键\n\n```haxe\nCtrl + E + D = 代码格式化1\nCtrl + K + F = 代码快速格式化2\nCtrl + E + C = 注释代码1\nCtrl + K + C = 注释代码2\nCtrl + E + U = 取消注释代码1\nCtrl + K + U = 取消注释代码2\nTab + Tab = 代码联想\nAlt + Enter = 快速引用\nCtrl + Shift + C 新建类\nCtrl + E + E = 在交互窗口中运行选中代码(很实用)\nF6 = 生成(整个解决方案中类库)\nShift + F6 = 生成(当前类库)\nCtrl + R + G = 删除无效Using\nCtrl + H = 批量替换\nCtrl + G = 跳转到指定行\nShift + F9 = 监控(代码运行时)\nShift + F12 = 查找所有引用\nCtor + Tab + Tab = 生成无参构造器\n```\n\n### 项目相关的快捷键\n\n```haxe\nCtrl + Shift + B = 生成项目\nCtrl + Alt + L = 显示 Solution Explorer（解决方案资源管理器）\nShift + Alt+ C = 添加新类\nShift + Alt + A = 添加新项目到项目\n```\n\n\n\n### 编辑相关的键盘快捷键\n\n```haxe\nCtrl + Enter = 在当前行插入空行\nCtrl + Shift + Enter = 在当前行下方插入空行\nCtrl + 空格键 = 使用 IntelliSense（智能感知）自动完成\nAlt + Shift + 箭头键(←,↑,↓,→) = 选择代码的自定义部分\nCtrl + } = 匹配大括号、括号\nCtrl + Shift +} = 在匹配的括号、括号内选择文本\nCtrl + Shift + S = 保存所有文件和项目\nCtrl + K，Ctrl + C = 注释选定行\nCtrl + K，Ctrl + U = 取消选定行的注释\nCtrl + K，Ctrl + D = 正确对齐所有代码\nShift + End = 从头到尾选择整行\nShift + Home = 从尾到头选择整行\nCtrl + Delete = 删除光标右侧的所有字\n```\n\n\n\n### 导航相关的键盘快捷键\n\n```haxe\nCtrl +Up/Down = 滚动窗口但不移动光标\nCtrl + - = 让光标移动到它先前的位置\nCtrl ++ = 让光标移动到下一个位置\nF12 = 转到定义\n```\n\n\n\n### 调试相关的键盘快捷键\n\n```haxe\nCtrl + Alt + P = 附加到进程\nF10 = 调试单步执行\nF5 = 开始调试\nShift + F5 = 停止调试\nCtrl + Alt + Q = 添加快捷匹配\nF9 = 设置或删除断点\n```\n\n\n\n### 搜索相关的键盘快捷键\n\n```haxe\nCtrl + K Ctrl + K = 将当前行添加书签\nCtrl + K Ctrl + N = 导航至下一个书签\nCtrl + . = 如果你键入一个类名如 Collection，且命名空间导入不正确的话，那么这个快捷方式组合将自动插入导入\n\nCtrl + Shift + F = 在文件中查找\nShift + F12 = 查找所有引用\nCtrl + F = 显示查找对话框\nCtrl + H = 显示替换对话框\nCtrl + G = 跳转到行号或行\nCtrl + Shift + F = 查找所选条目在整个解决方案中的引用 \n```\n\n\n\n### 窗口操作快捷键\n\n```haxe\nCtrl+W,W: 浏览器窗口\nCtrl+W,S: 解决方案管理器\nCtrl+W,C: 类视图\nCtrl+W,E: 错误列表\nCtrl+W,O: 输出视图\nCtrl+W,P: 属性窗口\nCtrl+W,T: 任务列表\nCtrl+W,X: 工具箱\nCtrl+W,B: 书签窗口\nCtrl+W,U: 文档大纲\nCtrl+D,B: 断点窗口\nCtrl+D,I: 即时窗口\nCtrl+Tab: 活动窗体切换\nCtrl+Shift+N: 新建项目\nCtrl+Shift+O: 打开项目\nCtrl+Shift+S: 全部保存\nShift+Alt+C: 新建类\nCtrl+Shift+A: 新建项\n```\n\n\n\n### 项目快捷键\n\n```haxe\nCTRL + SHIFT + B生成解决方案\nCTRL + F7 生成编译\nCTRL + O 打开文件\nCTRL + SHIFT + O打开项目\nCTRL + SHIFT + C显示类视图窗口\n\nF4 显示属性窗口\nSHIFT + F4显示项目属性窗口\nCTRL + SHIFT + E显示资源视图\n\nF12 转到定义\nCTRL + F12转到声明\nCTRL + ALT + J对象浏览\nCTRL + ALT + F1帮助目录\nCTRL + F1 动态帮助\n\nF1 帮助\nSHIFT + F1当前窗口帮助\nCTRL + ALT + F3帮助-搜索\nSHIFT + ALT + ENTER全屏显示\nCTRL + -向后定位\nCTRL + SHIFT + -向前定位\nCTRL + F4关闭文档窗口\nCTRL + PAGE DOWN光标定位到窗口上方\nCTRL + PAGE UP光标定位到窗口下方\n\nCTRL + F6\nCTRL + TAB下一个文档窗口\nCTRL + SHIFT + F6\nCTRL + SHIFT + TAB上一个文档窗口\nALT + F6下一个面板窗口\n\nCTRL + K, CTRL + L取消remark\nCTRL + K, CTRL + C注释选择的代码\nCTRL + K, CTRL + U取消对选择代码的注释\nCTRL + M, CTRL + O折叠代码定义\nCTRL + M, CTRL + L展开代码定义\nCTRL + DELETE删除至词尾\n\nCTRL + BACKSPACE删除至词头\nSHIFT + TAB取消制表符\nCTRL + U转小写\nCTRL + SHIFT + U转大写\nCTRL + SHIFT + END选择至文档末尾\nCTRL + SHIFT + HOME选择至文档末尾开始\nSHIFT + END选择至行尾\nSHIFT + HOME选择至行开始处\nSHIFT + ALT + END垂直选择到最后尾\nSHIFT + ALT + HOME垂直选择到最前面\nCTRL + A全选\nCTRL + W选择当前单词\nCTRL + SHIFT + PAGE UP选择至本页前面\nCTRL + SHIFT + PAGE DOWN选择至本页后面\nCTRL + END文档定位到最后\nCTRL + HOME文档定位到最前\nCTRL + G转到…\nCTRL + K, CTRL + P上一个标签\nCTRL + K, CTRL + N下一个标签\nALT + F10调试-ApplyCodeChanges\nCTRL + ALT+ Break停止调试\nCTRL + SHIFT + F9 取消所有断点\nCTRL + F9允许中断\nCTRL + SHIFT + F5调试-重新开始\nF5运行调试\nCTRL + F5运行不调试\nF10跨过程序执行\nF11单步逐句执行\nCTRL + J列出成员\nCTRL + PAGE DOWN下一个视图\nCTRL + B格式-粗体\nCTRL + SHIFT + T格式-文字缩进\n```\n\n\n\n### 调试快捷键\n\n```haxe\nF6: 生成解决方案\nCtrl+F6: 生成当前项目\nF7: 查看代码\nShift+F7: 查看窗体设计器\nF5: 启动调试\nCtrl+F5: 开始执行(不调试)\nShift+F5: 停止调试\nCtrl+Shift+F5: 重启调试\nF9: 切换断点\nCtrl+F9: 启用/停止断点\nCtrl+Shift+F9: 删除全部断点\nF10: 逐过程\nCtrl+F10: 运行到光标处\nF11: 逐语句\n```\n\n\n\n### 编辑快捷键\n\n```haxe\nCtrl+E,D ----格式化全部代码\nCtrl+E,F ----格式化选中的代码\nShift+Alt+Enter: 切换全屏编辑\nCtrl+B,T / Ctrl+K,K: 切换书签开关\nCtrl+B,N / Ctrl+K,N: 移动到下一书签\nCtrl+B,P: 移动到上一书签\nCtrl+B,C: 清除全部标签\nCtrl+I: 渐进式搜索\nCtrl+Shift+I: 反向渐进式搜索\nCtrl+F: 查找\nCtrl+Shift+F: 在文件中查找\nF3: 查找下一个\nShift+F3: 查找上一个\nCtrl+H: 替换\nCtrl+Shift+H: 在文件中替换\nAlt+F12: 查找符号(列出所有查找结果)\nCtrl+Shift+V: 剪贴板循环\nCtrl+左右箭头键: 一次可以移动一个单词\n\nCtrl+上下箭头键: 滚动代码屏幕，但不移动光标位置。\nCtrl+Shift+L: 删除当前行\nCtrl+M,M: 隐藏或展开当前嵌套的折叠状态\nCtrl+M,L: 将所有过程设置为相同的隐藏或展开状态\nCtrl+M,P: 停止大纲显示\nCtrl+E,S: 查看空白\n\nCtrl+E,W: 自动换行\nCtrl+G: 转到指定行\nShift+Alt+箭头键: 选择矩形文本\n\nAlt+鼠标左按钮: 选择矩形文本\nCtrl+Shift+U: 全部变为大写\nCtrl+U: 全部变为小写\n```\n\n\n\n### 代码快捷键\n\n```haxe\nCtrl+J / Ctrl+K,L: 列出成员\nCtrl+Shift+空格键 / Ctrl+K,P: 参数信息\nCtrl+K,I: 快速信息\nCtrl+E,C / Ctrl+K,C: 注释选定内容\nCtrl+E,U / Ctrl+K,U: 取消选定注释内容\nCtrl+K,M: 生成方法存根\nCtrl+K,X: 插入代码段\nCtrl+K,S: 插入外侧代码\nF12: 转到所调用过程或变量的定义\n```\n\n### 单元测试\n\n```haxe\nCtrl + R , A : 执行所有测试\nCtrl + R , T : 执行当前所在测试方法\nCtrl + R , D: 执行最后一次测试的所有测试\nCtrl + R , F: 执行最后一次测试的所有测试的失败测试\n```\n\n',10,0,'23.jpg',0,36,104,4,'2023-08-11 10:19:06','2023-08-11 10:19:06'),
(470,'css','CSS 指层叠样式表','# CSS\n\n## CSS 简介\n\n你需要具备的知识\n\n在继续学习之前，你需要对下面的知识有基本的了解：\n\n- HTML / XHTML\n\n### 什么是CSS\n\n- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)\n- 样式定义**如何显示** HTML 元素\n- 样式通常存储在**样式表**中\n- 把样式添加到 HTML 4.0 中，是为了**解决内容与表现分离的问题**\n- **外部样式表**可以极大提高工作效率\n- 外部样式表通常存储在 **CSS 文件**中\n- 多个样式定义可**层叠**为一个\n\n## CSS规范\n\n层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现[HTML](https://baike.baidu.com/item/HTML)（[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言/6805073)的一个应用）或[XML](https://baike.baidu.com/item/XML)（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 [1] \n\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。\n\n### 代码大小写\n\n样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。\n\n### 选择器选择\n\n- 尽量少用通用选择器 \n- 不使用 ID 选择器\n- 不使用无具体语义定义的标签选择器\n\n```css\n/* 推荐Class */\n.jdc {}\n.jdc li {}\n.jdc li p{}\n```\n\n### 属性值引号\n\ncss属性值用到引号时，统一用单引号\n\n```css\n/* 推荐 */\n.jdc { \n    font-family: ''Hiragino Sans GB'';\n}\n```\n\n### 属性书写顺序\n\n建议遵循以下顺序：\n\n1. 布局定位属性：display / position / float / clear / visibility / overflow\n2. 自身属性：width / height / margin / padding / border / background\n3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …\n\n### 文件信息注释\n\n在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息\n\n```css\n@charset \"UTF-8\";\n/**\n * @desc File Info\n * @author Author Name\n * @date 2015-10-10\n */\n```\n\n### 常用命名\n\n| **CSS类名**           | **说明**               |\n| --------------------- | ---------------------- |\n| **布局**              |                        |\n| layout/box/container  | 布局容器               |\n| wrapper/wrap          | 控制布局宽度的外围容器 |\n| header/head/hd        | 头部/顶部              |\n| main/bd               | 主体部分               |\n| footer/foot/ft        | 底部                   |\n| sidebar/side          | 侧边栏                 |\n| doc                   | 文档                   |\n| **容器**              |                        |\n| banner                | 广告栏                 |\n| content               | 内容部分               |\n| copyright             | 版权                   |\n| list                  | 列表                   |\n| menu/submenu          | 菜单/二级菜单          |\n| nav/subnav            | 导航栏/二级导航        |\n| **组件/细节**         |                        |\n| arrow                 | 箭头                   |\n| btn                   | 按钮                   |\n| download              | 下载                   |\n| logo                  | 徽标                   |\n| message/msg           | 信息                   |\n| news                  | 新闻                   |\n| product               | 产品                   |\n| search                | 搜索                   |\n| status                | 状态                   |\n| summary               | 摘要                   |\n| tab                   | 标签页                 |\n| tag                   | 标签                   |\n| text/txt              | 文本                   |\n| tip                   | 提示                   |\n| title/subtitle        | 标题/二级标题          |\n| **尺寸**              |                        |\n| large                 | 大                     |\n| middle                | 中等                   |\n| small                 | 小                     |\n| mini                  | 迷你                   |\n| **位置**              |                        |\n| top/right/bottom/left | 上/右/下/左            |\n| **关系**              |                        |\n| first                 | 第一个                 |\n| last                  | 最后一个               |\n| prev                  | 上一个                 |\n| current               | 当前项                 |\n| next                  | 下一个                 |\n| forward               | 向前                   |\n| back                  | 向后                   |\n| **状态**              |                        |\n| primary               | 主要                   |\n| info                  | 提示信息               |\n| success               | 成功                   |\n| warning               | 一般警告               |\n| danger/error          | 严重警告/错误警告      |\n| link                  | 文字链接               |\n| plain/ghost           | 按钮是否镂空           |\n| light                 | 亮模式                 |\n| dark                  | 暗模式                 |\n| disabled              | 禁用                   |\n| active                | 激活                   |\n| checked               | 选中                   |\n| loading               | 加载中                 |\n\n## 选择器\n\n选择器根据不同的需求把不同的标签选出来这就是选择器的作用。\n\nCSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析\n\n- 可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；\n- 不可继承的样式：border, padding, margin, width, height\n\n**优先级**\n\n| 选择器         | 权重值 |\n| :------------- | :----- |\n| !important标识 | 10000  |\n| 行内样式       | 1000   |\n| id选择器       | 100    |\n| 类选择器       | 10     |\n| 标签选择器     | 1      |\n| 通配符 *       | 0      |\n\n> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符\n\n### 标签选择器\n\n标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类的标签指定统一的CSS样式。\n\n```css\np{\n    color:red;\n }\n\n标签名{\n属性1;属性值1;\n属性2;属性值2;\n......\n}\n```\n\n作用：可以把某一类标签全部选择出来，比如所有的<div>标签和所有的<span>标签\n\n优点：能快速为页面中同类型的标签统一设置样式。\n\n缺点：不能设计差异化模式，只能选择全部的当前标签。\n\n### 类选择器\n\n如果想要差异化选择不同的标签，单独选一个或几个标签，可以使用类选择器。\n\n语法：\n\n```css\n.类名{\n 属性1;属性值1;\n ......\n }\n```\n\n结构需要用class属性来调用class类的意思。\n\n```html\n<div class=\"red\">变颜色</div>\n```\n\n注意：\n\n- 类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的）。\n- 可以理解为给这个个标签起了一个名字，来表示。\n- 长名称或词组可以使用中横线来为选择器命名。\n- 不要使用纯数字、中文等命名，尽量使用英文字母来表示。\n- 命名要有意义，尽量使别人一眼就知道这个类名的目的。\n- 命名规范：见附件（web前端开发规范手册.doc）\n\n**类选择器口诀：\n\n> 样式点定义 结构类调用 一个或多个 开发最常用\n\n### 类命名规则\n\n| 头       | header            | 菜单     |    menu    |\n| -------- | ----------------- | -------- | :--------: |\n| 内容     | content/container | 子菜单   |  submenu   |\n| 尾       | footer            | 搜索     |   search   |\n| 导航     | nav               | 友情链接 | friendlink |\n| 侧栏     | sidebar           | 页脚     |   footer   |\n| 栏目     | column            | 版权     | copyright  |\n| 标志     | logo              | 广告     |   banner   |\n| 页面主体 | main              | 热点     |    hot     |\n| 新闻     | news              | 下载     |  download  |\n| 子导航   | subnav            |          |            |\n\n### ID选择器\n\nid选择器可以为标有特点id的HTML元素指定特定的样式。HTML元素以id属性来设置ID选择器，CSS中id选择器以“#”来定义。\n\n```html\n<div id=\"warning\">----</div>\n```\n\n```css\n#warning{color:red;}\n\n# id名{\n属性1;属性值1;\n......\n}\n```\n\n注意：id属性只能在每个html文档中出现一次。\n\n口诀：\n\n> 样式自定义，结构id调用，只能调用一次，别人切勿使用。\n\n### ID选择器和类选择器区别\n\n- 类选择器（class）可以有多个class，同时一个class也可以被多个使用。\n- ID选择器好比人的身份证号码，全中国是唯一的，不得重复。\n- ID选择器和类选择器最大的不同在于使用次数上。\n- 类选择器在修改样式中用的最多，ID选择器一般用于页面唯一性的元素上，经常和JAVASCRIPT搭配使用。\n\n### 通配符选择器\n\n在css中，通配符选择器用“*”定义，它表示选取页面中所有元素（标签）\n\n语法：\n\n```bash\n * {\n属性1；属性值1；\n......\n}\n```\n\n- 通配符选择器不需要调用，自动就给所有的元素使用样式。\n- 特殊情况下才使用，后面讲解使用场景（以下是清除所有的元素标签的内外边距，后期讲）。\n\n```css\n* {\nmargin: 0;\npadding: 0;\n}\n```\n\n### 属性选择器\n\n```html\n<ul>\n    <li foo>1</li>\n    <li foo=\"abc\">2</li>\n    <li foo=\"abc efj\">3</li>\n    <li foo=\"abcefj\">4</li>\n    <li foo=\"efjabc\">5</li>\n    <li foo=\"ab\">6</li>\n</ul>\n```\n\n```css\n//选择 attribute=value 的所有元素。\n[foo=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性包含单词 value 的所有元素。\n[foo~=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始\n[foo^=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束\n[foo$=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性中包含 value 子串的每个元素。\n[foo*=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性值以 value 开头的所有元素。\n[foo|=abc]{\n    background-color:red;\n}\n```\n\n### 后代选择器\n\n后代选择器又称为包含选择器，可以选择父元素里面子元素，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n```CSS\nul li{\n    border: 1px solid red;\n}\n\n语法：元素1 元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有元素2（后代元素）。\n\n注意：\n\n- 元素1与元素2中间用空格隔开\n- 元素1是父级，元素2是子级，最终选择是元素2.\n\n### 子选择器\n\n子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。\n\n```css\n ul>li>p{\n   border: 1px solid red;\n}\n语法：元素1>元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有直接后代（子元素）元素2.\n\n注意：\n\n- 元素1和元素2中间用大于号隔开。\n- 元素1是父级元素，2是子级元素，最终选择的是元素2.\n- 元素2必须是亲儿子，其孙子、重孙不归他管，也可以叫亲儿子选择器。\n\n### 并集选择器\n\n并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。\n\n并集选择器是各选择器通过英文逗号（，）连接而成，任何形式的选择器都可以作为并集选择器的一部分。\n\n```text\n语法：元素1,元素2{样式声明}\n```\n\n上述语法表示选择元素1和元素2.\n\n### 相邻兄弟选择器\n\n```css\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n//选择紧接在 element元素之后的 element 元素。\nh1+p{\n    color:red;\n}\n```\n\n### 一般兄弟选择器\n\n```css\n//选择前面有 element1 元素的每个 elem 元素。\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n h1~p{\n   border: 1px solid red;\n}\n```\n\n### 伪类选择器\n\n伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第一个，第n个元素。\n\n伪类选择器书写最大的特点是用冒号（：）表示，比如:hover :first-child\n\n因为伪类选择器很多，比如有链接伪类、结构伪类等，所以这里，先给大家讲解常用的链接伪类选择器。\n\n链接伪类选择器\n\n| a:link    | /*选择所有未被访问的链接*/               |\n| --------- | ---------------------------------------- |\n| a:visited | /*选择所有已被访问的链接*/               |\n| a:hover   | /*选择鼠标指针位于其上的链接*/           |\n| a:active  | /*选择活动链接（鼠标按下未弹起的链接）*/ |\n\n注意：\n\n- 为了确保生效，请按照LVHA的循环顺序声明\n\n```text\n:link    :visited-   :hover-    :active \n```\n\n- 记忆法：love hate或者lv包hao\n- 因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。\n\n链接选择器在实际工作开发中的写法：\n\n```css\n/*a是标签选择器 所有的链接*/\na{\ncolor:gray;\ntext:decoration:none;\n}\n/* :hover是链接伪类选择器 鼠标经过*/\na:hover{\ncolor:red;/*鼠标经过的时候，由原来的灰色变成了红色；*/\ntext-decoration:underline;\n}\n```\n\n#### :focus伪类选择器\n\n：focus伪类选择器用于选取获得焦点的表单元素。\n\n焦点是光标，一般情况下（input）类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。\n\n```css\n语法：input:focus{\nbackgroud-color:yellow;\n}\n```\n\n### 选择器使用情况\n\n| 选择器         | 作用                   | 用法及隔开代码                      | 使用情况 |\n| -------------- | ---------------------- | ----------------------------------- | -------- |\n| 后代选择器     | 用来选择后代元素       | 符号是空格 .nav a                   | 较多     |\n| 子代选择器     | 选择最近一级元素       | 符号是大于 .nav>p                   | 较少     |\n| 并集选择器     | 选择某些相同样式的元素 | 符号是逗号 .nav，header             | 较多     |\n| 链接伪类选择器 | 选择不同状态的链接     | 重点记住a{}和a：hover实际开发的写法 | 较多     |\n| ：focus        | 选择获得光标的表单     | input：focus记住这个写法            | 较少     |\n\n### 伪元素选择器\n\n```css\nelement::first-line\n\n//p 元素的第一行发生改变\np:first-line{\n    background-color:yellow;\n}\n\nelement::first-letter\n//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色\nh1:first-letter{\n    color:yellow;\n}\n\n//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用\nelement::before\n\n//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它\nelement::after\n\n//选择被用户选取的元素部分。\n::selection\n```\n\n## 边距\n\n### 外边距(margin)\n\nmargin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。\n\nmargin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。\n\n| 值       | 说明                                        |\n| :------- | :------------------------------------------ |\n| auto     | 设置浏览器边距。 这样做的结果会依赖于浏览器 |\n| *length* | 定义一个固定的margin（使用像素，pt，em等）  |\n| *%*      | 定义一个使用百分比的边距                    |\n\n#### 边距属性\n\n| 属性          | 描述                                       |\n| :------------ | :----------------------------------------- |\n| margin        | 简写属性。在一个声明中设置所有外边距属性。 |\n| margin-bottom | 设置元素的下外边距。                       |\n| margin-left   | 设置元素的左外边距。                       |\n| margin-right  | 设置元素的右外边距。                       |\n| margin-top    | 设置元素的上外边距。                       |\n\n#### 单边外边距属性\n\n在CSS中，它可以指定不同的侧面不同的边距：\n\n```css\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n```\n\n#### Margin - 简写属性\n\n为了缩短代码，有可能使用一个属性中margin指定的所有边距属性。这就是所谓的简写属性。\n\n所有边距属性的简写属性是 **margin** :\n\n```css\nmargin:100px 50px;\n```\n\nmargin属性可以有一到四个值。\n\n- margin:25px 50px 75px 100px;\n  - 上边距为25px\n  - 右边距为50px\n  - 下边距为75px\n  - 左边距为100px\n- margin:25px 50px 75px;\n  - 上边距为25px\n  - 左右边距为50px\n  - 下边距为75px\n- margin:25px 50px;\n  - 上下边距为25px\n  - 左右边距为50px\n- margin:25px;\n  - 所有的4个边距都是25px\n\n#### 居中显示\n\n```css\nmargin: 0 auto;\n```\n\n## 背景\n\n### 属性背景效果(background)\n\n- background-color\n- background-image\n- background-repeat\n- background-attachment\n- background-position\n\n颜色值通常以以下方式定义:\n\n- 十六进制 - 如：\"#ff0000\"\n- RGB - 如：\"rgb(255,0,0)\"\n- 颜色名称 - 如：\"red\"\n\n### 背景颜色(background)\n\n```css\n background-color: #ffffff;\n```\n\n### 背景图像(background)\n\nbackground-image 属性描述了元素的背景图像.\n\n默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.\n\n```css\nbackground: no-repeat center/100% url(\"../img/index.png\");\n```\n\n### 背景透明(background)\n\n```css\nbackground-color: hsla(0,0%,100%,.7);\n```\n\n### 多个背景图片(background)\n\n```css\nbody {\n  background-image: url(https://image.flaticon.com/icons/svg/748/748122.svg), url(https://images.unsplash.com/photo-1478719059408-592965723cbc?ixlib=rb-1.2.1&auto=format&fit=crop&w=2212&q=80);\n  background-position: center, top;\n  background-repeat: repeat, no-repeat;\n  background-size: contain, cover;\n}\n```\n\n### 水平方向平铺(background)\n\n```css\nbackground-image:url(''gradient2.png'');\nbackground-repeat:repeat-x;\n```\n\n### 设置定位与不平铺(background)\n\n让背景图像不影响文本的排版\n\n如果你不想让图像平铺，你可以使用 background-repeat 属性:\n\n```css\nbackground-image:url(''img_tree.png'');\nbackground-repeat:no-repeat;\n```\n\n### 网格背景图像(background)\n\n```html\n<body>\n<div class=\"container\">\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n</div>\n</body>\n```\n\n```css\nbody {\n margin: 0;\n  padding: 0;\n}\n\n.container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background: black;\n  display: grid;\n  grid-template-columns: 25fr 30fr 40fr 15fr;\n  grid-template-rows: 20fr 45fr 5fr 30fr;\n  grid-gap: 20px;\n  .item_img {\n    background-image: url(''https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80'');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-attachment: fixed;\n  background-size: cover;\n}\n}\n```\n\n### 全局背景颜色\n\n```tsx\nmounted() {\n  document.querySelector(''body'').setAttribute(''style'', ''background-color:#f7f7f7'')\n},\nbeforeDestroy() {\n  document.querySelector(''body'').removeAttribute(''style'')\n}\n```\n\n### 背景属性(background)\n\n| Property              | 描述                                         |\n| :-------------------- | :------------------------------------------- |\n| background            | 简写属性，作用是将背景属性设置在一个声明中。 |\n| background-attachment | 背景图像是否固定或者随着页面的其余部分滚动。 |\n| background-color      | 设置元素的背景颜色。                         |\n| background-image      | 把图像设置为背景。                           |\n| background-position   | 设置背景图像的起始位置。                     |\n| background-repeat     | 设置背景图像是否及如何重复。                 |\n\n### 背景渐变\n\n使用方式:\n\n```css\n//渐变(方向)\nbackground: linear-gradient(to right, rgba(255, 255, 255, 0),#3FB6F7,rgba(255,255,255,0));\n\n//渐变(角度)\nbackground: linear-gradient(88deg, #4DF7BF 0%, rgba(77, 247, 191, 0.26) 12%, rgba(77, 247, 191, 0) 100%);\n```\n\n\n\n## 字体\n\n### 字体属性\n\nCSS使用font-family属性定义文本的字体系列。\n\n```css\np { font-family:\"微软雅黑\";}\ndiv {font-family:Arial,\"Microsoft Yahei\",\"微软雅黑\"；}\n```\n\n注意：\n\n- 各种字体之间必须使用英文状态下的逗号隔开。\n- 一般情况下，如果有空格隔开的多个单词组成的字体，加引号。\n- 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示。\n- 最常见的几个字体：\n\n```css\nbody {font-family:\"Microdoft Yahei\",tohoma,arial,\"Hiyayinosan GB\";}\n```\n\n### 字体大小\n\nCSS使用font-size属性定义字体大小\n\n```css\np {font-size:20px;}\n```\n\n注意：\n\n- px（像素）大小是我们网页最常用的单位。\n- 谷歌浏览器默认的文字大小为16px。\n- 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。\n- 可以给body指定整个页面文字的大小\n\n### 字体粗细\n\nCSS使用font-weight属性设置文字字体的粗细。\n\n```css\np {font-weight:normal\\body\\bolder\\light\\number;}\n```\n\n参数：\n\n| normal | 正常字体（相当于number=400）              |\n| ------ | ----------------------------------------- |\n| bold   | 粗体（相当于number=700）                  |\n| bolder | 特粗体（IF5+）                            |\n| light  | 细体（IF5+）                              |\n| number | 100/200/300/400/500/600/700/800/900(IF5+) |\n\nnumber语法：\n\n```css\np {font-weight:400;}\n```\n\n注意：\n\n- 学会加粗标签（比如h和strong等）不加粗，或者其他标签加粗\n- 实际开发时，我们更喜欢用字表示粗细。\n\n### 文字模式\n\nCSS使用font-style属性设置文本的网络。\n\n```css\np { font-style: normal; }\n```\n\n| 属性值 | 作用                                                 |\n| ------ | ---------------------------------------------------- |\n| normal | 默认值，浏览器会显示标准的字体样式 font-size：normal |\n| italic | 浏览器会显示斜体的字体样式                           |\n\n注意：平时我们很少给文字加斜体，反而要给斜体标签（em，；）改为不斜体字体。\n\n### 字体的复合属性\n\n```css\nbody { font-style font-weight font-size/line-height font-family;}\n```\n\n注意：\n\n- 使用font属性时，必须按上面的语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开。\n- 不需要设置的属性可以忽略（取默认值），但必须保留 font-size和font-family属性，否则font属性将不起作用。\n\n## 文本\n\n## 文本属性\n\ncolor属性用于定义文本的颜色\n\n```css\ndiv {\ncolor:red;\n    }\n```\n\n注意：开发中最常用的时十六进制。\n\n| 表示           | 属性值                          |\n| -------------- | ------------------------------- |\n| 预定义的颜色值 | red，green，blue，pink          |\n| 十六进制       | #FF0000，#FF6600，#FF29D794     |\n| RGB代码        | rgb（255,0,0）或rgb(100%,0%,0%) |\n\n### 文本对齐\n\ntext-align属性用于设置元素内文本内容的水平对齐方式。\n\n```css\ndiv {\ntext-align:center;\n}\n```\n\n| 属性值 | 解释             |\n| ------ | ---------------- |\n| left   | 左对齐（默认值） |\n| right  | 右对齐           |\n| center | 居中对齐         |\n\n### 文本装饰\n\ntext-decoration属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等。\n\n```css\ndiv {\ntext-decoration:underline;\n}\n```\n\n| 属性值       | 解释                            |\n| ------------ | ------------------------------- |\n| none         | 默认，没有装饰线（最常用）      |\n| underline    | 下划线：链接a自带下划线（常用） |\n| overline     | 上划线（几乎不用）              |\n| line-through | 删除线（不常用）                |\n\n### 文本缩进\n\ntext-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。\n\n```css\ndiv {\ntext-indent:10px/2em;\n}\n```\n\n*:2em代表2个字符\n\n### 行间距\n\nline-height属性用于设置行间的距离（行高），可以控制文本的行与行之间的距离。\n\n```css\np { line-height: 26px;}\n```\n\n**:用Faststone chature 软件的标尺测量上一行的行底与下一行的行底之间的距离。\n\n### 文本转换\n\n文本转换属性是用来指定在一个文本中的大写和小写字母。\n\n可用于所有字句变成大写或小写字母，或每个单词的首字母大写。\n\n```css\np.uppercase {text-transform:uppercase;}\np.lowercase {text-transform:lowercase;} \np.capitalize {text-transform:capitalize;}\n```\n\n## 边框\n\n### 边框样式\n\n边框样式属性指定要显示什么样的边界。\n\nborder-style属性用来定义边框的样式\n\nnone: 默认无边框\n\ndotted: 定义一个点线边框\n\ndashed: 定义一个虚线边框\n\nsolid: 定义实线边框\n\ndouble: 定义两个边框。 两个边框的宽度和 border-width 的值相同\n\ngroove: 定义3D沟槽边框。效果取决于边框的颜色值\n\nridge: 定义3D脊边框。效果取决于边框的颜色值\n\ninset:定义一个3D的嵌入边框。效果取决于边框的颜色值\n\noutset: 定义一个3D突出边框。 效果取决于边框的颜色值\n\n```css\n/* 样式 1px */\nborder-style: ridge;\n```\n\n### 边框宽度\n\n通过 border-width 属性为边框指定宽度。\n\n为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。\n\n**注意：**CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。\n\n```css\np.one {    \nborder-style:solid; \nborder-width:5px; \n}\np.two {   \nborder-style:solid;   \nborder-width:medium;\n}\n```\n\n### 边框颜色\n\nborder-color属性用于设置边框的颜色。\n\n您还可以设置边框的颜色为\"transparent\"。\n\n**注意：** border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。\n\n```css\n/* 边框宽度1px 样式 颜色 */\n  border: 1px solid #868686;\n\np.one {  \nborder-style:solid; \nborder-color:red; \n}\np.two {  \nborder-style:solid; \nborder-color:#98bf21;\n}\n```\n\n### 单独设置各边(border)\n\nborder-style属性可以有1-4个值：\n\n- border-style:dotted solid double dashed;\n  - 上边框是 dotted\n  - 右边框是 solid\n  - 底边框是 double\n  - 左边框是 dashed\n- border-style:dotted solid double;\n  - 上边框是 dotted\n  - 左、右边框是 solid\n  - 底边框是 double\n\n在CSS中，可以指定不同的侧面不同的边框：\n\n```css\n/* 上下左右 */\nborder-top-style:dotted; \nborder-right-style:solid;  \nborder-bottom-style:dotted; \nborder-left-style:solid; \n\n/* 多属性 */\nborder-bottom: 1px solid #edeef0;\n```\n\n### 边框边角弧度\n\n```css\nborder-radius: 5px;\n```\n\n### 边框的斜线语法\n\n```css\n.border-radius {\n  border-radius: 50px 25px / 25px 50px;\n}\n```\n\n### 实线边框\n\n```css\n-webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n```\n\n### 边框渐变\n\n```css\n.border-grident{\n  margin-top: 20px;\n  width: 200px;\n  height: 200px;\n  border: 4px solid;\n  border-image: linear-gradient(to right, #8f41e9, #578aef) 4;\n}\n```\n\n\n\n\n\n## 样式引入\n\n### CSS的三种样式表\n\n按照CSS样式书写的位置（或者引入方式）\n\n- 行业样式表（行内式）\n- 内部样式表（嵌入式）\n- 外部样式表（链接式）\n\n### 内部样式表\n\n内部样式表是写到html页面内部，是将所有的CSS代码抽取出来，单独放到一个style标签中。\n\n```css\n<style>\n     div{\n         color:red;\n         font-size: 12px;\n         }\n</style>\n```\n\n- 标签理论上可放在HTML文档的任何地方，但一般会放在文档的head标签中\n- 通过此种方式，可以方便控制当前整个页面中的元素样式设置。\n- 代码结构清晰，但是并没有实现结构与样式完全分离。\n\n### 行内样式表\n\n行内样式表是在元素标签内部的style属性中设置CSS样式，适合于修改简单样式。\n\n```css\n<div style=\"color:red; font-size:12px;\">青春不常在，抓紧谈恋爱</div>\n```\n\n- style其实就是标签的属性\n- 在双引号中间，写法要符合CSS规范。\n- 可以控制当前的标签设置样式。\n- 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用。\n- 使用行内样式表设定CSS，通常也被成为行内式引入。\n\n### 外部样式表\n\n实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。\n\n引入外部样式表分为两步：\n\n- 新建一个后缀名为CSS的样式文件，把所有CSS代码都放入此文件中。\n- 在HTML页面中，使用<link>标签引入这个文件。\n\n```css\nlink rel=\"style sheet\" href\"CSS文件路径\"\n```\n\n### CSS引入方式总结\n\n| 样式表     | 优点                     | 缺点         | 使用情况   | 控制范围     |\n| ---------- | ------------------------ | ------------ | ---------- | ------------ |\n| 行内样式表 | 书写方便；权重高         | 结构样式混写 | 较少       | 控制一个标签 |\n| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离 | 较多       | 控制一个页面 |\n| 外部样式表 | 完全实现结构和样式相分离 | 需要引入     | 最多(推荐) | 控制多个页面 |\n\n### 常用片段\n\n```css\n/* 字体颜色 */\n  color: #888888;\n/* 字体粗细 */\n  font-weight: 400;\n/* 字体大小 */\n  font-size: 14px;\n/* 文字居中 */\n  text-align: center;\n/* 字体行内居中 */\n  line-height: 45px;\n /*字体加深*/\n text-shadow: 0 0 1px rgba(0,0,0,.3);\n /*起始段落空2格*/\n text-indent: 2em;\n```\n\n## 定位(position)\n\nposition 属性指定了元素的定位类型。\n\nposition 属性的五个值：\n\nstatic, relative, fixed, absolute, sticky\n\n### static定位\n\nHTML 元素的默认值，即没有定位，遵循正常的文档流对象。\n\n静态定位的元素不会受到 top, bottom, left, right影响。\n\n```css\ndiv.static {    \nposition: static;   \nborder: 3px solid #73AD21; \n}\n```\n\n### fixed定位\n\n元素的位置相对于浏览器窗口是固定位置。\n\n即使窗口是滚动的它也不会移动：\n\n```css\np.pos_fixed {   \nposition:fixed;   \ntop:30px;   \nright:5px; \n}\n```\n\n**注意：** Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。\n\nFixed定位使元素的位置与文档流无关，因此不占据空间。\n\nFixed定位的元素和其他元素重叠。\n\n### relative定位\n\n相对定位元素的定位是相对其正常位置。\n\n```css\nh2.pos_left {   \nposition:relative; \nleft:-20px; \n} \nh2.pos_right {\nposition:relative; \nleft:20px; \n}\n```\n\n移动相对定位元素，但它原本所占的空间不会改变。\n\n```css\nh2.pos_top { \nposition:relative;  \ntop:-50px;\n}\n```\n\n相对定位元素经常被用来作为绝对定位元素的容器块。\n\n### absolute定位\n\n绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html\n\n```css\nh2 {   \nposition:absolute;  \nleft:100px;  \ntop:150px; \n}\n```\n\nabsolute 定位使元素的位置与文档流无关，因此不占据空间。\n\nabsolute 定位的元素和其他元素重叠。\n\n### sticky定位\n\nsticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。\n\n**position: sticky;** 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。\n\n它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。\n\n```css\ndiv.sticky {   \nposition: -webkit-sticky; /* Safari */  \nposition: sticky; \ntop: 0;  \nbackground-color: green;   \nborder: 2px solid #4CAF50; \n}\n```\n\n### 重叠的元素\n\n元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素\n\nz-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）\n\n一个元素可以有正数或负数的堆叠顺序：\n\n```css\nimg {    \nposition:absolute; \nleft:0px;   \ntop:0px;  \nz-index:-1;\n}\n```\n\n具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。\n\n**注意：** 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。\n\n### 定位属性\n\n\"CSS\" 列中的数字表示哪个CSS(CSS1 或者CSS2)版本定义了该属性。\n\n| 属性       | 说明                                                         | 值                                                           | CSS  |\n| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--- |\n| bottom     | 定义了定位元素下外边距边界与其包含块下边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| clip       | 剪辑一个绝对定位的元素                                       | *shape *auto inherit                                         | 2    |\n| cursor     | 显示光标移动到指定的类型                                     | *url* auto crosshair default pointer move e-resize ne-resize nw-resize n-resize se-resize sw-resize s-resize w-resize text wait help | 2    |\n| left       | 定义了定位元素左外边距边界与其包含块左边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| overflow   | 设置当元素的内容溢出其区域时发生的事情。                     | auto hidden scroll visible inherit                           | 2    |\n| overflow-y | 指定如何处理顶部/底部边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| overflow-x | 指定如何处理右边/左边边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| position   | 指定元素的定位类型                                           | absolute fixed relative static inherit                       | 2    |\n| right      | 定义了定位元素右外边距边界与其包含块右边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| top        | 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 | auto *length % *inherit                                      | 2    |\n| z-index    | 设置元素的堆叠顺序                                           | *number *auto inherit                                        | 2    |\n\n### 定位示例\n\n#### 元素固定\n\n```css\n@media (min-height: 500px) {\n    .site-header {\n        position: sticky;\n        top: 0;\n        /*other styles*/\n    }\n}\n```\n\n#### 居中定位\n\n示例1\n\n```c#\n   position: absolute;\n    width: 50%;\n    height: 80%;\n    overflow: auto;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n```\n\n示例2\n\n```css\n.tag_search {\n\n  @apply relative;\n  height: 50px;\n\n  div {\n    @apply absolute top-1/2 left-1/2;\n    width: 40%;\n    transform: translate(-50%, -50%);\n  }\n}\n```\n\n示例3\n\n@apply居中\n\n```css\n  // 居中\n  @apply top-1/2 left-1/2 absolute;\n  transform: translate(-50%, -50%);\n```\n\n## 瀑布流\n\n### 瀑布流(column)\n\n```html\n      <div class=\"w-full h-800px overflow-auto\">\n        <div class=\"test\">\n          <div v-for=\"(item, index) in rSnippet\" :key=\"index\" class=\"item\">\n            <div class=\"text-xl text-center\">{{ item.name }}</div>\n            <v-md-preview ref=\"preview\" :text=\"item.text\" />\n          </div>\n        </div>\n      </div>\n```\n\n```css\n.test {\n  margin: 0 auto;\n  column-count: 2;\n  column-gap: 10px;\n  counter-reset: count;\n\n  .item {\n    position: relative;\n    margin-bottom: 10px;\n    // page-break-inside: avoid;\n    // -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n这种方式超出宽高度使用 overflow-y-scroll 只能左右滑动\n\n### 瀑布流(grid)\n\n超出宽高度使用 overflow-y-scroll 可以上下滑动\n\n```html\n    <div class=\"test mt-4\">\n        <div class=\"bg-warm-gray-600 w-80 h-40\" t2></div>\n        <div class=\"bg-warm-gray-700 w-80 h-40 text2\"></div>\n        <div class=\"bg-slate-500\" w-80 h-50></div>\n        <div class=\"bg-warm-gray-500 w-80 h-50\"></div>\n        <div class=\"bg-warm-gray-800 w-80 h-20\"></div>\n        <div class=\"bg-warm-gray-100 w-80 h-70\"></div>\n        <div class=\"bg-warm-gray-200 w-80 h-40\"></div>\n        <div class=\"bg-warm-gray-500 w-80 h-60\"></div>\n      </div>\n```\n\n```css\n.test {\n  display: grid;\n  grid-gap: 10px;\n\n  /* 可以看到，网格大小，占据位置是需要提前设定的 */\n  grid-template-columns: repeat(3, 1fr);\n  box-sizing: border-box;\n  width: 80%;\n  height: 800px;\n  padding: 10px;\n  background-color: rgb(189 100 100);\n\n  @apply overflow-y-scroll;\n\n  div {\n    /* 避免子元素被分割的 2种方式 */\n    page-break-inside: avoid;\n    -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n\n\n## 代码片段\n\n#### 关闭x符号\n\n```\n&#215;\n```\n\n#### title换行\n\n```\n&#13;\n```\n\n#### 鼠标不允许点击\n\n```css\n  cursor: not-allowed;\n```\n\n####  input标签居中\n\n对于inline元素的input标签，将其父元素的text-align属性设置为center。\n\n```html\n<div style=\"text-align: center;\">\n  <input type=\"text\" placeholder=\"输入内容\">\n</div>\n```\n\n#### div局部滚动\n\n```\nh-full overflow-y-scroll\n```\n\n但是当元素没有内容时候，设置height:100%，该元素不会被撑开，此时高度为0，\n\n但是设置height:100vh，该元素会被撑开与屏幕高度一致\n\n#### 网站变灰gray\n\n```css\nhtml{\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\''http://www.w3.org/2000/svg\\''><filter id=\\''grayscale\\''><feColorMatrix type=\\''matrix\\'' values=\\''0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\''/></filter></svg>#grayscale\");\n    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n    -webkit-filter: grayscale(1);\n}\n```\n\n#### 父容器固定并占位\n\n- 使用相对定位 relative\n- 参照物：元素偏移前自身的位置\n- 相对定位也通过left,right,top,bottom来决定元素偏移的位置\n\n#### 通过#去锚定对应内容\n\n实现了一个 tab 切换的效果\n\n```html\n<div>\n  <a href=\"#A\">A</a>\n  <a href=\"#B\">B</a>\n</div>\n<div className=\"scroll-ctn\">\n  <div id=\"A\" className=\"scroll-panel\">\n    A\n  </div>\n  <div id=\"B\" className=\"scroll-panel\">\n    B\n  </div>\n</div>\n\n```\n\n为了实现平滑滚动，我们在滚动容器上设置了如下的 CSS\n\n```css\n.scroll-ctn {\n  display: block;\n  width: 100%;\n  height: 300px;\n  overflow-y: scroll;\n  scroll-behavior: smooth;\n  border: 1px solid grey;\n}\n```\n\n\n\n###  居中(flex)\n\n```css\n.center-layout {\n	display: flex;\n	justify-content: center; // 内容自适应：上下居中\n	align-items: center; // 子项对齐方式：左右居中\n}\n```\n\n\n\n### 居中(fixed)\n\n```css\n   .fixed-c {\n            height: 80px;\n            width: 90%;\n            position: fixed;\n            margin: auto;\n            bottom: 0; /*底部固定*/\n            left: 0; /*实现div的居中*/\n            right: 0; /*实现div的居中*/\n            text-align: center; /*div的内容居中*/\n            background: red;\n            line-height: 80px; /*垂直居中*/\n          }\n```\n\n\n\n### 平滑滚动\n\n```css\n html {\n  scroll-behavior: smooth;\n}\n```\n\n### 悬停放大图片特效\n\n```css\n.img-wrapper img {\n  -webkit-transition: 0.3s linear;\n  transition: 0.3s linear;\n}\n\n.img-wrapper img:hover {\n  transform: scale(1.1);\n}\n```\n\n### 绝对居中\n\n```css\n.Absolute-Center {\n  margin: auto;\n  position: absolute;\n  top: 0; left: 0; bottom: 0; right: 0;\n}\n```\n\n\n\n### 文字居中\n\n```css\n<div class=\"container\">\n    <div class=\"item\"></div>\n</div>\n\n.container {\n    text-align: center;\n}\n```\n\n### 块级元素居中\n\n适用于块级元素，其实就是把要居中的子元素的 margin-left、margin-right 都设置为 auto，该方法能让子元素水平居中，但是对浮动元素和绝对定位的元素无效。\n\n```css\n.item {\n    margin: auto;\n}\n```\n\n### 水平垂直居中\n\n **HTML结构如下**\n\n```html\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n```\n\n#### 绝对定位\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    /* top和left是以左上角为坐标原点 */\n    top: 50%;\n    left: 50%;\n    /* transform：translate的属性值为百分数时，是以元素自身为参考 */\n    transform: translate(-50%,-50%);\n}\n\n/* 或者 */\n.child {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n```\n\n值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。\n\n\n\n\n\n### 下划线跟随\n\n```vue\n<div class=\"bruce flex-ct-x\">\n    <ul class=\"underline-navbar\">\n        <li>11111</li>\n        <li>22222</li>\n        <li>33333</li>\n    </ul>\n</div>\n```\n\n```css\n.underline-navbar {\n    display: flex;\n    li {\n        position: relative;\n        padding: 10px;\n        cursor: pointer;\n        font-size: 20px;\n        color: #09f;\n        transition: all 300ms;\n        &::before {\n            position: absolute;\n            left: 100%;\n            top: 0;\n            border-bottom: 2px solid transparent;\n            width: 0;\n            height: 100%;\n            content: \"\";\n            transition: all 300ms;\n        }\n        &:active {\n            background-color: #09f;\n            color: #fff;\n        }\n        &:hover {\n            &::before {\n                left: 0;\n                top: 0;\n                z-index: -1;\n                border-bottom-color: #09f;\n                width: 100%;\n                transition-delay: 100ms;\n            }\n            & + li::before {\n                left: 0;\n            }\n        }\n    }\n}\n```\n\n### 描绘波浪线\n\n```vue\n<div class=\"bruce flex-ct-x\">\n    <p class=\"waveline-text\">波浪线文字</p>\n</div>\n```\n\n```css\n@mixin waveline($h, $color: #f66) {\n    position: relative;\n    &::after {\n        position: absolute;\n        left: 0;\n        top: 100%;\n        width: 100%;\n        height: $h;\n        background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);\n        background-size: $h * 2 $h * 2;\n        content: \"\";\n    }\n}\n.waveline-text {\n    height: 20px;\n    line-height: 20px;\n    letter-spacing: 10px;\n    @include waveline(10px);\n}\n```\n\n### 元素隐藏\n\n```css\n/**这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；**/\nvisibility: hidden; \n/**属性，设置0可以使一个元素完全透明；**/\nopacity: 0;CSS3\n/**设置一个很大的 left 负值定位，使元素定位在可见区域之外；**/\nposition: absolute; \n/**元素会变得不可见，并且不会再占用文档的空间；**/\ndisplay: none; \n/**将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；**/\ntransform: scale(0); \n```\n\n### 虚线效果\n\n```css\n.dotted-line{\n    border: 1px dashed transparent;\n    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);\n}\n```\n\n### 文本超出省略号\n\n**单行文本**\n\n```css\n.single-ellipsis{\n  overflow: hidden; // 溢出隐藏\n  text-overflow: ellipsis;  // 溢出用省略号显示\n  white-space: nowrap;  // 规定段落中的文本不进行换行\n}\n```\n\n**多行文本**\n\n```css\n.multiline-ellipsis {\n  display: -webkit-box;/ 作为弹性伸缩盒子模型显示。\n  -webkit-box-orient: vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列\n  -webkit-line-clamp: 4; //需要显示的行数\n  overflow: hidden; // 溢出隐藏\n  text-overflow: ellipsis; // 溢出用省略号显示\n}\n```\n\n### 自动打字\n\n```html\n<div class=\"bruce flex-ct-x\">\n    <div class=\"auto-typing\">Do You Want To Know More About CSS Development Skill</div>\n</div>\n```\n\n```css\n@mixin typing($count: 0, $duration: 0, $delay: 0) {\n    overflow: hidden;\n    border-right: 1px solid transparent;\n    width: #{$count + 1}ch;\n    font-family: Consolas, Monaco, Monospace;\n    white-space: nowrap;\n    animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;\n}\n.auto-typing {\n    font-weight: bold;\n    font-size: 30px;\n    color: #09f;\n    @include typing(52, 5);\n}\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n@keyframes caret {\n    50% {\n        border-right-color: currentColor;\n    }\n}\n```\n\n### 渐变色文字\n\n```css\n<h2 class=\"gradient-text\">Gradient text</h2>\n<style>\n.gradient-text {\n  background-image: linear-gradient(90deg, red, blue);\n  background-clip: text;\n  color: transparent;\n}\n</style>\n```\n\n### 清除overflow的滚动条\n\n```css\n.div{\n  overflow: auto\n}\n\n.div::-webkit-scrollbar{\n    display: none;\n}\n```',1,0,'23.jpg',0,4,109,4,'2023-08-11 10:23:58','2023-08-11 10:23:58'),
(471,'vue3+storage实现token验证','登录成功返回 token','### 验证过程\n\n1. 登录成功返回 token\n2. 拿到token，将token存储到localStorage，并跳转路由页面\n3.  跳转路由，就判断 localStroage 中有无 token\n4.  调后端接口，都要在请求头中加token\n5. 前端拿到状态码为401，就清除token信息并跳转到登录页面\n\n### storage\n\nlocalStorage特性，这个特性主要是用来作为本地存储来使用的，解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。\n\n```tsx\n/**\n * 封装操作localstorage本地存储的方法\n */\nexport const storage = {\n  //存储\n  set(key: string, value: any) {\n    localStorage.setItem(key, JSON.stringify(value))\n  },\n  //取出数据\n  get<T>(key: string) {\n    const value = localStorage.getItem(key)\n    if (value && value != \"undefined\" && value != \"null\") {\n      return <T>JSON.parse(value)\n    }\n  },\n  // 删除数据\n  remove(key: string) {\n    localStorage.removeItem(key)\n  }\n};\n\n/**\n * 封装操作sessionStorage本地存储的方法\n */\nexport const sessionStorage = {\n  //存储\n  set(key: string, value: any) {\n    window.sessionStorage.setItem(key, JSON.stringify(value))\n  },\n  //取出数据\n  get<T>(key: string) {\n    const value = window.sessionStorage.getItem(key)\n    if (value && value != \"undefined\" && value != \"null\") {\n      return JSON.parse(value)\n    }\n    return null\n  },\n  // 删除数据\n  remove(key: string) {\n    window.sessionStorage.removeItem(key)\n  }\n}\n```\n\n### login\n\n登录成功后进行token保存\n\n```vue\n<script setup lang=\"ts\">\nimport { useStore } from ''vuex''\nimport { storage } from ''@/utils/storage/storage''\nconst stores = useStore()\nconst state = reactive({\n  user: '''',\n  pwd: '''',\n  result: [],\n})\n\nasync function login() {\n  user.Login(state.user, state.pwd).then((res) => {\n    state.result = res.data.split('','')\n    if (state.result[0] === ''1'') {\n      storage.set(''token'', ''Bearer '' + state.result[1])\n    }\n  })\n}\n</script>\n\n```\n\n### axios\n\n```tsx\n// 添加请求拦截器\naxios.interceptors.request.use(function (config) {\n  if (\n    config.method === \"post\" ||\n    config.method === \"put\" ||\n    config.method === \"delete\"\n  ) {\n    // qs序列化\n    config.data = qs.parse(config.data);\n  }\n  // 鉴权token , 给头部带上token\n  if (storage.get(''token'')) {\n    config.headers.Authorization = storage.get(''token'');\n  }\n  return config;\n}, error => {\n  return Promise.reject(error.data.error.message);\n})\n```\n\n### *全局前置守卫*\n\n```tsx\n// 导航守卫\n// 使用 router.beforeEach 注册一个全局前置守卫，判断用户是否登陆\nrouter.beforeEach((to, from, next) => {\n  if (to.path === \"/Login\") {\n    next();\n  } else {\n\n    const token = storage.get(''token'')\n    if (token === undefined || token === \"\") {\n      next(\"/Login\");\n    } else {\n      next();\n    }\n  }\n});\n```\n\n',1,0,'11.jpg',0,51,1,4,'2023-08-11 11:13:14','2023-08-11 11:13:14'),
(472,'c#使用委托执行带有超时检查的方法.','在编程中，有时我们需要执行一些可能会花费很长时间的操作。为了避免程序长时间等待，我们可以使用超时机制来限制操作的执行时间 , 执行带有超时检查的方法的方式。','在编程中，有时我们需要执行一些可能会花费很长时间的操作。为了避免程序长时间等待，我们可以使用超时机制来限制操作的执行时间 , 执行带有超时检查的方法的方式。\n\n```csharp\nnamespace TimeOutHelper\n{\n    internal class Program\n    {\n        // 定义一个泛型委托，用于定义带有超时检查的方法的签名\n        public delegate TR TimeOutDelegate<in T, out TR>(T param);\n\n        private static void Main()\n        {\n            Dictionary<Guid, string> result;\n            \n            // 调用TimeoutFunction类的Execute方法执行带有超时检查的方法\n            // Test方法是一个示例方法，它接受一个字符串参数，并返回一个字典\n            // \"Hello, World!\"是传递给Test方法的参数\n            // result是用于接收Test方法的返回值的字典\n            // TimeSpan.FromSeconds(3)表示超时时间为3秒\n            // Execute方法返回一个布尔值，表示是否超时\n            Console.WriteLine(TimeoutFunction.Execute(Test, \"Hello, World!\", out result, TimeSpan.FromSeconds(3)));\n            \n            Console.WriteLine(\"Hello, World!\");\n            Console.ReadKey();\n        }\n\n        // 示例方法，接受一个字符串参数，并返回一个字典\n        public static Dictionary<Guid, string> Test(string sourceString)\n        {\n            // 将字符串转换为字典，每个字符作为键，使用Guid作为值\n            var result = sourceString.ToDictionary(\n                character => Guid.NewGuid(),\n                character => character.ToString(CultureInfo.InvariantCulture));\n            \n            // 模拟耗时操作，暂停4秒\n            Thread.Sleep(4000);\n            \n            return result;\n        }\n\n        public static class TimeoutFunction\n        {\n            /// <summary>\n            /// 执行带有超时检查的方法\n            /// </summary>\n            /// <typeparam name=\"T\">目标方法的参数类型</typeparam>\n            /// <typeparam name=\"TR\">执行结果的类型</typeparam>\n            /// <param name=\"timeoutMethod\">目标方法</param>\n            /// <param name=\"param\">目标方法的参数</param>\n            /// <param name=\"result\">执行结果</param>\n            /// <param name=\"timeout\">超时时间</param>\n            /// <returns>是否超时</returns>\n            public static Boolean Execute<T, TR>(\n                TimeOutDelegate<T, TR> timeoutMethod, T param, out TR result, TimeSpan timeout)\n            {\n                // 使用异步方式执行目标方法\n                var asyncResult = timeoutMethod.BeginInvoke(param, null, null);\n                \n                // 等待指定的超时时间\n                if (!asyncResult.AsyncWaitHandle.WaitOne(timeout, false))\n                {\n                    // 如果超时，则将结果设置为默认值，并返回true\n                    result = default(TR);\n                    return true;\n                }\n                \n                // 如果未超时，则获取执行结果，并返回false\n                result = timeoutMethod.EndInvoke(asyncResult);\n                return false;\n            }\n        }\n    }\n}\n```\n\n',0,0,'4.jpg',0,51,104,4,'2023-10-30 14:32:22','2023-10-30 14:32:22'),
(473,'c#实现文件压缩的方法',' 实现一个压缩文件的方法','```csharp\n// 实现一个压缩文件的方法\npublic static void CompressFile(string sourceFilePath, string zipFilePath)\n{\n    // 如果文件没有找到，则报错\n    if(!File.Exists(sourceFilePath))\n    {\n        throw new FileNotFoundException(sourceFilePath + \"文件不存在！\");\n    }\n    // 如果压缩文件没有找到，则进行创建\n    if(!Directory.Exists(zipFilePath))\n    {\n        Directory.CreateDirectory(zipFilePath);\n    }\n    // 压缩文件的名称\n    var zipFileName = zipFilePath + \"\\\\\" + Path.GetFileNameWithoutExtension(sourceFilePath) + \".zip\";\n    // 如果压缩文件存在，则进行删除\n    if(File.Exists(zipFileName))\n    {\n        File.Delete(zipFileName);\n    }\n    // 开始压缩文件\n    ZipFile.CreateFromDirectory(sourceFilePath, zipFileName);\n}\n```\n\n方法示例\n\n```csharp\nstring sourceFilePath = \"C:\\\\path\\\\to\\\\source\\\\file.txt\";\nstring zipFilePath = \"C:\\\\path\\\\to\\\\zip\\\\folder\";\n\nCompressFile(sourceFilePath, zipFilePath);\n```\n\n',3,0,'23.jpg',0,51,104,4,'2023-10-30 15:15:44','2023-10-30 15:15:44'),
(474,'使用c#在指定的时间内等待函数执行结果','在指定的时间内等待某个函数的执行结果的方法。该方法接受三个参数：等待的最大时间、等待的频率和要等待的函数。方法会在指定的时间内每隔一定频率检查函数的执行结果，如果在等待时间内函数返回了true，则表示等待成功，返回true；如果超过等待时间仍未返回true，则表示等待失败，返回false。','在指定的时间内等待某个函数的执行结果的方法。该方法接受三个参数：等待的最大时间、等待的频率和要等待的函数。方法会在指定的时间内每隔一定频率检查函数的执行结果，如果在等待时间内函数返回了true，则表示等待成功，返回true；如果超过等待时间仍未返回true，则表示等待失败，返回false。\n\n```csharp\n/// <summary>\n/// 在指定的时间内等待某个函数的执行结果，并返回一个布尔值表示是否等待成功,\n/// 调用 bool result = WaitSomething(5000, 1000, () =>{})\n/// </summary>\n/// <param name=\"timeout\">表示等待的最大时间，以毫秒为单位</param>\n/// <param name=\"freq\">表示等待的频率，即每隔多少毫秒检查一次函数的执行结果</param>\n/// <param name=\"func\">表示要等待的函数，它是一个返回布尔值的委托</param>\n/// <returns></returns>\npublic static bool WaitSomething(int timeout, int freq, Func < bool > func)\n{\n    for(int index = 0; index < timeout; index += freq)\n    {\n        if(func()) return true;\n        Thread.Sleep(freq);\n    }\n    return false;\n}\n```\n\n使用示例\n\n```csharp\nbool result = WaitSomething(5000, 1000, () =>\n{\n    // 执行一些操作，返回一个布尔值\n    return true;\n});\n```\n\n',0,0,'16.jpg',0,51,104,4,'2023-10-30 15:26:54','2023-10-30 15:26:54'),
(475,'c#十六进制字符转十进制','- 十六进制字符串：由0-9和A-F组成的字符串，表示十六进制数。\n- 十进制数：由0-9组成的数字，表示十进制数。','- 十六进制字符串：由0-9和A-F组成的字符串，表示十六进制数。\n- 十进制数：由0-9组成的数字，表示十进制数。\n\n```csharp\n /// <summary>\n /// 十六进制字符串转十进制\n /// </summary>\n /// <param name=\"str\">十六进制字符</param>\n /// <returns></returns>\n static int To16Convert10(string str)\n {\n     int res = 0;\n     try\n     {\n         str = str.Trim().Replace(\" \", \"\"); //移除空字符\n         //方法1\n         res = int.Parse(str, System.Globalization.NumberStyles.AllowHexSpecifier);\n         方法2\n         //int r2 = System.Int32.Parse(str, System.Globalization.NumberStyles.HexNumber);\n         //Console.WriteLine(r2);\n         方法3\n         //int r3 = Convert.ToInt32(str, 16);\n         //Console.WriteLine(r3);\n     }\n     catch(Exception e)\n     {\n         res = 0;\n     }\n     return res;\n }\n```\n\n执行步骤\n\n1. 首先，代码中的`To16Convert10`函数接受一个十六进制字符串作为参数，并声明一个整型变量`res`用于存储转换后的十进制数。\n2. 接下来，代码使用`Trim`和`Replace`方法移除字符串中的空字符，以确保字符串的格式正确。\n3. 然后，代码使用`int.Parse`方法将十六进制字符串转换为十进制数，并将结果赋值给`res`变量。`System.Globalization.NumberStyles.AllowHexSpecifier`参数指定了允许解析十六进制数的格式。\n4. 最后，代码使用`try-catch`块来捕获可能发生的异常，并将`res`变量初始化为0，以防止转换失败时返回无效值。\n\n',2,0,'29.jpg',0,4,104,4,'2023-10-30 15:36:54','2023-10-30 15:36:54'),
(476,'winfrom窗体比例缩放','用于控件大小随窗体大小等比例缩放的C#代码。该代码可以在窗体重载中使用，以确保窗体中的控件在窗体大小改变时能够按比例缩放。','用于控件大小随窗体大小等比例缩放的C#代码。该代码可以在窗体重载中使用，以确保窗体中的控件在窗体大小改变时能够按比例缩放。\n\n- `SetTag`方法：该方法用于设置控件的`Tag`属性，以存储控件的宽度、高度、左边距、顶边距和字体大小等信息。\n- `SetControls`方法：该方法用于遍历窗体中的控件，并根据窗体缩放的比例重新设置控件的大小和位置。\n\n#### 封装缩放函数\n\n```csharp\n/// <summary>\n/// 定义当前窗体的宽度\n/// </summary>\npublic static float X;\n/// <summary>\n/// 定义当前窗体的高度\n/// </summary>\npublic static float Y;\n/// <summary>\n/// 控件大小随窗体大小等比例缩放,\n/// 在窗体重载中使用\n/// </summary>\n/// <param name=\"cons\"></param>\npublic static void SetTag(Control cons)\n    {\n        foreach(Control con in cons.Controls)\n        {\n            con.Tag = con.Width + \";\" + con.Height + \";\" + con.Left + \";\" + con.Top + \";\" + con.Font.Size;\n            if(con.Controls.Count > 0)\n            {\n                SetTag(con);\n            }\n        }\n    }\n    /// <summary>\n    /// \n    /// </summary>\n    /// <param name=\"newx\"></param>\n    /// <param name=\"newy\"></param>\n    /// <param name=\"cons\"></param>\npublic static void SetControls(float newx, float newy, Control cons)\n{\n    //遍历窗体中的控件，重新设置控件的值\n    foreach(Control con in cons.Controls)\n    {\n        //获取控件的Tag属性值，并分割后存储字符串数组\n        if(con.Tag != null)\n        {\n            string[] mytag = con.Tag.ToString().Split(new char[]\n            {\n                '';''\n            });\n            //根据窗体缩放的比例确定控件的值\n            con.Width = Convert.ToInt32(System.Convert.ToSingle(mytag[0]) * newx); //宽度\n            con.Height = Convert.ToInt32(System.Convert.ToSingle(mytag[1]) * newy); //高度\n            con.Left = Convert.ToInt32(System.Convert.ToSingle(mytag[2]) * newx); //左边距\n            con.Top = Convert.ToInt32(System.Convert.ToSingle(mytag[3]) * newy); //顶边距\n            Single currentSize = System.Convert.ToSingle(mytag[4]) * newy; //字体大小\n            con.Font = new Font(con.Font.Name, currentSize, con.Font.Style, con.Font.Unit);\n            if(con.Controls.Count > 0)\n            {\n                SetControls(newx, newy, con);\n            }\n        }\n    }\n}\n```\n\n#### 窗体初始化时使用\n\n```csharp\n// 在窗体重载方法中调用SetTag方法，设置控件的Tag属性\npublic ExeStart()\n{\n    InitializeComponent();\n    MechForm.X = this.Width;\n    MechForm.Y = this.Height;\n    MechForm.SetTag(this);\n}\n```\n\n#### 在Resize事件加载中使用\n\n在窗体大小改变事件中调用SetControls方法，重新设置控件的大小和位置\n\n```csharp\nprivate void ExeStart_Resize(object sender, EventArgs e)\n{\n    float newX = this.Width / MechForm.X; //获取当前宽度与初始宽度的比例\n    float newY = this.Height / MechForm.Y; //获取当前高度与初始高度的比例\n    MechForm.SetControls(newX, newY, this);\n}\n```\n\n',0,0,'9.jpg',0,2,104,4,'2023-10-30 16:51:49','2023-10-30 16:51:49'),
(477,'c#获取Windows当前选文件定路径','在Windows系统中点击文件后获取到文件完整路径','\n\n在Windows系统中点击文件后获取到文件完整路径\n\n```csharp\n/// <summary>\n/// 获取Windows当前选中的文件或文件夹的完整路径\n/// </summary>\n/// <returns>完整路径</returns>\nprivate static string GetWindowsSelectedPath()\n{  \n    // 获取命令行参数\n    string[] commandLineArgs = Environment.GetCommandLineArgs();\n    // 检查是否有参数传入\n    if(commandLineArgs.Length > 1)\n    {   \n         // 获取传入的路径\n        string path = commandLineArgs[1];\n         // 检查路径是否存在文件或文件夹\n        if(File.Exists(path) || Directory.Exists(path))\n        {\n            // 返回完整路径\n            return path;\n        }\n    }\n    // 如果没有找到有效路径，则返回null\n    return null;\n}\n```\n\n',2,0,'1.jpg',0,51,104,4,'2023-10-30 17:13:56','2023-10-30 17:15:32'),
(478,'c#后台任务运行','在C#中如果想要执行一段一直运行的程序，如监听网络状态，实时读取PLC数据，遇到这种情况有多种解决方法。\n\n方法一，可以起一个Task任务，在Task任务中写个死循环，这种死循环最好在最后写个 Thread.Sleep，不然程序会占用很高的CPU。','在C#中如果想要执行一段一直运行的程序，如监听网络状态，实时读取PLC数据，遇到这种情况有多种解决方法。\n\n方法一，可以起一个Task任务，在Task任务中写个死循环，这种死循环最好在最后写个 Thread.Sleep，不然程序会占用很高的CPU。\n\n```csharp\n//用于创建并启动任务的方法。它接受一个委托作为参数，该委托定义了任务要执行的代码\nTask.Factory.StartNew(() =>\n{\n    while(true)\n    {\n        Console.WriteLine(\"一直运行的代码\");\n        Thread.Sleep(10);\n    }\n}, TaskCreationOptions.LongRunning);//选项：这是一个用于指定任务类型的选项。使用LongRunning选项可以告诉任务调度器，该任务是一个长时间运行的任务，从而使任务在一个单独的线程上执行。\n```\n\n方法二 **System.Timers.Timer**\n\n```csharp\n//定义Timer\nSystem.Timers.Timer Timers_Timer = new System.Timers.Timer();\n//手动设置Timer，开始执行\nTimers_Timer.Interval = 20;\nTimers_Timer.Enabled = true;\n// AutoReset属性决定计时器是不是要发起一次事件然后停止，还是进入开始/等待的循环。\n Timers_Timer.AutoReset = true;\nTimers_Timer.Elapsed += new System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed); \n//一直运行的循环\nvoid Timers_Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n{ \nThread.Sleep(1000);\n}\n```\n\n',3,0,'16.jpg',0,52,104,4,'2023-10-31 14:31:25','2023-10-31 14:31:25'),
(479,'c#耗时及性能监测','在编程中，我们经常需要测量代码的执行时间，以便评估代码的性能和效率','### c#耗时及性能监测\n\n在编程中，我们经常需要测量代码的执行时间，以便评估代码的性能和效率\n\n命名空间 using System.Diagnostics;\n\n| 字段             | 字段说明                                              |\n| ---------------- | ----------------------------------------------------- |\n| Frequency        | 获取以每秒刻度数表示的计时器频率。此字段为只读。      |\n| IsHighResolution | 指示计时器是否基于高分辨率性能计数器。 此字段为只读。 |\n\n| 属性                | 属性说明                                               |\n| ------------------- | ------------------------------------------------------ |\n| Elapsed             | 获取当前实例测量得出的总运行时间。                     |\n| ElapsedMilliseconds | 获取当前实例测量得出的总运行时间（以毫秒为单位）。     |\n| ElapsedTicks        | 获取当前实例测量得出的总运行时间（用计时器刻度表示）。 |\n| IsRunning           | 获取一个值，该值表示 Stopwatch 计时器是否正在运行。    |\n\n| 方法              | 方法说明                                                     |\n| ----------------- | ------------------------------------------------------------ |\n| Equals(Object)    | 确定指定对象是否等于当前对象。                               |\n| GetHashCode()     | 作为默认哈希函数。                                           |\n| GetTimestamp()    | 获取计时器机制中的当前刻度数。                               |\n| GetType()         | 获取当前实例的 Type。                                        |\n| MemberwiseClone() | 创建当前 Object 的浅表副本。                                 |\n| Reset()           | 停止时间间隔测量，并将运行时间重置为零。                     |\n| Restart()         | 停止时间间隔测量，将运行时间重置为零，然后开始测量运行时间。 |\n| Start()           | 开始或继续测量某个时间间隔的运行时间。                       |\n| StartNew()        | 初始化新的 Stopwatch 实例，将运行时间属性设置为零，然后开始测量运行时间。 |\n| Stop()            | 停止测量某个时间间隔的运行时间。                             |\n| ToString()        | 返回表示当前对象的字符串。                                   |\n\n#### 基础示例\n\n`Stopwatch`类相关字段、属性、方法的使用示例，可以参考代码如下，\n\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Diagnostics;\n\nnamespace ConsoleApplication\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            //创建Stopwatch实例\n            Stopwatch sw = new Stopwatch();\n            //开始计时\n            sw.Start();\n            for (int i = 0; i < 100; i++)\n            {\n                Console.WriteLine(i);\n            }\n            //停止计时\n            sw.Stop();\n            Console.WriteLine(\"用时：\" + sw.ElapsedMilliseconds + \"\");\n            //重置 停止时间间隔测量，并将运行时间重置为0\n            sw.Reset();\n            Console.WriteLine(\"用时：\" + sw.ElapsedMilliseconds + \"\");\n            //重启 停止时间间隔测量，并将运行时间重置为0，然后重新开始           测量运行时间\n            sw.Restart();\n            for (int i = 0; i < 100; i++)\n            {\n                Console.WriteLine(i);\n            }\n            sw.Stop();\n            //获取当前实例测量得出的总运行时间（以毫秒为单位）\n            Console.WriteLine(\"用时：\" + sw.ElapsedMilliseconds + \"\");\n            //获取当前实例测量得出的总运行时间\n            Console.WriteLine(\"用时：\" + sw.Elapsed);\n            //获取当前实例测量得出的总运行时间（用计时器刻度表示）。\n            Console.WriteLine(sw.ElapsedTicks);\n            Console.Read();\n            //开始计时\n            sw.Start();\n            System.Threading.Thread.Sleep(1000);  //耗时操作 测试代码，休眠1000毫秒\n            //结束计时\n            sw.Stop();\n            Console.WriteLine(sw.ElapsedMilliseconds);     //输出：消耗的毫秒\n            Console.WriteLine(sw.Elapsed.ToString());      //输出：时：分：秒\n\n            //重置秒表\n            sw.Reset();\n            Console.WriteLine(\"Reset End\");\n            //再次开始计时，或者直接用**Restart**函数直接重置并开始\n            sw.Start();\n            System.Threading.Thread.Sleep(1200);\n            //第二次计时结束\n            sw.Stop();\n            Console.WriteLine(sw.ElapsedMilliseconds);\n            if (Stopwatch.IsHighResolution)\n            {\n                Console.WriteLine(\"使用系统的高分辨率性能计数器的计时的操作.\");\n            }\n            else\n            {\n                Console.WriteLine(\"使用DateTime类的计时操作.\");\n            }\n\n            long frequency = Stopwatch.Frequency;\n            Console.WriteLine(\"计时器频率，以滴答/秒为单位 = {0}\", frequency);\n\n            long nanosecPerTick = (1000L * 1000L * 1000L) / frequency;\n            Console.WriteLine(\"计时器在{0}纳秒以下范围内准确\", nanosecPerTick.ToString());\n\n        }\n    }\n}\n```\n\n#### 实现测量代码块执行时间的封装\n\n创建MeasureDuration.cs，并实现 `IDisposable` 接口的\n\n```csharp\nusing System;\nusing System.Diagnostics;\n\nnamespace MechTE_480.Util\n{\n    /// <summary>\n    /// 定义了一个名为MeasureDuration的类，用于测量代码的执行时间。该类实现了IDisposable接口，以便在代码块结束时自动释放资源。\n    /// </summary>\n    public class MeasureDuration : IDisposable\n    {\n        private readonly Stopwatch _stopwatch;\n        private readonly Action<TimeSpan> _callback;\n\n        /// <summary>\n        /// 构造函数接受一个Action&lt;TimeSpan&gt;类型的回调函数作为参数。在构造函数中，我们将回调函数赋值给私有字段_callback，并使用Stopwatch.StartNew()方法启动一个新的计时器。\n        /// </summary>\n        /// <param name=\"callback\"></param>\n        public MeasureDuration(Action<TimeSpan> callback)\n        {\n            _callback = callback;\n            _stopwatch = Stopwatch.StartNew();\n        }\n\n        /// <summary>\n        /// 释放资源\n        /// </summary>\n        public void Dispose()\n        {\n            _stopwatch.Stop();\n            _callback(_stopwatch.Elapsed);\n        }\n    }\n}\n```\n\n在单元测试中使用 `MeasureDuration` 类来测量代码块的执行时间\n\n```csharp\n[Fact]\npublic void Duration()\n{\n    using(new MeasureDuration(duration => _msg.WriteLine($ \"代码执行时间：{duration}\")))\n    {\n        // 在这里编写需要测量执行时间的代码\n        for(int i = 0; i < 10; i++)\n        {\n            // 一些耗时的操作\n            Thread.Sleep(1000);\n        }\n    }\n}\n```\n\n使用了using语句来创建一个MeasureDuration对象，并在代码块结束时自动释放资源。在MeasureDuration的构造函数中，我们传入了一个回调函数，该函数将在代码块结束时被调用，并将代码执行的时间间隔作为参数传递给回调函数。在回调函数中，我们将代码执行的时间间隔输出到控制台。',0,0,'17.jpg',0,4,104,4,'2023-10-31 15:26:21','2023-10-31 15:26:21'),
(480,'vscode文件嵌套配置','这是一个配置代码段，使用 VS Code 的文件[嵌套功能](https://code.visualstudio.com/updates/v1_67#_explorer-file-nesting)使您的文件树更干净。在settings.json中配置','这是一个配置代码段，使用 VS Code 的文件[嵌套功能](https://code.visualstudio.com/updates/v1_67#_explorer-file-nesting)使您的文件树更干净。在settings.json中配置\n\n```makefile\n  // updated 2023-09-12 03:14\n  // https://github.com/antfu/vscode-file-nesting-config\n  \"explorer.fileNesting.enabled\": true,\n  \"explorer.fileNesting.expand\": false,\n  \"explorer.fileNesting.patterns\": {\n    \"*.asax\": \"$(capture).*.cs, $(capture).*.vb\",\n    \"*.ascx\": \"$(capture).*.cs, $(capture).*.vb\",\n    \"*.ashx\": \"$(capture).*.cs, $(capture).*.vb\",\n    \"*.aspx\": \"$(capture).*.cs, $(capture).*.vb\",\n    \"*.bloc.dart\": \"$(capture).event.dart, $(capture).state.dart\",\n    \"*.c\": \"$(capture).h\",\n    \"*.cc\": \"$(capture).hpp, $(capture).h, $(capture).hxx\",\n    \"*.cjs\": \"$(capture).cjs.map, $(capture).*.cjs, $(capture)_*.cjs\",\n    \"*.component.ts\": \"$(capture).component.html, $(capture).component.spec.ts, $(capture).component.css, $(capture).component.scss, $(capture).component.sass, $(capture).component.less\",\n    \"*.cpp\": \"$(capture).hpp, $(capture).h, $(capture).hxx\",\n    \"*.cs\": \"$(capture).*.cs\",\n    \"*.cshtml\": \"$(capture).cshtml.cs\",\n    \"*.csproj\": \"*.config, *proj.user, appsettings.*, bundleconfig.json\",\n    \"*.css\": \"$(capture).css.map, $(capture).*.css\",\n    \"*.cxx\": \"$(capture).hpp, $(capture).h, $(capture).hxx\",\n    \"*.dart\": \"$(capture).freezed.dart, $(capture).g.dart\",\n    \"*.ex\": \"$(capture).html.eex, $(capture).html.heex, $(capture).html.leex\",\n    \"*.go\": \"$(capture)_test.go\",\n    \"*.java\": \"$(capture).class\",\n    \"*.js\": \"$(capture).js.map, $(capture).*.js, $(capture)_*.js\",\n    \"*.jsx\": \"$(capture).js, $(capture).*.jsx, $(capture)_*.js, $(capture)_*.jsx, $(capture).less, $(capture).module.less\",\n    \"*.master\": \"$(capture).*.cs, $(capture).*.vb\",\n    \"*.mjs\": \"$(capture).mjs.map, $(capture).*.mjs, $(capture)_*.mjs\",\n    \"*.module.ts\": \"$(capture).resolver.ts, $(capture).controller.ts, $(capture).service.ts\",\n    \"*.mts\": \"$(capture).mts.map, $(capture).*.mts, $(capture)_*.mts\",\n    \"*.pubxml\": \"$(capture).pubxml.user\",\n    \"*.resx\": \"$(capture).*.resx, $(capture).designer.cs, $(capture).designer.vb\",\n    \"*.tex\": \"$(capture).acn, $(capture).acr, $(capture).alg, $(capture).aux, $(capture).bbl, $(capture).blg, $(capture).fdb_latexmk, $(capture).fls, $(capture).glg, $(capture).glo, $(capture).gls, $(capture).idx, $(capture).ind, $(capture).ist, $(capture).lof, $(capture).log, $(capture).lot, $(capture).out, $(capture).pdf, $(capture).synctex.gz, $(capture).toc, $(capture).xdv\",\n    \"*.ts\": \"$(capture).js, $(capture).d.ts.map, $(capture).*.ts, $(capture)_*.js, $(capture)_*.ts\",\n    \"*.tsx\": \"$(capture).ts, $(capture).*.tsx, $(capture)_*.ts, $(capture)_*.tsx, $(capture).less, $(capture).module.less\",\n    \"*.vbproj\": \"*.config, *proj.user, appsettings.*, bundleconfig.json\",\n    \"*.vue\": \"$(capture).*.ts, $(capture).*.js, $(capture).story.vue\",\n    \"*.xaml\": \"$(capture).xaml.cs\",\n    \"+layout.svelte\": \"+layout.ts,+layout.ts,+layout.js,+layout.server.ts,+layout.server.js,+layout.gql\",\n    \"+page.svelte\": \"+page.server.ts,+page.server.js,+page.ts,+page.js,+page.gql\",\n    \".clang-tidy\": \".clang-format, .clangd, compile_commands.json\",\n    \".env\": \"*.env, .env.*, .envrc, env.d.ts\",\n    \".gitignore\": \".gitattributes, .gitmodules, .gitmessage, .mailmap, .git-blame*\",\n    \".project\": \".classpath\",\n    \"BUILD.bazel\": \"*.bzl, *.bazel, *.bazelrc, bazel.rc, .bazelignore, .bazelproject, WORKSPACE\",\n    \"CMakeLists.txt\": \"*.cmake, *.cmake.in, .cmake-format.yaml, CMakePresets.json\",\n    \"I*.cs\": \"$(capture).cs\",\n    \"Pipfile\": \".editorconfig, .flake8, .isort.cfg, .python-version, Pipfile, Pipfile.lock, requirements*.in, requirements*.pip, requirements*.txt, tox.ini\",\n    \"artisan\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, server.php, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, webpack.mix.js, windi.config.*\",\n    \"astro.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"cargo.toml\": \".clippy.toml, .rustfmt.toml, cargo.lock, clippy.toml, cross.toml, rust-toolchain.toml, rustfmt.toml\",\n    \"composer.json\": \".php*.cache, composer.lock, phpunit.xml*, psalm*.xml\",\n    \"default.nix\": \"shell.nix\",\n    \"deno.json*\": \"*.env, .env.*, .envrc, api-extractor.json, deno.lock, env.d.ts, import-map.json, import_map.json, jsconfig.*, tsconfig.*, tsdoc.*\",\n    \"dockerfile\": \".dockerignore, docker-compose.*, dockerfile*\",\n    \"flake.nix\": \"flake.lock\",\n    \"gatsby-config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, gatsby-browser.*, gatsby-node.*, gatsby-ssr.*, gatsby-transformer.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"gemfile\": \".ruby-version, gemfile.lock\",\n    \"go.mod\": \".air*, go.sum\",\n    \"go.work\": \"go.work.sum\",\n    \"hatch.toml\": \".editorconfig, .flake8, .isort.cfg, .python-version, hatch.toml, requirements*.in, requirements*.pip, requirements*.txt, tox.ini\",\n    \"mix.exs\": \".credo.exs, .dialyzer_ignore.exs, .formatter.exs, .iex.exs, .tool-versions, mix.lock\",\n    \"next.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, next-env.d.ts, next-i18next.config.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"nuxt.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .nuxtignore, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"package.json\": \".browserslist*, .circleci*, .commitlint*, .cz-config.js, .czrc, .dlint.json, .dprint.json, .editorconfig, .eslint*, .firebase*, .flowconfig, .github*, .gitlab*, .gitpod*, .huskyrc*, .jslint*, .lintstagedrc*, .markdownlint*, .node-version, .nodemon*, .npm*, .nvmrc, .pm2*, .pnp.*, .pnpm*, .prettier*, .release-please*.json, .releaserc*, .sentry*, .simple-git-hooks*, .stackblitz*, .styleci*, .stylelint*, .tazerc*, .textlint*, .tool-versions, .travis*, .versionrc*, .vscode*, .watchman*, .xo-config*, .yamllint*, .yarnrc*, Procfile, apollo.config.*, appveyor*, azure-pipelines*, bower.json, build.config.*, bun.lockb, commitlint*, crowdin*, dangerfile*, dlint.json, dprint.json, electron-builder.*, eslint*, firebase.json, grunt*, gulp*, jenkins*, lerna*, lint-staged*, nest-cli.*, netlify*, nodemon*, npm-shrinkwrap.json, nx.*, package-lock.json, package.nls*.json, phpcs.xml, pm2.*, pnpm*, prettier*, pullapprove*, pyrightconfig.json, release-please*.json, release-tasks.sh, release.config.*, renovate*, rollup.config.*, rspack*, simple-git-hooks*, stylelint*, tslint*, tsup.config.*, turbo*, typedoc*, unlighthouse*, vercel*, vetur.config.*, webpack*, workspace.json, xo.config.*, yarn*\",\n    \"pubspec.yaml\": \".metadata, .packages, all_lint_rules.yaml, analysis_options.yaml, build.yaml, pubspec.lock, pubspec_overrides.yaml\",\n    \"pyproject.toml\": \".editorconfig, .flake8, .isort.cfg, .pdm-python, .pdm.toml, .python-version, MANIFEST.in, Pipfile, Pipfile.lock, hatch.toml, pdm.lock, poetry.lock, pyproject.toml, requirements*.in, requirements*.pip, requirements*.txt, setup.cfg, setup.py, tox.ini\",\n    \"quasar.conf.js\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, quasar.extensions.json, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"readme*\": \"authors, backers*, changelog*, citation*, code_of_conduct*, codeowners, contributing*, contributors, copying*, credits, governance.md, history.md, license*, maintainers, readme*, security.md, sponsors*\",\n    \"remix.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, remix.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"requirements.txt\": \".editorconfig, .flake8, .isort.cfg, .python-version, requirements*.in, requirements*.pip, requirements*.txt, tox.ini\",\n    \"rush.json\": \".browserslist*, .circleci*, .commitlint*, .cz-config.js, .czrc, .dlint.json, .dprint.json, .editorconfig, .eslint*, .firebase*, .flowconfig, .github*, .gitlab*, .gitpod*, .huskyrc*, .jslint*, .lintstagedrc*, .markdownlint*, .node-version, .nodemon*, .npm*, .nvmrc, .pm2*, .pnp.*, .pnpm*, .prettier*, .release-please*.json, .releaserc*, .sentry*, .simple-git-hooks*, .stackblitz*, .styleci*, .stylelint*, .tazerc*, .textlint*, .tool-versions, .travis*, .versionrc*, .vscode*, .watchman*, .xo-config*, .yamllint*, .yarnrc*, Procfile, apollo.config.*, appveyor*, azure-pipelines*, bower.json, build.config.*, bun.lockb, commitlint*, crowdin*, dangerfile*, dlint.json, dprint.json, electron-builder.*, eslint*, firebase.json, grunt*, gulp*, jenkins*, lerna*, lint-staged*, nest-cli.*, netlify*, nodemon*, npm-shrinkwrap.json, nx.*, package-lock.json, package.nls*.json, phpcs.xml, pm2.*, pnpm*, prettier*, pullapprove*, pyrightconfig.json, release-please*.json, release-tasks.sh, release.config.*, renovate*, rollup.config.*, rspack*, simple-git-hooks*, stylelint*, tslint*, tsup.config.*, turbo*, typedoc*, unlighthouse*, vercel*, vetur.config.*, webpack*, workspace.json, xo.config.*, yarn*\",\n    \"setup.cfg\": \".editorconfig, .flake8, .isort.cfg, .python-version, MANIFEST.in, requirements*.in, requirements*.pip, requirements*.txt, setup.cfg, tox.ini\",\n    \"setup.py\": \".editorconfig, .flake8, .isort.cfg, .python-version, MANIFEST.in, requirements*.in, requirements*.pip, requirements*.txt, setup.cfg, setup.py, tox.ini\",\n    \"shims.d.ts\": \"*.d.ts\",\n    \"svelte.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, houdini.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, mdsvex.config.js, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vite.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"vite.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\",\n    \"vue.config.*\": \"*.env, .babelrc*, .codecov, .cssnanorc*, .env.*, .envrc, .htmlnanorc*, .lighthouserc.*, .mocha*, .postcssrc*, .terserrc*, api-extractor.json, ava.config.*, babel.config.*, contentlayer.config.*, cssnano.config.*, cypress.*, env.d.ts, formkit.config.*, formulate.config.*, histoire.config.*, htmlnanorc.*, i18n.config.*, jasmine.*, jest.config.*, jsconfig.*, karma*, lighthouserc.*, playwright.config.*, postcss.config.*, puppeteer.config.*, rspack.config.*, svgo.config.*, tailwind.config.*, tsconfig.*, tsdoc.*, uno.config.*, unocss.config.*, vitest.config.*, vuetify.config.*, webpack.config.*, windi.config.*\"\n  },\n```\n\n',2,0,'22.jpg',0,53,110,4,'2023-10-31 15:44:25','2023-10-31 15:44:25'),
(481,'c#局部类','partial是局部类型的意思。允许我们将一个类、结构或接口分成几个部分，分别实现在几个不同的.cs文件中。C#编译器在编译的时候仍会将各个部分的局部类型合并成一个完整的类\n','partial是局部类型的意思。允许我们将一个类、结构或接口分成几个部分，分别实现在几个不同的.cs文件中。C#编译器在编译的时候仍会将各个部分的局部类型合并成一个完整的类\n\n### 使用事项\n\n关键字partial是一个上下文关键字，只有和 class、struct、interface 放在一起时才有关键字的含义。因此partial的引入不会影响现有代码中名称为partial的变量\n\n**适用于以下情况**\n\n- 类型特别大，不宜放在一个文件中实现\n- 一个类型中的一部分代码为自动化工具生成的代码，不宜与我们自己编写的代码混合在一起\n- 需要多人合作编写一个类\n\n**类型限制**\n\n- 局部类型只适用于类、接口、结构，不支持委托和枚举\n- 同一个类型的各个部分必须都有修饰符 partial\n- 使用局部类型时，一个类型的各个部分必须位于相同的命名空间中\n- 个类型的各个部分必须被同时编译\n\n### 累加效应\n\n在局部类型上的特性具有“累加”效应。\n\n```csharp\n[Attribute1, Attribute2(\"Hello\")]\npartial class Class1{}\n\n[Attribute3, Attribute2(\"Exit\")]\npartial class Class1{}\n\n//相当于\n[Attribute1, Attribute2(\"Hello\"), Attribute3, Attribute2(\"Exit\")]\nclass Class1 {}\n```\n\n基类和接口\n\n一个类型的各个部分上指定的基类必须一致。某个部分可以不指定基类，但如果指定，则必须相同。\n\n```csharp\npartial class Class2: Iinterface1, Iinterface2 {}\npartial class Class2: Iinterface3 {}\npartial class Class2: Iinterface2 {}\n\n//相当于  \nclass Class2: Iinterface1, Iinterface2, Iinterface3 {}\n```\n\n### 局部类型修饰符\n\n- 一个类型的各个部分上的访问修饰符必须维持一致性。\n- 如果一个类型有一个部分使用了abstract修饰符，那么整个类都将被视为抽象类。\n- 如果一个类型有一个部分使用了 sealed 修饰符，那么整个类都将被视为密封类。\n- 一个类的各个部分不能使用相互矛盾的修饰符，比如不能在一个部分上使用abstract，又在另一个部分上使用sealed。\n\n### 局部类使用\n\n声明必须使用partial关键字\n\n```csharp\npublic partial class MyClass\n{\n    // class implementation\n}\n```\n\n可以像普通类一样使用\n\n```csharp\nMyClass myObject = new MyClass();\nmyObject.MyMethod();\n```\n\n示例代码：\n\n```csharp\npartial class MyClass\n{\n    private int myField;\n\n    public void MyMethod()\n    {\n        Console.WriteLine(\"MyMethod called.\");\n    }\n}\n```\n\n在另一个文件中，可以使用相同的类名和partial关键字来声明该类的另一个部分：\n\n```csharp\npartial class MyClass\n{\n    private string myOtherField;\n\n    public void MyOtherMethod()\n    {\n        Console.WriteLine(\"MyOtherMethod called.\");\n    }\n}\n```\n\n这两个部分将组合成一个完整的类。\n\n```csharp\nmyObject = new MyClass();\nmyObject.MyMethod();\nmyObject.MyOtherMethod();\n```\n\n输出：\n\n```undefined\nMyMethod called.\nMyOtherMethod called.\n```\n\n',0,0,'20.jpg',0,54,104,4,'2023-11-03 08:50:04','2023-11-03 08:50:04'),
(483,'c#匿名类','匿名类是一种特殊的类，它允许我们在不定义具体类的情况下创建一个临时的、只有属性的类。匿名类通常用于临时存储和传递数据，特别是在LINQ查询中非常有用','匿名类是一种特殊的类，它允许我们在不定义具体类的情况下创建一个临时的、只有属性的类。匿名类通常用于临时存储和传递数据，特别是在LINQ查询中非常有用\n\n匿名类在linq to sql或者entity framework中返回查询数据时很好用。\n\n- 匿名类是一种临时的、只有属性的类。\n- 匿名类的属性可以根据需要动态创建。\n- 匿名类的属性可以通过对象初始化器进行赋值。\n\n```csharp\nvar person = new\n{\n    Name = \"张三\",\n    Age = 25,\n    Occupation = \"工程师\"\n};\n\nConsole.WriteLine($\"姓名：{person.Name}\");\nConsole.WriteLine($\"年龄：{person.Age}\");\nConsole.WriteLine($\"职业：{person.Occupation}\");\n\n```\n\n\n\n',1,0,'26.jpg',0,54,104,4,'2023-11-03 09:08:51','2023-11-03 09:08:51'),
(484,'c#字符格式化','字符串格式化是一种将变量的值插入到字符串中的方法。它允许我们创建动态的字符串，其中包含变量的值。','字符串格式化是一种将变量的值插入到字符串中的方法。它允许我们创建动态的字符串，其中包含变量的值。\n\n### string.Format\n\n通过在字符串中使用占位符`{0}`，`{1}`等，我们可以指定要插入的变量的位置。然后，通过在`string.Format`方法的参数中提供相应的变量值，我们可以将这些值插入到字符串中\n\n```csharp\nvar contactInfo = string.Format(\"Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}\", \ncontact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);\n```\n\n### 新语法格式化\n\n使用了字符串插值的新语法。在字符串前面加上`$`符号，我们可以直接在字符串中插入变量的值，而无需使用占位符。变量的值将在字符串中用花括号`{}`括起来\n\n```csharp\nvar contactInfo2 = $\"Id:{contact.Id} Name:{contact.Name} EmailAddr:\n{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n\n字符串插值的更高级用法。在这个示例中，我们使用了条件表达式来检查联系人姓名的长度。如果姓名的长度为0，则将默认值\"Frank\"插入到字符串中，否则将插入实际的姓名\n\n```csharp\nvar contactInfo = $\"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? \"Frank\" : \ncontact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n\n',1,0,'17.jpg',0,4,104,4,'2023-11-03 10:19:32','2023-11-03 10:19:32'),
(485,'c#字符串转整数类型','将字符串转换为整数类型。为了方便，C#提供了一个内置的方法`TryParse`来实现这个功能','将字符串转换为整数类型。为了方便，C#提供了一个内置的方法`TryParse`来实现这个功能\n\n- 字符串（String）：表示一串字符的数据类型。\n- 整数（Integer）：表示不带小数点的数字。\n- 解析（Parsing）：将字符串转换为其他数据类型的过程。\n\n###  TryParse\n\n`TryParse`方法是一个静态方法，可以直接通过类名调用。它的代码结构如下：\n\n```csharp\npublic static bool TryParse(string s, out Int32 i);\n```\n\n示例代码\n\n转换成功返回true,否则返回false\n\n```csharp\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n\n',0,0,'10.jpg',0,55,104,4,'2023-11-03 10:30:43','2023-11-03 10:31:26'),
(486,' c#中使用METest单元测试','METest是一个用于测试C#代码的单元测试框架。单元测试是一种软件测试方法，用于验证代码的各个单元（函数、方法、类等）是否按照预期工作。METest提供了一种简单而强大的方式来编写和运行单元测试。','METest是一个用于测试C#代码的单元测试框架。单元测试是一种软件测试方法，用于验证代码的各个单元（函数、方法、类等）是否按照预期工作。METest提供了一种简单而强大的方式来编写和运行单元测试。\n\n- `TestMethod`：这是一个特性，用于标记测试方法。\n- `Assert`：这是一个断言类，用于验证测试结果是否符合预期。\n- `DataTestMethod`属性：用于标记一个方法作为参数化测试方法。\n- `DataRow`属性：用于提供参数值，每个参数值对应一个测试用例。\n\n### 使用单元测试\n\n点击VS项目解决方案>> MSTest单元测试项目\n\n建好单元项目引入需要测试的项目\n\n**AAA（准备、执行、断言）模式**\n\n是编写待测试方法的单元测试的常用方法：\n\n- **准备**（Arrange)，单元测试方法的准备部分初始化对象并设置传递给待测试方法的数据；\n- **执行**（Act），执行部分调用具有准备参数的待测试方法；\n- **断言**（Assert），断言部分验证待测试方法的执行行为与预期相同。\n\n```csharp\n[TestMethod()]\npublic void GetTriangle_Test()\n{\n    // arrange  \n    string[] sideArr = { \"5\", \"5\", \"5\" }; // 准备传给待测试方法的数据\n    string expected = \"等边三角形\";\n    // act  \n    var actual = UnitTestClass.GetTriangle(sideArr); // 调用测试方法\n    // assert  \n    Assert.AreEqual(expected, actual); // 验证待测试方法的执行结果是否与预期相同\n}\n```\n\n### 参数化测试\n\n同样的逻辑，根据**输入参数不同**，**给出不同的结果**。因为只是参数不同，所以并不希望把测试方法写多遍，但是又希望对每个参数的测试成为一个独立的测试用例。举例说，假定我有一个数学计算的方法是把两个整数相加求和，我希望证明这个方法对于任意两个数都是通过的。\n\n```csharp\n[DataTestMethod] //注明这个方法是参数化测试方法；\n[DataRow(\"0508\")] //一组参数，参数可以是任何值；但是一定要和参数的测试方法匹配。\n[DataRow(\"0509\")]\n[DataRow(\"0005\")]\npublic void GetFlag(string name)\n{\n    //act 执行部分 调用具有准备参数的待测方法\n    var r = fun.Flag(\"D\", \"R\", name);\n    //assert 断言部分 验证预期和实际结果是否相同\n    Assert.AreEqual(name, r);\n}\n```\n\n这里有一个要点，参数的个数设置多少个，因为测试的方法适合三个参数，所以大部分的人都认为是三个参数就够了，其实不是，应该是四个参数，还有一个是结果值。看上面的代码，我们最后断言的标准是期望值和实际值进行对比，而期望值是来自参数组\n\n\n\n### 测试示例1\n\n```csharp\nusing Autofac;\nusing MerryDllFramework;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace MsTestMerryDLL\n{\n    [TestClass]\n    public class UnitTest1\n    {\n        Functional fun;\n        private static IContainer Container\n        {\n            set;\n            get;\n        }\n\n        [ClassInitialize]\n        public static void ClassInitialize(TestContext testContext)\n        {\n            // 在测试类初始化之前进行调用的方法\n        }\n\n        [TestInitialize]\n        public void TestInitialize()\n        {\n            // 在每个测试方法执行之前进行调用的方法\n            ContainerBuilder builder = new ContainerBuilder();\n            builder.RegisterType<Functional>().As<Functional>().SingleInstance();\n            Container = builder.Build();\n            fun = Container.Resolve<Functional>();\n            var res = fun.USB(\"D\", 1);\n            Assert.AreEqual(expected: \"True\", res);\n        }\n\n        [TestCleanup]\n        public void TestCleanup()\n        {\n            // 在每个测试方法执行之后进行调用的方法\n            var res = fun.USB(\"D\", 0);\n            Assert.AreEqual(\"True\", res);\n        }\n\n        [DataTestMethod]\n        [DataRow(\"0508\")]\n        [DataRow(\"0509\")]\n        [DataRow(\"0005\")]\n        public void GetFlag(string name)\n        {\n            // 测试方法\n            var r = fun.Flag(\"D\", \"R\", name);\n            Assert.AreEqual(name, r);\n        }\n    }\n}\n\n```\n\n',1,0,'6.jpg',0,56,104,4,'2023-11-03 10:55:55','2023-11-03 10:55:55'),
(487,'Sandcastle生成文档','使用Sandcastle生成Api文档需要使用对应程序集的注释xml + 程序集dll作为数据源，通过对xml + dll数据解析生成文档；所以主体步骤如下：','下载: https://github.com/EWSoftware/SHFB/releases\n\n使用Sandcastle生成Api文档需要使用对应程序集的注释xml + 程序集dll作为数据源，通过对xml + dll数据解析生成文档；所以主体步骤如下：\n\n- 程序集资源生成\n- 创建配置.shfbproj项目\n- 编译构建文档\n\n### 程序集资源生成\n\n#### 生成程序集Api Xml\n\n配置需要生成的程序集Api Xml，默认生成到\\bin\\Debug\\xxx下\n\n ![image-20230602092253720](http://kai.snblogs.cn/typora/image-20230602092253720.png)\n\n\n\n#### 输出文件\n\n ![image-20230602092330398](http://kai.snblogs.cn/typora/image-20230602092330398.png)\n\n### 创建配置.shfbproj项目\n\n此处为使用 Sandcastle Help File Builder GUI进行项目的创建、配置；\n\n当然，你也可以使用vs创建，前提是需要安装vs插件包：[四种Sandcastle方法生成c#.net帮助类帮助文档](https://www.cnblogs.com/anyushengcms/p/7682501.html)\n\n#### 新建.shfbproj项目\n\n ![image-20230602092413995](http://kai.snblogs.cn/typora/image-20230602092413995.png)\n\n#### 配置项目\n\n##### 配置build\n\n ![image-20230602092438559](http://kai.snblogs.cn/typora/image-20230602092438559.png)\n\n\n\n##### 配置help file\n\n ![image-20230602092455675](http://kai.snblogs.cn/typora/image-20230602092455675.png)\n\n##### 添加xml及dll 等资源文件\n\n ![image-20230602092513328](http://kai.snblogs.cn/typora/image-20230602092513328.png)\n\n### 编译构建文档\n\n#### 使用shfb gui工具\n\n ![image-20230602092543520](http://kai.snblogs.cn/typora/image-20230602092543520.png)\n\n\n\n### 自定义配置生成方法\n\n默认情况下dll中所有方法和属性都会生成对应文档，也可以根据自己需要只把DLL中需要的类或方法生成文档，可通过如下图配置：\n\n ![image-20230602103610929](http://kai.snblogs.cn/typora/image-20230602103610929.png)\n\n\n\n ![image-20230602103624339](http://kai.snblogs.cn/typora/image-20230602103624339.png)',0,0,'1.jpg',0,36,104,4,'2023-11-06 10:08:10','2023-11-06 10:08:10'),
(488,'c#中switch常用模式','c#中switch常用模式','#### 声明模式\n\n首先检查`value`的类型，然后根据类型输出相应的消息\n\n```csharp\npublic void ShowMessage(object value)\n{\n    switch (value)\n    {\n        case int i: Console.WriteLine($\"value is int:{i}\"); break;\n        case long l: Console.WriteLine($\"value is long:{l}\"); break;\n        case bool b: Console.WriteLine($\"value is bool:{b}\"); break;\n        case string s: Console.WriteLine($\"value is string:{s}\"); break;\n        default: Console.WriteLine($\"value is object\"); break;\n    }\n}\n\n```\n\n#### 类型模式\n\n类型模式可以理解为在声明模式中使用了弃元：　　\n\n```csharp\npublic void ShowMessage(object value)\n{\n    switch (value)\n    {\n        case int: Console.WriteLine($\"value is int\"); break;\n        case long: Console.WriteLine($\"value is long\"); break;\n        case bool: Console.WriteLine($\"value is bool\"); break;\n        case string: Console.WriteLine($\"value is string\"); break;\n        default: Console.WriteLine($\"value is object\"); break;\n    }\n}\n\n```\n\n#### 常量模式\n\n　　常量模式可以理解为原来C#6.0及之前的用法：　　\n\n```csharp\nswitch (score)\n{\n    case 10:\n    case 9:\n        Console.WriteLine(\"优秀\");\n        break;\n    case 8:\n        Console.WriteLine(\"良好\");\n        break;\n    case 7:\n    case 6:\n        Console.WriteLine(\"及格\");\n        break;\n    default:\n        Console.WriteLine(\"不及格\");\n        break;\n}\n```\n\n####  关系模式　　\n\n```csharp\nswitch(score)\n{\n    case >=80:\n        Console.WriteLine(\"excellent\");\n        break;\n    case >=60:\n        Console.WriteLine(\"good\");\n        break;\n    default:\n        Console.WriteLine(\"poor\");\n        break;\n}\n```\n\n#### 逻辑模式　　\n\n```csharp\nswitch(value)\n{\n    case 0:\n        Console.WriteLine(\"value is 0\");\n        break;\n    case not 0 and(100 or - 100):\n        Console.WriteLine(\"abs(value)==100\");\n        break;\n    case not 0 and( > 0 and < 100):\n        Console.WriteLine(\"value is positive and less than 100\");\n        break;\n    case not 0 and > 0:\n        Console.WriteLine(\"value is positive and greater than 100\");\n        break;\n    case <-100 or( < 0 and > -100):\n        Console.WriteLine(\"value is negative and not equals -100\");\n        break;\n}\n```\n\n#### 属性模式\n\n```csharp\nswitch(time)\n{\n    case {\n        Year: 2020 or 2021,\n        Month: <= 6,\n        Day: 1\n    }\n    t:\n        Console.WriteLine($ \"the first day of every month in the first half of 2020 and 2021\");\n        break;\n    case {\n        Year: not 2022\n    }:\n        Console.WriteLine($ \"not 2022\");\n        break;\n    case {\n        DayOfWeek: not DayOfWeek.Sunday and not DayOfWeek.Saturday\n    }:\n        Console.WriteLine($ \"recursion\");\n        break;\n}\n```\n\n#### 位置模式\n\n　　位置模式采用解构的特性来说明指定的模式是否匹配：　　\n\n```csharp\npublic record Point2D(int X, int Y); //记录可以解构\nstatic void Print(Point2D point)\n{\n    switch(point)\n    {\n        case( > 0, > 0):\n            Console.WriteLine(\"first quadrant\");\n            break;\n        case( < 0, > 0):\n            Console.WriteLine(\"second quadrant\");\n            break;\n        case( < 0, < 0):\n            Console.WriteLine(\"third quadrant\");\n            break;\n        case( > 0, < 0):\n            Console.WriteLine(\"fourth quadrant\");\n            break;\n        default:\n            Console.WriteLine(\"coordinate axis\");\n            break;\n    }\n}\n```\n\n#### Var模式\n\n　　Var模式往往和属性模式和位置模式结合，用于提取属性变量值：　　\n\n```csharp\nswitch(point)\n{\n    case(var x,\n        var y,\n            var z):\n        Console.WriteLine($ \"3D point:({x},{y},{z})\");\n        break; //在位置模式中使用\n    case Point2D\n    {\n        X: var x, Y: var y\n    }:\n        Console.WriteLine($ \"2D point:({x},{y})\");\n        break; //在属性模式中使用\n    default:\n        Console.WriteLine(\"others\");\n        break;\n}\n```\n\n#### 弃元模式\n\n　　弃元模式在switch语句中用的不多，但是在switch表达式中使用的多：　　\n\n```csharp\nvar result = score\nswitch\n{ >= 80 => \"excellent\", >= 60 => \"good\",\n        _ => \"poor\" //弃元在switch表达式中就相当于default\n};\n```\n\n',1,0,'29.jpg',0,57,104,4,'2023-11-06 10:37:19','2023-11-06 10:37:19'),
(489,'c#中的析构函数','用于在对象被销毁时执行清理操作。它与构造函数相反，构造函数用于在对象创建时执行初始化操作。','用于在对象被销毁时执行清理操作。它与构造函数相反，构造函数用于在对象创建时执行初始化操作。\n\n- 析构函数是用于释放资源和执行清理操作的特殊方法\n- 析构函数的名称与类名相同，但前面加上一个波浪线（~）作为前缀\n- 析构函数在对象被销毁之前自动调用\n\n```csharp\n// 析构函数\n~ClassName()\n{\n    // 析构函数的代码\n}\n```\n\n### 示例1\n\n```csharp\nusing System;\n\npublic class MyClass\n{\n    private int[] myArray;\n\n    public MyClass()\n    {\n        myArray = new int[100];\n        Console.WriteLine(\"Object created.\");\n    }\n\n    ~MyClass()\n    {\n        Console.WriteLine(\"Object destroyed.\");\n    }\n}\n\npublic class Program\n{\n    public static void Main()\n    {\n        MyClass myObject = new MyClass();\n        Console.WriteLine(\"Press any key to destroy object.\");\n        Console.ReadKey();\n    }\n}\n```\n\n当`MyClass`对象被销毁时，析构函数将输出`Object destroyed.`。在`Main`方法中，我们创建了一个`MyClass`对象，并等待用户按下任意键来销毁该对象。\n\n使用析构函数时，应该小心，因为它们可能会导致性能问题和内存泄漏。\n\n### 注意点\n\n 1.只能对**类**使用析构函数。\n 2.一个**类**只能有一个**析构函数**。\n 3.无法继承或重载**析构函数**。\n 4.无法调用**析构函数**。 它们是被**自动**调用的。\n 5.析构函数既没有**修饰符**，也没有**参数**。\n 6.不应使用**空**析构函数。 如果析构函数为空，只会导致不必要的性能损失。\n',1,0,'22.jpg',0,51,104,4,'2023-11-06 11:55:12','2023-11-09 14:15:38'),
(490,'vue3中使用Pinia','Pinia 是一个用于 Vue 的状态管理库，类似 Vuex, 是 Vue 的另一种状态管理方案\n','Pinia 是一个用于 Vue 的状态管理库，类似 Vuex, 是 Vue 的另一种状态管理方案\n\n三大核心：state（存储的值），getters（计算属性），actions也可支持同步（改变值的方法，支持同步和异步）\n\n```\nnpm install pinia@next\nor\nyarn add pinia@next\n```\n\n### 模块化封装\n\n#### 创建实例\n\n新建 store/index.ts（src目录下新建store文件夹，并创建index.ts文件）\n\n创建 pinia 实例并导出所有模块\n\n```js\nimport { createPinia } from ''pinia''\n\nconst store = createPinia()\n\nexport default store\n```\n\n```js\n//main.ts\n// 引入 pinia\nimport store from ''./stores''\n\nconst app = createApp(App)\napp.use(store)\n```\n\n#### module\n\n新建store/modules/urer.ts\n\nmodules 按模块定义对应的 `store`, `user.ts` 表示用户相关数据存储的仓库\n\n```js\n// user.ts\nimport { defineStore } from ''pinia''\n\n// 你可以对 `defineStore()` 的返回值进行任意命名，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。(比如 `useUserStore`，`useCartStore`，`useProductStore`)\n// 第一个参数是你的应用中 Store 的唯一 ID。\nexport const useUserInfoStore = defineStore(''useUserInfoStore'', {\n  // 其他配置...\n  // state: 返回对象的函数\n  state: () => {\n    return {\n      login: false\n    }\n  },\n    getters: {\n    newName: (state) => state.userInfo.name + ''vip'',\n  },\n    actions: {\n    //更新整个对象\n    updateUserInfo(userInfo: { name: string; age: number }) {\n      this.userInfo = userInfo;\n    },\n    //更新对象中某个属性\n    updateAge(age: number) {\n      this.userInfo.age = age;\n    },\n    //更新基础数据类型\n    updateToken(token: string) {\n      this.token = token;\n    },\n  },\n})\n```\n\n#### constant\n\nconstant/index.ts 用来存放定义的一些全局常量信息，暂时不是很多，所以统一放在了一个文件下。\n\n#### 调用store\n\n```js\nimport { useUiSetStore } from ''@/store/modules/uiSettings''\nconst ui = useUiSetStore()\nui.login = true\n```\n\nor\n\nstore 是一个用 reactive 包装的对象，直接解构读取state会失去响应式，因此需要storeToRefs，它将为每一个响应式属性创建引用；需通过 .value 读取解构出来的值\n\n```js\n<template>\n  <div>\n    <div>姓名：{{ userInfo.name }} 年龄：{{ userInfo.age }}</div>\n    <div>token：{{ token }}</div>\n    <div>getter值：{{ newName }}</div>\n    <button @click=\"handleUser\">更新用户</button>\n    <button @click=\"handleAge\">更新年龄</button>\n    <button @click=\"handleToken\">更新token</button>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { storeToRefs } from ''pinia'';\nimport { useUserStore } from ''@/store/user''; //路径别名，引入store\n\nconst userStore = useUserStore();\n\n//storeToRefs 会跳过所有的 action 属性\nconst { userInfo, token, newName } = storeToRefs(userStore);\n\n//action 属性直接解构\nconst { updateUserInfo, updateAge, updateToken } = userStore;\n\nconst handleUser = () => {\n  updateUserInfo({ name: ''lisi'', age: 24 });\n};\n\nconst handleAge = () => {\n  //userInfo是一个ref响应式引用，需通过.value取值\n  updateAge(userInfo.value.age + 1);\n};\n\nconst handleToken = () => {\n  updateToken(''23234'');\n};\n</script>\n\n```\n\n### Store\n\nStore是一个保存状态和业务逻辑的实体，可以自由读取和写入，并通过导入后在 setup 中使用\n\n```javascript\n// pinia.ts\nimport { defineStore } from ''pinia'';\n\n// defineStore 调用后返回一个函数，调用该函数获得 Store 实体\nexport const useStore = defineStore({\n  // id: 必须的，在所有 Store 中唯一\n  id: ''App'',\n  // state: 返回对象的函数\n  state: () => ({\n    count: 1\n  })\n});\n```\n\n#### 访问state\n\n默认情况下，您可以通过 `store` 实例访问状态来直接读取和写入状态：\n\n```js\nconst store = useStore();\nstore.counter++;\n```\n\n\n\n#### 相互引用\n\n每个store可看做一个hook。相互引用即调用不同hook\n\n```js\nimport { defineStore } from ''pinia'';\nimport { useUserStore } from ''./user'';\n\nenum Sex {\n  man = ''男人'',\n  woman = ''女人'',\n}\n\nexport const userSexStore = defineStore(''user2'', {\n  state: () => {\n    return {\n      sex: Sex.man,\n    };\n  },\n  actions: {\n    updateSex() {\n      const userStore = useUserStore();  // 引用其他store\n      if (userStore.userInfo.name !== ''zhangsan'') this.sex = Sex.woman;\n    },\n  },\n});\n\n```\n\n#### 路由钩子中使用store\n\n使用store的前提是保证pinia已被注册\n\n```js\nimport { useUserStore } from ''@/store/user'';\n\nrouter.beforeEach((to, from) => {\n  // 这样做是可行的，因为路由器是在其被安装之后开始导航的，\n  // 而此时 Pinia 也已经被安装。\n  const userStore = useUserStore();\n  if (!userStore.token && to.path !== \"/login\") {\n    return \"/login\";\n  }\n});\n\n```\n\n#### 重置状态\n\n您可以通过调用 store 上的 `$reset()` 方法将状态 _重置_ 到其初始值：\n\n```js\nconst store = useStore();\nstore.$reset();\n```\n\n#### 改变状态\n\n除了直接用 `store.counter++` 修改 store，你还可以调用 `$patch` 方法。 它允许您使用部分“state”对象同时应用多个更改：\n\n1.第一种\n\n```js\nstore.$patch({\n  counter: store.counter + 1,\n  name: ''Abalam''\n});\n```\n\n2.第二种\n\n```\nconst handleClick = () => {\n  store.count++;\n};\n```\n\n3.第三种方式 `$patch 传递函数`\n\n```\nconst handleClickMethod = () => {\n  // 这里的state就是指代的仓库中的state\n  store.$patch((state) => {\n    state.count++;\n    state.helloWord = state.helloWord === \"jspang\" ? \"Hello World\" : \"jspang\";\n  });\n};\n```\n\n4.第四种方式 `action`\n\n当业务逻辑很复杂的时候，就将方法写在`store`中的`action`里\n\n```javascript\nactions: {\n    changeState() {\n      this.count++\n      this.helloWord = ''jspang''\n    }\n  }\n```\n\n#### 解构使用\n\n_解构后可以直接省略掉 store，减少了代码量_\n\n```\nimport { mainStore } from \"../store/counter\";\nimport { storeToRefs } from \"pinia\";\nconst store = mainStore();\n// 进行解构\nconst { helloWord, count } = storeToRefs(store);\n```\n\n解构必须要用到`storeToRefs()`函数！\n\n#### 替换state\n\n您可以通过将其 `$state` 属性设置为新对象来替换 Store 的整个状态：\n\n```js\nstore.$state = { counter: 666, name: ''Paimon'' };\n```\n\n您还可以通过更改 `pinia` 实例的 `state` 来替换应用程序的整个状态。 这在 [SSR for hydration](https://pinia.web3doc.top/ssr/#state-hydration) 期间使用。\n\n```\npinia.state.value = {}\n```\n\n\n\n### Getters\n\nGetters 直接在 Store 上读取，形似 Store.xx，就和一般的属性读取一样,相当于 vue 中的计算方法\n\n```javascript\n// 修改 store.js\nimport { defineStore } from \"pinia\";\nimport { otherState } from \"@/store/otherState.js\";\n\nexport const useStore = defineStore({\n  id: \"myGlobalState\",\n  state: ()=> ({\n    count: 2\n  }),\n  getters: {\n    // 一个基本的 Getter： 计算 count 的平方\n    // 使用参数\n    countPow2(state) {\n      return state.count ** 2;\n    },\n\n    // 获取其它 Getter， 直接通过 this\n    countPow2Getter() {\n      return this.countPow2;\n    }\n\n    // 使用其它 Store\n    otherStoreCount(state) {\n      // 这里是其他的 Store，调用获取 Store，就和在 setup 中一样\n      const otherStore = useOtherStore();\n      return otherStore.count;\n    },\n  }\n});\n\n// otherState.js\nimport { defineStore } from \"pinia\";\nexport const useStore = defineStore({\n  id: \"otherState\",\n  state: ()=> ({\n    count: 5\n  }),\n});\n```\n\n### actions\n\nPinia 没有 Mutations，统一在 actions 中操作 state，通过 this.xx 访问相应状态\n虽然可以直接操作 Store，但还是推荐在 actions 中操作，保证状态不被意外改变\naction 和普通的函数一样\naction 同样可以像 Getter 一样访问其他的 Store，同上方式使用其它 Store，这里不在赘述,详细请移步 [官方文档 Actions](https://link.juejin.cn?target=https%3A%2F%2Fpinia.esm.dev%2Fcore-concepts%2Factions.html)\n\n### action\n\n```javascript\n// store.js\nexport const useStore({\n  state: ()=> ({\n    count: 2,\n    // ...\n  })\n  // ...\n  actinos: {\n    countPlusOne() {\n      this.count++;\n    },\n    countPlus(num) {\n      this.count += num;\n    }\n  }\n})\n```\n\n可以自由扩展 [官方文档 Plugins](https://link.juejin.cn?target=https%3A%2F%2Fpinia.esm.dev%2Fcore-concepts%2Fplugins.html)\n\n#### 异步 actions\n\n```js\nimport { defineStore } from ''pinia'';\n\nconst getData = () => {\n  return new Promise<number>((resolve) => {\n    setTimeout(() => {\n      resolve(Math.random() * 100);\n    }, 200);\n  });\n};\n\nexport const useListStore = defineStore(''list'', {\n  state: () => {\n    return {\n      list: [] as number[],\n    };\n  },\n  actions: {\n    async updateList() {\n      try {\n        const data = await getData();\n        this.list.push(data);\n      } catch {\n        /* empty */\n      }\n    },\n  },\n});\n\n```\n\n### 数据持久化\n\n由于pinia里没有自带的持久化存储，所以我们需要使用要持久化存储的插件 pinia-plugin-persistedstate npm地址：[pinia-plugin-persistedstate](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fpinia-plugin-persistedstate) 文档入口:[pinia-plugin-persistedstate](https://link.juejin.cn?target=https%3A%2F%2Fprazdevs.github.io%2Fpinia-plugin-persistedstate%2Fzh%2F)\n\n```\nnpm i pinia-plugin-persistedstate\n#或者使用 npm\nyarn add pinia-plugin-persistedstate\n```\n\n#### 基础使用\n\n1. 将插件添加到 pinia 实例上\n\n```js\nimport { createPinia } from ''pinia''\nimport piniaPluginPersistedstate from ''pinia-plugin-persistedstate''\nconst store = createPinia()\nstore.use(piniaPluginPersistedstate) // 使用持久化插件\nexport default store\n```\n\n2. 创建 Store 时，将 `persist` 选项设置为 `true`。\n\n```js\n// user.ts\nimport { defineStore } from ''pinia''\n\n// 你可以对 `defineStore()` 的返回值进行任意命名，但最好使用 store 的名字，同时以 `use` 开头且以 `Store` 结尾。(比如 `useUserStore`，`useCartStore`，`useProductStore`)\n// 第一个参数是你的应用中 Store 的唯一 ID。\nexport const useUserInfoStore = defineStore(''userInfo'', {\n  // 其他配置...\n  // state: 返回对象的函数\n  state: () => {\n    return {\n      login: false\n    }\n  },\n  persist: true // 开始数据持久化\n})\n\n```\n\n#### 配置\n\n默认配置如下\n\n- 使用 [`localStorage`](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage) 进行存储\n- [`store.$id`](https://pinia.vuejs.org/api/interfaces/pinia.StoreProperties.html) 作为 storage 默认的 key\n- 使用 [`JSON.stringify`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)/[`JSON.parse`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse) 进行序列化/反序列化\n- 整个 state 默认将被持久化\n\n修改默认配置\n\n将一个对象传递给 Store 的 `persist` 属性来配置持久化。\n\n```js\nimport { defineStore } from ''pinia''\n\nexport const useStore = defineStore(''main'', {\n  state: () => ({\n    someState: ''你好 pinia'',\n  }),\n  persist: {\n    // 在这里进行自定义配置\n    key: ''my-custom-key'', //将被持久化存储在 localStorage 中的 my-custom-key key 中\n    storage: sessionStorage, //持久化存储在 sessionStorage中 ，默认localStorage\n    paths: [''save.me'', ''saveMeToo''], // 只有 save.me 和 saveMeToo 被持久化，而未设置的不会被持久化。\n  },\n})\n```\n\n\n\n### 问题点\n\n1. `pinia` 里存储的用户信息，刷新后数据恢复默认 ， 使用持久化插件解决\n\n2. 在axios中使用 ，报错未挂载\n\n   在*响应拦截器* 中调用 uiSettings = useUiSetStore()\n\n3. 在 js 或vue hooks中单独使用报错\n\n   错误\n\n   ```\n    \"getActivePinia()\" was called but there was no active Pinia. Did you forget to install pinia? 	const pinia = createPinia() 	app.use(pinia) This will fail in production..\n   ```\n\n   解决方式\n\n   1. 为pinia单独新建一个文件store.js\n\n   2. 然后在要使用pinia的js文件中导入\n\n   ```js\n   import { createPinia } from ''pinia''\n   import piniaPluginPersistedstate from ''pinia-plugin-persistedstate''\n   const store = createPinia()\n   store.use(piniaPluginPersistedstate)\n   export default store\n   ```\n\n   使用\n\n   ```js\n   import pinia from ''@store/index''\n   import { useUiSetStore } from ''@/store/modules/uiSettings''\n   const ui = useUiSetStore(pinia)\n   ```\n\n   ',1,0,'20.jpg',0,59,1,4,'2023-11-08 13:50:55','2023-11-08 13:50:55'),
(491,'mitt插件实现同级组件传值','npm install --save mitt','#### 项目中安装mitt\n\n```\nnpm install --save mitt\n```\n\n#### 新建event.js\n\n```js\nimport mitt from ''mitt''\nconst VueEvent = mitt()\nexport default VueEvent\n```\n\n#### 使用\n\n```js\nimport VueEvent from ''@/plugins/event.js'' // 事件总线，同级组件传值\n// 触发\nVueEvent.emit(''collectionPlaylistID'', state.collectionPlaylist[0].id) // 传递给左侧组件，实现默认选中\n\n// 接收\nonMounted(() => {\n    VueEvent.on(''collectionPlaylistID'', data => {\n        state.cur = data // 默认选中\n    })\n})\n```\n\n离开组件时销毁绑定事件，要不当绑定多个事件的时候会有不必要的麻烦\n\n```js\n// 组件销毁完成后执行的函数\nonUnmounted(() => {\n    VueEvent.off(''comments'')\n})\n```\n\n',0,0,'18.jpg',0,59,1,4,'2023-11-08 15:30:46','2023-11-09 14:15:24'),
(492,'vue3异步组件','父组件中，子组件的加载一般是按照先后顺序加载的，子组件加载后才会加载父组件。\n\n一个页面的子组件很多，由于会先加载子组件，那么父组件可能会出现比较长的白屏等待时间\n\n大型项目，可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件Vue 提供`defineAsyncComponent`方法：','父组件中，子组件的加载一般是按照先后顺序加载的，子组件加载后才会加载父组件。\n\n一个页面的子组件很多，由于会先加载子组件，那么父组件可能会出现比较长的白屏等待时间\n\n大型项目，可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件Vue 提供`defineAsyncComponent`方法：\n\n```js\nimport { defineAsyncComponent } from ''vue'';\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */);\n  });\n});\n```\n\n### 使用import导入组件\n\n得到的 `AsyncComp` 是一个包裹组件，仅在页面需要它渲染时才调用加载函数。另外，它还会将 props 传给内部的组件，所以你可以使用这个异步的包裹组件无缝地替换原始组件，同时实现延迟加载\n\n```js\nimport { defineAsyncComponent } from ''vue'';\n\nconst AsyncComp = defineAsyncComponent(() => import(''./components/MyComponent.vue''));\n```\n\n### 处理加载与错误的状态\n\n异步操作不可避免地会涉及到加载和错误状态，因此 `defineAsyncComponent()` 也支持在高级选项中处理这些状态：\n\n```js\nconst AsyncComp = defineAsyncComponent({\n  // 加载函数 需要返回一个Promise，可以使用动态import的方式，也可以自己new Promise()\n  loader: () => import(''./Foo.vue''),\n  // 加载异步组件时使用的组件，该组件会在异步组件加载时显示，如果异步组件加载很快，可能不会出现loading组件\n  loadingComponent: LoadingComponent,\n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n  // 加载失败后展示的组件，可以通过Promise的reject来测试\n  errorComponent: ErrorComponent,\n  // 如果提供了一个 timeout 时间限制，并超时了\n  // 也会显示这里配置的报错组件，默认值是：Infinity\n  timeout: 3000\n});\n```\n\n如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得太快，导致最终组件的替换可能看起来像是闪烁。\n\n如果提供了一个报错组件，当加载器函数返回的 Promise 被 reject 时，它将被显示出来。你还可以指定一个超时时间，在请求耗时过长时显示报错组件。\n\n### 动态加载函数方式导入组件\n\n`import`默认导入的模块是静态的，如果我们将`import`用于动态导入模块，那么将放回一个 Promise，也就是说我们可以在`defineAsyncComponent`的加载函数中直接使用`import`来动态导入一个模块。\n\n**若非必要，请不要滥用动态导入**。\n\n```tsx\nimport { defineAsyncComponent } from ''vue'';\nconst VmdContent = defineAsyncComponent(() => {\n  return import(''@/components/editor/VmdContent.vue'');\n});\n```\n\n```html\n<VmdContent :loading=\"state.spinning\" :result=\"state.resultData.text\"></VmdContent>\n```\n\n### 示例\n\n#### new Promise方式\n\nscript setup\n\n```tsx\n// app.vue\nimport { onMounted, defineAsyncComponent } from ''vue'';\nimport Child from ''./child.vue'';\nconst AsyncChild = defineAsyncComponent(() => new Promise((resolve, reject) => resolve(Child)));\nonMounted(() => {\n  console.log(''app'');\n});\n```\n\n```html\n<template>\n  <AsyncChild />\n</template>\n```\n\n#### 对象的方式创建\n\nscript setup\n\n```tsx\n// app.vue\nimport {ref, onMounted, defineAsyncComponent } from ''vue''\nimport LoadingComp from ''./LoadingComp.vue'' //加载中\nimport ErrorComp from ''./ErrorComp.vue'' //加载错误\nconst AsyncChild = defineAsyncComponent({\n    loader: () => (new Promise((resolve, reject) => reject())),\n    loadingComponent: LoadingComp,\n    delay: 200,\n    errorComponent: ErrorComp,\n    timeout: 2000\n})\nonMounted(() => {\n    console.log(''app'')\n})\nlet isShowAsyncComp = ref(false)\nconst loader = () => {\n  isShowAsyncComp.value = true\n}\n<template>\n    <button @click=\"loader\">加载异步组件</button>\n    <AsyncChild v-if=\"isShowAsyncComp\" />\n</template>\n```\n\n',3,0,'12.jpg',0,60,1,4,'2023-11-08 15:59:42','2023-11-08 15:59:42'),
(493,'vue3中使用qrcode生成二维码','使用qrcode生成二维码','### 安装\n\n```\nnpm install --save qrcode.vue \nor \nyarn add qrcode.vue\n```\n\n### 组件中使用\n\n```vue\n<script setup lang=\"ts\">\nimport { useUiSetStore } from ''@store/modules/uiSettings''\n//导入二维码组件\nimport QrcodeVue from ''qrcode.vue''\nconst ui = useUiSetStore()\nconst payUrl = ref('''')\n</script>\n\n<template>\n  <footer-modal :visible=\"ui.fToolsQR\">\n    <div>\n        <input v-model=\"payUrl\" type=\"text\" class=\"w-150\" placeholder=\"输入要生成的数据\" />\n      </div>\n      <div class=\"m-auto my-2 w-14\"></div>\n      <div class=\"m-auto my-2 w-14\">二维码</div>\n      <div v-if=\"payUrl === ''''\" class=\"m-a h-50 w-50\"></div>\n      <div v-else class=\"m-a h-50 w-50\">\n          //组件中使用\n          <qrcode-vue :value=\"payUrl\" :size=\"200\" level=\"H\" />\n    </div>\n  </footer-modal>\n</template>\n```\n\n### 全局注册使用\n\n```js\n//main.ts中注册全局组件\nimport QrCode from ''./components/QrCode.vue''\nconst app = createApp(App)\napp.component(''qr-code'',QrCode)\n\n//组件中使用\n<qr-code :value=\"links\" :size=\"150\" id=\"canvasDom\"></qr-code>\n```\n\n### 下载qrcode二维码\n\n```js\nconst downLoadQRcode = ():void => {\n    const canvas = document.getElementById(''canvasDom'') as HTMLCanvasElement\n    const url = canvas.toDataURL(\"image/png\") // 通过 toDataURL 返回一个包含图片展示的 data URI \n    const aDom = document.createElement(\"a\")\n    aDom.download = state.linksName// 设置下载的文件名\n    aDom.href = url\n    document.body.appendChild(aDom)\n    aDom.click()\n    aDom.remove()\n}\n```\n\n',1,0,'16.jpg',0,59,1,4,'2023-11-09 14:06:35','2023-11-09 14:06:35'),
(494,'使用委托监听方法','监听按键测试的方法`ButtonTest`。该方法接受一个方法参数和一个字符串参数，并执行按键测试操作','监听按键测试的方法`ButtonTest`。该方法接受一个方法参数和一个字符串参数，并执行按键测试操作\n\n```csharp\n/// <summary>\n/// 下指令按键测试\n/// </summary>\n/// <param name=\"func\">传入方法, _button.ButtonTest(() =&gt; BtnTest(\"0x01\"), \"请按Teams键\")) </param>\n/// <param name=\"name\">按键操作对应窗口名</param>\n/// <returns></returns>\npublic bool ButtonTest(Func < bool > func, string name)\n{\n    var flag = true;\n    //用于监控按键操作\n    var buttonMonitor = Task.Run(() =>\n    {\n        Thread.Sleep(50);\n        while(flag)\n        {\n            if(func.Invoke())\n            {   \n                // 如果返回值为true，则设置msgbox的DialogResult为OK\n                msgbox.DialogResult = DialogResult.OK;\n            }\n            Thread.Sleep(100);\n        }\n    });\n    var result = ProgressBarsBox(name);\n    flag = false;\n    return result;\n}\n```\n\n```csharp\n_button.ButtonTest(() =&gt; BtnTest(\"0x01\")\n```',1,0,'1.jpg',0,8,104,4,'2024-01-18 12:02:44','2024-01-18 12:02:44'),
(495,'c#使用委托进行winfrom窗体传值','在窗体中先获取到要接受值窗体。然后通过.得到某个空间或者属性，直接赋值，这个需要接收放的窗体属性或者空间必须是public ，是极不安全的一种方式','\n\n在窗体中先获取到要接受值窗体。然后通过.得到某个空间或者属性，直接赋值，这个需要接收放的窗体属性或者空间必须是public ，是极不安全的一种方式\n\n#### 定义委托\n\n委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法\n\n定义了一个参数是string ，无返回值的委托，名为 SendMessageToChildForms。\n\n```c#\n public delegate void SendMessageToChildForms(string s);\n```\n\n#### 委托实例化\n\n一旦声明了委托类型，委托对象必须使用 **new** 关键字来创建，且与一个特定的方法有关。当创建委托时，传递到 **new** 语句的参数就像方法调用一样书写，但是不带有参数。\n\n本质就是实例化了一个事件event\n\n```c#\npublic event SendMessageToChildForms smtcf_event;\n```\n\n#### 执行的方法\n\n```c#\npublic void ToShowGetMessage(string s)\n{\n     this.lb_收到内容.Text=s;\n}\n```\n\n#### 绑定方法\n\n在一实例化的一个委托事件上绑定子窗体的具体方法\n\n```c#\n Parameter frm_child = new Parameter();\n            smtcf_event += frm_child.ToShowGetMessage; \n            frm_child.Show();\n```\n\n#### 触发委托\n\n```c#\nif(smtcf_event != null) //判断委托事件是否为空，如果委托不为空才执行\n{\n    smtcf_event.Invoke(\"12212\"); // 可以省略Invoke 简写为smtcf(this.textBox1.Text.Trim());\n}\n```',1,0,'4.jpg',0,8,104,4,'2024-01-18 12:11:33','2024-01-18 12:11:33');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;

-- 
-- Definition of diary
-- 

DROP TABLE IF EXISTS `diary`;
CREATE TABLE IF NOT EXISTS `diary` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '内容',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `read` int NOT NULL COMMENT '阅读数',
  `give` int NOT NULL COMMENT '点赞',
  `user_id` int NOT NULL COMMENT '作者',
  `comment_id` int unsigned NOT NULL COMMENT '评论',
  `type_id` int NOT NULL COMMENT '分类',
  `time_create` datetime NOT NULL COMMENT '时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `sn_one_type` (`type_id`) USING BTREE,
  KEY `one_user_id` (`user_id`) USING BTREE,
  CONSTRAINT `one_type_id` FOREIGN KEY (`type_id`) REFERENCES `diary_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `one_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=35 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC COMMENT='日记表';

-- 
-- Dumping data for table diary
-- 

/*!40000 ALTER TABLE `diary` DISABLE KEYS */;
INSERT INTO `diary`(`id`,`name`,`text`,`img`,`read`,`give`,`user_id`,`comment_id`,`type_id`,`time_create`,`time_modified`) VALUES
(1,'123','丹尼尔·平克在《驱动力 3.0》一书中有说：“服从让我们撑过白天，而投入才能让我们撑过夜晚。”这告诉了我们一个很简单的事实：外驱让我们可以做好本职工作，而内驱才能让我们成就卓越。写过超级畅销书《全新思维》的知名商业思想家丹尼尔·平克（Daniel Pink），被称为全球50位最有影响力的商业思想家之一。','1',1,1,1,0,4,'2023-02-02 10:34:25','2023-02-02 10:34:28'),
(8,'vol.001 舔狗日记','没事，你有对象不重要，你可以偶尔回一下我的信息好吗，一天一条也行，让我知道你还在。','321321',8,9,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(9,'vol.002 舔狗日记','时隔30个小时，你终于发了信息给我，你说“宝贝，我想你了。”，我很开心，我终于以为我的舔狗日子到了，可没想到信息发出来两秒都没有，你就撤回了，你说发错了，当我说准备要回没关系的时候，我看见了红色的感叹号。','321321',1,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(10,'vol.003 舔狗日记','蒋介石因为宋美龄的一句喜欢梧桐，他便种满了整个南京。而我因为你的一句不喜欢小偷，我便放过了整个上海的电动车。','321321',1,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(11,'vol.004 舔狗日记','我今天送了你一支口红，你拿到之后很开心，在他的嘴巴上亲了一下，或许他送你口红的时候，你也会在我的嘴巴上亲一下吧。','321321',4,1,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(12,'vol.005 舔狗日记','别的妹妹叫你打游戏，你让人家语音给你发了句哥哥，你就陪她打一天。我叫你打游戏，你回了我一句 70/h。','321321',6,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(13,'vol.006 舔狗日记','今天在楼上窗户上看见你和他在公园里接吻，我看见哭了出来，并打电话给你，想问问你为什么？但你说怎么了，声音是那么好听。于是我说“以后你和他接吻的时候，能不能用我送给你的口红啊？”','321321',5,1,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(14,'vol.007 舔狗日记','今天上班不是太忙，百无聊赖，又翻出了你的相片，看了又看。今天是我认识你的第302天，也是我爱你的第302天，可是这些你并不知道，也许你知道了，也不会在意吧。 此刻的我好想你！','321321',0,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(15,'vol.008 舔狗日记','你好像从来没有对我说过晚安，我在我们的聊天记录里搜索了关键字：“晚安”，你说过一次：我早晚安排人弄死你。','321321',0,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(16,'vol.009 舔狗日记','她好像从来没有主动说过爱我，我搜索了一下关键字“爱”。在我们的聊天记录里，她只说过一次：爱奇艺会员借我一下。','321321',5,0,4,0,4,'2020-12-18 00:00:00','2020-12-18 00:00:00'),
(17,'vol.010 毒鸡汤','如果人生是一部电影，那你就是，中间弹出来的广告。','string',7,1,4,0,4,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(20,'vol.011 舔狗日记','现在已经凌晨一点多了，我望着手机屏幕迟迟没有他的消息：你知道吗？我等了一晚上你的消息。他终于回复我了：是我让你等的？','无',5,3,4,0,4,'2020-12-23 00:00:00','2020-12-18 00:00:00'),
(21,'vol.012 舔狗日记','今天你又来我们班看美女了，路过的时候瞥了一眼坐在第一排的我，我就知道你心里还是有我的。啊！真是美好的一天！','无',14,2,4,0,4,'2021-01-03 00:00:00','2020-12-18 00:00:00'),
(22,'vol.013 毒鸡汤','别以为你一无所有，至少你还有丑！','无',11,0,4,0,4,'2021-01-03 00:00:00','2020-12-18 00:00:00'),
(31,'vol.014 舔狗日记','今天打单子赚了56，给你转了52自己留了4块钱。我花两块买了两包泡面，用剩下的两块钱买了一瓶矿泉水，自己烧水泡面吃，而你用那52块钱想都没想的给你别的哥哥买了皮肤。 我太开心了，因为你用上我的钱了，以后我要赚更多的钱给你','无',11,2,4,0,4,'2021-07-20 00:00:00','2020-12-18 00:00:00'),
(33,'vol.015 舔狗日记','今天你说了要和我打电话，我等了一天，马上十二点了才打过来，我有点不高兴就挂了，你骂了句给脸不要脸。我想了一下，哎呀你还会关心我的脸，多么善良的女孩子，我发誓还能再等一天电话','无',7,3,4,0,4,'2021-09-02 00:00:00','2020-12-18 00:00:00'),
(34,'vol.016 舔狗日记','你好像成熟了，你学会隐忍，开始压抑自己对我的感情。这很好……可是我觉得自己被你忽略了……你好像看不见我。这不可能，对吗？','无',12,4,4,0,4,'2021-09-02 00:00:00','2020-12-18 00:00:00');
/*!40000 ALTER TABLE `diary` ENABLE KEYS */;

-- 
-- Definition of navigation
-- 

DROP TABLE IF EXISTS `navigation`;
CREATE TABLE IF NOT EXISTS `navigation` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(60) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '导航标题',
  `describe` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题描述',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片路径',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '链接路径',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL COMMENT '用户',
  `time_create` datetime DEFAULT NULL,
  `time_modified` datetime DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `nav_user_id` (`user_id`) USING BTREE,
  KEY `nav_type_id` (`type_id`) USING BTREE,
  CONSTRAINT `nav_type_id` FOREIGN KEY (`type_id`) REFERENCES `navigation_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `nav_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=727 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table navigation
-- 

/*!40000 ALTER TABLE `navigation` DISABLE KEYS */;
INSERT INTO `navigation`(`id`,`name`,`describe`,`img`,`url`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(3,'TypeScript','TypeScript 是由微软开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。','27.jpg','https://typescript.bootcss.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(4,'Svelte','Svelte 是构建 Web 应用程序的一种新方法。Svelte 是一个编译器，它将声明性组件转换成高效的 JavaScript 代码，并像做外科手术一样细粒度地更新 DOM。','6.jpg','https://www.sveltejs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(5,'Next.js','Next.js 是一个轻量级的 React 服务端渲染应用框架。','11.jpg','https://www.nextjs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(6,'Babel','Babel 是一个 JavaScript 编译器。Babel 通过语法转换器支持最新版本的 JavaScript 语法。','7.jpg','https://www.babeljs.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(7,'Node.js','Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。','18.jpg','https://www.nodeapp.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(9,'Yarn','Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。','16.jpg','https://yarn.bootcss.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(10,'Yarn v2','Yarn 是一个快速、可靠、安全的依赖管理工具。是 NPM 的替代品。Yarn v2 与 v1 版本有很大的不同，Yarn v2 改进了 CLI 交互、支持 workspace、PnP 等新功能。','5.jpg','https://www.yarnpkg.com.cn/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(11,'前端学习路线','好好学习，天天敲代码','1.jpg','https://objtube.github.io/front-end-roadmap/#/',15,4,'2021-11-10 14:45:01','2021-12-16 14:25:19'),
(12,'Visual Studio','功能完备的集成开发环境 (IDE)，适用于 Android、iOS、Windows、Web 和云 (IDE)','25.jpg','https://visualstudio.microsoft.com/zh-hans/downloads/',14,4,'2021-11-10 14:45:01','2022-10-13 10:13:40'),
(14,'现代 JavaScript','以最新的 JavaScript 标准为基准。通过简单但足够详细的内容，为你讲解从基础到高阶的 JavaScript 相关知识。','3.jpg','https://zh.javascript.info/',5,4,'2021-11-10 14:45:01','2022-10-18 08:38:01'),
(15,'Sass中文网','Sass 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。','26.jpg','https://www.sass.hk/docs/',9,4,'2021-11-10 14:45:01','2022-10-18 08:37:43'),
(16,'BootstrapVue','我们开始BootstrapVue之旅游，基于全球最流行的Bootstrap V4框架，构建移动优先的响应式门户，在Vue.js前端栈基础上。','23.jpg','http://code.z01.com/bootstrap-vue/docs/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:36'),
(17,'前端导航站','前端内容汇总','28.jpg','http://jsdig.com/',15,4,'2021-11-10 14:45:01','2021-12-16 14:25:48'),
(18,'Md2All排版','Markdown排版利器，支持 \"一键排版\" 、自定义css、80多种代码高亮。\n能让Markdown内容，无需作任何调整就能一键复制到微信公众号、博客园、掘金、知乎、csdn、51cto、wordpress、hexo。。。等平台。','4.jpg','http://md.aclickall.com/',20,4,'2021-11-10 14:45:01','2022-10-18 08:37:29'),
(19,'VuePress','Vue 驱动的静态网站生成器','7.jpg','https://v0.vuepress.vuejs.org/zh/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:24'),
(20,'Blog.Core','BCVP（Blog.Core & Vue Project）是一个开箱即用的企业级权限管理应用框架。\n采用最新的前后端完全分离技术【 ASP.NET Core Api 3.x + Vue 2.x 】。','26.jpg','http://apk.neters.club/.doc/',4,4,'2021-11-10 14:45:01','2022-10-18 08:37:11'),
(21,'sqlSugar','.NET 4.+ & .NET CORE 高性能 轻量级 ORM框架，众多.NET框架中最容易使用的数据库访问技术','13.jpg','http://www.codeisbug.com/',16,4,'2021-11-10 14:45:01','2022-11-08 15:54:28'),
(22,'Avue','一个很多骚操作的前端框架\n让数据驱动视图，减去繁琐的操作，更贴近企业级的前端开发组件','21.jpg','https://avuejs.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:37:02'),
(24,'Bootstrap ','基于 Bootstrap 样式库精心打造，并且额外增加了 50 多种常用的组件，为您快速开发项目带来非一般的感觉','8.jpg','https://blazor.sdgxgz.com/',9,4,'2021-11-10 14:45:01','2022-10-18 08:36:53'),
(25,'Editor.md','\n开源在线 Markdown 编辑器','23.jpg','http://editor.md.ipandao.com/',20,4,'2021-11-10 14:45:01','2022-10-18 08:36:44'),
(26,'标签[c#]','','24.jpg','https://stackoom.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:36:32'),
(27,'Font Aweso','世界上最流行的ICON图标字体库和CSS工具包','17.jpg','http://www.fontawesome.com.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 08:35:25'),
(28,'Dotnet9','Donet技术论坛','4.jpg','https://dotnet9.com/',8,4,'2021-11-10 14:45:01','2021-11-15 14:30:21'),
(29,'vol.vue','前后端分离\n\n全自动代码生成\n\n支持前端、后台扩展的快速开发框架','7.jpg','http://www.volcore.xyz/',3,4,'2021-11-10 14:45:01','2022-10-18 08:35:19'),
(30,'jQuery插件库','jQuery插件库','3.jpg','https://www.jq22.com/',5,4,'2021-11-10 14:45:01','2022-10-18 08:35:07'),
(31,'Vue.js中文文档','渐进式\nJavaScript 框架','3.jpg','https://vue.docschina.org/',3,4,'2021-11-10 14:45:01','2022-10-18 08:35:02'),
(33,'CSS Fonts','网络安全 CSS 字体堆栈的完整集合。','4.jpg','https://www.cssfontstack.com/',9,4,'2021-11-10 14:45:01','2022-10-18 08:34:54'),
(34,'CSS速查总表 ','','21.jpg','http://css.cuishifeng.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 08:34:40'),
(36,'青找博客','我们总在生活中与「一瞬的感动」相遇。','12.jpg','https://www.linguang.me/',8,4,'2021-11-10 14:45:01','2021-11-11 16:24:27'),
(37,'axios中文网','易用、简洁且高效的http库','11.jpg','http://www.axios-js.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:34:32'),
(38,'layui','由职业前端倾情打造，面向全层次的前后端开发者，低门槛开箱即用的前端 UI 解决方案','7.jpg','https://www.layui.com/',5,4,'2021-11-10 14:45:01','2022-10-18 08:34:23'),
(40,'Quasar Fra','以最短时间构建高性能的VueJS用户界面','9.jpg','http://www.quasarchs.com/',3,4,'2021-11-10 14:45:01','2022-10-18 08:34:13'),
(41,'Electron','使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序','24.jpg','https://www.electronjs.org/',24,4,'2021-11-10 14:45:01','2022-10-18 08:34:06'),
(42,'2020年Web前端','新手入门前端，需要学习的基础内容有很多，如下。','12.jpg','https://www.cnblogs.com/qianguyihao/p/8776837.html',10,4,'2021-11-10 14:45:01','2022-11-08 15:54:12'),
(43,'ZUI','一个基于 Bootstrap 深度定制开源前端实践方案，帮助你快速构建现代跨屏应用。','21.jpg','https://www.openzui.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:20'),
(44,'Aplayer','Wow, such a beautiful HTML5 music player','3.jpg','https://aplayer.js.org/#/zh-Hans/',24,4,'2021-11-10 14:45:01','2022-10-18 08:33:50'),
(46,'.NET万能框架','项目基于.NET 4.5构建，语法版本C#6.0，包含日常编程多数的常用封装，可以说是一个万能框架，能够用于任何基于.NET平台的项目当中。','18.jpg','https://masuit.com/55',4,4,'2021-11-10 14:45:01','2022-10-18 08:33:20'),
(47,'Tailwind Grids','为 Tailwind CSS 项目轻松生成响应式网格。所有生成的类都基于 Tailwind 默认值，只需选择您的设置即可开始使用。','3.jpg','https://tailwindgrids.com/#/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:16'),
(48,'CSS Inspiration -- CSS灵感','这里可以让你寻找到使用或者是学习 CSS 的灵感，以分类的形式，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。','18.jpg','https://csscoco.com/inspiration/#/',9,4,'2021-11-10 14:45:01','2022-10-18 08:32:58'),
(49,'小游网','二次元技术宅','28.jpg','https://xiaoyou66.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(50,'全历史','全历史(Allhistory)以AI知识图谱为核心引擎,通过高度时空化、关联化数据的方式构造及展现数字人文内容,尤其是历史知识。','12.jpg','https://www.allhistory.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(51,'疯狂去水印','打开短视频APP， 选择要下载的视频，点击右下角分享按钮，在分享弹框中点击“复制链接”','18.jpg','https://douyin.video996.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(52,'知妖','知妖是一个开放的在线“妖怪”资料库。致力于收集、整理、介绍、分享古人文献中的“妖怪”。我们尽可能地收录古文献中的“妖怪”资料，让更多的人能够完整，系统地了解中国“妖怪”文化。','27.jpg','https://www.cbaigui.com/',2,4,'2021-11-10 14:45:01','2021-11-10 14:45:13'),
(53,'煎蛋','地球上没有新鲜事','10.jpg','http://jandan.net/',10,4,'2021-11-10 14:45:01','2022-10-18 10:02:14'),
(55,'网站任意门','你将被传送到完全随机的一个网站，传送到任何一个网站的概率都是相等的。','22.jpg','https://gate.ofo.moe/',11,4,'2021-11-10 14:45:01','2022-10-18 10:02:08'),
(56,'Tailwind CSS','Tailwind 是基于 PostCSS 开发的,通过 JavaScript 代码进行配置,这意味着你可以完全发挥真正的编程语言的能力。 Tailwind 不仅仅是一个 CSS 框架,他更是构建设计系统','17.jpg','https://www.tailwindcss.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 09:57:11'),
(57,'Flexbox网格','基于flex显示属性的网格系统。','21.jpg','http://flexboxgrid.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:59'),
(58,'purecss','一组小型的自适应CSS模块，您可以在每个Web项目中使用。','13.jpg','https://purecss.io/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:55'),
(59,'vue-aplayer','A beautiful HTML5 music player for Vue.js','5.jpg','https://aplayer.netlify.app/docs/',24,4,'2021-11-10 14:45:01','2022-10-18 08:32:11'),
(60,'林德熙','微软最具价值专家 Windows Development MVP','11.jpg','https://blog.lindexi.com/',8,4,'2021-11-10 14:45:01','2022-10-18 08:32:02'),
(61,'MahApps.Me','MahApps.Metro是一个框架，使开发人员可以轻松地为自己的WPF应用程序整合Metro或Modern UI。','10.jpg','https://mahapps.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:31:54'),
(62,'C#入门经典教程','C# 是微软推出的一门面向对象的通用型编程语言，它除了可以开发 PC 软件、网站（借助 ASP.NET）和 APP（基于 Windows Phone），还能作为游戏脚本，编写游戏逻辑。','13.jpg','http://c.biancheng.net/csharp/',13,4,'2021-11-10 14:45:01','2022-10-18 08:31:34'),
(64,'C# 指南','官方指南','20.jpg','https://docs.microsoft.com/zh-cn/dotnet/csharp/',13,4,'2021-11-10 14:45:01','2022-10-18 08:31:07'),
(65,'Ant Design Blazor','这里是 Ant Design 的 Blazor 实现，开发和服务于企业级后台产品。','10.jpg','https://ant-design-blazor.gitee.io/zh-CN/docs/introduce',4,4,'2021-11-10 14:45:01','2022-09-28 11:43:42'),
(66,'mavonEditor','关于\nmavonEditor-基于Vue的markdown编辑器，支持多种个性化功能','19.jpg','https://github.com/hinesboy/mavonEditor',24,4,'2021-11-10 14:45:01','2022-09-28 11:44:16'),
(68,'VUE粒子','粒子背景的Vue.js组件','19.jpg','https://vue-particles.netlify.app/',24,4,'2021-11-10 14:45:01','2021-11-18 14:38:44'),
(69,'Element','Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库','5.jpg','https://element.eleme.cn/#/zh-CN',19,4,'2021-11-10 14:45:01','2021-11-18 14:38:29'),
(70,'outils','前端业务代码工具库','4.jpg','https://www.npmjs.com/package/outils',5,4,'2021-11-10 14:45:01','2021-11-15 14:33:28'),
(71,'Anime.js','一个强大的、轻量级的用来制作动画的javascript库','29.jpg','https://animejs.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:50'),
(72,'Hover.css','CSS hover 悬停效果，可以应用于链接、按钮、图片等等','3.jpg','http://ianlunn.github.io/Hover/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:47'),
(73,'Waves','点击波纹效果','24.jpg','http://fian.my.id/Waves/#examples',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:52'),
(74,'Viewer.js','图片滑动切换展示效果','7.jpg','https://fengyuanchen.github.io/viewerjs/',5,4,'2021-11-10 14:45:01','2021-11-18 14:38:37'),
(75,'clipboard','复制粘贴插件','10.jpg','https://clipboardjs.com/',24,4,'2021-11-10 14:45:01','2021-11-18 14:38:02'),
(76,'You-need-to-know-css','作为一名Web开发者，CSS是必备技能之一，我一直以为自己对CSS的掌握已经够用了，直到读Lea Verou的《CSS揭秘》，我发现自己充其量就算个会打CS的选手，书中针对我们常见的网页设计难题从不同的角度提出了多种实用又优雅的解决方案，在这里强烈的推荐给每一位从事前端相关工作和对前端有兴趣的同学，相信你一定会有所收获','18.jpg','https://lhammer.cn/You-need-to-know-css/#/zh-cn/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:38'),
(77,'Shiro','Shiro，是alphardex平时所做的CSS创意作品集','18.jpg','https://shiroi.netlify.app/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:32'),
(78,'今日热榜','每日榜单','23.jpg','https://tophub.today/',11,4,'2021-11-10 14:45:01','2021-11-18 14:37:25'),
(80,'PostCSS','是一个用 JavaScript 工具和插件转换 CSS 代码的工具','3.jpg','https://www.postcss.com.cn/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:42'),
(81,'Articles','css技巧','9.jpg','https://css-tricks.com/archives/',9,4,'2021-11-10 14:45:01','2021-11-18 14:37:10'),
(82,'JavaScript 秘密花园','此中文翻译由三生石上独立完成，博客园首发，转载请注明出处。','28.jpg','https://bonsaiden.github.io/JavaScript-Garden/zh/#intro',5,4,'2021-11-10 14:45:01','2021-11-18 14:35:56'),
(83,'uni-app','uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。','22.jpg','https://uniapp.dcloud.io/README',21,4,'2021-11-10 14:45:01','2021-11-18 14:37:45'),
(84,'前端小册子','前端学习曲线陡峭，入门容易精通难。后期有瓶颈往往是因为前期基础不扎实。学习一点，掌握一点，貌似慢，实际快。实战是好事，但理论不扎实就着急实战并非是好事。实战帮助更好地理解理论，而不是帮助学习理论。理论学明白，项目才能踏实做，否则，在实战的过程中得到的只是零碎知识点，并没有形成完善的理论体系，收效不大\n好的代码像粥一样，都是用时间熬出来的。小火柴立志要做一名前端工匠\n\n这个小册子是小火柴总结的前端知识结构，方便自己学习，也希望能够帮到更多人\n由于里面许多内容是自己的总结，可能会有错误或纰漏之处，希望不会造成误导，多多交流','14.jpg','https://xiaohuochai.site/introduce.html',11,4,'2021-11-10 14:45:01','2021-11-18 14:36:36'),
(85,'uView(uni-appUI框架)','uView UI，是uni-app生态最优秀的UI框架，全面的组件和便捷的工具会让您信手拈来，如鱼得水','21.jpg','https://uviewui.com/',19,4,'2021-11-10 14:45:01','2021-11-18 14:36:53'),
(86,'umy-ui','为开发者准备的基于 Vue 2.0 的桌面端组件库; 流畅渲染表格万级数据','4.jpg','https://www.umyui.com/',21,4,'2021-11-10 14:45:01','2021-11-18 14:36:30'),
(87,'Element UI表单设计及代码生成器','可将生成的代码直接运行在基于Element的vue项目中；也可导出JSON表单，使用配套的解析器将JSON解析成真实的表单。','23.jpg','https://jakhuang.github.io/form-generator/#/',19,4,'2021-11-10 14:45:01','2021-11-18 14:36:47'),
(88,'luch-request(uni-app)','基于Promise开发的uni-app跨平台请求库','20.jpg','https://www.quanzhan.co/luch-request/',21,4,'2021-11-10 14:45:01','2021-11-18 14:36:22'),
(89,'Entity Framework Core API 参考','欢迎使用 .NET API 浏览器！这个一站式商店，销售 Microsoft 提供的所有基于 .NET 的 API。 在下面的框中键入字词，开始搜索任意托管 API 吧。 可以通过我们的博文详细了解 API 浏览器。','23.jpg','https://docs.microsoft.com/zh-cn/dotnet/api/?view=efcore-3.1',22,4,'2021-11-10 14:45:01','2022-10-18 08:48:47'),
(90,'Furion','Furion 是 .NET 5 平台下极易入门、极速开发的 Web 应用框架。','28.jpg','https://dotnetchina.gitee.io/furion/',37,4,'2021-11-10 14:45:01','2023-08-10 17:08:10'),
(92,'vue-admin-beautiful','是一款基于vue+element-ui的绝佳的中后台前端开发管理框架（基于vue/cli 4 最新版，同时支持电脑，手机，平板）,他同时是拥有100+页面的大型vue前端单页应用','27.jpg','https://gitee.com/chu1204505056/vue-admin-beautiful/?hmsr=github&hmpl=&hmcu=&hmkw=&hmci=',19,4,'2021-11-10 14:45:01','2021-11-18 13:41:17'),
(93,'Animate中文网','强大的跨平台的预设css3动画库\n内置了很多典型的css3动画，兼容性好使用方便','14.jpg','http://www.animate.net.cn/',9,4,'2021-11-10 14:45:01','2021-11-18 13:40:25'),
(94,'jQuery API 3.3.1 速查表','速查表','21.jpg','https://www.94xh.com/index.html',5,4,'2021-11-10 14:45:01','2021-11-18 13:40:08'),
(95,'flv.js(播放器)','flv.js 是一个使用纯JavaScript编写的FLV(HTML5 Flash Video)播放器。','4.jpg','https://www.bootcdn.cn/flv.js/1.5.0/',5,4,'2021-11-10 14:45:01','2021-11-18 13:39:57'),
(96,'福利汇总','大千世界收集福利分享','1.jpg','https://www.gifxu.com/',10,4,'2021-11-10 14:45:01','2021-11-18 12:28:16'),
(97,'Animate.css','Just-add-water CSS animations','17.jpg','https://animate.style/',9,4,'2021-11-10 14:45:01','2021-11-18 10:58:10'),
(99,'Umar Hansa的开发人员技巧','开发人员技巧','5.jpg','https://umaar.com/dev-tips/',13,4,'2021-11-10 14:45:01','2022-12-26 16:16:55'),
(100,'iconfont','阿里巴巴图形库','1.jpg','https://www.iconfont.cn/',18,4,'2021-11-10 14:45:01','2021-11-18 14:36:05'),
(101,'highlight.js','Web语法突出显示','21.jpg','https://highlightjs.org/',5,4,'2021-11-10 14:45:01','2021-11-18 10:57:30'),
(102,'MakingCSS','The web tool for generating CSS3 code','10.jpg','https://makingcss.com/',9,4,'2021-11-10 14:45:01','2021-11-18 10:57:38'),
(103,'CSS生成器','','1.jpg','https://www.cssportal.com/',9,4,'2021-11-10 14:45:01','2021-11-18 10:37:40'),
(104,'LintCode 领扣','空前强大的  在线编程  训练系统  即刻启程！','25.jpg','https://www.lintcode.com/',17,4,'2021-11-10 14:45:01','2021-11-18 10:52:12'),
(105,'postcss简介','PostCSS 是一个允许使用 JS 插件转换样式的工具。 这些插件可以检查（lint）你的 CSS，支持 CSS Variables 和 Mixins， 编译尚未被浏览器广泛支持的先进的 CSS 语法，内联图片，以及其它很多优秀的功能。','7.jpg','https://www.cnblogs.com/aidixie/p/12771985.html',9,4,'2021-11-10 14:45:01','2021-11-18 10:44:28'),
(106,'TypeScript','TypeScript是JavaScript类型的超集，它可以编译成纯JavaScript。\nTypeScript可以在任何浏览器、任何计算机和任何操作系统上运行，并且是开源的。','14.jpg','https://www.tslang.cn/index.html',5,4,'2021-11-10 14:45:01','2021-11-18 10:44:35'),
(107,'Axios中文文档','Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。','3.jpg','https://www.kancloud.cn/yunye/axios/234845',13,4,'2021-11-10 14:45:01','2021-11-18 10:44:07'),
(108,'关于ASP.NETCore的分享之路','学习路线图\nASP.NET CORE学习指南\n《基础知识掌握部分》\n《部署与组件学习部分》\n《容器化与跨平台部分》','24.jpg','https://www.cnblogs.com/laozhang-is-phi/p/all-knowledge-for-netcore.html#autoid-2-1-0',15,4,'2021-11-10 14:45:01','2021-11-18 14:36:14'),
(109,'C#之Action和Func的用法','','12.jpg','https://www.cnblogs.com/LipeiNet/p/4694225.html',7,4,'2021-11-10 14:45:01','2022-10-18 08:29:37'),
(110,'NanUI 界面组件','这是一个开放源代码的 .NET / .NET Core 窗体应用程序（WinForms）界面组件。您可以使用 HTML5 / CSS3 / Javascript 等前端技术来构建您的应用程序界面。主流的Javascript框架，比如Angular, React, Vue都是可以用来构架SPA应用的明智选择。使用 NanUI 界面组件将给您的窗体设计工作带来无限可能。','9.jpg','https://www.formium.net/',4,4,'2021-11-10 14:45:01','2021-11-18 10:44:13'),
(112,'vuepress-theme-vdoing','一款简洁高效的VuePress 知识管理&博客 主题','17.jpg','https://doc.xugaoyi.com/vuepress-theme-vdoing-doc/',3,4,'2021-11-10 14:45:01','2022-10-18 08:29:26'),
(113,'软件工艺师(bibi)','视频教程','20.jpg','https://space.bilibili.com/361469957/video',8,4,'2021-11-10 14:45:01','2021-11-18 10:38:51'),
(114,'NetModular','为中小型企业而生的基于.Net Core平台的模块化快速开发解决方案','20.jpg','https://docs.17mkh.com/',4,4,'2021-11-10 14:45:01','2022-10-18 08:29:19'),
(115,'秦枫鸢梦','花有重开日，人无再少年','16.jpg','https://blog.zwying.com/',8,4,'2021-11-10 14:45:01','2021-11-18 10:39:15'),
(116,'Mikutap','','13.jpg','https://xiabor.com/',8,4,'2021-11-10 14:45:01','2022-10-18 08:29:04'),
(117,'Typora','Typora 是一款支持实时预览的 Markdown 文本编辑器。它有 OS X、Windows、Linux 三个平台的版本，并且由于仍在测试中，是完全免费的。','12.jpg','https://typora.io/',36,4,'2021-11-10 14:45:01','2023-08-10 17:01:30'),
(119,'ExCSS','一个CSS3解析器C#库','1.jpg','https://www.ctolib.com/ExCSS.html',4,4,'2021-11-10 14:45:01','2021-11-18 10:39:02'),
(120,'Everything','Everything中文版是一款功能强大，便捷实用的文件搜索软件。','16.jpg','https://everything.en.softonic.com/',14,4,'2021-11-10 14:45:01','2022-10-18 08:27:59'),
(121,'AnyDesk','远程连接到您的计算机，无论是从办公室的另一层还是世界的另一端。 AnyDesk为IT专业人员和移动用户提供安全可靠的远程桌面连接。','12.jpg','https://anydesk.com/zhs',14,4,'2021-11-10 14:45:01','2022-10-18 08:27:52'),
(122,'WebStorm','WebStorm 是jetbrains公司旗下一款JavaScript 开发工具。已经被广大中国JS开发者誉为“Web前端开发神器”、“最强大的HTML5编辑器”、“最智能的JavaScript IDE”等。与IntelliJ IDEA同源，继承了IntelliJ IDEA强大的JS部分的功能。','25.jpg','https://www.jetbrains.com/help/webstorm/installation-guide.html',14,4,'2021-11-10 14:45:01','2021-11-18 10:43:58'),
(124,'XMind','思如泉涌 • 成竹在图','13.jpg','https://www.xmind.cn/',14,4,'2021-11-10 14:45:01','2021-11-18 10:39:08'),
(125,'Postman','API开发协作平台','25.jpg','https://www.postman.com/',14,4,'2021-11-10 14:45:01','2021-11-18 10:35:45'),
(126,'AutoHotkey','AutoHotkey 是一个自由、开源的宏生成器和自动化软件工具，它让用户能够自动执行重复性任务。AutoHotkey 可以修改任何应用程序的用户界面（例如，把默认的 Windows 按键控制命令替换为 Emacs 风格）。它是由定制的脚本语言驱动，旨在提供键盘快捷键或热键。——wikipedia','3.jpg','https://www.autohotkey.com/',14,4,'2021-11-10 14:45:01','2021-11-17 17:10:09'),
(127,'Notepad++','Notepad++ 是在微软视窗环境之下的一个免费的代码编辑器。为了产生小巧且有效率的代码编辑器,这个在GPL许可证下的自由软体开发专案采用 win32 api 和 STL 以 ...','4.jpg','https://notepad-plus-plus.org/',14,4,'2021-11-10 14:45:01','2021-11-17 17:10:00'),
(128,'字体仓库','免费字体库','13.jpg','https://www.ziticangku.com/',14,4,'2021-11-10 14:45:01','2021-11-17 17:09:40'),
(129,'You-need-to-know-css','为了以后可以更爽的复制粘贴，笔者把自己的收获和工作中常用的一些CSS小样式总结成这份文档','26.jpg','https://lhammer.cn/You-need-to-know-css/#/zh-cn/',9,4,'2021-11-10 14:45:01','2021-11-17 17:09:33'),
(130,'CSS Tricks','总结一些常用的 CSS 样式\n记录一些 CSS 的新属性和一点奇技淫巧\n在“动”部分下有些动画并不是 CSS 效果，因为没有地方放置，所以暂时寄存在这里\n尽量少说废话，代码简单易用，方便复制','27.jpg','http://css-tricks.neatbang.com/',9,4,'2021-11-10 14:45:01','2021-11-17 17:09:22'),
(131,'animista','该项目里面有各种 CSS 实现的效果，还有代码演示，方便直接复制代码，还可以复制压缩后的代码，如果你在找某个 CSS 的效果的话，可以到这里找找看。','12.jpg','https://animista.net/',9,4,'2021-11-10 14:45:01','2021-11-18 10:35:52'),
(132,'spinkit','汇集了实现各种加载效果的 CSS 代码片段。\n\nSpinKit 仅使用（transform 和 opacity）CSS 动画来创建平滑且易于自定义的动画。','28.jpg','https://tobiasahlin.com/spinkit/',9,4,'2021-11-10 14:45:01','2022-10-18 08:27:41'),
(133,'Blog.Admin','框架涵盖 VUE 开发中常见的基本知识点，不仅适合初学者入门，同时也适用于企业级别的开发。','7.jpg','https://vueadmin.neters.club/.doc/',19,4,'2021-11-10 14:45:01','2021-11-17 17:09:47'),
(135,'.NET Core 学习资料精选：进阶','主要分享一些.NET Core比较优秀的社区资料和微软官方资料。我进行了知识点归类，让大家可以更清晰的学习.NET Core。\n\n首先感谢资料原作者的贡献。','13.jpg','https://www.cnblogs.com/heyuquan/p/dotnet-advance-learning-resource.html',15,4,'2021-11-10 14:45:01','2021-11-17 17:09:11'),
(136,'ASP.NET Core on K8S 入门学习系列文章目录','K8S的入门学习放到了2019年的学习列表中，并总结了一些学习笔记和实践总结的文章并汇总在这里，希望对各位园友有帮助！','14.jpg','https://www.cnblogs.com/edisonchou/',15,4,'2021-11-10 14:45:01','2021-11-18 12:28:04'),
(137,'.NET Core微服务架构学习与实践系列文章目录','拥抱开源，任重而道远！','1.jpg','https://www.cnblogs.com/edisonchou/p/dotnetcore_microservice_foundation_blogs_index_final.html',15,4,'2021-11-10 14:45:01','2021-11-18 10:43:50'),
(138,'C# 官方语言指南','提供许多有关 C# 语言学习资源、新增功能、概念、操作指南、编程指南和语言参考等。','1.jpg','https://docs.microsoft.com/zh-cn/dotnet/csharp/',13,4,'2021-11-10 14:45:01','2021-11-17 17:04:51'),
(139,'ASP.NET Core 教程','跨平台的高性能开源框架，用于在 Windows、Mac 或 Linux 上开发基于现代化的 Web 应用程序。','16.jpg','https://docs.microsoft.com/zh-cn/aspnet/core/?view=aspnetcore-5.0',15,4,'2021-11-10 14:45:01','2021-11-18 10:59:12'),
(140,'EF Core 官方教程','Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的常用数据访问技术。','7.jpg','https://docs.microsoft.com/zh-cn/ef/core/',13,4,'2021-11-10 14:45:01','2021-11-17 16:56:56'),
(141,'Visual Studio 文档','学习使用强大功能提高开发效率，开发、生成、调试、测试、部署、版本控制、 DevOps 和性能分析','18.jpg','https://docs.microsoft.com/zh-cn/visualstudio/?view=vs-2019',13,4,'2021-11-10 14:45:01','2021-11-17 16:56:48'),
(142,'.NET 微服务应用程序架构指南','本指南介绍如何使用 .NET Core 和 Docker 容器开发基于微服务的应用程序并对其进行管理。','7.jpg','https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/',33,4,'2021-11-10 14:45:01','2023-07-28 11:24:43'),
(143,'微软 eShopOnWeb 开源框架','基于 ASP.NET Core 构建的单体分层应用架构，使用 DDD 领域驱动设计程序体系结构和部署模型。','10.jpg','https://www.cnblogs.com/MrHSR/p/10855824.html',4,4,'2021-11-10 14:45:01','2021-11-17 16:56:23'),
(144,'IdentityServer4中文文档','dentityServer4 是一个免费的开源 OpenID Connect 和 OAuth 2.0 身份认证与授权框架，适用于 ASP.NET Core 平台，IdentityServer4 由 Dominick Baier 和 Brock Allen 两位大神创建和维护，您可以快捷的在应用程序中集成基于令牌的身份验证，单点登录和 API 访问控制，支持非常多的协议实现和可扩展点，IdentityServer4 由 OpenID 基金会正式认证，因此符合规范且可互操作，被微软作为 .NET 基金会项目的一部分，并根据其行为准则运行，虽然这个框架也非常的好，博客也不少，但以下整理的中文文档值得推荐学习。','21.jpg','https://www.xcode.me/post/6038#',4,4,'2021-11-10 14:45:01','2021-11-17 16:56:30'),
(145,'dnSpy基于.NET的反编译工具','dnSpy是一款基于.NET的反编译与调试工具，开源免费，能够讲.NET开发的Exe和Dll程序集反编译为C#代码，同时支持断点调试和代码二次编辑，如果您只有编译后的程序集，在没有源码的情况下想还原C#源码，dnSpy绝对是首选。','28.jpg','https://github.com/dnSpy/dnSpy/releases',4,4,'2021-11-10 14:45:01','2021-11-17 17:05:15'),
(146,'Visual Studio 2015','软就放出了VS2015不同版本的离线安装镜像包，支持32位和64位，现在，您就可以下载并安装它','1.jpg','https://www.xcode.me/post/1916',14,4,'2021-11-10 14:45:01','2021-11-17 16:55:55'),
(149,'零度编程','分享编程之美','25.jpg','https://www.xcode.me/',8,4,'2021-11-10 14:45:01','2021-11-17 16:54:17'),
(150,'技术胖','专注前端开发,每年100集免费视频。','11.jpg','http://www.jspang.com/',8,4,'2021-11-10 14:45:01','2021-11-17 16:40:28'),
(151,'网站(Web App)','这里包含了基于Vue.js开发的网站应用程序，包括管理工具、网页游戏、购物社交网站等。','25.jpg','https://madewith.cn/',3,4,'2021-11-10 14:45:01','2021-11-17 16:40:20'),
(152,'任务协助系统','任何业务场景，您都可以找到合适的方案 PearProject 拥有丰富且灵活的产品研发管理功能，协助您释放产品研发能力，是推动研发进程的强力驱动','24.jpg','https://home.vilson.xyz/?from=madewith.cn#/',13,4,'2021-11-10 14:45:01','2021-11-17 16:40:10'),
(154,'npm','NPM（node package manager）是 Node.js 世界的包管理器。NPM 可以让 JavaScript 开发者在共享代码、复用代码以及更新共享的代码上更加方便。','23.jpg','https://www.npmjs.cn/',13,4,'2021-11-10 14:45:01','2022-10-18 10:02:47'),
(155,'Lerna','Lerna 是一个管理工具，用于管理包含多个软件包（package）的 JavaScript 项目。','1.jpg','https://lernajs.bootcss.com/',5,4,'2021-11-10 14:45:01','2021-11-18 10:36:35'),
(157,'Nuxt.js','Nuxt.js 是一个基于 Vue.js 的通用应用框架。通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。','27.jpg','https://www.nuxtjs.cn/',19,4,'2021-11-10 14:45:01','2021-11-18 10:36:01'),
(158,'Parcel','Parcel - 极速、零配置的 web 应用打包工具。','26.jpg','https://www.parceljs.cn/',13,4,'2021-11-10 14:45:01','2021-11-17 16:54:33'),
(160,'Pro Git','Pro Git 中文版（第二版）是一本详细的 Git 指南，主要介绍了 Git 的使用基础和原理，让你从 Git 初学者成为 Git 专家。','11.jpg','https://www.progit.cn/',13,4,'2021-11-10 14:45:01','2021-11-18 10:36:26'),
(161,'PurgeCSS','PurgeCSS 是一个用来删除未使用的 CSS 代码的工具，能够减小 CSS 文件的体积。例如可以用来减小 Bootstrap 等前端框架的文件体积，提升加载速度。','11.jpg','https://www.purgecss.cn/',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:47'),
(162,'Markdown','Markdown 是一种轻量级标记语言，便于人们使用易读易写的纯文本格式编写文档并添加格式元素。Markdown 是 John Gruber 于 2004 年创建的。','8.jpg','https://www.markdown.xyz/',20,4,'2021-11-10 14:45:01','2021-11-16 16:37:14'),
(163,'ESLint','ESLint 是一个插件化并且可配置的 JavaScript 语法规则和代码风格的检查工具。ESLint 能够帮你轻松写出高质量的 JavaScript 代码。','20.jpg','https://cn.eslint.org/',3,4,'2021-11-10 14:45:01','2021-11-16 16:37:05'),
(164,'Infima CSS 框架','Infima 是 Facebook 出品的一个 CSS 框架，专为内容驱动型网站而设计，并且内建对暗模式的支持。是 Docusaurus 的姊妹项目。','28.jpg','https://infima.bootcss.com/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:38'),
(165,'Stylus','Stylus - 富于表现力、健壮、功能丰富的 CSS 预处理语言。','26.jpg','https://stylus.bootcss.com/',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:38'),
(166,'懒得勤快','勤于发现,乐于分享','28.jpg','https://masuit.org/',8,4,'2021-11-10 14:45:01','2022-11-02 16:34:25'),
(167,'爱哔哔','视频解析','11.jpg','https://www.ibilibili.com/',14,4,'2021-11-10 14:45:01','2021-11-16 16:36:45'),
(168,'果核剥壳','工具分享','15.jpg','https://www.ghpym.com/category/all/pcsoft/pccode',14,4,'2021-11-10 14:45:01','2021-11-16 16:36:59'),
(169,'醉秋风','要相信一切都是最好的安排','26.jpg','https://blog.slomoo.cn/',8,4,'2021-11-10 14:45:01','2021-11-16 16:36:27'),
(170,'薛定喵君','scan to see more ?','8.jpg','http://tiaocaoer.com/',8,4,'2021-11-10 14:45:01','2021-11-16 16:36:51'),
(171,'舔狗日记','我们是狗,是舔狗','24.jpg','https://we.dog/',10,4,'2021-11-10 14:45:01','2021-11-16 16:35:44'),
(172,'rscss','CSS样式表结构的合理系统。\n一组简单的想法可以指导您构建可维护CSS的过程。','19.jpg','https://rscss.io/index.html',9,4,'2021-11-10 14:45:01','2021-11-17 16:39:20'),
(173,'WEB安全色','WEB安全色','3.jpg','https://www.bootcss.com/p/websafecolors/',9,4,'2021-11-10 14:45:01','2021-11-16 16:36:00'),
(174,'Adobe Color ','色輪 (或「擷取主題」標籤中的影像)','20.jpg','https://color.adobe.com/zh/create/color-wheel',9,4,'2021-11-10 14:45:01','2021-11-18 10:36:08'),
(175,'中国色 ','中国色 ','17.jpg','http://zhongguose.com/',9,4,'2021-11-10 14:45:01','2021-11-16 16:35:52'),
(176,'托盘式 ','利用数百万设计师的知识生成漂亮的调色板。','25.jpg','https://www.palettable.io/CCCC82',9,4,'2021-11-10 14:45:01','2021-11-17 17:04:42'),
(177,'itmeo','WebGradients 是180个线性渐变的免费集合，您可以将其用作\n网站任何部分的内容背景。轻松复制CSS3跨浏览器代码\n，稍后使用！我们还为每个渐变准备了.PNG版本。\n 作为奖励，还有用于Sketch  ＆  Photoshop的软件包 。','23.jpg','https://webgradients.com/',9,4,'2021-11-10 14:45:01','2021-11-17 16:56:42'),
(178,'配色表','网页设计常用色彩搭配表','5.jpg','http://tool.c7sky.com/webcolor/',9,4,'2021-11-10 14:45:01','2021-11-16 16:34:27'),
(179,'avascript粒子动画引擎','avascript粒子动画引擎','14.jpg','https://drawcall.github.io/Proton/#examples',9,4,'2021-11-10 14:45:01','2021-11-16 16:36:20'),
(180,'Keyframes helps you write better CSS','Dead simple visual tools to help you generate CSS for your projects.','14.jpg','https://keyframes.app/',9,4,'2021-11-10 14:45:01','2021-11-16 16:35:34'),
(181,'Ant Design Pro','开箱即用的中台前端/设计解决方案','4.jpg','https://pro.ant.design/index-cn',19,4,'2021-11-10 14:45:01','2021-11-17 16:39:29'),
(182,'Laravel诗词博客','','27.jpg','https://www.qqphp.com/article',8,4,'2021-11-10 14:45:01','2021-11-16 15:46:38'),
(183,'hexo','快速、简洁且高效的博客框架','2.jpg','https://hexo.io/zh-cn/',13,4,'2021-11-10 14:45:01','2021-11-16 16:35:21'),
(184,'Gridea',' 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。','4.jpg','https://gridea.dev/',13,4,'2021-11-10 14:45:01','2021-11-16 16:35:29'),
(185,'awesome-bookmarks','个人收藏夹','29.jpg','https://panjiachen.github.io/awesome-bookmarks/',11,4,'2021-11-10 14:45:01','2021-11-18 10:36:18'),
(186,'VueRequest','⚡️ 一个很酷的 Vue3 的请求库','28.jpg','https://cn.attojs.org/',3,4,'2021-11-10 14:45:01','2021-11-16 16:34:20'),
(187,'牛客网','','14.jpg','https://www.nowcoder.com/profile/8768562',17,4,'2021-11-10 14:45:01','2021-11-16 15:44:54'),
(188,'TinyPNG','','14.jpg','https://tinypng.com/',18,4,'2021-11-10 14:45:01','2021-11-16 16:36:09'),
(189,'长征部落格','事 不 三 思 终 有 悔， 人 能 百 忍 自 无 忧。','19.jpg','https://www.cz5h.com/',8,4,'2021-11-10 14:45:01','2021-11-16 15:44:02'),
(190,'Zidone','莫道君行早 更有早行人','6.jpg','https://www.aye.ink/',8,4,'2021-11-10 14:45:01','2021-11-16 16:34:12'),
(191,'天涯社区','提供论坛、部落、博客、问答、文学、相册、个人空间等服务。拥有天涯杂谈、娱乐八卦、情感天地等人气栏目,以及关天茶舍、煮酒论史等高端人文论坛。','17.jpg','https://bbs.tianya.cn/',10,4,'2021-11-10 14:45:01','2021-11-16 15:45:07'),
(192,'胶囊日记','凌晨零点，集体失忆','21.jpg','http://www.timepill.net/',10,4,'2021-11-10 14:45:01','2021-11-16 15:45:01'),
(193,'码库CTOlib','收集GitHub上的实用dotnet开源项目，并进行分类。每天都有新的库和项目添加到列表中。','12.jpg','https://www.ctolib.com/',11,4,'2021-11-10 14:45:01','2021-11-17 16:55:45'),
(194,'SegmentFault','每一位开发者都在贡献和更新技术内容，共同参与社区建设，维护社区秩序。\n\n如果你和我们一样有技术理想，并愿意贡献自己的力量，欢迎加入我们。','29.jpg','https://segmentfault.com/',10,4,'2021-11-10 14:45:01','2021-11-17 16:55:37'),
(195,'LearnKu','编程者社区','7.jpg','https://learnku.com/',10,4,'2021-11-10 14:45:01','2021-11-16 11:54:14'),
(196,'毒导航','网络资源','2.jpg','https://www.toxic.ltd/',11,4,'2021-11-10 14:45:01','2021-11-16 15:44:35'),
(197,'tailblocks','tailblocks','3.jpg','https://tailblocks.cc/',19,4,'2021-11-10 14:45:01','2021-11-16 16:33:56'),
(198,'TailwindCSS 中文网','TailwindCSS 使用教程、TailwindCSS 中文文档及 TailwindCSS 相关资源','10.jpg','https://tailwindchina.com/',13,4,'2021-11-10 14:45:01','2021-11-16 15:46:22'),
(199,'vue-tailwind.com','针对 TailwindCss 优化的 Lightview 和完全可定制的 Vue 组件集','8.jpg','https://www.vue-tailwind.com/',19,4,'2021-11-10 14:45:01','2021-11-16 16:34:05'),
(200,'emantic UI','用户界面就是 Web 的语言','2.jpg','https://semantic-ui.com/',19,4,'2021-11-10 14:45:01','2021-11-16 15:46:31'),
(201,'be-a-professional-programmer','成为专业程序员路上用到的各种优秀资料、神器及框架','28.jpg','http://tools.stanzhai.site/',13,4,'2021-11-10 14:45:01','2021-11-16 11:39:41'),
(202,'Bulma','现代化的CSS框架','19.jpg','https://bulma.zcopy.site/',9,4,'2021-11-10 14:45:01','2022-10-18 09:56:31'),
(203,'PhotoKit','图片编辑器','19.jpg','https://photokit.com/?lang=zh',18,4,'2021-11-10 14:45:01','2021-11-16 14:15:02'),
(204,'V2EX','V2EX 是一个关于分享和探索的地方','2.jpg','https://www.v2ex.com/',10,4,'2021-11-10 14:45:01','2021-11-16 15:44:16'),
(205,'screensiz','screensiz','17.jpg','https://screensiz.es/phone',14,4,'2021-11-10 14:45:01','2021-11-17 16:55:28'),
(206,'Vue Router','用 Vue + Vue Router 创建单页应用非常简单：通过 Vue.js，我们已经用组件组成了我们的应用。当加入 Vue Router 时，我们需要做的就是将我们的组件映射到路由上，让 Vue Router 知道在哪里渲染它们。','11.jpg','https://next.router.vuejs.org/',3,4,'2021-11-10 14:45:01','2021-11-16 15:44:08'),
(207,'View UI','View UI®，即原先的 iView，是一套基于 Vue.js 的开源 UI 组件库，主要服务于 PC 界面的中后台产品。','20.jpg','https://www.iviewui.com/docs/introduce',19,4,'2021-11-10 14:45:01','2021-11-16 15:42:35'),
(208,'it365万能解码器','it365万能解码器，能自动识别各种编码的文本文件，如：GB2312、Big5、UTF-8等。此解码器小巧，但是非常强悍。支持几十种编码，支持自动探测文件编码。一个web网页程序，就能解决文件乱码、编码转换等工作。','27.jpg','https://it365.gitlab.io/zh-cn/decode/?81206z',14,4,'2021-11-10 14:45:01','2021-11-16 14:15:09'),
(209,'果糖网net论坛','','5.jpg','https://www.donet5.com/',10,4,'2021-11-10 14:45:01','2021-11-16 14:17:04'),
(210,'Vue3 One Piece','下一代web开发方式，更快，更轻，易维护，更多的原生支持','23.jpg','https://vue3js.cn/',3,4,'2021-11-10 14:45:01','2021-11-16 14:14:50'),
(211,'vuepress-theme-vdoing','一款简洁高效的VuePress 知识管理&博客 主题','21.jpg','https://doc.xugaoyi.com/',13,4,'2021-11-10 14:45:01','2021-11-16 15:42:27'),
(212,'TailwindCSS的漂亮扩展。','Tailwind Starter Kit是免费和开源的。它不会更改或从TailwindCSS向已添加的CSS添加任何CSS 。它具有多个HTML元素，并带有ReactJS，Vue和Angular的动态组件。','7.jpg','https://www.creative-tim.com/learning-lab/tailwind-starter-kit/presentation',19,4,'2021-11-10 14:45:01','2021-11-16 11:57:06'),
(213,'创造者日报','一群创造者','5.jpg','https://creatorsdaily.com/',10,4,'2021-11-10 14:45:01','2021-11-16 14:13:23'),
(214,'唧唧','','10.jpg','https://www.jijidown.com/',8,4,'2021-11-10 14:45:01','2021-11-16 14:14:34'),
(215,'OpenJudge','OpenJudge是开放的在线程序评测系统','8.jpg','http://openjudge.cn/',14,4,'2021-11-10 14:45:01','2021-11-16 14:13:18'),
(217,'万有导航','','27.jpg','http://wanyouw.com/',11,4,'2021-11-10 14:45:01','2021-11-16 14:13:05'),
(218,'极客阅读','','4.jpg','https://jikeyuedu.cn/topic/Vue.js',10,4,'2021-11-10 14:45:01','2021-11-16 14:12:59'),
(219,'鱼塘热榜','','23.jpg','https://mo.fish/',10,4,'2021-11-10 14:45:01','2021-11-16 14:12:52'),
(220,'老张的哲学','','27.jpg','https://www.cnblogs.com/laozhang-is-phi/',8,4,'2021-11-10 14:45:01','2021-11-16 11:55:03'),
(221,'软件盒子','','29.jpg','https://www.bsc1011.top/',11,4,'2021-11-10 14:45:01','2021-11-16 14:12:47'),
(222,'编程导航','站长是腾讯全栈开发 & 腾讯云开发高级布道师，欢迎关注他的  微信公众号【程序员鱼皮】，或添加  微信 liyupi66  交流学习 ','4.jpg','https://www.code-nav.cn/recommend',11,4,'2021-11-10 14:45:01','2021-11-16 14:12:39'),
(223,'手把手教你AspNetCore WebApi：数据验证','小明最近又遇到麻烦了，小红希望对接接口传送的数据进行验证，既然是小红要求，那小明说什么都得满足呀，这还不简单嘛。','18.jpg','https://www.cnblogs.com/zcqiand/p/13795675.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:33'),
(226,'.net Core 使用AutoMapper','在我们的项目中慢慢的要把数据库的实体模型和视图模型进行分离，防止被人拿到我们表字段。在学校的时候自己只是有将很多数据库模型，写成一个视图模型返回到前台。','16.jpg','https://www.cnblogs.com/chenxi001/p/11800943.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:21'),
(227,'Autofac 框架初识与应用','AutoFac是一个开源的轻量级的依赖注入容器，也是.net下比较流行的实现依赖注入的工具之一。','16.jpg','https://www.cnblogs.com/i3yuan/archive/2021/04/13/14654547.html',15,4,'2021-11-10 14:45:01','2021-11-16 14:12:15'),
(228,'Vue项目中实现用户登录及token验证','','14.jpg','https://www.cnblogs.com/web-record/p/9876916.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:52'),
(229,'asp.net core 批量依赖注入服务','看园子里netcore的文章都是简单的注入几个服务的例子,在项目中肯定不会一行一行的写注册服务的代码，参考网上，找到一些解决方案，根据自己实际需求进行更改，特记录下来。','27.jpg','https://www.cnblogs.com/5jia0/archive/2021/04/14/14658642.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:46'),
(230,'张鑫旭的个人主页','张鑫旭-鑫空间-鑫生活','29.jpg','https://www.zhangxinxu.com/',8,4,'2021-11-10 14:45:01','2021-11-16 11:56:41'),
(231,'colorui文档','','26.jpg','https://www.kancloud.cn/m22543/colorui/1289223',13,4,'2021-11-10 14:45:01','2021-11-16 11:56:35'),
(232,'lucky-canvas','一个基于 Js + Canvas 的【大转盘 & 九宫格】抽奖，致力于为 web 前端提供一个功能强大且专业可靠的组件，只需要通过简单配置即可实现自由化定制，帮助你快速的完成产品需求','26.jpg','https://100px.net/',24,4,'2021-11-10 14:45:01','2021-11-16 11:56:30'),
(233,'[C#] NAudio 库的各种常见使用方式: 播放 录制 转码 音频可视化','在 NAudio 中, 常用类型有 WaveIn, WaveOut, WaveStream, WaveFileWriter, WaveFileReader, AudioFileReader 以及接口: IWaveProvider, ISampleProvider, IWaveIn, IWavePlayer','23.jpg','https://www.cnblogs.com/slimenull/p/14735111.html',4,4,'2021-11-10 14:45:01','2021-11-16 11:56:24'),
(234,'.NET之生成数据库全流程','本文主要是回顾下从项目创建到生成数据到数据库(代码优先)的全部过程。采用EFCore作为ORM框架。','26.jpg','https://www.cnblogs.com/azrng/p/14757769.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:56:16'),
(235,'24K导航','','11.jpg','https://www.24kdh.com/',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:52'),
(236,'印记中文','','13.jpg','https://docschina.org/',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:47'),
(237,'NuxtJS ','NuxtJS 让你构建你的下一个 Vue.js 应用程序变得更有信心。这是一个 开源 的框架，让 web 开发变得简单而强大','12.jpg','https://www.nuxtjs.cn/',3,4,'2021-11-10 14:45:01','2021-11-16 11:54:41'),
(238,'Tailwind CSS文档','开始 Tailwind CSS 之旅\n用最适合您的方式学习 Tailwind','7.jpg','https://www.tailwindcss.cn/docs',13,4,'2021-11-10 14:45:01','2021-11-16 11:54:36'),
(239,'outils 代码库','outils 代码库','12.jpg','https://www.npmjs.com/package/outils',11,4,'2021-11-10 14:45:01','2021-11-16 11:54:31'),
(240,'30 seconds of code ','代码片段','14.jpg','https://www.30secondsofcode.org/',5,4,'2021-11-10 14:45:01','2021-11-16 11:54:24'),
(243,'Pagination.js','分页控件','13.jpg','http://pagination.js.org/',24,4,'2021-11-10 14:45:01','2021-11-16 11:54:03'),
(244,'Lodash 中文文档','Lodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。','28.jpg','https://www.lodashjs.com/',5,4,'2021-11-10 14:45:01','2021-11-16 11:53:57'),
(245,'微信SDK微信SDK','微信SDK微信SDK','14.jpg','https://sdk.weixin.senparc.com/Document',4,4,'2021-11-10 14:45:01','2021-11-16 11:53:52'),
(246,'VUE API 手册','VUE API 手册','3.jpg','https://vue3js.cn/vue-composition-api/',3,4,'2021-11-10 14:45:01','2021-11-16 11:53:47'),
(247,'极客导航','极客导航','25.jpg','https://geekdocs.cn/',11,4,'2021-11-10 14:45:01','2021-11-16 11:47:47'),
(248,'.NET 官方文档','了解如何使用 .NET 在任何使用 C#、F# 和 Visual Basic 的平台上创建应用程序。 浏览 API 引用、代码示例、教程以及其他内容。','9.jpg','https://docs.microsoft.com/zh-cn/dotnet/',4,4,'2021-11-10 14:45:01','2021-11-16 11:53:42'),
(249,'开源前哨','分享热门、有趣和实用的开源项目～','14.jpg','https://www.zhihu.com/column/c_1317124962785062912',11,4,'2021-11-10 14:45:01','2021-11-16 11:53:35'),
(250,'DotNet 资源大全中文版','DotNet 资源大全中文版，内容包括：编译器、压缩、应用框架、应用模板、加密、数据库、反编译、IDE、日志、风格指南等。','12.jpg','https://github.com/jobbole/awesome-dotnet-cn#api',11,4,'2021-11-10 14:45:01','2021-11-16 11:53:29'),
(251,'C#/.NET/.NET Core学习视频汇总（持续更新ing）','之前有很多小伙伴在我的公众号后台留言问有没有C#/.NET/.NET Core这方面相关的视频推荐，我一般都会推荐他们去B站搜索一下。今天刚好有空收集了网上一些比较好的C#/.NET/.NET Core这方面的学习视频，希望能够帮助到有需要的小伙伴们。当然假如你有更好的资源视频推荐可以在我的文章下面留言，开篇之前我要感谢各位小伙伴对【C#/.NET/.NET Core学习、工作、面试指南','27.jpg','https://www.cnblogs.com/Can-daydayup/p/15046838.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:38'),
(256,'MYSQL中数据类型介绍','MySQL的数据类型','7.jpg','https://www.cnblogs.com/-xlp/p/8617760.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:53:17'),
(287,'LBO.net','保持饥饿！保持愚蠢！ ->C#在线编辑','6.jpg','https://www.cnblogs.com/lbonet/',8,4,'2021-11-10 14:45:01','2021-11-16 11:44:54'),
(288,'牛客网','求职之前，先上牛客','14.jpg','https://www.nowcoder.com/',17,4,'2021-11-10 14:45:01','2021-11-16 11:47:36'),
(289,'GitHub Profile README Generator','简历生成','15.jpg','https://rahuldkjain.github.io/gh-profile-readme-generator/',14,4,'2021-11-10 14:45:01','2021-11-16 11:53:11'),
(290,'vue3最新学习资料集合，不断更新','vue3最新学习资料集合，不断更新','21.jpg','https://learnku.com/articles/48928',3,4,'2021-11-10 14:45:01','2021-11-16 11:53:05'),
(292,'wangEditorV5','wangEditorV4\nTypescript 开发的 Web 富文本编辑器， 轻量、简洁、易用、开源免费','1.jpg','https://www.wangeditor.com/',20,4,'2021-11-10 14:45:01','2022-10-11 13:56:18'),
(293,'最好的uniapp入门实战教程','uniapp是Dcloud公司的产品，是一个跨端开发框架，基于vue.js技术栈。开发者编写一套代码，可发布到iOS、Android、Web（响应式）、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉/淘宝）、快应用等多个平台。这是它的功能架构图','16.jpg','https://juejin.cn/post/6899642866693423111#heading-16',15,4,'2021-11-10 14:45:01','2021-11-16 11:47:55'),
(294,'EFCore之详细增删改查','EFCore之详细增删改查','27.jpg','https://juejin.cn/post/6965727147189075976#heading-31',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:53'),
(295,'NET Core和Blog.Core【老张的哲学】','NET Core和Blog.Core【老张的哲学】','21.jpg','https://www.yuque.com/docs/share/c58f37a4-677c-4a08-b240-4f7f4088a63b#dlCt7',15,4,'2021-11-10 14:45:01','2021-11-16 11:52:46'),
(296,'Vue3+Vite工程常用工具的接入方法','Vue3+Vite工程常用工具的接入方法','2.jpg','https://juejin.cn/post/6982476410279460878',15,4,'2021-11-10 14:45:01','2021-11-16 11:48:02'),
(297,'Uni-App从入门到实战-黑马程序员杭州校区出品','Uni-App从入门到实战-黑马程序员杭州校区出品','8.jpg','https://www.bilibili.com/video/BV1BJ411W7pX?p=40',15,4,'2021-11-10 14:45:01','2021-11-16 11:45:02'),
(298,'dotNet全栈开发','dotNet全栈开发\n.NET Core\\xamarin爱好者、篮球狂热爱好者https://dwz.cn/ppnuFzrZ','22.jpg','https://blog.csdn.net/kebi007',8,4,'2021-11-10 14:45:01','2021-11-16 11:39:27'),
(299,'什么是 Docker','Docker 最初是 dotCloud 公司创始人 Solomon Hykes (opens new window)在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源 (opens new window)，主要项目代码在 GitHub (opens new window)上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI） (opens new window)。','26.jpg','https://vuepress.mirror.docker-practice.com/',23,4,'2021-11-10 14:45:01','2021-11-15 14:30:37'),
(300,'编程之家','','10.jpg','https://www.jb51.cc/netcore/index_2.html',11,4,'2021-11-10 14:45:01','2021-11-16 11:39:18'),
(305,'【EFCORE笔记】添加数据的多种方案','','13.jpg','https://www.cnblogs.com/lbonet/p/14599549.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:38:54'),
(306,'ES6 入门教程','《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。','24.jpg','https://es6.ruanyifeng.com/',15,4,'2021-11-10 14:45:01','2021-11-16 11:38:48'),
(307,'图文','','1.jpg','https://pixabay.com/',18,4,'2021-11-10 14:45:01','2021-11-16 11:38:41'),
(309,'Moment.js','JavaScript 日期处理类库','7.jpg','http://momentjs.cn/',5,4,'2021-11-10 14:45:01','2021-11-16 11:38:29'),
(311,'泽泽社长','','6.jpg','https://zezeshe.com/',8,4,'2021-11-10 14:45:01','2021-11-16 11:29:47'),
(312,'逗比表情包','','27.jpg','https://www.dbbqb.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:41'),
(313,'两个BT','','11.jpg','https://www.bttwo.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:36'),
(314,'电影蜜蜂','','12.jpg','https://www.idybee.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:31'),
(315,'人人影视','','9.jpg','https://yyets.dmesg.app/home',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:26'),
(316,'努努影视','','1.jpg','https://www.nunuyy.cc/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:20'),
(317,'人人美剧','','16.jpg','https://www.meiju11.com/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:09'),
(318,'pianku','','1.jpg','https://www.pianku.li/',7,4,'2021-11-10 14:45:01','2021-11-16 11:29:16'),
(319,'换脸','','22.jpg','https://myvoiceyourface.com/',14,4,'2021-11-10 14:45:01','2021-11-16 11:28:57'),
(320,'ECMAScript 6 入门','《ECMAScript 6 入门教程》是一本开源的 JavaScript 语言教程，全面介绍 ECMAScript 6 新引入的语法特性。','2.jpg','https://es6.ruanyifeng.com/',5,4,'2021-11-10 14:45:01','2021-11-16 11:28:42'),
(321,'WindiCSS','下一代工具类 CSS 框架','20.jpg','https://cn.windicss.org/',37,4,'2021-11-10 14:45:01','2023-08-10 17:16:02'),
(322,'wow.js','滚动时显示动画。非常Animate.css朋友 :-)\n轻松自定义动画设置：样式、延迟、长度、偏移、迭代...','24.jpg','https://www.delac.io/WOW/',5,4,'2021-11-10 14:45:01','2021-11-16 11:28:27'),
(323,'.Net Core + DDD基础分层 + 项目基本框架 + 个人总结','','6.jpg','https://www.cnblogs.com/shijiehaiyang/p/14918544.html',4,4,'2021-11-10 14:45:01','2021-11-16 11:28:21'),
(324,'一文梳理CSS必会知识点','','8.jpg','https://juejin.cn/post/6854573212337078285',15,4,'2021-11-10 14:45:01','2022-10-18 09:55:09'),
(325,'30个你必须熟记的CSS选择器','','23.jpg','https://code.tutsplus.com/zh-hans/tutorials/the-30-css-selectors-you-must-memorize--net-16048',15,4,'2021-11-10 14:45:01','2022-10-18 09:55:26'),
(326,'深入理解 TypeScript','','12.jpg','https://jkchao.github.io/typescript-book-chinese/#why',15,4,'2021-11-10 14:45:01','2021-11-16 11:28:03'),
(327,'Vue Patterns CN','有用的Vue模式，技巧，提示和技巧以及有帮助的精选链接。','22.jpg','https://zyszys.github.io/vue-patterns-cn/',3,4,'2021-11-10 14:45:01','2021-11-16 11:27:57'),
(328,'代码整洁的 JavaScript','','15.jpg','https://github.com/beginor/clean-code-javascript',5,4,'2021-11-10 14:45:01','2021-11-15 14:33:46'),
(329,'JavaScript 风格指南','','11.jpg','https://github.com/alivebao/clean-code-js',5,4,'2021-11-10 14:45:01','2021-11-16 11:27:49'),
(330,'typescript基础史上最强学习文章','','23.jpg','https://juejin.cn/post/7018805943710253086',15,4,'2021-11-10 14:45:01','2021-11-16 11:27:41'),
(331,'CSS Icons','Open-source CSS, SVG and Figma UI Icons\nAvailable in SVG Sprite, styled-components, NPM & API','11.jpg','https://css.gg/',9,4,'2021-11-10 14:45:01','2021-11-15 14:33:06'),
(332,'发现导航','','6.jpg','https://www.nav3.cn/#/light',11,4,'2021-11-10 14:45:01','2021-11-15 14:32:33'),
(333,'50个Vue知识点','','28.jpg','https://juejin.cn/post/6984210440276410399#heading-21',15,4,'2021-11-10 14:45:01','2021-11-16 11:27:19'),
(334,'daisyUI','Tailwind CSS Components','5.jpg','https://daisyui.com/',19,4,'2021-11-10 14:45:01','2021-11-16 11:27:11'),
(336,'SqlSugar','NET 开源ORM框架，由果糖大数据科技团队维护和更新 ，开箱即用\n最易上手的ORM框架 ，51Job和Boss直招简历数超过 国外框架 Nhibernate PetaPoco, \n仅次于Dapp','2.jpg','https://www.donet5.com/',29,4,'2021-11-10 14:45:01','2022-10-18 08:47:54'),
(337,'使用 FluentValidation 实现数据校验、验重','','20.jpg','https://www.cnblogs.com/zl33842902/p/13514929.html',15,4,'2021-11-10 14:45:01','2021-11-16 11:25:02'),
(338,'c# asp.net core 3.1 自动注入','','12.jpg','https://www.cnblogs.com/Byboys/p/13744481.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:49'),
(339,'.Net Core3.1下Autofac的使用','','25.jpg','https://blog.csdn.net/sammy520/article/details/114417432',15,4,'2021-11-10 14:45:01','2021-11-15 14:31:12'),
(340,'获取windows 操作系统下的硬件或操作系统信息等','','8.jpg','https://www.cnblogs.com/pilgrim/p/15115782.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:56'),
(341,'pixabay','Stunning free images & royalty free stock','8.jpg','https://pixabay.com/',18,4,'2021-11-10 14:45:01','2021-11-16 11:20:08'),
(342,'学会这几招,轻松让你的github脱颖而出','','25.jpg','https://juejin.cn/post/6997070653010477087',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:18'),
(343,'使用模板生成网页/Pdf/Word/Png/Html的简历','','22.jpg','https://github.com/liangjingkanji/Resume-Template',14,4,'2021-11-10 14:45:01','2021-11-15 14:32:41'),
(344,'ASP.NET Core定时之Quartz.NET使用','Quartz.NET 是一个功能齐全的开源作业调度系统，可用于从最小的应用程序到大型企业系统。\n\nQuartz.NET是纯净的，它是一个.Net程序集，是非常流行的Java作业调度系统Quartz的C#实现。','4.jpg','https://www.cnblogs.com/LaoPaoEr/p/15129899.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:33:37'),
(345,'C# 实现发送QQ邮箱功能','','6.jpg','https://www.cnblogs.com/2002-YiZhiYu/p/15118080.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:04'),
(346,'.Net Core5.0中Autofac依赖注入整合多层，项目中可直接用','','13.jpg','https://www.cnblogs.com/wei325/p/15121451.html#autoid-3-0-0',15,4,'2021-11-10 14:45:01','2021-11-15 14:32:12'),
(347,'Fantastic-admin','一款开箱即用的 Vue 中后台管理系统框架','5.jpg','https://hooray.gitee.io/fantastic-admin/',19,4,'2021-11-10 14:45:01','2021-11-15 14:31:04'),
(348,'vue-element-admin','A magical vue admin','5.jpg','https://panjiachen.gitee.io/vue-element-admin-site/zh/',19,4,'2021-11-10 14:45:01','2021-11-15 14:31:55'),
(349,'wallhaven','','28.jpg','https://wallhaven.cc/',18,4,'2021-11-10 14:45:01','2021-11-16 11:19:39'),
(350,'基于vue3实现的vue3-seamless-scroll无缝滚动','','20.jpg','https://juejin.cn/post/7001831268811800584',24,4,'2021-11-10 14:45:01','2021-11-15 14:30:03'),
(351,'在vite2和Vue3中配置Mockjs _','','2.jpg','https://www.cnblogs.com/wdyyy/p/mockjs_vite2.html',15,4,'2021-11-10 14:45:01','2021-11-15 14:31:46'),
(352,'Vue 3.0 训练营','Vue 3.0 训练营','18.jpg','https://vue3.github.io/vue3-News/',3,4,'2021-11-10 14:45:01','2021-11-15 14:29:50'),
(354,'Quasar ','Quasar ','9.jpg','https://quasar.dev/start/pick-quasar-flavour',19,4,'2021-11-10 14:45:01','2021-11-15 14:29:57'),
(355,'jstips','jstips','8.jpg','https://www.jstips.co/zh_CN/javascript/',5,4,'2021-11-10 14:45:01','2021-11-15 14:29:33'),
(356,'Pinia','状态管理','15.jpg','https://pinia.esm.dev/',3,4,'2021-11-10 14:45:01','2021-11-15 14:29:25'),
(357,'Vue-H5-Template','使用 Vue3.0+Typescript+Vant 搭建 h5 开发基础模板，并提供通用型的解决方案。','23.jpg','https://docs.xwhx.top/',15,4,'2021-11-10 14:45:01','2021-11-15 14:29:20'),
(358,'vsc片段生成','片段生成器','5.jpg','https://snippet-generator.app/',27,4,'2021-11-10 14:45:01','2023-09-14 11:56:49'),
(359,'Vben Admin ','一个开箱即用的前端框架','16.jpg','https://vvbin.cn/doc-next/',19,4,'2021-11-10 14:45:01','2021-11-15 14:29:02'),
(360,'Vue-Mastery学习笔记','Vue-Mastery学习笔记','28.jpg','https://www.yuque.com/nxtt7g/kompdt',15,4,'2021-11-10 14:45:01','2021-11-15 14:28:56'),
(361,'u.tools','新一代效率工具平台\n自由组合丰富插件，打造随手可取的终极神器','5.jpg','https://u.tools/',36,4,'2021-11-10 14:45:01','2023-08-10 17:06:43'),
(362,'VARLET','面向Vue3的Material风格移动端组件库','15.jpg','https://varlet.gitee.io/varlet-ui/#/zh-CN/home',19,4,'2021-11-10 14:45:01','2021-11-15 14:28:42'),
(363,'devhints.io','Rico''s cheatsheets','1.jpg','https://devhints.io/',13,4,'2021-11-10 14:45:01','2021-11-16 11:18:39'),
(364,'TypeScript 4.0 使用手册','TypeScript语言用于大规模应用的JavaScript开发。 ✔️ TypeScript支持类型，是JavaScript的超集且可以编译成纯JavaScript代码。 ✔️ TypeScript兼容所有浏览器，所有宿主环境，所有操作系统。 ✔️ TypeScript是开源的。','9.jpg','https://www.bookstack.cn/read/TypeScript-4.0-zh/README.md',13,4,'2021-11-10 14:45:01','2021-11-15 14:28:31'),
(365,'Apifox 使用文档','API 文档、API 调试、API Mock、API 自动化测试一体化协作平台，定位 Postman + Swagger + Mock + JMeter。通过一套系统、一份数据，解决多个系统之间的数据同步问题。只要定义好 API 文档，API 调试、API 数据 Mock、API 自动化测试就可以直接使用，无需再次定义；API 文档和 API 开发调试使用同一个工具，API 调试完成后即可保证和 API 文档定义完全一致。高效、及时、准确！','3.jpg','https://www.apifox.cn/help/',14,4,'2021-11-10 14:45:01','2021-11-15 14:28:26'),
(366,'Snipaste','Snipaste 不只是截图，善用贴图功能将帮助你提升工作效率','4.jpg','https://docs.snipaste.com/zh-cn/',14,4,'2021-11-10 14:45:01','2021-11-15 14:28:20'),
(367,'【TypeScript】- 一篇够用的TS总结','【TypeScript】- 一篇够用的TS总结','21.jpg','https://alexwjj.github.io/pages/cf42a74e3cc8f/',15,4,'2021-11-10 14:45:01','2021-11-15 14:28:12'),
(368,'柠檬大师的空间站','97程序员一枚，软件工程专业，现居北京，喜欢捣腾，专攻后端，用其他技术打辅助','14.jpg','https://leidl.top/',8,4,'2021-11-10 14:45:01','2021-11-15 14:21:59'),
(369,'Loader Gallery','customize and make your own unique loader!','23.jpg','https://loading.io/spinner/',9,4,'2021-11-10 14:45:01','2021-11-15 14:28:06'),
(370,'程序员导航','程序员导航','7.jpg','https://cxy521.com/',11,4,'2021-11-10 14:45:01','2021-11-15 14:17:29'),
(371,'Live Demo','Live Demo','19.jpg','https://theoxiong.github.io/vue-search-panel/',24,4,'2021-11-10 14:45:01','2021-11-15 14:17:17'),
(372,'书栈网','书栈网','19.jpg','https://www.bookstack.cn/',10,4,'2021-11-10 14:45:01','2021-11-15 14:16:44'),
(373,'axios','易用、简洁且高效的http库','4.jpg','http://www.axios-js.com/zh-cn/',3,4,'2021-11-10 14:45:01','2021-11-15 14:16:33'),
(374,'jQuery','jQuery','13.jpg','http://hemin.cn/jq/',19,4,'2021-11-10 14:45:01','2021-11-15 14:16:27'),
(375,'Linux命令大全(手册)','准确，丰富，稳定，在技术之路上为您护航！','17.jpg','https://www.linuxcool.com/',15,4,'2021-11-10 14:45:01','2021-11-15 14:16:16'),
(376,'JavaScript中的这些骚操作，你都知道吗？','JavaScript中的这些骚操作，你都知道吗？','4.jpg','https://juejin.cn/post/7007306019307175966',15,4,'2021-11-10 14:45:01','2021-11-15 14:16:10'),
(377,'分享32个JavaScript工作中常用的代码片段','整理一下工作中常用的JavaScript小技巧分享给大家，希望能帮助到各位小伙伴们，在工作中提升开发效率。','11.jpg','https://segmentfault.com/a/1190000040637925',15,4,'2021-11-10 14:45:01','2021-11-15 14:15:58'),
(378,'Vue3的7种和Vue2的12种组件通信','Vue3的7种和Vue2的12种组件通信','20.jpg','https://juejin.cn/post/6999687348120190983',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:53'),
(379,'v-md-editor','v-md-editor 是基于 Vue 开发的 markdown 编辑器组件','25.jpg','https://ckang1229.gitee.io/vue-markdown-editor/zh/#%E4%BB%8B%E7%BB%8D',20,4,'2021-11-10 14:45:01','2021-11-15 14:14:18'),
(384,'前端“技师”们强推的效率开发工具汇总','各位程序员“技师”提供的小技巧的汇总。将我们平常累计的一些开发技巧分享给大家，希望能对大家有所帮助','27.jpg','https://juejin.cn/post/7021320464836329502#heading-3',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:10'),
(385,'Windows 快捷操作大全','快捷键只介绍能让你成为开发大佬的，类似 Ctrl+C、Ctrl+V 这种大家熟知的，一概省略，咱们只来干货。','29.jpg','https://juejin.cn/post/7020574670097219621',15,4,'2021-11-10 14:45:01','2021-11-15 14:14:00'),
(386,'一文让你30分钟快速掌握Vue3','经过了漫长的迭代，Vue 3.0 终于在上 2020-09-18 发布了，带了翻天覆地的变化，使用了 Typescript 进行了大规模的重构，带来了 Composition API RFC 版本，类似 React Hook 一样的写 Vue，可以自定义自己的 hook ，让使用者更加的灵活，接下来总结一下 vue 3.0 带来的部分新特性。','28.jpg','https://mp.weixin.qq.com/s/1orWGlOXT2Wn2pJLK6VAIg',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:52'),
(387,'前端进阶之道','针对前端的知识难点进行细致入微的讲解，让你的进阶之路不再崎岖！','9.jpg','https://yuchengkai.cn/',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:46'),
(388,'Web 控制台终极指南','一旦掌握了控制台，它将帮助我们更有条理、更快地调试并了解应用程序中发生的一切。所以我会试着用例子总结你需要知道的所有内容','1.jpg','https://segmentfault.com/a/1190000040705234',15,4,'2021-11-10 14:45:01','2021-11-15 14:13:36'),
(389,'JSRUN.NET','用代码说话,一惯的风格','15.jpg','http://jsrun.net/t',13,4,'2021-11-10 14:45:01','2021-11-15 14:13:27'),
(390,'vue-manage-system','vue-manage-system','18.jpg','https://github.com/lin-xin/vue-manage-system',24,4,'2021-11-10 14:45:01','2021-11-15 14:13:09'),
(391,'微信Markdown','导航简述','19.jpg','https://doocs.gitee.io/md/#/',20,4,'2021-11-10 14:45:01','2021-12-15 15:00:07'),
(392,'cssreference.io','免费的 CSS 视觉指南 通过示例学习：cssreference.io是一个免费的 CSS 视觉指南。它以最流行的属性为特色，并通过插图和动画示例对其进行了解释。','3.jpg','https://cssreference.io/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:53'),
(393,'css-tricks.com','可以包含（在另一个特定 HTML 元素中的特定 HTML 元素）','2.jpg','https://css-tricks.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:47'),
(400,'color-ui','简述','5.jpg','https://www.color-ui.com/',19,4,'2021-11-10 14:45:01','2021-11-15 14:12:39'),
(402,'codemyui','简述','19.jpg','https://codemyui.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:12:32'),
(403,'学习CSS布局','本站教授的是现在广泛使用于网站布局领域的CSS基础。  我们假设你已经掌握了CSS的选择器、属性和值。并且你可能已经对布局有一定了解，即使亲自去写的话还是会很苦恼。如果你想要从头开始学习HTML和CSS，那么你可以看下这篇教程。不然的话，让我们看看我们是否可以让你在下一个项目少一些烦恼。','29.jpg','https://zh.learnlayout.com/',9,4,'2021-11-10 14:45:01','2021-11-15 14:11:34'),
(410,'CSShake','一些 CSS 类 移动你的 DOM！','20.jpg','https://elrumordelaluz.github.io/csshake/',9,4,'2021-11-10 14:45:01','2021-11-15 14:11:28'),
(411,'Nuxt3','使用 Vue 3 构建您的下一个应用程序，体验混合渲染、强大的数据获取和新功能。Nuxt 3 是一个开源框架，使 Web 开发变得简单而强大。','9.jpg','https://v3.nuxtjs.org/',3,4,'2021-11-10 14:45:01','2021-11-15 14:11:21'),
(412,'Day.js中文网','Day.js是一个极简的JavaScript库，可以为现代浏览器解析、验证、操作和显示日期和时间。','13.jpg','https://dayjs.fenxianglu.cn/',5,4,'2021-11-10 14:45:01','2021-11-15 10:17:04'),
(413,'fenxianglu','fenxianglu','7.jpg','https://www.fenxianglu.cn/',13,4,'2021-11-10 14:45:01','2021-11-15 10:16:57'),
(414,'Vuex','Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。','25.jpg','https://next.vuex.vuejs.org/zh/',3,4,'2021-11-10 14:45:01','2021-11-15 10:16:37'),
(415,'Vue I18n','Vue I18n 是 Vue.js 的国际化插件','23.jpg','https://kazupon.github.io/vue-i18n/zh/',24,4,'2021-11-10 14:45:01','2021-11-15 10:16:30'),
(416,'Material Design 框架','Vuetify 是一个纯手工精心打造的 Material 样式的 Vue UI 组件库。 不需要任何设计技能 — 创建叹为观止的应用程序所需的一切都触手可及。','4.jpg','https://vuetifyjs.com/zh-Hans/',19,4,'2021-11-10 14:45:01','2021-11-15 10:16:23'),
(417,'Typora+picGo+Gitee搭建图床','Vuetify 是一个纯手工精心打造的 Material 样式的 Vue UI 组件库。 不需要任何设计技能 — 创建叹为观止的应用程序所需的一切都触手可及。','18.jpg','https://juejin.cn/post/7011762633691168805',15,4,'2021-11-10 14:45:01','2021-11-15 10:16:14'),
(418,'Axios的封装思想及实践（TS版本）','Axios的封装思想及实践（TS版本）','5.jpg','https://juejin.cn/post/7023006049732919309',15,4,'2021-11-10 14:45:01','2021-11-15 10:16:09'),
(420,'Fect UI -Vue','@fect-ui/vue是根据 Geist-ui/vue作为设计依赖对 vue2 版本进行升级的一个Vue3UI 库。项目基于typescript,拥有更完备的类型提示和对编译器的友好支持, 相较 vue2 版本组件库进行了交互的优化。','24.jpg','https://vue.miaya.art/Introduce',19,4,'2021-11-10 14:45:01','2021-11-15 10:15:53'),
(421,'CSS Layout','使用 CSS 制作的流行布局和图案','11.jpg','https://csslayout.io/',9,4,'2021-11-10 14:45:01','2021-11-15 10:13:01'),
(422,'vue3-progress','进度条','9.jpg','https://vue3-progress-demo.netlify.app/',24,4,'2021-11-10 14:45:01','2021-11-11 16:31:09'),
(423,'webPack转vite所遇到的问题','webPack转vite所遇到的问题','17.jpg','https://blog.csdn.net/WH_Crx/article/details/118106097',15,4,'2021-11-10 14:45:01','2021-11-15 10:12:49'),
(424,'mind-map','vue 图文','6.jpg','https://github.com/jCodeLife/mind-map/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:41'),
(425,'图像优化','在文件尺寸和质量之间选择完美平衡，并且可获取完整在线预览,您的图像从不会离开您的浏览器。','16.jpg','https://zh.recompressor.com/',27,4,'2021-11-10 14:45:01','2022-10-13 10:14:49'),
(426,'Vue Trend','Vue.js Live Demo 的简单、优雅的火花线','28.jpg','https://cinwell.com/vue-trend/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:26'),
(427,'极客猿导航','导航','19.jpg','https://nav.geekape.net/',11,4,'2021-11-10 14:45:01','2021-11-11 16:29:35'),
(428,'vue-fullscreen','一个用于将任意页面元素进行全屏切换的vue组件，基于 screenfull.js','2.jpg','https://mirari.cc/2017/08/14/%E5%85%A8%E5%B1%8F%E5%88%87%E6%8D%A2%E7%BB%84%E4%BB%B6vue-fullscreen/',24,4,'2021-11-10 14:45:01','2021-11-15 10:12:14'),
(429,'CodePen','CodePen 是一个面向前端设计人员和开发人员的社交开发环境。构建和部署网站，展示您的工作，构建测试用例以学习和调试，并寻找灵感。','29.jpg','https://codepen.io/',39,4,'2021-11-10 14:45:01','2023-08-10 17:29:26'),
(430,'GKA','简单的、高效的帧动画生成工具.  使用简单(仅需一行命令) 内置多种图片优化 多类生成模板，支持定制','9.jpg','https://gka.js.org/#/',24,4,'2021-11-10 14:45:01','2021-11-15 10:11:54'),
(431,'Sonar','\"Sonar一个Web系统，展现了静态代码扫描的结果，结果是可以自定义的 ,支持多种语言的原理是它的扩展性 \"','29.jpg','http://www.sonar.org.cn/',14,4,'2021-11-10 14:45:01','2021-11-15 10:11:18'),
(432,'highcharts','数据可视化','27.jpg','http://www.sonar.org.cn/',5,4,'2021-11-10 14:45:01','2021-11-11 16:29:50'),
(433,'chartjs','图表','23.jpg','https://www.chartjs.org/',5,4,'2021-11-10 14:45:01','2021-11-11 16:30:31'),
(434,'Apache ECharts','一个基于 JavaScript 的开源可视化图表库','22.jpg','https://echarts.apache.org/zh/index.html',5,4,'2021-11-10 14:45:01','2021-11-15 10:10:53'),
(435,'JavaScript Promise迷你书','本书的目的是以目前还在制定中的ECMAScript 6 Promises规范为中心，着重向各位读者介绍JavaScript中对Promise相关技术的支持情况。','5.jpg','http://liubin.org/promises-book/#introduction',13,4,'2021-11-10 14:45:01','2021-11-15 10:10:39'),
(436,'EJS','嵌入式 JavaScript 模板。','18.jpg','https://ejs.co/#promo',5,4,'2021-11-10 14:45:01','2021-11-15 10:10:14'),
(437,'Redux 中文官网','JS 应用的状态容器，提供可预测的状态管理','25.jpg','https://cn.redux.js.org/',5,4,'2021-11-10 14:45:01','2021-11-11 16:30:56'),
(438,'LOCALFORAGE','localForage 是一个 JavaScript 库，通过简单类似 localStorage API 的异步存储来改进你的 Web 应用程序的离线体验。它能存储多种类型的数据，而不仅仅是字符串。','4.jpg','https://localforage.docschina.org/#api-getitem',5,4,'2021-11-10 14:45:01','2021-11-11 16:37:43'),
(439,'v-charts','在使用 echarts 生成图表时，经常需要做繁琐的数据类型转化、修改复杂的配置项，v-charts 的出现正是为了解决这个痛点。基于 Vue2.0 和 echarts 封装的 v-charts 图表组件，只需要统一提供一种对前后端都友好的数据格式设置简单的配置项，便可轻松生成常见的图表。','12.jpg','https://v-charts.js.org/#/',24,4,'2021-11-10 14:45:01','2021-11-11 16:30:48'),
(440,'pexels','免费图库','7.jpg','https://www.pexels.com/zh-cn/',18,4,'2021-11-10 14:45:01','2021-11-11 16:30:40'),
(441,'HELLOGITHUB','分享 GitHub 上 有趣、入门级的开源项目','23.jpg','https://hellogithub.com/',13,4,'2021-11-10 14:45:01','2021-11-15 10:09:57'),
(442,'GitHub Corners','Phew, GitHub is over ten years old now... and is unquestionably synonomous with open source. After 10 years, those GitHub ribbons are more than overdue for a cleaner, more modern alternative. This is my take.  By using SVG, these ','18.jpg','https://tholman.com/github-corners/',24,4,'2021-11-10 14:45:01','2021-11-11 16:29:15'),
(444,'Vuetable-2','数据表','7.jpg','https://www.vuetable.com/#current-version',24,4,'2021-11-10 14:45:01','2021-11-11 16:28:57'),
(445,'v-viewer','vue的图片查看器组件，支持旋转、缩放、缩放等，基于viewer.js','19.jpg','https://mirari.cc/v-viewer/',5,4,'2021-11-10 14:45:01','2021-11-11 16:27:33'),
(446,'Vue 3 选框','为你的 Vue 3 应用程序制作的一个简单的动态选取框组件','3.jpg','https://vue3-marquee.vercel.app/',24,4,'2021-11-10 14:45:01','2021-11-11 16:25:35'),
(447,' GoGoCode','代码转换从未如此简单 全网最简单易上手，可读性最强的 AST 处理工具！','25.jpg','https://gogocode.io/zh',14,4,'2021-11-10 14:45:01','2021-11-11 16:23:36'),
(462,'Ovilia','Ovilia','15.jpg','http://zhangwenli.com/',8,4,'2021-11-15 14:37:19','2021-11-15 14:37:19'),
(463,'carbon','创建和共享源代码的精美图像。 开始在文本区域键入或拖放文件以开始使用。','4.jpg','https://carbon.now.sh/',14,4,'2021-11-15 14:39:13','2021-11-15 14:39:13'),
(464,'比格张','比格张','27.jpg','https://bigezhang.com/',11,4,'2021-11-15 14:39:54','2021-11-15 14:39:54'),
(471,'accordionslider','css','20.jpg','https://accordionslider.com/',9,4,'2021-12-02 15:54:30','2021-12-02 15:54:30'),
(472,'vuex-module-decorators','Typescript/ES7 装饰器使 Vuex 模块变得轻而易举','20.jpg','https://championswimmer.in/vuex-module-decorators/',3,4,'2021-12-02 15:57:40','2021-12-02 15:57:40'),
(473,'tool.lu','在线工具','2.jpg','https://tool.lu/',27,4,'2021-12-02 16:09:02','2022-10-13 10:12:18'),
(480,'一条咸鱼与狗的博客','一条咸鱼与狗的博客','7.jpg','https://purefish.cn/',8,1,'2021-12-03 15:19:28','2021-12-03 15:19:28'),
(481,'图片转码','在线图片转码','16.jpg','http://www.jsons.cn/img2base64/',18,1,'2021-12-03 15:20:18','2021-12-03 15:20:18'),
(482,'防网易云','防网易云','9.jpg','https://music-player.immortalboy.cn/',8,4,'2021-12-06 11:19:40','2021-12-06 11:19:40'),
(483,'讨厌的CSS','心脏强者和心灵弱者的动画。','19.jpg','https://tholman.com/obnoxious/',9,4,'2021-12-06 11:22:36','2021-12-06 11:22:36'),
(484,'VueUse','Collection of essential Vue Composition Utilities','13.jpg','https://vueuse.org/',3,4,'2021-12-06 11:23:45','2021-12-06 11:23:45'),
(485,'Vue.js 的表单验证','熟悉且易于设置的声明式验证 灵活 同步、异步、字段级或表单级验证  使用直观的 API 和较小的占用空间更快地构建更快的表单','6.jpg','https://vee-validate.logaretm.com/v4/',24,4,'2021-12-06 11:30:47','2021-12-06 11:30:47'),
(486,'v-slot插槽','第十三篇：你会用v-slot插槽？你倒是用啊','12.jpg','https://juejin.cn/post/7023188569162252295',15,4,'2021-12-06 13:35:36','2021-12-06 13:35:36'),
(487,'Jest','Jest 是一个令人愉快的 JavaScript 测试框架，专注于 简洁明快。','14.jpg','https://www.jestjs.cn/',3,4,'2021-12-06 13:49:50','2021-12-06 13:49:50'),
(488,'Qui Max','Neumorphic design system for Web','21.jpg','https://qvant-lab.github.io/qui-max/',24,4,'2021-12-06 13:57:02','2021-12-06 13:57:02'),
(489,'Zepto','Zepto 是一个轻量级的、针对现代高级浏览器的 JavaScript 工具库，它兼容 jQuery 的 API 。 如果你会用 jQuery，那么你就已经会用 Zepto 了。','8.jpg','https://zeptojs.bootcss.com/',5,4,'2021-12-06 14:02:01','2021-12-06 14:02:01'),
(490,'ANTD PRO VUE','开箱即用的中台前端/设计解决方案','27.jpg','https://pro.antdv.com/',19,4,'2021-12-06 14:05:18','2021-12-06 14:05:18'),
(491,'getwaves','Make some waves!','26.jpg','https://getwaves.io/',9,4,'2021-12-06 14:06:48','2021-12-06 14:06:48'),
(492,'Normalize.css','一种现代的、支持 HTML5 的 CSS 重置替代方案','6.jpg','http://necolas.github.io/normalize.css/',9,4,'2021-12-06 14:07:53','2021-12-06 14:07:53'),
(493,'vue-awesome-swiper','@vuejs 的 Swiper 组件','23.jpg','https://github.surmon.me/vue-awesome-swiper/',24,4,'2021-12-06 14:13:23','2021-12-06 14:13:23'),
(494,'lru cache','A cache object that deletes the least-recently-used items.','13.jpg','https://github.com/isaacs/node-lru-cache#readme',3,4,'2021-12-06 14:18:27','2021-12-06 14:18:27'),
(495,'vite-plugin-vue-docs','vite 插件 - 自动生成 vue 组件文档网站。','6.jpg','https://meetqy.github.io/vite-plugin-vue-docs/#/docs',24,4,'2021-12-06 14:19:40','2021-12-06 14:19:40'),
(496,'制作缩略图','让我们制作缩略图','18.jpg','http://makethumbnails.com/#options',18,4,'2021-12-06 14:25:34','2021-12-06 14:25:34'),
(497,'c#编程之路','c#编程之路','8.jpg','https://www.cjavapy.com/75/',13,4,'2021-12-06 14:44:08','2021-12-06 14:44:08'),
(498,'SweetAlert','SweetAlert 使弹出消息变得简单而漂亮。','17.jpg','https://sweetalert.js.org/',24,4,'2021-12-06 14:49:43','2021-12-06 14:49:43'),
(499,'Docusaurus','Docusaurus 能够帮助你建立并发布 美观的文档网站。','25.jpg','https://www.docusaurus.cn/docs',13,4,'2021-12-06 14:54:36','2021-12-06 14:54:36'),
(500,'avaScript for','avaScript for','1.jpg','https://www.javascript.fun/',11,4,'2021-12-06 15:07:29','2021-12-06 15:07:29'),
(501,'bootswatch','An ode to Metro','29.jpg','https://bootswatch.com/cosmo/',9,4,'2021-12-06 15:10:26','2022-10-18 09:54:14'),
(502,'icons8','icons8','16.jpg','https://icons8.com/',18,4,'2021-12-06 15:13:29','2021-12-06 15:13:29'),
(503,'CSS Grid Generator','CSS Grid Generator','2.jpg','https://cssgrid-generator.netlify.app/',9,4,'2021-12-06 15:17:41','2021-12-06 15:17:41'),
(504,'listary','Are Clumsy File Management Systems Slowing Down Your Workflow?','6.jpg','https://www.listary.com/',14,4,'2021-12-06 15:19:29','2021-12-06 15:19:29'),
(505,'Vue CLI','ue.js 开发的标准工具','5.jpg','https://cli.vuejs.org/zh/',3,4,'2021-12-06 15:34:42','2021-12-06 15:34:42'),
(506,'c#扩展方法的使用','c#扩展方法的使用','17.jpg','https://blog.csdn.net/liangmengbk/article/details/112393864',15,4,'2021-12-09 15:03:51','2021-12-09 15:03:51'),
(507,'fastgithub','fastgithub是使用dotnet开发的一款github加速器','1.jpg','https://www.cnblogs.com/kewei/p/15533079.html',14,4,'2021-12-09 15:07:45','2021-12-09 15:07:45'),
(508,'Simple CSS','简单的 CSS媒体查询生成器 为数百种设备生成 CSS 媒体查询，包括众多 ipad 和 iphone 型号、三星、LG 的安卓设备等等。有时您必须针对特定设备，这只是一个令人不快的事实。','26.jpg','https://simplecss.eu/',9,4,'2021-12-15 15:14:02','2021-12-15 15:14:02'),
(509,'BootCDN','BootCDN 稳定、快速、免费的前端开源项目 CDN 加速服务','20.jpg','https://www.bootcdn.cn/',30,4,'2021-12-15 15:44:57','2022-10-18 09:53:13'),
(510,'staticfile CDN','CDN加速服务','16.jpg','https://www.staticfile.org/',3,4,'2021-12-15 15:45:41','2022-10-17 15:58:01'),
(511,'convue','convue 是一个基于 vite 和 vue3 开发的一个 vite 的插件，让你拥有一套快速开发项目的体验，类似于 nuxt 和 umi.js。','12.jpg','https://ziping-li.github.io/convue/zh/index.html',3,4,'2021-12-15 15:54:36','2021-12-15 15:54:36'),
(512,'G6 图可视化引擎','G6 是一个简单、易用、完备的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图可视化、图分析、或图编辑器应用。','22.jpg','https://antv-g6.gitee.io/zh',19,4,'2021-12-16 14:24:41','2021-12-16 14:24:41'),
(513,'HTML DOM','with vanilla JavaScript','7.jpg','https://htmldom.dev/',15,4,'2021-12-16 14:27:03','2021-12-16 14:27:03'),
(514,'rolan','即刻提升你的工作效率','20.jpg','https://getrolan.com/',14,4,'2021-12-16 14:37:05','2021-12-16 14:37:05'),
(515,'极简插件','极简插件','9.jpg','https://chrome.zzzmh.cn/#/index',14,4,'2021-12-16 14:46:51','2021-12-16 14:46:51'),
(516,'百页窗','一款专业的文件管理工具','29.jpg','https://shutters.160.com/',14,4,'2021-12-16 15:25:10','2021-12-16 15:25:10'),
(517,'F2 移动端可视化引擎','F2 是一个专注于移动端，面向常规统计图表，开箱即用的可视化引擎，完美支持 H5 环境同时兼容多种环境（Node, 小程序），完备的图形语法理论，满足你的各种可视化需求，专业的移动设计指引为你带来最佳的移动端图表体验。','28.jpg','https://antv-f2.gitee.io/zh',19,4,'2021-12-16 15:26:21','2021-12-16 15:26:21'),
(518,'Chrome插件扩展下载网','Chrome插件扩展下载网','15.jpg','https://www.extfans.com/',14,4,'2021-12-16 15:29:24','2021-12-16 15:29:24'),
(520,'box-shadow 例子','所有这些 box-shadow 都是使用复制的  (点击这里尝试免费演示）。 使用 CSS Scan，您可以轻松检查或复制任何网站的 CSS。','19.jpg','https://getcssscan.com/css-box-shadow-examples',9,4,'2021-12-24 13:55:12','2021-12-24 13:55:12'),
(521,'arco.design','智能设计体系 连接轻盈体验 # 全面开源的企业级产品设计系统','13.jpg','https://arco.design/',19,4,'2021-12-27 09:29:51','2021-12-27 09:29:51'),
(523,'Vue 组合式 API','Vue 组合式 API','24.jpg','https://vue3js.cn/vue-composition-api/',3,4,'2022-03-11 10:03:59','2022-03-11 10:03:59'),
(524,'Chart.js','Chart.js','19.jpg','https://chartjs.bootcss.com/docs/getting-started/',24,4,'2022-03-11 10:04:58','2022-03-11 10:04:58'),
(525,'Cookie的使用（js-cookie插件）','Cookie的使用（js-cookie插件）','22.jpg','https://www.cnblogs.com/star-meteor/p/12881296.html',15,4,'2022-03-11 10:13:20','2022-03-11 10:13:20'),
(526,'PicGo','图片上传、管理新体验','27.jpg','https://picgo.github.io/PicGo-Doc/',14,4,'2022-03-11 10:37:23','2022-03-11 10:37:23'),
(527,'手册网','','13.jpg','https://www.shouce.ren/',13,4,'2022-03-11 10:38:56','2022-03-11 10:38:56'),
(528,'VS插件Supercharger的安装','VS插件Supercharger的安装','24.jpg','https://www.cnblogs.com/arxive/p/13513057.html',15,4,'2022-03-11 10:39:50','2022-03-11 10:39:50'),
(529,'Axios HTTP','基于 Axios 拓展的 HTTP 模块','2.jpg','https://zhengxs2018.github.io/axios-http/',3,4,'2022-03-11 11:00:09','2022-03-11 11:00:09'),
(530,'图像编辑','在线图像编辑','19.jpg','https://pixlr.com/cn/x/#search',14,4,'2022-03-11 11:01:36','2022-03-11 11:01:36'),
(531,'CSI.JS','CSI.JS是一个特别的前端日志系统，帮你快速重建犯罪现场。','20.jpg','https://github.com/tnfe/csijs',24,4,'2022-03-11 11:13:54','2022-03-11 11:13:54'),
(532,'SunnyUI','winfrom组件文档','5.jpg','https://gitee.com/yhuse/SunnyUI/wikis/pages?sort_id=3025093&doc_id=1022550',13,4,'2022-03-11 11:20:21','2022-03-11 11:20:21'),
(533,'LOCALFORAGE','改进的离线存储','13.jpg','http://localforage.docschina.org/',5,4,'2022-03-23 15:16:03','2022-03-23 15:16:03'),
(534,'vite-plugin-vue-layouts','插件','17.jpg','https://github.com/JohnCampionJr/vite-plugin-vue-layouts',26,4,'2022-03-23 15:20:51','2022-03-23 15:20:51'),
(535,'vite-plugin-vue-type-imports','使您能够导入类型并在您的defineProps和defineEmits','24.jpg','https://github.com/wheatjs/vite-plugin-vue-type-imports',26,4,'2022-03-23 15:22:44','2022-03-23 15:22:44'),
(536,'迅速了解ES6~ES12的全部特性','迅速了解ES6~ES12的全部特性','5.jpg','https://juejin.cn/post/7068935394191998990',15,4,'2022-03-23 15:23:24','2022-03-23 15:23:24'),
(537,'ES6-ES12总结','ES6-ES12总结','15.jpg','https://juejin.cn/post/7012519052841074696',15,4,'2022-03-23 15:24:03','2022-03-23 15:24:03'),
(538,'一文读懂 TypeScript 泛型及应用','一文读懂 TypeScript 泛型及应用','29.jpg','https://juejin.cn/post/6844904184894980104',15,4,'2022-03-23 15:24:44','2022-03-23 15:24:44'),
(539,'Vue 3 Babel JSX 插件','以 JSX 的方式来编写 Vue 代码','3.jpg','https://github.com/vuejs/babel-plugin-jsx/blob/dev/packages/babel-plugin-jsx/README-zh_CN.md',26,4,'2022-03-23 15:25:59','2022-03-23 15:25:59'),
(541,'.NET Core资料精选','.NET Core资料精选','28.jpg','.https://www.cnblogs.com/heyuquan/p/dotnet-architecture-learning-resource.html',15,4,'2022-03-23 17:01:46','2022-03-23 17:01:46'),
(542,'总结了38个ES6-ES12的开发技巧','总结了38个ES6-ES12的开发技巧','15.jpg','https://juejin.cn/post/6995334897065787422',15,4,'2022-03-23 17:02:14','2022-03-23 17:02:14'),
(543,'软件先锋','软件先锋','23.jpg','https://soft.macxf.com/',14,4,'2022-03-23 17:02:50','2022-03-23 17:02:50'),
(544,'加速器','加速器','2.jpg','http://101.34.95.10:8081/',14,4,'2022-03-23 17:05:19','2022-03-23 17:05:19'),
(545,'JavaScript工具函数','JavaScript工具函数','28.jpg','https://juejin.cn/post/6844904181761835016',15,4,'2022-03-23 17:05:51','2022-03-23 17:05:51'),
(546,'vite-plugin-pages','使用Vite的 Vue 3 / React 应用程序的基于文件系统的路由','16.jpg','https://github.com/hannoeru/vite-plugin-pages',26,4,'2022-03-24 10:49:04','2022-03-24 10:49:04'),
(547,'ProComponents','让中后台开发更简单','22.jpg','https://procomponents.ant.design/',24,4,'2022-03-24 10:51:04','2022-03-24 10:51:04'),
(548,'netcore','netcore','29.jpg','https://www.cnblogs.com/Can-daydayup/p/15046838.html',15,4,'2022-03-24 10:51:51','2022-03-24 10:51:51'),
(549,'Shell脚本编程30分钟入门','Shell脚本编程30分钟入门','20.jpg','https://github.com/qinjx/30min_guides/blob/master/shell.md',15,4,'2022-03-24 10:52:25','2022-03-24 10:52:25'),
(550,'C#/.NET/.NET Core推荐学习书籍','C#/.NET/.NET Core推荐学习书籍','14.jpg','https://www.cnblogs.com/Can-daydayup/p/14386782.html',15,4,'2022-03-24 10:54:41','2022-03-24 10:54:41'),
(551,'unplugin-icons','unplugin-icons','7.jpg','https://github.com/antfu/unplugin-icons',26,4,'2022-03-24 10:59:15','2022-03-24 10:59:15'),
(552,'github 的使用技巧 ','github 的使用技巧 ','19.jpg','https://juejin.cn/post/7069790758022152206',15,4,'2022-03-24 10:59:40','2022-03-24 10:59:40'),
(553,'WLib','WLib是一组对C#.NET和ArcGIS Engine开发常用代码进行封装的基础库和控件库；','11.jpg','https://github.com/Windr07/WLib',4,4,'2022-03-24 11:02:43','2022-03-24 11:02:43'),
(554,'Chrome 开发者工具','Chrome 开发者工具','9.jpg','https://leeon.gitbooks.io/devtools/content/',15,4,'2022-03-24 11:03:39','2022-03-24 11:03:39'),
(555,'接口大全','接口大全','20.jpg','https://www.free-api.com/',11,4,'2022-03-24 11:05:56','2022-03-24 11:05:56'),
(556,'理解ASP.NET Core','理解ASP.NET Core','11.jpg','https://www.cnblogs.com/xiaoxiaotank/p/15185288.html',15,4,'2022-04-02 10:39:59','2022-04-02 10:39:59'),
(557,'.NET Core中的鉴权授权正确方式(.NET5)','.NET Core中的鉴权授权正确方式(.NET5)','4.jpg','https://www.cnblogs.com/wei325/p/15575141.html',15,4,'2022-04-02 10:41:23','2022-04-02 10:41:23'),
(558,'iconpark','丰富多彩的资源库免费使用','5.jpg','https://iconpark.oceanengine.com/home',35,4,'2022-04-02 10:46:29','2023-08-10 17:00:01'),
(559,'carbon','代码片段,创建和共享源代码的精美图像。 开始键入或将文件拖放到文本区域中以开始使用。','4.jpg','https://carbon.now.sh/',27,4,'2022-04-02 10:48:24','2022-10-13 10:10:45'),
(563,'HandyOrg','WPF控件库','9.jpg','https://handyorg.github.io/',28,4,'2022-10-10 15:55:30','2022-10-18 08:46:08'),
(564,'v-contextmenu','右键菜单','13.jpg','https://github.com/heynext/v-contextmenu',24,4,'2022-10-11 08:34:48','2022-10-11 08:34:48'),
(565,'Qing''s Blog','Qing''s Blog','19.jpg','https://www.cnblogs.com/zhaoqingqing/category/527577.html',8,4,'2022-10-11 08:47:05','2022-10-11 08:47:05'),
(566,'Milkdown','插件驱动的所见即所得的Markdown编辑器框架','3.jpg','https://milkdown.dev/zh-hans/',20,4,'2022-10-11 13:57:11','2022-10-11 13:57:11'),
(567,'css工具箱','本站后续会推出各种前端实用的好工具，杜绝造轮子，每款工具都经过精心打磨，帮助所有程序员提高前端开发效率！','12.jpg','http://www.lingdaima.com/',27,4,'2022-10-17 10:01:26','2023-08-10 15:41:59'),
(568,'丹枫无迹的博客','码农升级','15.jpg','https://www.cnblogs.com/gl1573/',8,4,'2022-11-01 14:18:20','2022-11-01 14:18:31'),
(569,'码友网','我们分享C#&.NET/.NET Core及周边文章、问答、教程、资讯等。\n如果你和我们一样热爱.NET程序开发，欢迎加入我们。\n专注.NET，我们是认真的','23.jpg','https://codedefault.com/',10,4,'2022-11-01 14:19:49','2022-11-01 14:19:49'),
(570,'RestSharp使用教程','RestSharp是一个.NET平台下REST和HTTP API的开源客户端库，支持的平台包括','13.jpg','https://blog.csdn.net/huyu107/article/details/104502130',15,4,'2022-11-02 16:29:19','2022-11-02 16:29:19'),
(571,'发烧友软件','软件下载','6.jpg','https://fsylr.com/pc/page/22',14,4,'2022-11-02 16:31:04','2022-11-02 16:31:04'),
(572,'c#使用mysql (MySqlCommand、MySqlDataAdapter、BeginTransaction)','c#使用mysql (MySqlCommand、MySqlDataAdapter、BeginTransaction)','28.jpg','https://www.cnblogs.com/hepeng-web/p/14654430.html',15,4,'2022-11-02 16:32:58','2022-11-02 16:32:58'),
(574,'formkit','vue3组件库','3.jpg','https://formkit.com/',24,4,'2022-11-02 16:36:06','2023-07-26 15:54:11'),
(575,'gitclone','GitHub缓存加速网站，为开发者服务（使用git2.0+）','13.jpg','https://gitclone.com/',14,4,'2022-11-02 16:36:50','2022-11-02 16:36:50'),
(576,'Office交流网','Office交流网','7.jpg','http://www.office-cn.net/index.html',10,1,'2022-11-07 10:21:25','2022-11-07 10:21:25'),
(577,'USB-Devices','USB-Devices','20.jpg','https://www.codeproject.com/Articles/60579/A-USB-Library-to-Detect-USB-Devices',14,1,'2022-11-07 13:43:08','2022-11-07 13:43:08'),
(578,'2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）','2022年了，我才开始学 typescript ，晚吗？（7.5k字总结）','6.jpg','https://juejin.cn/post/7124117404187099172#heading-30',15,4,'2022-11-07 15:34:21','2022-11-07 15:34:21'),
(579,'前端Vuer，请收下这份《Vue3中使用JSX简明语法》','前端Vuer，请收下这份《Vue3中使用JSX简明语法》','21.jpg','https://juejin.cn/post/7114063575122984973',15,4,'2022-11-07 15:34:52','2022-11-07 15:34:52'),
(580,'vite-plugin-ssr','Like Next.js/Nuxt but as do-one-thing-do-it-well Vite plugin','29.jpg','https://vite-plugin-ssr.com/',26,4,'2022-11-07 15:35:47','2022-11-07 15:35:47'),
(582,'VueHooks Plus','基础和高级的 hook， 高性能逻辑的抽象封装，满足大量场景','23.jpg','https://nelsonyong.gitee.io/docs/hooks/',27,1,'2022-11-08 10:22:13','2022-11-08 10:23:30'),
(583,'web-norm','每当接手一个新项目（如果项目中没有配置 eslint husky commitlint）等这些规范的话，就需要自己手动配置一遍，配置多了后我只能来句窝草','8.jpg','https://github.com/lyh0371/web-norm',3,4,'2022-11-08 18:08:22','2022-11-08 18:08:22'),
(584,'bourbon','scss常用代码块','27.jpg','https://www.bourbon.io/docs/latest/#padding',9,4,'2022-11-08 18:10:09','2022-11-08 18:10:09'),
(586,'ahooks','ahooks 的 vue 实现。\n\n许多 hooks 是从ahooks移植过来的，但是不完全一致。','3.jpg','https://dewfall123.github.io/ahooks-vue/zh/',3,4,'2022-11-09 14:29:13','2022-11-09 14:29:13'),
(587,'爱给网','图片素材','18.jpg','https://www.aigei.com/',18,4,'2022-11-09 14:40:56','2022-11-09 14:40:56'),
(588,' css手册','api参考文档','8.jpg','https://www.apiref.com/css-zh/index.htm',9,4,'2022-11-09 14:47:43','2022-11-09 14:47:43'),
(589,'cdnjs','CDNJS 是一项免费的开源 CDN 服务，受到超过12.5% 的网站的信任，为 每月超过 2000 亿个请求，由 Cloudflare 提供支持','15.jpg','https://cdnjs.com/',30,4,'2022-11-09 14:48:50','2022-11-09 14:48:50'),
(590,'gitea','一款极易搭建的自助 Git 服务','7.jpg','https://try.gitea.io/',14,4,'2022-11-09 14:50:00','2022-11-09 14:50:00'),
(591,'vitest','Vitest\n由 Vite 提供支持的极速单元测试框架\n一个 Vite 原生的单元测试框架。非常的快！','19.jpg','https://cn.vitest.dev/',3,4,'2022-11-09 14:51:10','2022-11-09 14:51:10'),
(592,'zzhack ','嗨！欢迎来到我的应用 zzhack ，这是一个兴趣使然的项目，zzhack 被设计为一个注重信息展示的应用，它是序列化和沉淀我思想的地方。','13.jpg','https://www.zzhack.fun/about',8,4,'2022-11-09 15:10:56','2022-11-09 15:10:56'),
(593,'milkdown-vue','基于[milkdown](https://github.com/Saul-Mirone/milkdown)的封装，整合了所有常用插件的`Vue3`组件&#x20;\n','17.jpg','https://cyyjs.github.io/milkdown-vue/',24,4,'2022-11-09 15:22:31','2023-07-26 15:54:39'),
(594,'vexip UI','Vexip UI 提供了一系类开箱即用的组件。\n组件库使用 组合式 Api 编写，并尽可能采用 Vue 传统的方式设计和编写组件，全量的 TypeScript（不是 AnyScript）。','7.jpg','https://www.vexipui.com/zh-CN',24,4,'2022-11-09 15:24:20','2022-11-09 15:24:20'),
(595,'网道','网道（WangDoc.com）是一个文档网站，提供互联网开发文档，正在建设中。','1.jpg','https://wangdoc.com/',13,4,'2022-11-09 15:25:25','2022-11-09 15:25:25'),
(596,'SQL之父','快速生成 SQL 和模拟数据，大幅提高开发测试效率！','14.jpg','https://www.sqlfather.com/',16,4,'2022-11-09 15:49:47','2022-11-09 15:49:47'),
(597,'icia','类似 jQuery 的 dom 操作库。','27.jpg','https://licia.liriliri.io/docs_cn.html',5,4,'2022-11-09 16:18:35','2022-11-09 16:18:35'),
(598,' ESLint 配置预设','https://github.com/antfu/eslint-config','16.jpg','https://github.com/antfu/eslint-config',3,4,'2022-11-09 17:10:02','2022-11-09 17:10:02'),
(599,'pinia持久化','插件','17.jpg','https://seb-l.github.io/pinia-plugin-persist/',24,4,'2022-11-09 17:11:45','2023-07-28 08:23:06'),
(600,'HappyBoot Tiger','一个中后端框架Vite2+Vue3+HappyKit+NaiveUI','12.jpg','https://doc.happykit.org/',24,4,'2022-11-09 17:13:19','2022-11-09 17:13:19'),
(601,'轮子之王','将平常开发中非常常用的功能做成轮子，减少开发时间，让开发者拥有更多的时间能够摸鱼','1.jpg','http://it-learning-diary.gitee.io/it-wheels-king-inline-doc/#/README',3,4,'2022-11-09 17:14:30','2022-11-09 17:14:30'),
(602,'alova','MVVM 库的请求场景管理库，它是对请求库的一种武装，而非替代品','5.jpg','https://github.com/JOU-amjs/alova/blob/main/README-zh.md',3,4,'2022-11-09 17:16:20','2022-11-09 17:16:20'),
(603,'quark-design','Quark 是一款基于 Web Components 的跨框架 UI 组件库。 它可以同时在任意框架或无框架中使用。','29.jpg','https://quark-design.hellobike.com/#/',19,4,'2022-11-16 08:58:03','2022-11-16 08:58:03'),
(604,'icones','vue3常用图标库','20.jpg','https://icones.js.org/',35,4,'2022-11-18 09:18:25','2023-08-10 16:59:00'),
(605,'Quick Reference','为开发人员分享快速参考备忘清单【速查表】 (主要是方便自己)，在看到 Reference 快速参考备忘单','5.jpg','http://ref.ecdata.cn/',27,4,'2022-11-18 09:19:34','2022-11-18 09:19:34'),
(606,'tdesign','tdesign','17.jpg','https://tdesign.tencent.com/',24,4,'2022-11-22 15:20:58','2022-11-22 15:20:58'),
(607,'atool99','在线工具','24.jpg','https://www.atool99.com/',14,4,'2022-11-24 17:04:28','2022-11-24 17:04:28'),
(608,'91huajian','一款开源的、免费的简历设计神器\n快速设计、简历主题切换，支持一键导出高清PDF、JSON数据等。','2.jpg','https://91huajian.cn/',14,4,'2022-12-15 11:40:36','2022-12-15 11:40:36'),
(609,'C# 使用UUID生成各种模式方法','C# 使用UUID生成各种模式方法','26.jpg','https://www.cnblogs.com/im17me/p/10336375.html',15,4,'2022-12-15 12:10:02','2022-12-15 12:10:02'),
(610,'c^ret','https://lugolabs.com/caret','1.jpg','https://lugolabs.com/caret',9,4,'2022-12-15 14:27:59','2022-12-15 14:27:59'),
(611,'CSS3参考手册 ','CSS3参考手册 ','20.jpg','http://css.doyoe.com/',9,4,'2022-12-15 14:35:54','2022-12-15 14:35:54'),
(612,'icon-sets','icon-sets','14.jpg','https://icon-sets.iconify.design/',3,4,'2022-12-15 14:45:07','2022-12-15 14:45:07'),
(613,'程序员做饭指南','https://cook.aiurs.co/','28.jpg','https://cook.aiurs.co/',13,4,'2023-01-14 10:54:41','2023-01-14 10:54:41'),
(614,'Rust 打包网页生成很小的桌面','很简单的用 Rust 打包网页生成很小的桌面 App','28.jpg','https://github.com/tw93/Pake?utm_source=gold_browser_extension',14,4,'2023-01-14 11:01:53','2023-01-14 11:01:53'),
(615,'JavaScript 片段','JavaScript 代码片段集合包含各种各样的 ES6 帮助程序函数。它包括用于处理原语，数组和对象的帮助程序，以及算法，DOM操作函数和Node.js实用程序。','19.jpg','https://www.30secondsofcode.org/js/p/1',5,4,'2023-01-14 11:04:33','2023-01-14 11:04:33'),
(616,'Halo','好用又强大的开源建站工具。','15.jpg','https://halo.run/',14,4,'2023-02-06 09:33:37','2023-02-06 09:33:37'),
(617,'snipplr','代码片段','14.jpg','https://snipplr.com/',13,4,'2023-02-06 09:44:17','2023-02-06 09:44:17'),
(618,'tobiasahlin','加载动画','8.jpg','https://tobiasahlin.com/spinkit/',9,4,'2023-02-06 09:48:37','2023-02-06 09:48:37'),
(619,'Mini Sandbox','一个前端【代码/组件】的可视化方案，融合了【在线编辑 & 实时预览】等特点','5.jpg','https://buuing.github.io/mini-sandbox/#/',24,4,'2023-02-06 09:56:34','2023-02-06 09:56:34'),
(620,'notion中文文档','学习 Notion, 从这里开始\n这里有最新的 Notion 中文用户手册和最新最全的资源模版','17.jpg','https://notionchina.co/',13,4,'2023-02-21 09:49:19','2023-02-21 09:49:19'),
(621,'thisthat','代码片段','2.jpg','https://thisthat.dev/',13,4,'2023-02-21 11:17:06','2023-02-21 11:17:06'),
(622,'await-to-js','异步等待包装器','21.jpg','https://www.npmjs.com/package/await-to-js',1,4,'2023-02-23 14:08:20','2023-02-23 14:08:20'),
(623,'css动画','css动画','6.jpg','https://www.webhek.com/post/css3-animation-sniplet-collection/#/',9,4,'2023-05-05 15:54:42','2023-05-05 15:54:42'),
(624,'axios-retry','','21.jpg','http://www.axios-js.com/zh-cn/docs/axios-retry.html',15,4,'2023-05-16 09:11:00','2023-05-16 09:11:00'),
(625,'Hooks时代，如何写出高质量的react和vue组件','Hooks时代，如何写出高质量的react和vue组件','10.jpg','https://juejin.cn/post/7123961170188304391',15,4,'2023-05-16 09:13:07','2023-05-16 09:13:07'),
(626,'代码缺乏装饰？使用ts装饰器来装饰你的代码','','13.jpg','https://juejin.cn/post/7053887981928579103#heading-14',15,4,'2023-05-16 09:14:06','2023-05-16 09:14:06'),
(627,'从 await-to-js 到 try-run-js','从 await-to-js 到 try-run-js','1.jpg','https://juejin.cn/post/7178467482456293434',15,4,'2023-05-16 09:14:27','2023-05-16 09:14:34'),
(628,'blueimp-md5','blueimp-md5\n','14.jpg','https://www.npmjs.com/package/blueimp-md5',1,4,'2023-05-16 09:15:30','2023-05-16 09:15:30'),
(629,'hevue-img-preview','hevue-img-preview\n基于Vue.js的可能很好用的网页端图片浏览插件','1.jpg','https://heyongsheng.github.io/',3,4,'2023-05-17 09:42:19','2023-05-17 09:42:30'),
(630,'gitcode','','5.jpg','https://gitcode.net/dashboard/projects/home',14,4,'2023-05-17 09:44:55','2023-05-17 09:44:55'),
(631,'github中文社区','中文社区','25.jpg','https://www.githubs.cn/',10,4,'2023-05-24 14:28:18','2023-05-24 14:28:18'),
(632,'vue3-video-play','vue3视频播放插件','9.jpg','https://codelife.cc/vue3-video-play/',24,4,'2023-05-24 14:39:06','2023-05-24 14:39:06'),
(633,'emoji','中文表情网','9.jpg','https://www.emojiall.com/zh-hans',18,4,'2023-05-24 14:45:29','2023-05-24 14:45:29'),
(634,'edge','在Windows，MacOS和Linux上运行.NET和Node.js代码','10.jpg','https://github.com/tjanczuk/edge',3,4,'2023-05-27 09:56:35','2023-05-27 09:56:35'),
(635,'[保姆级] Vue3 开发文档','[保姆级] Vue3 开发文档','16.jpg','https://juejin.cn/post/7220220100384407610',15,4,'2023-05-27 09:58:01','2023-05-27 09:58:01'),
(636,'vue导航','vue导航','28.jpg','https://dombro.site/vue#/vue',13,4,'2023-05-27 09:59:02','2023-05-27 09:59:02'),
(637,'离职自缴社保医保+取公积金失业金记录/攻略 ','离职自缴社保医保+取公积金失业金记录/攻略 ','14.jpg','https://www.cnblogs.com/anding/p/16039725.html',15,4,'2023-06-20 15:31:11','2023-06-20 15:31:11'),
(638,'Hello 2023','Hello 2023','26.jpg','https://flowus.cn/share/c1169c04-17d7-4b31-ba84-580cfc514e84',15,4,'2023-06-20 15:32:20','2023-06-20 15:32:20'),
(639,'Electron + Vue3 + TS + Vite 桌面应用项目搭建教程！','','3.jpg','https://juejin.cn/post/7102681636096966687',15,4,'2023-06-20 15:33:32','2023-06-20 15:33:32'),
(640,'好用便签','','27.jpg','http://360bq.xianxingzhewl.top/?utm_source=360&utm_medium=cpc&utm_term=%E5%B7%A5%E4%BD%9C%E4%BE%BF%E7%AD%BE&utm_content=%E5%85%B6%E4%BB%96&utm_campaign=%E4%BE%BF%E7%AD%BE%E4%BE%BF%E7%AC%BA%E4%BE%BF%E5%88%A9%E8%B4%B4',14,4,'2023-06-20 15:34:43','2023-06-20 15:34:43'),
(641,'LINQ 到对象的扩展','','22.jpg','https://morelinq.github.io/',4,4,'2023-06-20 15:41:12','2023-06-20 15:41:12'),
(642,'系统托盘','','6.jpg','https://github.com/Hofknecht/SystemTrayMenu',14,4,'2023-06-20 15:45:58','2023-06-20 15:45:58'),
(643,'electron-vue 跨平台桌面应用开发实战教程','','27.jpg','https://www.bookstack.cn/read/David1025-electron-vue-in-action/c42ae52c69ffc24a.md',15,4,'2023-06-25 16:40:58','2023-06-25 16:40:58'),
(644,'ScottPlot.NET','适用于 .NET 的交互式绘图库','20.jpg','https://scottplot.net/',4,4,'2023-06-25 16:57:36','2023-06-25 16:57:36'),
(646,'InfiniteGrid','InfiniteGrid','12.jpg','https://naver.github.io/egjs-infinitegrid/',24,4,'2023-06-26 15:38:24','2023-06-26 15:38:24'),
(647,'pinyin-pro','一个识别准确、性能优异的专业的汉字拼音转换库','20.jpg','https://pinyin-pro.cn/',24,4,'2023-06-27 08:37:20','2023-06-27 08:37:20'),
(648,'transition.css','动画','22.jpg','https://www.transition.style/#out:custom:circle-swoop',9,4,'2023-06-27 08:51:59','2023-07-26 15:51:41'),
(649,'typescript-cheatsheet','','6.jpg','https://rmolinamir.github.io/typescript-cheatsheet/#introduction',5,4,'2023-06-27 10:07:00','2023-06-27 10:07:00'),
(650,'一个有趣和棘手的 JavaScript 示例列表','','23.jpg','https://github.com/denysdovhan/wtfjs/blob/master/README-zh-cn.md',5,4,'2023-06-27 10:09:41','2023-06-27 10:09:41'),
(651,'JavaScript开发者应懂的33个概念','','7.jpg','https://github.com/stephentian/33-js-concepts',5,4,'2023-06-27 10:11:46','2023-06-27 10:11:46'),
(652,'JavaScript Snippets','','29.jpg','https://www.30secondsofcode.org/js/p/1/',5,4,'2023-06-27 10:12:14','2023-06-27 10:12:14'),
(653,'CSS 函数的完整指南','像任何其他编程语言一样，CSS也有函数。它们可以插入到放置值的位置，或者在某些情况下，与另一个值声明一起插入。','21.jpg','https://css-tricks.com/complete-guide-to-css-functions/',9,4,'2023-06-27 10:19:30','2023-06-27 10:19:30'),
(654,'overapi.com','','10.jpg','overapi.com',13,4,'2023-06-27 10:44:57','2023-06-27 10:44:57'),
(655,'精美简单的CSS','','28.jpg','https://cssfx.netlify.app/',9,4,'2023-06-27 14:29:26','2023-08-10 14:53:56'),
(656,'右键管理','','15.jpg','https://github.com/BluePointLilac/ContextMenuManager',14,4,'2023-07-07 14:14:09','2023-07-07 14:14:09'),
(657,'WindowTextExtractor','窗口文本提取器','7.jpg','https://github.com/AlexanderPro/WindowTextExtractor',32,4,'2023-07-07 14:14:59','2023-07-28 08:14:36'),
(658,'svgrepo','500.000+ 开放许可的 SVG 矢量和图标\n使用各种矢量库为您的项目搜索、探索和编辑最适合您的项目的免费图标或矢量。下载免费的 SVG 矢量和图标用于商业用途。','16.jpg','https://www.svgrepo.com/',18,4,'2023-07-17 10:35:21','2023-07-17 10:35:21'),
(659,'vue示例','vue示例','23.jpg','https://vuejsexamples.com/',24,4,'2023-07-17 15:23:50','2023-07-26 15:48:43'),
(660,'vue3风格指南','vue3风格指南','22.jpg','https://cn.vuejs.org/guide/introduction.html',3,4,'2023-07-17 15:28:15','2023-07-26 15:09:39'),
(663,'onu.zyob.top','uno界面库','7.jpg','https://onu.zyob.top/components/button.html',31,4,'2023-07-26 15:52:32','2023-07-26 15:52:32'),
(664,'vite + vue3 + ts 开箱即用现代开发模板','vite + vue3 + ts 开箱即用现代开发模板','26.jpg','https://github.com/dishait/tov-template',32,4,'2023-07-26 18:38:40','2023-07-26 18:38:40'),
(665,'md-editor-v3','vue3 环境的 Markdown 编辑器，使用 jsx 和 typescript 语法开发，支持在 tsx 项目使用。','24.jpg','https://github.com/imzbf/md-editor-v3/blob/develop/README-CN.md',20,4,'2023-07-26 18:40:24','2023-07-26 18:40:24'),
(666,'设计模式 C# 版（ .NET 6），有系列文章讲解','设计模式 C# 版（ .NET 6），有系列文章讲解','10.jpg','https://github.com/sheng-jie/Design-Pattern',32,4,'2023-07-26 18:40:57','2023-07-26 18:40:57'),
(667,'aspnet-api-versioning','版本控制库','25.jpg','https://github.com/dotnet/aspnet-api-versioning',32,4,'2023-07-28 08:44:53','2023-07-28 08:44:53'),
(668,'shellprogressbar','控制台进度条','19.jpg','https://github.com/Mpdreamz/shellprogressbar',32,4,'2023-07-28 08:54:03','2023-07-28 08:54:03'),
(669,'openedv','嵌入式','16.jpg','http://www.openedv.com/forum.php?gid=102',10,4,'2023-07-31 10:40:02','2023-07-31 10:40:02'),
(670,'Vitest Preview','可视化 Vitest 调试体验','24.jpg','https://www.vitest-preview.com/zh/',3,4,'2023-07-31 13:37:32','2023-07-31 13:37:32'),
(671,'vite-plugin-environment','','5.jpg','https://www.npmjs.com/package/vite-plugin-environment',1,4,'2023-07-31 15:15:47','2023-07-31 15:15:47'),
(672,'接口生成','quicktype json生成接口','12.jpg','https://app.quicktype.io/#',27,4,'2023-08-01 17:41:07','2023-08-10 16:57:10'),
(673,'DotnetSpider','DotnetSpider爬虫','28.jpg','https://github.com/dotnetcore/DotnetSpider',32,4,'2023-08-02 09:02:50','2023-08-02 09:02:50'),
(674,'FastTunnel-内网穿透','','4.jpg','https://github.com/FastTunnel/FastTunnel/blob/v2/README_zh.md',32,4,'2023-08-02 09:03:19','2023-08-02 09:03:19'),
(675,'基于EntityFrameworkCore和Lucene.NET实现的全文检索搜索引擎','','23.jpg','https://github.com/ldqk/Masuit.LuceneEFCore.SearchEngine',32,4,'2023-08-02 09:12:24','2023-08-02 09:12:24'),
(676,'GeekDesk','极客桌面','12.jpg','https://github.com/BookerLiu/GeekDesk/blob/master/README-zh.md',32,4,'2023-08-02 09:19:11','2023-08-02 09:19:11'),
(677,'嵌入式','','19.jpg','http://www.ing10bbs.com/forum.php?mod=forumdisplay&fid=65',10,4,'2023-08-02 09:50:40','2023-08-02 09:50:40'),
(678,'sourcetreeapp','','28.jpg','https://www.sourcetreeapp.com/',14,4,'2023-08-02 11:10:16','2023-08-02 11:10:16'),
(679,'notion','','19.jpg','https://www.notion.so/zh-tw',14,4,'2023-08-02 11:11:59','2023-08-02 11:11:59'),
(680,'eslint-config','esji基础配置','24.jpg','https://github.com/antfu/eslint-config',32,4,'2023-08-02 17:37:44','2023-08-09 14:39:19'),
(684,'掘金','','10.jpg','https://juejin.cn/frontend',34,4,'2023-08-10 16:46:10','2023-08-10 16:46:10'),
(685,'unocss互动','文档','21.jpg','https://unocss.dev/interactive/',27,4,'2023-08-10 17:05:54','2023-08-10 17:05:54'),
(687,'uiverse','','9.jpg','https://uiverse.io/all?page=1',39,4,'2023-08-10 17:13:03','2023-08-10 17:13:03'),
(688,'博客园','','26.jpg','https://www.cnblogs.com/',34,4,'2023-08-10 17:14:20','2023-08-10 17:14:20'),
(689,'csdn','','13.jpg','https://blog.csdn.net/',34,4,'2023-08-10 17:14:56','2023-08-10 17:14:56'),
(690,'codesandbox','CodeSandbox 通过为您提供可在 1 秒内恢复的云开发环境，让您保持流畅。','22.jpg','https://codesandbox.io/',39,4,'2023-08-10 17:30:06','2023-08-10 17:30:06'),
(691,'Masuit.Tools','新手友好的C#万能工具库，码数吐司库，包含一些常用的操作类，大都是静态类，加密解密，反射操作，权重随机筛选算法...','3.jpg','https://github.com/ldqk/Masuit.Tools',32,4,'2023-08-15 11:15:24','2023-08-15 11:15:24'),
(692,'c.biancheng','c语言中文网','6.jpg','http://c.biancheng.net/',10,4,'2023-08-15 11:16:56','2023-08-15 11:16:56'),
(693,'win32','win32参考手册','22.jpg','http://www.yfvb.com/help/win32sdk/index.htm?page=html/4luzha.htm',13,4,'2023-08-15 11:44:53','2023-08-15 11:44:53'),
(694,'vite-plugin-qiniu-oss','将项目中打包后生产文件上传到 qiniu OSS，除了 html 以外','16.jpg','https://github.com/th-come/vite-plugin-qiniu-oss/blob/main/README_CN.md',32,4,'2023-08-16 14:23:28','2023-08-16 14:23:28'),
(695,'字体','','16.jpg','https://juejin.cn/post/7243067221999894583',15,4,'2023-09-05 15:06:04','2023-09-05 15:06:04'),
(696,'TypeScript 配置工具','https://yue1123.github.io/ts-config-helper/','13.jpg','https://yue1123.github.io/ts-config-helper/',27,4,'2023-09-08 14:17:29','2023-09-08 14:17:52'),
(697,'AI问答','人工智能问答','3.jpg','https://zzzcode.ai/answer-question',38,4,'2023-09-14 10:40:59','2023-09-14 10:40:59'),
(698,'周报生成','','21.jpg','https://weeklyreport.avemaria.fun/zh',38,4,'2023-09-14 10:42:34','2023-09-14 10:42:34'),
(699,'代码格式化','','15.jpg','https://stackoverflow.org.cn/formatcs/',27,4,'2023-09-14 10:44:13','2023-09-14 10:44:13'),
(700,'InsCode','InsCode 文档\n从开发-部署-运维-运营，一站搞定','2.jpg','https://inscode.csdn.net/',27,4,'2023-09-14 10:46:38','2023-09-14 10:46:38'),
(701,'ToolGood.Words',' 敏感词检测','27.jpg','https://github.com/toolgood/ToolGood.Words',32,4,'2023-09-14 10:53:23','2023-09-14 10:53:23'),
(702,'UnoCSS文档','UnoCSS\n即时按需的原子级CSS引擎','10.jpg','https://alfred-skyblue.github.io/unocss-docs-cn/',27,4,'2023-09-14 10:54:52','2023-09-14 10:55:13'),
(703,'vite-aliases','别名生成','13.jpg','https://github.com/subwaytime/vite-aliases',32,4,'2023-09-14 10:59:13','2023-09-14 10:59:13'),
(704,'文心一言','','14.jpg','https://yiyan.baidu.com/',38,4,'2023-09-14 11:54:52','2023-09-14 11:54:52'),
(705,'javascript-guidebook','知识图谱','18.jpg','https://tsejx.github.io/javascript-guidebook/',5,4,'2023-10-31 13:55:25','2023-10-31 13:55:25'),
(706,'Awesome-PicGo','PicGo插件合集','8.jpg','https://github.com/PicGo/Awesome-PicGo',14,4,'2023-10-31 14:01:51','2023-10-31 14:01:51'),
(707,'构建一个 Electron 桌面应用','','5.jpg','https://juejin.cn/post/7228935408900571193',15,4,'2023-11-01 15:09:07','2023-11-01 15:09:07'),
(708,'pinyin-pro','中文转拼音','25.jpg','https://github.com/zh-lx/pinyin-pro',24,4,'2023-11-01 15:11:23','2023-11-01 15:11:23'),
(709,'最详细的 Vue3 + TypeScript 使用教程【值得收藏】','','18.jpg','https://juejin.cn/post/7121253172013694990',15,4,'2023-11-01 15:18:16','2023-11-01 15:18:16'),
(710,'VContextmenu','适用于 Vue 3.0 的 Contextmenu 组件。','24.jpg','https://heynext.github.io/v-contextmenu/',24,4,'2023-11-02 15:35:01','2023-11-02 15:35:01'),
(711,'一劳永逸快速启动软件','','15.jpg','https://hui-zz.gitee.io/runany/#/',14,4,'2024-02-03 09:52:46','2024-02-03 09:52:46'),
(712,'TS类型写不好？一起来训练提升吧！','','14.jpg','https://juejin.cn/post/7193917621069152311',15,4,'2024-02-29 11:38:41','2024-02-29 11:38:41'),
(713,'w3c','','26.jpg','https://w3schools.cn/',13,4,'2024-02-29 11:40:03','2024-02-29 11:40:03'),
(714,'花了一天的时间，地板式扫盲了vue3所有API盲点','花了一天的时间，地板式扫盲了vue3所有API盲点','23.jpg','https://juejin.cn/post/7164159759619194893#heading-1',15,4,'2024-02-29 11:47:55','2024-02-29 11:47:55'),
(716,'TypeScript 知识图谱 构建 JS 语言超集 TS 知识体系','TypeScript 知识图谱 构建 JS 语言超集 TS 知识体系','11.jpg','https://tsejx.github.io/typescript-guidebook/',15,4,'2024-02-29 11:52:22','2024-02-29 11:52:22'),
(717,'Vue-sonner','','24.jpg','https://vuejsfeed.com/blog/vue-sonner',15,4,'2024-02-29 13:41:07','2024-02-29 13:41:07'),
(718,'ESLint 入门','','11.jpg','https://zh-hans.eslint.org/docs/latest/use/getting-started',15,4,'2024-02-29 13:45:25','2024-02-29 13:45:25'),
(719,'3天整理的3W3千字的JS年度毒打！','','7.jpg','https://juejin.cn/post/7275576110818099240',15,4,'2024-02-29 13:46:33','2024-02-29 13:46:33'),
(720,'Vue 中从 template 到 jsx 语法指南','','25.jpg','https://juejin.cn/post/7276750877250060344',15,4,'2024-02-29 14:16:04','2024-02-29 14:16:04'),
(721,'一言 开发者中心','','8.jpg','https://developer.hitokoto.cn/',13,4,'2024-02-29 14:18:13','2024-02-29 14:18:13'),
(722,'一款实用的 JavaScript 函数式编程库。','','27.jpg','https://ramda.cn/',5,4,'2024-02-29 16:58:00','2024-02-29 16:58:00'),
(723,'vue3.0+vite项目中使用JSX语法','','4.jpg','https://juejin.cn/post/7239744255674400825',15,4,'2024-03-01 14:13:12','2024-03-01 14:13:12'),
(724,'如何进阶TypeScript功底？一文带你理解TS中各种高级语法','','19.jpg','https://juejin.cn/post/7089809919251054628',15,4,'2024-03-01 15:28:50','2024-03-01 15:28:50'),
(725,'一篇搞懂Vue里的自定义指令','','2.jpg','https://juejin.cn/post/7249177497190907959',15,4,'2024-03-01 15:30:37','2024-03-01 15:30:37'),
(726,'轻量级请求策略库','','27.jpg','https://alova.js.org/zh-CN/',3,4,'2024-03-04 09:43:11','2024-03-04 09:43:11');
/*!40000 ALTER TABLE `navigation` ENABLE KEYS */;

-- 
-- Definition of photo
-- 

DROP TABLE IF EXISTS `photo`;
CREATE TABLE IF NOT EXISTS `photo` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(80) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '名称',
  `path` varchar(225) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '路径',
  `description` varchar(225) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '描述',
  `read` smallint NOT NULL DEFAULT '0' COMMENT '阅读',
  `give` smallint NOT NULL DEFAULT '0' COMMENT '热度',
  `tag` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '标签',
  `type_id` int NOT NULL DEFAULT '0' COMMENT '分类',
  `user_id` int DEFAULT NULL COMMENT '用户',
  `photo_gallery_id` int DEFAULT NULL,
  `time_create` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `fk_user` (`user_id`) USING BTREE,
  KEY `fk_type` (`type_id`) USING BTREE,
  KEY `fk_ph_gallery` (`photo_gallery_id`) USING BTREE,
  CONSTRAINT `fk_ph_gallery` FOREIGN KEY (`photo_gallery_id`) REFERENCES `photo_gallery` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_type` FOREIGN KEY (`type_id`) REFERENCES `photo_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `fk_user` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC COMMENT='图册';

-- 
-- Dumping data for table photo
-- 

/*!40000 ALTER TABLE `photo` DISABLE KEYS */;
INSERT INTO `photo`(`id`,`name`,`path`,`description`,`read`,`give`,`tag`,`type_id`,`user_id`,`photo_gallery_id`,`time_create`) VALUES
(4,'1','2','3',0,0,'4',1,4,1,'2023-08-02 13:43:09');
/*!40000 ALTER TABLE `photo` ENABLE KEYS */;

-- 
-- Definition of photo_gallery
-- 

DROP TABLE IF EXISTS `photo_gallery`;
CREATE TABLE IF NOT EXISTS `photo_gallery` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '名称',
  `description` varchar(225) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '描述',
  `img` varchar(225) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `type_id` int NOT NULL,
  `user_id` int NOT NULL,
  `tag` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `give` smallint NOT NULL DEFAULT (0),
  `time_create` datetime NOT NULL,
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `FK1_TYPE` (`type_id`) USING BTREE,
  KEY `FK2_USER` (`user_id`) USING BTREE,
  CONSTRAINT `FK1_TYPE` FOREIGN KEY (`type_id`) REFERENCES `photo_gallery_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK2_USER` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb3 ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table photo_gallery
-- 

/*!40000 ALTER TABLE `photo_gallery` DISABLE KEYS */;
INSERT INTO `photo_gallery`(`id`,`name`,`description`,`img`,`type_id`,`user_id`,`tag`,`time_create`,`time_modified`) VALUES
(1,'From 少年 To Jenny','1','20.jpg',1,1,'信件','2023-08-02 14:19:03','2023-08-02 14:19:04');
/*!40000 ALTER TABLE `photo_gallery` ENABLE KEYS */;

-- 
-- Definition of sn_setblog
-- 

DROP TABLE IF EXISTS `sn_setblog`;
CREATE TABLE IF NOT EXISTS `sn_setblog` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '设置的内容名称',
  `router_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '路由链接',
  `isopen` tinyint(1) NOT NULL COMMENT '是否启用',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL COMMENT '关联用户表',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `setblog_user_id` (`user_id`) USING BTREE,
  KEY `setblog_type_id` (`type_id`) USING BTREE,
  CONSTRAINT `setblog_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_setblog_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `setblog_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table sn_setblog
-- 

/*!40000 ALTER TABLE `sn_setblog` DISABLE KEYS */;
INSERT INTO `sn_setblog`(`id`,`name`,`router_url`,`isopen`,`type_id`,`user_id`) VALUES
(1,'SetPage','df',0,1,4),
(2,'1','5',1,0,4);
/*!40000 ALTER TABLE `sn_setblog` ENABLE KEYS */;

-- 
-- Definition of snippet
-- 

DROP TABLE IF EXISTS `snippet`;
CREATE TABLE IF NOT EXISTS `snippet` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin DEFAULT NULL,
  `text` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_bin,
  `type_id` int DEFAULT NULL,
  `type_sub_id` int DEFAULT '7',
  `tag_id` int DEFAULT '1',
  `user_id` int DEFAULT NULL,
  `snippet_version_id` int DEFAULT '0',
  `time_create` datetime DEFAULT '2023-08-04 09:43:08',
  `time_update` datetime DEFAULT '2023-08-04 09:43:08',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `uid` (`user_id`) USING BTREE,
  KEY `typeid` (`type_id`) USING BTREE,
  KEY `FK_snippet_snippet_type_sub` (`type_sub_id`) USING BTREE,
  KEY `FK_snippet_snippet_tag` (`tag_id`) USING BTREE,
  KEY `snippet_version_id` (`snippet_version_id`) USING BTREE,
  CONSTRAINT `FK_snippet_snippet_tag` FOREIGN KEY (`tag_id`) REFERENCES `snippet_tag` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `FK_snippet_snippet_type_sub` FOREIGN KEY (`type_sub_id`) REFERENCES `snippet_type_sub` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `typeid` FOREIGN KEY (`type_id`) REFERENCES `snippet_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `uid` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=1218 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table snippet
-- 

/*!40000 ALTER TABLE `snippet` DISABLE KEYS */;
INSERT INTO `snippet`(`id`,`name`,`text`,`type_id`,`type_sub_id`,`tag_id`,`user_id`,`snippet_version_id`,`time_create`,`time_update`) VALUES
(26,'vue3生命周期','onBeforeMount -> onMounted -> onBeforeUpdate -> onUpdated -> onBeforeUnmount -> onUnmounted -> onErrorCaptured \n\n跟 options api 混用时 onBeforeMount 在 beforeMount 之前，onMounted 在 mounted 之前\n\n| vue3              | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| setup()           | 开始创建组件之前，在beforeCreate和created之前执行。创建的是data和method |\n| //挂载阶段        |                                                              |\n| onBeforeMount()   | 组件挂载到节点上之前执行的函数。                             |\n| onMounted()       | 组件挂载完成后执行的函数。                                   |\n| //更新            |                                                              |\n| onBeforeUpdate()  | 组件更新之前执行的函数。                                     |\n| onUpdated()       | 组件更新完成之后执行的函数。                                 |\n| //销毁            |                                                              |\n| onBeforeUnmount() | 组件卸载(销毁)之前执行的函数。                               |\n| onUnmounted()     | 组件卸载(销毁)完成后执行的函数                               |\n| onActivated()     | 被包含在 keep-alive 中的组件，会多出两个生命周期钩子函数。被激活时执行。 |\n| onDeactivated()   | 比如从 A 组件，切换到 B 组件，A 组件消失时执行。             |\n| onErrorCaptured() | 当捕获一个来自子孙组件的异常时激活钩子函数                   |',2,142,34,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(27,'文本插值({{ msg }})','数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值：\n\n```html\n<span>Message: {{ msg }}</span>\n```\n\n使用的是 `Mustache` 语法 (即双大括号)，每次 `msg` 属性更改时它也会同步更新',2,3,102,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(28,' AXIOS String contains non ISO-8859-1',' 在头信息中存在中文，需要对其进行编码,使用encodeURIComponent()对中文信息进行编码即可。\n\n``` js\nif (storage.get(store.state.Roles)) {\n    req.headers.Authorization =\n        encodeURIComponent(storage.get(store.state.Roles)) as string\n}\n```',3,73,118,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(30,'命名基本约定','\n| **标识符** | **大小写** | **示例**                                 |\n| ---------- | ---------- | ---------------------------------------- |\n| 命名空间   | Pascal     | namespace Com.Techstar.ProductionCenter  |\n| 类型       | Pascal     | public class DevsList                    |\n| 接口       | Pascal     | public interface ITableModel             |\n| 方法       | Pascal     | public void UpdateData()                 |\n| 属性       | Pascal     | Public int Length{…}                     |\n| 事件       | Pascal     | public event EventHandler Changed;       |\n| 私有字段   | Camel      | private string fieldName;                |\n| 非私有字段 | Pascal     | public string FieldName；                |\n| 枚举值     | Pascal     | FileMode{Append}                         |\n| 参数       | Camel      | public void UpdateData(string fieldName) |\n| 局部变量   | Camel      | string fieldName;                        |',1,156,234,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(31,'List集合的声明','List是一种动态数组，可以存储多个元素，并且可以根据需要动态调整大小\n\n```csharp\nList<string> list = new List<string>();  // 创建一个名为list的列表对象\n\nlist.Add(\"a一\");  // 向列表中添加一个元素，值为\"a一\"\nlist.Add(\"b二\");  // 向列表中添加一个元素，值为\"b二\"\n\n//语法糖\nList<string> list = new List<string> {\"def\",\"OK\"};  // 使用语法糖创建一个列表对象，并初始化两个元素，值分别为\"def\"和\"OK\"\n```\n\n遍历集合\n\n```csharp\nforeach (string item in list)\n{\n  Console.WriteLine(item);\n}\n//语法糖\nlist.ForEach(a => Console.WriteLine(a));\n```\n\n',1,134,552,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(32,'c#访问修饰符','- public:公有访问，不受任何限制 , 表示成员可以从任何地方访问\n- private:私有访问，成员只能在同一类中访问。\n- protected:受保护的，只限于本类和子类访问。\n- internal:内部访问，只限于本项目内访问，其他的不能访问\n- protected internal:内部保护访问，只限于本项目或是子类访问，其他的不能访问',1,133,547,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(33,'using等于try finally','使用完释放资源，经常要用using，using实质上就是try fiannaly的一个语法糖\n\n```c#\nStreamWriter sw = null;\ntry\n{\n    sw = new StreamWriter(\"d:\\abc.txt\");\n    sw.WriteLine(\"test\");\n}\nfinally {\n    if(sw!= null) sw.Dispose();\n}\n```\n\n简化为：\n\n```c#\nusing (var sw = new StreamWriter(\"d:\\abc.txt\")) {\n    sw.WriteLine(\"test\");\n}\n```\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(34,'v-html','双大括号将会将数据插值为纯文本，而不是 HTML。若想插入 HTML，你需要使用 v-html 指令：\n``` html\n<p>Using mustaches: {{ rawHtml }}</p>\n<p>Using v-html directive: <span v-html=\"rawHtml\"></span></p>\n```\n双大括号{{}}会将数据解释为纯文本，使用 v-html 指令，将插入 HTML',2,3,291,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(35,'v-bind','`v-bind` 指令指示 Vue 将元素的 `id` attribute 与组件的 `dynamicId` property 保持一致。如果绑定的值是 `null` 或者 `undefined`，那么该 attribute 将会从渲染的元素上移除。\n\n```html\n<!-- 完整语法 -->\n<a v-bind:href=\"url\">...</a>\n\n<!-- 缩写 -->\n<a :href=\"url\">...</a>\n\n<!-- 动态参数的缩写 (2.6.0+) -->\n<a :[key]=\"url\"> ... </a>\n```\n',2,3,55,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(36,'v-on监听事件','使用 `v-on` 指令 (简写为 `@`) 来监听 DOM 事件和运行 JavaScript \n#### 基本语法\n```html\n<!-- 完整语法 -->\n<a v-on:click=\"doSomething\">...</a>\n<!-- 缩写 -->\n<a @click=\"doSomething\">...</a>\n<!-- 动态参数的缩写 -->\n<a @[event]=\"doSomething\"> ... </a>\n<!-- 动态的事件名绑定处理函数 -->\n<a v-on:[eventName]=\"doSomething\"> ... </a>\n```\n事件处理器的值：\n1. 内联事件处理器：事件被触发时执行的内联 JavaScript 语句 (与 `onclick` 类似) 。\n2. 方法事件处理器：一个组件的属性名、或对某个方法的访问。',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(37,'vite-plugin-restart','[github](https://github.com/antfu/vite-plugin-restart)\n\n通过监听文件修改，自动重启 vite 服务。\n\n最常用的场景就是监听 `vite.config.js` 和 `.env.development` 文件，我们知道，修改 vite 配置文件和环境配置文件，是需要重启 vite 才会生效，通过这个插件，我们将从反复重启中解脱出来。\n\n\nInstall\n\n```bash\nnpm i vite-plugin-restart -D \nyarn add vite-plugin-restart -D\n```\n\nAdd it to `vite.config.js`\n\n```js\n// vite.config.js\nimport ViteRestart from ''vite-plugin-restart''\n\nexport default {\n  plugins: [\n    ViteRestart({\n      restart: [\n        ''my.config.[jt]s'',\n      ]\n    })\n  ],\n};\n```\n',9,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(38,'vite-plugin-tips','[github:](https://github.com/yingpengsha/vite-plugin-tips)\n\n服务器状态提示\n\n Install\n\n``` bash\n$ npm install vite-plugin-tips -D\n```\n\n configuration\n\n``` js\nimport { viteTips } from ''vite-plugin-tips''\n\nexport default {\n  plugins: [\n    viteTips()\n  ]\n}\n```\n\n Options\n\n``` js\ninterface Options {\n  // Whether to enable relevant tips. Default is enabled.\n  connect?: boolean\n  update?: boolean\n  disconnect?: boolean\n}\n```\n\n',9,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(39,'script setup','- 所有的组合 API 函数都在此使用, 只在初始化时执行一次\n- 函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用\n\nscript setup 可以和 script 同时存在, script setup 中的顶层的导入和变量声明都将自动地在该组件的模板上可用。\n\n```vue\n<script>\nexport const name = 1;\n</script>\n\n<script setup>\nimport { ref } from ''vue'';\nconst count = ref(0);\n</script>\n```\n\n',2,4,645,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(40,'nextTick','延迟代码执行，是将回调函数的逻辑延迟在`下一次dom更新后`调用，简单的理解是：当数据更新时，在dom渲染后，自动执行该函数。\n\n\n\n`Vue采用异步渲染`，简单来说就是为了提升性能，因为不采用异步更新，在每次更新数据都会对当前组件进行重新渲染，为了性能考虑，Vue会在本轮数据更新后，再去异步更新视图。如果我们想要在`数据更新后进行dom操作`，就需要用到nextTick(),，使用它可以让我们获取到`最新的dom`。\n\n```ts\nimport { nextTick } from ''vue'';\n\nfunction increment() {\n  count.value++;\n  nextTick(() => {\n    // 访问更新后的 DOM\n  });\n}\n\n// 还可以使用 async/await\nasync () => {\n  await nextTick();\n  // ....\n};\n```\n\n',2,4,646,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(42,'组件命名','单文件组件名应该始终是**单词大写开头** NewComponent.vue \n\n**子组件命名**\n\n- FooterSection.vue\n- FooterSectionHeading.vue\n\n**没有子组件，尝试加前缀 `the` 来命名**\n\n- TheNavbar.vue\n\n```\n// 反例\ncomponents/\n|- MyButton.vue\n|- VueTable.vue\n\n// 好例子\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n```\n\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(43,'常用命名','**注意**：ad、banner、gg、guanggao 等有机会和广告挂勾的字眠不建议直接用来做ClassName，因为有些浏览器插件（Chrome的广告拦截插件等）会直接过滤这些类名\n\n| ClassName              | 含义                                     |\n| :--------------------- | :--------------------------------------- |\n| about                  | 关于                                     |\n| account                | 账户                                     |\n| arrow                  | 箭头图标                                 |\n| article                | 文章                                     |\n| aside                  | 边栏                                     |\n| audio                  | 音频                                     |\n| avatar                 | 头像                                     |\n| bg,background          | 背景                                     |\n| bar                    | 栏（工具类）                             |\n| branding               | 品牌化                                   |\n| crumb,breadcrumbs      | 面包屑                                   |\n| btn,button             | 按钮                                     |\n| caption                | 标题，说明                               |\n| category               | 分类                                     |\n| chart                  | 图表                                     |\n| clearfix               | 清除浮动                                 |\n| close                  | 关闭                                     |\n| col,column             | 列                                       |\n| comment                | 评论                                     |\n| community              | 社区                                     |\n| container              | 容器                                     |\n| content                | 内容                                     |\n| copyright              | 版权                                     |\n| current                | 当前态，选中态                           |\n| default                | 默认                                     |\n| description            | 描述                                     |\n| details                | 细节                                     |\n| disabled               | 不可用                                   |\n| entry                  | 文章，博文                               |\n| error                  | 错误                                     |\n| even                   | 偶数，常用于多行列表或表格中             |\n| fail                   | 失败（提示）                             |\n| feature                | 专题                                     |\n| fewer                  | 收起                                     |\n| field                  | 用于表单的输入区域                       |\n| figure                 | 图                                       |\n| filter                 | 筛选                                     |\n| first                  | 第一个，常用于列表中                     |\n| footer                 | 页脚                                     |\n| forum                  | 论坛                                     |\n| gallery                | 画廊                                     |\n| group                  | 模块，清除浮动                           |\n| header                 | 页头                                     |\n| help                   | 帮助                                     |\n| hide                   | 隐藏                                     |\n| hightlight             | 高亮                                     |\n| home                   | 主页                                     |\n| icon                   | 图标                                     |\n| info,information       | 信息                                     |\n| last                   | 最后一个，常用于列表中                   |\n| links                  | 链接                                     |\n| login                  | 登录                                     |\n| logout                 | 退出                                     |\n| logo                   | 标志                                     |\n| main                   | 主体                                     |\n| menu                   | 菜单                                     |\n| meta                   | 作者、更新时间等信息栏，一般位于标题之下 |\n| module                 | 模块                                     |\n| more                   | 更多（展开）                             |\n| msg,message            | 消息                                     |\n| nav,navigation         | 导航                                     |\n| next                   | 下一页                                   |\n| nub                    | 小块                                     |\n| odd                    | 奇数，常用于多行列表或表格中             |\n| off                    | 鼠标离开                                 |\n| on                     | 鼠标移过                                 |\n| output                 | 输出                                     |\n| pagination             | 分页                                     |\n| pop,popup              | 弹窗                                     |\n| preview                | 预览                                     |\n| previous               | 上一页                                   |\n| primary                | 主要                                     |\n| progress               | 进度条                                   |\n| promotion              | 促销                                     |\n| rcommd,recommendations | 推荐                                     |\n| reg,register           | 注册                                     |\n| save                   | 保存                                     |\n| search                 | 搜索                                     |\n| secondary              | 次要                                     |\n| section                | 区块                                     |\n| selected               | 已选                                     |\n| share                  | 分享                                     |\n| show                   | 显示                                     |\n| sidebar                | 边栏，侧栏                               |\n| slide                  | 幻灯片，图片切换                         |\n| sort                   | 排序                                     |\n| sub                    | 次级的，子级的                           |\n| submit                 | 提交                                     |\n| subscribe              | 订阅                                     |\n| subtitle               | 副标题                                   |\n| success                | 成功（提示）                             |\n| summary                | 摘要                                     |\n| tab                    | 标签页                                   |\n| table                  | 表格                                     |\n| txt,text               | 文本                                     |\n| thumbnail              | 缩略图                                   |\n| time                   | 时间                                     |\n| tips                   | 提示                                     |\n| title                  | 标题                                     |\n| video                  | 视频                                     |\n| wrap                   | 容器，包，一般用于最外层                 |\n| wrapper                | 容器，包，一般用于最外层                 |',2,94,234,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(45,'字符串(String)','一个字符系列，使用单引号（**''**）或双引号（**\"**）来表示字符串类型。反引号（**`**）来定义多行文本和内嵌表达式。\n\n```tsx\nlet myName: string = ''Tom'';\nlet myAge: number = 25;\n\n// 模板字符串\nlet sentence: string = `Hello, my name is ${myName}.\nI''ll be ${myAge + 1} years old next month.`;\n```\n',5,85,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(47,'C#类型转换','| 序号 | 方法 & 描述                                                  |\n| ---- | ------------------------------------------------------------ |\n| 1    | **ToBoolean** 如果可能的话，把类型转换为布尔型。             |\n| 2    | **ToByte** 把类型转换为字节类型。                            |\n| 3    | **ToChar** 如果可能的话，把类型转换为单个 Unicode 字符类型。 |\n| 4    | **ToDateTime** 把类型（整数或字符串类型）转换为 日期-时间 结构。 |\n| 5    | **ToDecimal** 把浮点型或整数类型转换为十进制类型。           |\n| 6    | **ToDouble** 把类型转换为双精度浮点型。                      |\n| 7    | **ToInt16** 把类型转换为 16 位整数类型。                     |\n| 8    | **ToInt32** 把类型转换为 32 位整数类型。                     |\n| 9    | **ToInt64** 把类型转换为 64 位整数类型。                     |\n| 10   | **ToSbyte** 把类型转换为有符号字节类型。                     |\n| 11   | **ToSingle** 把类型转换为小浮点数类型。                      |\n| 12   | **ToString** 把类型转换为字符串类型。                        |\n| 13   | **ToType** 把类型转换为指定类型。                            |\n| 14   | **ToUInt16** 把类型转换为 16 位无符号整数类型。              |\n| 15   | **ToUInt32** 把类型转换为 32 位无符号整数类型。              |\n| 16   | **ToUInt64** 把类型转换为 64 位无符号整数类型。              |',1,135,271,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(48,'CSS简介','层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现[HTML](https://baike.baidu.com/item/HTML)（[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言/6805073)的一个应用）或[XML](https://baike.baidu.com/item/XML)（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。 [1] \n\nCSS 能够对网页中元素位置的排版进行像素级精确控制，支持几乎所有的字体字号样式，拥有对网页对象和模型样式编辑的能力。',8,30,41,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(49,'代码大小写','样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(50,'选择器','选择器根据不同的需求把不同的标签选出来这就是选择器的作用。\nCSS选择器的解析是从上到下，从右向左解析，为了避免对所有元素进行解析\n- 可继承的样式：font-size, font-family, color，ul，li，dl，dt，dd；\n- 不可继承的样式：border, padding, margin, width, height\n\n**优先级**\n\n| 选择器         | 权重值 |\n| :------------- | :----- |\n| !important标识 | 10000  |\n| 行内样式       | 1000   |\n| id选择器       | 100    |\n| 类选择器       | 10     |\n| 标签选择器     | 1      |\n| 通配符 *       | 0      |\n\n> !important>行内样式>ID选择器>类、伪类、属性>元素、伪元素>继承>通配符',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(51,'标签选择器','标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类的标签指定统一的CSS样式。\n\n```css\np{\n    color:red;\n }\n\n标签名{\n属性1;属性值1;\n属性2;属性值2;\n......\n}\n```\n\n作用：可以把某一类标签全部选择出来,比如所有的div标签和所有的span标签\n优点：能快速为页面中同类型的标签统一设置样式。\n缺点：不能设计差异化模式，只能选择全部的当前标签。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(52,'类选择器','如果想要差异化选择不同的标签，单独选一个或几个标签，可以使用类选择器。\n\n语法：\n\n```css\n.类名{\n 属性1;属性值1;\n ......\n }\n```\n\n结构需要用class属性来调用class类的意思。\n\n```html\n<div class=\"red\">变颜色</div>\n```\n\n注意：\n\n- 类选择器使用“.”（英文点号）进行标识，后面紧跟类名(自定义，我们自己命名的）。\n- 可以理解为给这个个标签起了一个名字，来表示。\n- 长名称或词组可以使用中横线来为选择器命名。\n- 不要使用纯数字、中文等命名，尽量使用英文字母来表示。\n- 命名要有意义，尽量使别人一眼就知道这个类名的目的。\n- 命名规范：见附件（web前端开发规范手册.doc）\n\n**类选择器口诀：\n\n> 样式点定义 结构类调用 一个或多个 开发最常用\n\n### 类命名规则\n\n| 头       | header            | 菜单     |    menu    |\n| -------- | ----------------- | -------- | :--------: |\n| 内容     | content/container | 子菜单   |  submenu   |\n| 尾       | footer            | 搜索     |   search   |\n| 导航     | nav               | 友情链接 | friendlink |\n| 侧栏     | sidebar           | 页脚     |   footer   |\n| 栏目     | column            | 版权     | copyright  |\n| 标志     | logo              | 广告     |   banner   |\n| 页面主体 | main              | 热点     |    hot     |\n| 新闻     | news              | 下载     |  download  |\n| 子导航   | subnav            |          |            |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(53,'ID选择器','id选择器可以为标有特点id的HTML元素指定特定的样式。HTML元素以id属性来设置ID选择器，CSS中id选择器以“#”来定义。\n\n```html\n<div id=\"warning\">----</div>\n```\n\n```css\n#warning{color:red;}\n\n# id名{\n属性1;属性值1;\n......\n}\n```\n\n注意：id属性只能在每个html文档中出现一次。\n\n口诀：\n\n> 样式自定义，结构id调用，只能调用一次，别人切勿使用。\n\n### ID选择器和类选择器区别\n\n- 类选择器（class）可以有多个class，同时一个class也可以被多个使用。\n- ID选择器好比人的身份证号码，全中国是唯一的，不得重复。\n- ID选择器和类选择器最大的不同在于使用次数上。\n- 类选择器在修改样式中用的最多，ID选择器一般用于页面唯一性的元素上，经常和JAVASCRIPT搭配使用。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(54,'通配符选择器','通配符选择器用“*”定义，它表示选取页面中所有元素（标签）\n\n语法：\n\n```bash\n * {\n属性1；属性值1；\n......\n}\n```\n\n- 通配符选择器不需要调用，自动就给所有的元素使用样式。\n- 特殊情况下才使用，后面讲解使用场景（以下是清除所有的元素标签的内外边距，后期讲）。\n\n```css\n* {\nmargin: 0;\npadding: 0;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(55,'属性选择器','```html\n<ul>\n    <li foo>1</li>\n    <li foo=\"abc\">2</li>\n    <li foo=\"abc efj\">3</li>\n    <li foo=\"abcefj\">4</li>\n    <li foo=\"efjabc\">5</li>\n    <li foo=\"ab\">6</li>\n</ul>\n```\n\n```css\n//选择 attribute=value 的所有元素。\n[foo=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性包含单词 value 的所有元素。\n[foo~=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 开头的所有元素。类似正则的 ^,以什么开始\n[foo^=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性值以 value 结束的所有元素。类似正则的 $,以什么结束\n[foo$=abc]{\n    background-color:red;\n}\n\n//选择其 attribute 属性中包含 value 子串的每个元素。\n[foo*=abc]{\n    background-color:red;\n}\n\n//选择 attribute 属性值以 value 开头的所有元素。\n[foo|=abc]{\n    background-color:red;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(57,'子选择器','子元素选择器（子选择器）只能选择作为某元素的最近一级子元素，简单理解就是选亲儿子元素。\n\n```css\n ul>li>p{\n   border: 1px solid red;\n}\n语法：元素1>元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有直接后代（子元素）元素2.\n\n注意：\n\n- 元素1和元素2中间用大于号隔开。\n- 元素1是父级元素，2是子级元素，最终选择的是元素2.\n- 元素2必须是亲儿子，其孙子、重孙不归他管，也可以叫亲儿子选择器。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(58,'并集选择器','并集选择器可以选择多组标签，同时为他们定义相同的样式，通常用于集体声明。\n\n并集选择器是各选择器通过英文逗号（，）连接而成，任何形式的选择器都可以作为并集选择器的一部分。\n\n```text\n语法：元素1,元素2{样式声明}\n```\n\n上述语法表示选择元素1和元素2.',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(59,'相邻兄弟选择器','```css\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n//选择紧接在 element元素之后的 element 元素。\nh1+p{\n    color:red;\n}\n```\n\n',8,86,190,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(60,'一般兄弟选择器','```css\n//选择前面有 element1 元素的每个 elem 元素。\n<div>\n    <h1>h1</h1>\n    <p>p1</p>\n    <p>p2</p>\n    <p>p3</p>\n</div>\n\n h1~p{\n   border: 1px solid red;\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(61,'伪类选择器','伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第一个，第n个元素。\n\n伪类选择器书写最大的特点是用冒号（：）表示，比如:hover :first-child\n\n因为伪类选择器很多，比如有链接伪类、结构伪类等，所以这里，先给大家讲解常用的链接伪类选择器。\n\n链接伪类选择器\n\n| a:link    | /*选择所有未被访问的链接*/               |\n| --------- | ---------------------------------------- |\n| a:visited | /*选择所有已被访问的链接*/               |\n| a:hover   | /*选择鼠标指针位于其上的链接*/           |\n| a:active  | /*选择活动链接（鼠标按下未弹起的链接）*/ |\n\n注意：\n\n- 为了确保生效，请按照LVHA的循环顺序声明\n\n```text\n:link    :visited-   :hover-    :active \n```\n\n- 记忆法：love hate或者lv包hao\n- 因为a链接在浏览器中具有默认样式，所以我们实际工作中都需要给链接单独指定样式。\n\n链接选择器在实际工作开发中的写法：\n\n```css\n/*a是标签选择器 所有的链接*/\na{\ncolor:gray;\ntext:decoration:none;\n}\n/* :hover是链接伪类选择器 鼠标经过*/\na:hover{\ncolor:red;/*鼠标经过的时候，由原来的灰色变成了红色；*/\ntext-decoration:underline;\n}\n```\n\n#### :focus伪类选择器\n\n：focus伪类选择器用于选取获得焦点的表单元素。\n\n焦点是光标，一般情况下（input）类表单元素才能获取，因此这个选择器也主要针对于表单元素来说。\n\n```css\n语法：input:focus{\nbackgroud-color:yellow;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(62,'伪元素选择器','```css\nelement::first-line\n\n//p 元素的第一行发生改变\np:first-line{\n    background-color:yellow;\n}\n\nelement::first-letter\n//直接第一个字符变黄，如果JavaScript做的话，需要获取字符串，再获取第一个字符，再改变其颜色\nh1:first-letter{\n    color:yellow;\n}\n\n//在每个 element 元素的内容之前插入内容。我们更多的可能是当作一个div来用\nelement::before\n\n//在每个element元素的内容之后插入内容。我们可能更多的是用来清除浮动或验证表单提示等其它\nelement::after\n\n//选择被用户选取的元素部分。\n::selection\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(63,'外边距(margin)','margin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。\n\nmargin 可以单独改变元素的上，下，左，右边距，也可以一次改变所有的属性。\n\n| 值       | 说明                                        |\n| :------- | :------------------------------------------ |\n| auto     | 设置浏览器边距。 这样做的结果会依赖于浏览器 |\n| *length* | 定义一个固定的margin（使用像素，pt，em等）  |\n| *%*      | 定义一个使用百分比的边距                    |\n\n#### 边距属性\n\n| 属性          | 描述                                       |\n| :------------ | :----------------------------------------- |\n| margin        | 简写属性。在一个声明中设置所有外边距属性。 |\n| margin-bottom | 设置元素的下外边距。                       |\n| margin-left   | 设置元素的左外边距。                       |\n| margin-right  | 设置元素的右外边距。                       |\n| margin-top    | 设置元素的上外边距。                       |\n\n#### 单边外边距属性\n\n在CSS中，它可以指定不同的侧面不同的边距：\n\n```css\nmargin-top:100px;\nmargin-bottom:100px;\nmargin-right:50px;\nmargin-left:50px;\n```\n\n#### Margin - 简写属性\n\n为了缩短代码，有可能使用一个属性中margin指定的所有边距属性。这就是所谓的简写属性。\n\n所有边距属性的简写属性是 **margin** :\n\n```css\nmargin:100px 50px;\n```\n\nmargin属性可以有一到四个值。\n\n- margin:25px 50px 75px 100px;\n  - 上边距为25px\n  - 右边距为50px\n  - 下边距为75px\n  - 左边距为100px\n- margin:25px 50px 75px;\n  - 上边距为25px\n  - 左右边距为50px\n  - 下边距为75px\n- margin:25px 50px;\n  - 上下边距为25px\n  - 左右边距为50px\n- margin:25px;\n  - 所有的4个边距都是25px\n\n#### 居中显示\n\n```css\nmargin: 0 auto;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(64,'padding填充','当元素的 padding（填充）内边距被清除时，所释放的区域将会受到元素背景颜色的填充。\n\n单独使用 padding 属性可以改变上下左右的填充\n\n| 值       | 说明                                |\n| :------- | :---------------------------------- |\n| *length* | 定义一个固定的填充(像素, pt, em,等) |\n| *%*      | 使用百分比值定义一个填充            |\n\n#### 单边内边距属性\n\n在CSS中，它可以指定不同的侧面不同的填充：\n\n```css\npadding-top:25px;\npadding-bottom:25px;\npadding-right:50px;\npadding-left:50px;\n```\n\n#### 简写属性\n\n为了缩短代码，它可以在一个属性中指定的所有填充属性。\n\n这就是所谓的简写属性。所有的填充属性的简写属性是 **padding** :\n\n```css\npadding:25px 50px;\n```\n\nPadding属性，可以有一到四个值。\n\n **padding:25px 50px 75px 100px;**\n\n- 上填充为25px\n\n- 右填充为50px\n\n- 下填充为75px\n\n- 左填充为100px\n\n  **padding:25px 50px 75px;**\n\n- 上填充为25px\n\n- 左右填充为50px\n\n- 下填充为75px\n\n  **padding:25px 50px;**\n\n- 上下填充为25px\n\n- 左右填充为50px\n\n  **padding:25px;**\n\n- 所有的填充都是25px',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(65,'属性背景效果(background)','- background-color\n- background-image\n- background-repeat\n- background-attachment\n- background-position\n\n颜色值通常以以下方式定义:\n\n- 十六进制 - 如：\"#ff0000\"\n- RGB - 如：\"rgb(255,0,0)\"\n- 颜色名称 - 如：\"red\"\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(66,'背景颜色(background)','```css\n background-color: #ffffff;\n```',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(67,'背景图像(background)','background-image 属性描述了元素的背景图像.\n\n默认情况下，背景图像进行平铺重复显示，以覆盖整个元素实体.\n\n```css\nbackground: no-repeat center/100% url(\"../img/index.png\");\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(68,'多个背景图片(background)','```css\nbody {\n  background-image:\n url(https://xxxx.svg),\n url(https://xxxxxx.svg);\n  background-position: center, top;\n  background-repeat: repeat, no-repeat;\n  background-size: contain, cover;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(69,'水平方向平铺(background)','```css\nbackground-image:url(''gradient2.png'');\nbackground-repeat:repeat-x;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(70,'设置定位与不平铺(background)','让背景图像不影响文本的排版\n如果你不想让图像平铺，你可以使用 background-repeat 属性:\n```css\nbackground-image:url(''img_tree.png'');\nbackground-repeat:no-repeat;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(71,'网格背景图像(background)','```html\n<body>\n<div class=\"container\">\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n  <div class=\"item_img\"></div>\n  <div class=\"item\"></div>\n</div>\n</body>\n```\n\n```css\nbody {\n margin: 0;\n  padding: 0;\n}\n\n.container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  background: black;\n  display: grid;\n  grid-template-columns: 25fr 30fr 40fr 15fr;\n  grid-template-rows: 20fr 45fr 5fr 30fr;\n  grid-gap: 20px;\n  .item_img {\n    background-image: url(''https://images.unsplash.com/photo-1499856871958-5b9627545d1a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2207&q=80'');\n  background-repeat: no-repeat;\n  background-position: center;\n  background-attachment: fixed;\n  background-size: cover;\n}\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(72,'全局背景颜色','### 全局背景颜色\n\n```js\nmounted() {\n  document.querySelector(''body'').setAttribute(''style'', ''background-color:#f7f7f7'')\n},\nbeforeDestroy() {\n  document.querySelector(''body'').removeAttribute(''style'')\n}\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(73,'背景属性(background)','| Property              | 描述                                         |\n| :-------------------- | :------------------------------------------- |\n| background            | 简写属性，作用是将背景属性设置在一个声明中。 |\n| background-attachment | 背景图像是否固定或者随着页面的其余部分滚动。 |\n| background-color      | 设置元素的背景颜色。                         |\n| background-image      | 把图像设置为背景。                           |\n| background-position   | 设置背景图像的起始位置。                     |\n| background-repeat     | 设置背景图像是否及如何重复。                 |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(74,'元素隐藏','```css\n/**这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在；**/\nvisibility: hidden; \n/**属性，设置0可以使一个元素完全透明；**/\nopacity: 0;CSS3\n/**设置一个很大的 left 负值定位，使元素定位在可见区域之外；**/\nposition: absolute; \n/**元素会变得不可见，并且不会再占用文档的空间；**/\ndisplay: none; \n/**将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留；**/\ntransform: scale(0); \n```\n\n\n\n\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(75,'虚线效果','```css\n.dotted-line{\n    border: 1px dashed transparent;\n    background: linear-gradient(white,white) padding-box, repeating-linear-gradient(-45deg,#ccc 0, #ccc .25em,white 0,white .75em);\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(76,'文本超出省略号','**单行文本**\n\n```css\n.single-ellipsis{\n  width: 500px;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n}\n```\n\n**多行文本**\n\n```css\n.multiline-ellipsis {\n  display: -webkit-box;\n  word-break: break-all;\n  -webkit-box-orient: vertical;\n  -webkit-line-clamp: 4; //需要显示的行数\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(77,'自动打字','```html\n<div class=\"bruce flex-ct-x\">\n    <div class=\"auto-typing\">Do You Want To Know More About CSS Development Skill</div>\n</div>\n```\n\n```css\n@mixin typing($count: 0, $duration: 0, $delay: 0) {\n    overflow: hidden;\n    border-right: 1px solid transparent;\n    width: #{$count + 1}ch;\n    font-family: Consolas, Monaco, Monospace;\n    white-space: nowrap;\n    animation: typing #{$duration}s steps($count + 1) #{$delay}s backwards, caret 500ms steps(1) #{$delay}s $duration * 2 forwards;\n}\n.auto-typing {\n    font-weight: bold;\n    font-size: 30px;\n    color: #09f;\n    @include typing(52, 5);\n}\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n@keyframes caret {\n    50% {\n        border-right-color: currentColor;\n    }\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(78,'渐变色文字','```css\n<h2 class=\"gradient-text\">Gradient text</h2>\n<style>\n.gradient-text {\n  background-image: linear-gradient(90deg, red, blue);\n  background-clip: text;\n  color: transparent;\n}\n</style>\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(79,'清除overflow的滚动条','```css\n.div{\n  overflow: auto\n}\n\n.div::-webkit-scrollbar{\n    display: none;\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(80,'字体属性','CSS使用font-family属性定义文本的字体系列。\n\n```css\np { font-family:\"微软雅黑\";}\ndiv {font-family:Arial,\"Microsoft Yahei\",\"微软雅黑\"；}\n```\n\n注意：\n\n- 各种字体之间必须使用英文状态下的逗号隔开。\n- 一般情况下，如果有空格隔开的多个单词组成的字体，加引号。\n- 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示。\n- 最常见的几个字体：\n\n```css\nbody {font-family:\"Microdoft Yahei\",tohoma,arial,\"Hiyayinosan GB\";}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(81,'字体大小','CSS使用font-size属性定义字体大小\n\n```css\np {font-size:20px;}\n```\n\n注意：\n\n- px（像素）大小是我们网页最常用的单位。\n- 谷歌浏览器默认的文字大小为16px。\n- 不同浏览器可能默认显示的字号大小不一致，我们尽量给一个明确值大小，不要默认大小。\n- 可以给body指定整个页面文字的大小',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(82,'字体粗细','CSS使用font-weight属性设置文字字体的粗细。\n\n```css\np {font-weight:normal\\body\\bolder\\light\\number;}\n```\n\n参数：\n\n| normal | 正常字体（相当于number=400）              |\n| ------ | ----------------------------------------- |\n| bold   | 粗体（相当于number=700）                  |\n| bolder | 特粗体（IF5+）                            |\n| light  | 细体（IF5+）                              |\n| number | 100/200/300/400/500/600/700/800/900(IF5+) |\n\nnumber语法：\n\n```css\np {font-weight:400;}\n```\n\n注意：\n\n- 学会加粗标签（比如h和strong等）不加粗，或者其他标签加粗\n- 实际开发时，我们更喜欢用字表示粗细。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(83,'文字模式','CSS使用font-style属性设置文本的网络。\n\n```css\np { font-style: normal; }\n```\n\n| 属性值 | 作用                                                 |\n| ------ | ---------------------------------------------------- |\n| normal | 默认值，浏览器会显示标准的字体样式 font-size：normal |\n| italic | 浏览器会显示斜体的字体样式                           |\n\n注意：平时我们很少给文字加斜体，反而要给斜体标签（em，；）改为不斜体字体。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(84,'字体的复合属性','```css\nbody { font-style font-weight font-size/line-height font-family;}\n```\n\n注意：\n\n- 使用font属性时，必须按上面的语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开。\n- 不需要设置的属性可以忽略（取默认值），但必须保留 font-size和font-family属性，否则font属性将不起作用。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(85,'文本属性','color属性用于定义文本的颜色\n\n```css\ndiv {\ncolor:red;\n    }\n```\n\n注意：开发中最常用的时十六进制。\n\n| 表示           | 属性值                          |\n| -------------- | ------------------------------- |\n| 预定义的颜色值 | red，green，blue，pink          |\n| 十六进制       | #FF0000，#FF6600，#FF29D794     |\n| RGB代码        | rgb（255,0,0）或rgb(100%,0%,0%) |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(86,'文本对齐','text-align属性用于设置元素内文本内容的水平对齐方式。\n\n```css\ndiv {\ntext-align:center;\n}\n```\n\n| 属性值 | 解释             |\n| ------ | ---------------- |\n| left   | 左对齐（默认值） |\n| right  | 右对齐           |\n| center | 居中对齐         |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(87,'文本装饰','text-decoration属性规定添加到文本的修饰，可以给文本添加下划线、删除线、上划线等。\n\n```css\ndiv {\ntext-decoration:underline;\n}\n```\n\n| 属性值       | 解释                            |\n| ------------ | ------------------------------- |\n| none         | 默认，没有装饰线（最常用）      |\n| underline    | 下划线：链接a自带下划线（常用） |\n| overline     | 上划线（几乎不用）              |\n| line-through | 删除线（不常用）                |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(88,'文本缩进','text-indent属性用来指定文本的第一行的缩进，通常是将段落的首行缩进。\n\n```css\ndiv {\ntext-indent:10px/2em;\n}\n```\n\n*:2em代表2个字符',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(89,'行间距','line-height属性用于设置行间的距离（行高），可以控制文本的行与行之间的距离。\n\n```css\np { line-height: 26px;}\n```\n\n**:用Faststone chature 软件的标尺测量上一行的行底与下一行的行底之间的距离。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(90,'文本转换','文本转换属性是用来指定在一个文本中的大写和小写字母。\n可用于所有字句变成大写或小写字母，或每个单词的首字母大写。\n```css\np.uppercase {text-transform:uppercase;}\np.lowercase {text-transform:lowercase;} \np.capitalize {text-transform:capitalize;}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(91,'CSS常用片段','```css\n/* 字体颜色 */\n  color: #888888;\n/* 字体粗细 */\n  font-weight: 400;\n/* 字体大小 */\n  font-size: 14px;\n/* 文字居中 */\n  text-align: center;\n/* 字体行内居中 */\n  line-height: 45px;\n /*字体加深*/\n text-shadow: 0 0 1px rgba(0,0,0,.3);\n /*起始段落空2格*/\n text-indent: 2em;\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(92,'描绘波浪线','```html\n<div class=\"bruce flex-ct-x\">\n    <p class=\"waveline-text\">波浪线文字</p>\n</div>\n```\n\n```css\n@mixin waveline($h, $color: #f66) {\n    position: relative;\n    &::after {\n        position: absolute;\n        left: 0;\n        top: 100%;\n        width: 100%;\n        height: $h;\n        background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%), linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);\n        background-size: $h * 2 $h * 2;\n        content: \"\";\n    }\n}\n.waveline-text {\n    height: 20px;\n    line-height: 20px;\n    letter-spacing: 10px;\n    @include waveline(10px);\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(93,'下划线跟随','```html\n<div class=\"bruce flex-ct-x\">\n    <ul class=\"underline-navbar\">\n        <li>11111</li>\n        <li>22222</li>\n        <li>33333</li>\n    </ul>\n</div>\n```\n\n```css\n.underline-navbar {\n    display: flex;\n    li {\n        position: relative;\n        padding: 10px;\n        cursor: pointer;\n        font-size: 20px;\n        color: #09f;\n        transition: all 300ms;\n        &::before {\n            position: absolute;\n            left: 100%;\n            top: 0;\n            border-bottom: 2px solid transparent;\n            width: 0;\n            height: 100%;\n            content: \"\";\n            transition: all 300ms;\n        }\n        &:active {\n            background-color: #09f;\n            color: #fff;\n        }\n        &:hover {\n            &::before {\n                left: 0;\n                top: 0;\n                z-index: -1;\n                border-bottom-color: #09f;\n                width: 100%;\n                transition-delay: 100ms;\n            }\n            & + li::before {\n                left: 0;\n            }\n        }\n    }\n}\n```\n\n\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(94,'透明opacity','### 透明opacity\n\n```css\n opacity: 0.9;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(95,'水平垂直居中','**HTML结构如下**\n\n```html\n<div class=\"parent\">\n    <div class=\"child\"></div>\n</div>\n```\n\n#### 使用Flex布局\n\n```css\n.parent {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\nFlex布局是我日常使用过程中使用最频繁的一种方案，通过很简单的几行代码就可以实现我们想要的布局。\n\n#### 绝对定位\n\n```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    /* top和left是以左上角为坐标原点 */\n    top: 50%;\n    left: 50%;\n    /* transform：translate的属性值为百分数时，是以元素自身为参考 */\n    transform: translate(-50%,-50%);\n}\n\n/* 或者 */\n.child {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n```\n\n值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。\n\n#### Flex的另一种方法\n\n```css\n.parent {\n    display: flex;\n}\n.child {\n    margin: auto;\n}\n```\n\n#### Grid布局\n\n```css\n.parent {\n    display: grid;\n}\n.child {\n    justify-self: center;\n    align-self: center;\n}\n```\n\nGrid布局也是比较常用的一种方法，一般用在构建整体布局的时候用到的比较多。它有固定和灵活的尺寸，还可以通过名称或网格线把目标放置在指定的位置。\n\n#### Table布局\n\n```css\n.parent {\n    display: table;\n}\n.child {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(96,'内部样式表','内部样式表是写到html页面内部，是将所有的CSS代码抽取出来，单独放到一个style标签中。\n\n```css\n<style>\n     div{\n         color:red;\n         font-size: 12px;\n         }\n</style>\n```\n\n- 标签理论上可放在HTML文档的任何地方，但一般会放在文档的head标签中\n- 通过此种方式，可以方便控制当前整个页面中的元素样式设置。\n- 代码结构清晰，但是并没有实现结构与样式完全分离。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(97,'边框样式','边框样式属性指定要显示什么样的边界。\n\nborder-style属性用来定义边框的样式\nnone: 默认无边框\ndotted: 定义一个点线边框\ndashed: 定义一个虚线边框\nsolid: 定义实线边框\ndouble: 定义两个边框。 两个边框的宽度和 border-width 的值相同\ngroove: 定义3D沟槽边框。效果取决于边框的颜色值\nridge: 定义3D脊边框。效果取决于边框的颜色值\ninset:定义一个3D的嵌入边框。效果取决于边框的颜色值\noutset: 定义一个3D突出边框。 效果取决于边框的颜色值\n\n```css\n/* 样式 1px */\nborder-style: ridge;\n```',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(98,'边框宽度','通过 border-width 属性为边框指定宽度。\n\n为边框指定宽度有两种方法：可以指定长度值，比如 2px 或 0.1em(单位为 px, pt, cm, em 等)，或者使用 3 个关键字之一，它们分别是 thick 、medium（默认值） 和 thin。\n\n**注意：**CSS 没有定义 3 个关键字的具体宽度，所以一个用户可能把 thick 、medium 和 thin 分别设置为等于 5px、3px 和 2px，而另一个用户则分别设置为 3px、2px 和 1px。\n\n```css\np.one {    \nborder-style:solid; \nborder-width:5px; \n}\np.two {   \nborder-style:solid;   \nborder-width:medium;\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(99,'边框颜色','border-color属性用于设置边框的颜色。\n\n您还可以设置边框的颜色为\"transparent\"。\n**注意：** border-color单独使用是不起作用的，必须得先使用border-style来设置边框样式。\n\n```css\n/* 边框宽度1px 样式 颜色 */\n  border: 1px solid #868686;\n\np.one {  \nborder-style:solid; \nborder-color:red; \n}\np.two {  \nborder-style:solid; \nborder-color:#98bf21;\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(100,'单独设置各边(border)','border-style属性有1-4个值：\n- border-style:dotted solid double dashed;\n  - 上边框 dotted\n  - 右边框 solid\n  - 底边框 double\n  - 左边框 dashed\n- border-style:dotted solid double;\n  - 上边框 dotted\n  - 左、右边框 solid\n  - 底边框 double\n\n可以指定不同的侧面不同的边框：\n\n```css\n/* 上下左右 */\nborder-top-style:dotted; \nborder-right-style:solid;  \nborder-bottom-style:dotted; \nborder-left-style:solid; \n\n/* 多属性 */\nborder-bottom: 1px solid #edeef0;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(101,'边框边角弧度','```css\nborder-radius: 5px;\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(102,'边框的斜线语法','```css\n.border-radius {\n  border-radius: 50px 25px / 25px 50px;\n}\n```',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(103,'实线边框','```css\n-webkit-box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n box-shadow: 0 1px 3px rgba(0,0,0,.12), 0 1px 2px rgba(0,0,0,.24);\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(104,'悬停放大图片特效','```css\n.img-wrapper img {\n  -webkit-transition: 0.3s linear;\n  transition: 0.3s linear;\n}\n\n.img-wrapper img:hover {\n  transform: scale(1.1);\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(105,'定位(position)','position 属性指定了元素的定位类型。\n\nposition 属性的五个值：\n\nstatic, relative, fixed, absolute, sticky',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(106,'static定位','HTML 元素的默认值，即没有定位，遵循正常的文档流对象。\n\n静态定位的元素不会受到 top, bottom, left, right影响。\n\n```css\ndiv.static {    \nposition: static;   \nborder: 3px solid #73AD21; \n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(107,'fixed定位','元素的位置相对于浏览器窗口是固定位置。\n\n即使窗口是滚动的它也不会移动：\n\n```css\np.pos_fixed {   \nposition:fixed;   \ntop:30px;   \nright:5px; \n}\n```\n\n**注意：** Fixed 定位在 IE7 和 IE8 下需要描述 !DOCTYPE 才能支持。\n\nFixed定位使元素的位置与文档流无关，因此不占据空间。\n\nFixed定位的元素和其他元素重叠。',8,77,124,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(108,'relative定位','相对定位元素的定位是相对其正常位置。\n\n```css\nh2.pos_left {   \nposition:relative; \nleft:-20px; \n} \nh2.pos_right {\nposition:relative; \nleft:20px; \n}\n```\n\n移动相对定位元素，但它原本所占的空间不会改变。\n\n```css\nh2.pos_top { \nposition:relative;  \ntop:-50px;\n}\n```\n\n相对定位元素经常被用来作为绝对定位元素的容器块。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(109,'absolute定位','绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html\n\n```css\nh2 {   \nposition:absolute;  \nleft:100px;  \ntop:150px; \n}\n```\n\nabsolute 定位使元素的位置与文档流无关，因此不占据空间。\n\nabsolute 定位的元素和其他元素重叠。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(110,'sticky定位','sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。\n\n**position: sticky;** 基于用户的滚动位置来定位。\n\n粘性定位的元素是依赖于用户的滚动，在 **position:relative** 与 **position:fixed** 定位之间切换。\n\n它的行为就像 **position:relative;** 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。\n\n元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。\n\n这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。\n\n**注意:** Internet Explorer, Edge 15 及更早 IE 版本不支持 sticky 定位。 Safari 需要使用 -webkit- prefix (查看以下实例)。\n\n```css\ndiv.sticky {   \nposition: -webkit-sticky; /* Safari */  \nposition: sticky; \ntop: 0;  \nbackground-color: green;   \nborder: 2px solid #4CAF50; \n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(111,'重叠的元素','元素的定位与文档流无关，所以它们可以覆盖页面上的其它元素\n\nz-index属性指定了一个元素的堆叠顺序（哪个元素应该放在前面，或后面）\n\n一个元素可以有正数或负数的堆叠顺序：\n\n```css\nimg {    \nposition:absolute; \nleft:0px;   \ntop:0px;  \nz-index:-1;\n}\n```\n\n具有更高堆叠顺序的元素总是在较低的堆叠顺序元素的前面。\n\n**注意：** 如果两个定位元素重叠，没有指定z - index，最后定位在HTML代码中的元素将被显示在最前面。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(112,'定位属性','\"CSS\" 列中的数字表示哪个CSS(CSS1 或者CSS2)版本定义了该属性。\n\n| 属性       | 说明                                                         | 值                                                           | CSS  |\n| :--------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--- |\n| bottom     | 定义了定位元素下外边距边界与其包含块下边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| clip       | 剪辑一个绝对定位的元素                                       | *shape *auto inherit                                         | 2    |\n| cursor     | 显示光标移动到指定的类型                                     | *url* auto crosshair default pointer move e-resize ne-resize nw-resize n-resize se-resize sw-resize s-resize w-resize text wait help | 2    |\n| left       | 定义了定位元素左外边距边界与其包含块左边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| overflow   | 设置当元素的内容溢出其区域时发生的事情。                     | auto hidden scroll visible inherit                           | 2    |\n| overflow-y | 指定如何处理顶部/底部边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| overflow-x | 指定如何处理右边/左边边缘的内容溢出元素的内容区域            | auto hidden scroll visible no-display no-content             | 2    |\n| position   | 指定元素的定位类型                                           | absolute fixed relative static inherit                       | 2    |\n| right      | 定义了定位元素右外边距边界与其包含块右边界之间的偏移。       | auto *length % *inherit                                      | 2    |\n| top        | 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。 | auto *length % *inherit                                      | 2    |\n| z-index    | 设置元素的堆叠顺序                                           | *number *auto inherit                                        | 2    |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(113,'定位示例','#### 元素固定\n\n```css\n@media (min-height: 500px) {\n    .site-header {\n        position: sticky;\n        top: 0;\n        /*other styles*/\n    }\n}\n```\n\n#### 居中定位\n\n示例1\n\n```c#\n   position: absolute;\n    width: 50%;\n    height: 80%;\n    overflow: auto;\n    margin: auto;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n```\n\n示例2\n\n```css\n.tag_search {\n\n  @apply relative;\n  height: 50px;\n\n  div {\n    @apply absolute top-1/2 left-1/2;\n    width: 40%;\n    transform: translate(-50%, -50%);\n  }\n}\n```\n\n示例3\n\n@apply居中\n\n```css\n  // 居中\n  @apply top-1/2 left-1/2 absolute;\n  transform: translate(-50%, -50%);\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(114,'全局片段','## 全局片段\n\n在vscode中可以生成一个代码片段，方便快速生成。\n\n1. 复制自己需要生成代码片段的代码；\n2. [snippet-generator.app/](https://link.juejin.cn?target=https%3A%2F%2Fsnippet-generator.app%2F) 在网站中生成代码片段；\n3. 在vscode中配置代码片段；\n\n### 配置\n\n设置 - 用户代码片段 - - 粘贴生成的代码片段\n\n1. 可以直接打开现有代码片段\n2. 可以选择创建全局代码片段\n3. 可以选择创建当前文件夹的代码片段',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(116,'Code Spell Checker','检测你写代码时拼写的单词是否正确。\n\n#### 安装方法\n\n1. 在应用商店中搜索Code Spell Checker。\n2. 点击安装，等待安装完成，然后重启VSCode。\n\n#### Add Word to Workspace Dictionaries\n\n（向工作区词典添加单词）\n\n选中要添加的单词–>右击鼠标–>点击这个Add Word to Workspace Dictionaries，这样下次在拼写这个单词的时候便不会出现波浪线的提示。\n\n#### Add Word to User Dictionary\n\n（将单词添加到用户词典）\n操作步骤如上，只需要选中不同的Add Word to User Dictionary功能即可。\n\n#### Ignore Word\n\n（忽略单词）\n\n操作步骤如上，只需要选中不同的Ignore Word功能即可。\n\n\n#### 删除单词解决方案：\n\nAdd Word to Workspace Dictionaries，这就是意味着添加进来了工作区词典，而在VSCode中创建项目时，系统会给我们生成一个.vscode的文件夹，修改settings.json即可\n\n\n\n\nAdd Word to User Dictionary，这就需要我们再我们再VSCode的系统设置中修改。\n\n设置–>用户–>扩展–>找到安装的Code Spell Checker–>打开settings.json，在其中找到图6的内容，在其中修改添加错的单词，我在其中添加的是bindblur单词。\n\n Ignore Word，方法和第一个一样，因为都是在.vscode中的setting.json文件中。\n\n\n#### 总结\n\nAdd Word to Workspace Dictionaries和Ignore Word仅是将word添加到该项目中，如果再新建一个项目以前添加的word将不再在新项目中生效，而Add Word to User Dictionary是将word添加到VSCode的系统中，所以即是新建一个项目也不会提示有波浪线。',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(117,'Code Runner','可以让你在 `vscode` 里方便的运行某个文件或者运行选取的某段代码。\n### Bracket Pair Colorizer 2\n\n- 给你的括号用颜色标记一下，这样当你的函数块里面有很多嵌套，就比较容易理清楚。\n\n### Debugger for Chrome\n\n- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？\n- [在 vscode 中调试 vue](',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(118,'Debugger for Chrome','### Debugger for Chrome\n\n- 我们知道可以在 `chrome` 浏览器中利用开发者工具打断点调试，那么如何在 `vscode` 进行 `debugger` 调试？\n- [在 vscode 中调试 vue',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(119,'ESLint','- 代码检查及错误提示。\n- 结合 Prettier 插件可以让我们快速格式化代码。',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(120,'Prettier','- 格式化代码，规范代码风格。',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(121,'字符串转整数类型','将字符串转换为整数类型。为了方便，C#提供了一个内置的方法`TryParse`来实现这个功能\n\n###  TryParse\n\n`TryParse`方法是一个静态方法，可以直接通过类名调用。它的代码结构如下：\n\n```csharp\npublic static bool TryParse(string s, out Int32 i);\n```\n\n示例代码\n\n转换成功返回true,否则返回false\n\n```csharp\n//参数：s是要转换的字符，i是转换的结果。执行成功返回true，输出转换成功的值；执行失败返回0\nint.TryParse(string s,out int i)\n```\n\n',1,113,561,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(123,'命名规范','* Pascal法：首字母大写，连接词的首字母也都大写 → GetInfo\n* Camel：第一个单词的首字母小写 → getInfo\n* MENTIONS:\n\n1. 成员变量最好加一个“_”\n2. 接口的名称前加前缀“*I*”',1,156,234,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(124,'代码编写规则','- 尽量使用接口\n- 局部变量尽量在最接近的地方使用\n- 不要使用goto系列语句（除非是在跳出深层循环时）\n- 构建和构建一个长的字符串时，一定要使用**StringBuilder**类型\n- switch语句要有**default**来处理意外情况',1,156,810,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(125,'问号的演变','表示左边的变量如果为null则值为右边的变量，否则就是左边的变量值\n\n```c#\nstring a = null;\nvar b = a??””;\n```\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(126,'类型实例化','```c#\npublic class Abc\n{\n    public int ID {get; set; }\n    public string Name { get; set; }\n}\n\npublic static void Main(string[] args)\n{\n  var abc = new Abc\n  {\n    ID = 1,\n    Name = \"yukaizhao\",\n  };\n}\n```\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(127,'匿名类','匿名类在linq to sql或者entity framework中返回查询数据时很好用。\n\n```csharp\nvar a = new {\n    ID = 1,\n    Name=”yukaizhao”,\n};\n```\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(128,'NULL条件运算符','Null 条件运算符（?.）和空合并运算符（??）是用于处理可能为空的对象的特殊运算符\n\n- Null 条件运算符（?.）用于在访问对象的属性或调用对象的方法之前，先检查对象是否为空。如果对象为空，运算符将返回 null，否则将继续执行后续操作。\n- 空合并运算符（??）用于在对象为空时提供一个默认值。如果对象为空，运算符将返回默认值，否则将返回对象本身。\n\n```csharp\n// 使用 Null 条件运算符\nCustomer customer = new Customer();\nstring name = customer?.Name;\n\n// 编译代码\nCustomer customer = new Customer();\nif (customer != null)\n{\n    string name = customer.Name;\n}\n\n// 使用 Null 条件运算符和空合并运算符的组合\nif (customer?.Face() ?? false)\n{\n    // 执行操作\n}\n\n// 使用多个 Null 条件运算符和空合并运算符的组合\nint? contactNameLen = contact?.Name?.Length;\n```\n\n在对象使用前检查是否为null。如对象空，则赋值给变量为空值，所以例子中需要一个为空的int类型、即int?。如果对象不为空，则调用对象的成员取值，并赋值给变量。',1,136,557,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(129,'字符串格式化','### string.Format\n\n通过在字符串中使用占位符`{0}`，`{1}`等，我们可以指定要插入的变量的位置。然后，通过在`string.Format`方法的参数中提供相应的变量值，我们可以将这些值插入到字符串中\n\n```csharp\nvar contactInfo = string.Format(\"Id:{0} Name:{1} EmailAddr:{2} PhoneNum:{3}\", \ncontact.Id, contact.Name, contact.EmailAddress, contact.PhoneNum);\n```\n\n### 新语法格式化\n\n使用了字符串插值的新语法。在字符串前面加上`$`符号，我们可以直接在字符串中插入变量的值，而无需使用占位符。变量的值将在字符串中用花括号`{}`括起来\n\n```csharp\nvar contactInfo2 = $\"Id:{contact.Id} Name:{contact.Name} EmailAddr:\n{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n\n字符串插值的更高级用法。在这个示例中，我们使用了条件表达式来检查联系人姓名的长度。如果姓名的长度为0，则将默认值\"Frank\"插入到字符串中，否则将插入实际的姓名\n\n```csharp\nvar contactInfo = $\"Id:{contact.Id} Name:{(contact.Name.Length == 0 ? \"Frank\" : \ncontact.Name)} EmailAddr:{contact.EmailAddress} PhoneNum:{contact.PhoneNum}\";\n```\n\n',1,113,560,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(130,'绑定图片属性','```html\n<img v-bind:src=\"imgUrl\"/>\n```\n',2,3,463,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(131,'动态属性绑定','在某些情况下，我们属性的名称可能也不是固定的：\n如果属性名称不是固定的，我们可以使用 `:[属性名]=''值''` 的格式来定义\n这种绑定的方式，我们称之为动态绑定属性；\n```js\nconst objectOfAttrs = {\n  id: ''container'',\n  class: ''wrapper''\n}\n//通过不带参数的 v-bind，你可以将它们绑定到单个元素上：\n<div v-bind=\"objectOfAttrs\"></div>\n```\n\n\n',2,3,405,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(132,'绑定style对象语法','```js\n:style=\"包含css样式的对象\"\n:style=\"{属性名: ''属性值''}\"\n```\n\n​      1 {color: ''red''} 这里需要注意属性值必须添加'''', 如果没有引号会将red当做变量去数据中寻找\n\n​      2 { fontSize: ''24px''} ,这里也可以写成烤串命名法，但是需要用''''包起来，否则会报错\n\n​      3 {fontSize: `${finalFontSize}px`} 也可以写成字符串拼接\n\n​      4 :style=\"finalStyleObj\" 也可以直接绑定对象\n\n​      5  也可以写在方法或者计算属性中\n\n```js\n  <!-- <h2 :style=\"{key(属性名):value(属性值)}\">{{massage}}</h2> -->\n  <!-- 这里要加'' ''要不然vue会去解析50px这个变量然后报错 -->\n  :style=\"{fontSize: ''50px''}\">{{massage}}\n  <!-- finalSize当成一个变量在使用 -->\n  :style=\"{fontSize: finalSize}\">{{massage}}\n  <!-- 也可以拼接 -->\n   :style=\"{fontSize: finalSize + ''px'',color:finalColor}\">{{massage}}\n  <!-- 数组语法 -->\n  :style=\"[baseStyle,baseStyle1]\">{{massage}}\n\nconst app = new Vue({\n	el: \"#app\",\n	data: {	\n        finalSize: 100,\n        finalColor: ''red'',\n        baseStyle:{color:''red''},\n        baseStyle1:{fontSize:''75px''}\n		}})\n\n```\n\n2\n\n```vue\n<div :style=\"{color: ''red''}\">绑定style对象语法</div>\n<div :style=\"{color: ''red'', fontSize: ''24px''}\">绑定style对象语法</div>\n<div :style=\"{color: ''red'', ''font-size'': ''24px''}\">绑定style对象语法</div>\n<div :style=\"{fontSize: `${finalFontSize}px`}\">绑定style对象语法</div>\n<div :style=\"finalStyleObj\">绑定style对象语法</div>\n\n<script>\n  let App = {\n    template: ''#my-app'',\n    data() {\n      return {\n        finalFontSize: 50,\n        finalStyleObj: {\n          fontSize: ''40px'',\n          color: ''red'',\n          background: ''blue'',\n        },\n      };\n    },\n  };\n  Vue.createApp(App).mount(''#app'');\n</script>\n```\n\n',2,3,405,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(133,'JavaScript表达式','```js\n{{ number + 1 }}\n{{ ok ? ''YES'' : ''NO'' }}\n{{ message.split('''').reverse().join('''') }\n<div :id=\"`list-${id}`\"></div>\n```\n\n这些表达式都会被作为 JavaScript ，以组件为作用域解析执行。\n\n在 vue 模板内，JavaScript 表达式可以被使用在如下场景上：\n\n- 在文本插值中 (双大括号)\n- 在任何 Vue 指令 (以 `v-` 开头的特殊 attribute) attribute 的值中',2,3,589,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(134,'使用v-bind调用函数','可以在绑定的表达式中使用一个组件暴露的方法：\n```html\n<span :title=\"toTitleDate(date)\">\n  {{ formatDate(date) }}\n</span>\n```\n\n',2,3,405,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(135,'内联事件处理器','内联事件处理器，通常用于简单场景，例如：\n\n```js\nconst count = ref(0)\n```\n```js\n<button @click=\"count++\">Add 1</button>\n<p>Count is: {{ count }}</p>\n```\n\n',2,3,115,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(136,'方法事件处理器','`v-on` 也可以接受一个方法名或对某个方法的调用。\n\n```js\nconst name = ref(''Vue.js'')\n\nfunction greet(event) {\n  alert(`Hello ${name.value}!`)\n  // `event` 是 DOM 原生事件\n  if (event) {\n    alert(event.target.tagName)\n  }\n}\n<!-- `greet` 是上面定义过的方法名 -->\n<button @click=\"greet\">Greet</button>\n```\n\n通过被触发事件的 `event.target.tagName` 访问到该 DOM 元素。',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(137,'内联处理器中调用方法','除了直接绑定方法名，你还可以在内联事件处理器中调用方法。这允许我们向方法传入自定义参数以代替原生事件：\n\n```js\nfunction say(message) {\n  alert(message)\n}\n<button @click=\"say(''hello'')\">Say hello</button>\n<button @click=\"say(''bye'')\">Say bye</button>\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(138,'内联事件处理器中访问事件参数','有时需要在内联事件处理器中访问原生 DOM 事件。可以向该处理器方法传入一个特殊的 `$event` 变量，或者使用内联箭头函数：\n```js\nfunction warn(message, event) {\n  // `这里可以访问 DOM 原生事件`\n  if (event) {\n    event.preventDefault()\n  }\n  alert(message)\n}\n```\n```html\n<!-- 使用特殊的 $event 变量 -->\n<button @click=\"warn(''Form cannot be submitted yet.'', $event)\">\n  Submit\n</button>\n\n<!-- 使用内联箭头函数 -->\n<button @click=\"(event) => warn(''Form cannot be submitted yet.'', event)\">\n  Submit\n</button>\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(139,'多事件处理器','事件处理程序中可以有多个方法，这些方法由逗号运算符分隔：\n\n```html\n<button @click=\"one($event), two($event)\">Submit</button>\n```\n\n```js\n  one(event) {\n    // 第一个事件处理器逻辑...\n  },\n  two(event) {\n   // 第二个事件处理器逻辑...\n  }\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(140,'事件修饰符','在处理事件时调用 `event.preventDefault()` 或 `event.stopPropagation()` 是很常见的。尽管我们可以直接在方法内调用，但如果方法能更专注于数据逻辑而不用去处理 DOM 事件的细节会更好。\n\n- `.stop`：阻止事件冒泡。阻止事件向上级 DOM 元素传递。\n- `.prevent`：阻止默认事件。默认事件，指对 DOM 的操作会引起自动执行的动作。比如，点击超链接的时候会进行页面的跳转，点击表单提交按钮时会重新加载页面等。\n- `.capture`：使用事件的捕获模式。使事件触发，从包含这个元素的顶层，开始往下触发。\n- `.self`：只有 event.target 是当前操作的元素时，才触发事件。\n- `.once`：事件只触发一次。\n- `.passive`：事件的默认行为立即执行，无需等待事件回调执行完毕。\n```html\n<!-- 单击事件将停止传递 -->\n<a @click.stop=\"doThis\"></a>\n<!-- 提交事件将不再重新加载页面 -->\n<form @submit.prevent=\"onSubmit\"></form>\n<!-- 修饰语可以使用链式书写 -->\n<a @click.stop.prevent=\"doThat\"></a>\n<!-- 也可以只有修饰符 -->\n<form @submit.prevent></form>\n<!-- 添加事件监听器时使用事件捕获模式 -->\n<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->\n<div v-on:click.capture=\"doThis\">...</div>\n<!-- 仅当 event.target 是元素本身时才会触发事件处理器 -->\n<!-- 例如：事件处理器不来自子元素 -->\n<div @click.self=\"doThat\">...</div>\n<!-- 点击事件将只会触发一次 -->\n<a v-on:click.once=\"doThis\"></a\n    <!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n```\n',2,3,115,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(141,'按键修饰符','在监听键盘事件时，我们经常需要检查特定的按键。Vue 允许在 `v-on` 或 `@` 监听按键事件时添加按键修饰符。\n\n```html\n<!-- 仅在 `key` 为 `Enter` 时调用 `vm.submit()` -->\n<input @keyup.enter=\"submit\" />\n\n<!--仅会在 $event.key 为 ''PageDown'' 时调用事件处理。 -->\n<input @keyup.page-down=\"onPageDown\" />\n```\n\nVue 为最常用的键提供了别名：\n\n- `.enter`\n- `.tab`\n- `.delete`(捕获“删除”和“退格”键)\n- `.esc`\n- `.space`\n- `.up`\n- `.down`\n- `.left`\n- `.right`',2,3,115,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(142,'.exact修饰符','\n修饰符允许你控制由精确的系统修饰符组合触发的事件\n```html\n<!-- 即使 Alt 或 Shift 被一同按下时也会触发 -->\n<button v-on:click.ctrl=\"onClick\">A</button>\n<!-- 有且只有 Ctrl 被按下的时候才触发 -->\n<button v-on:click.ctrl.exact=\"onCtrlClick\">A</button>\n<!-- 没有任何系统修饰符被按下的时候才触发 -->\n<button v-on:click.exact=\"onClick\">A</button>\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(143,'系统按键修饰符','你可以使用以下系统按键修饰符来触发鼠标或键盘事件监听器，只有当按键被按下时才会触发。\n- `.ctrl`\n- `.alt`\n- `.shift`\n- `.meta`\n\n```html\n<!-- Alt + Enter -->\n<input @keyup.alt.enter=\"clear\" />\n<!-- Ctrl + 点击 -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(144,'事件处理器标注类型','在处理原生 DOM 事件时，应该为我们传递给事件处理器的参数正确地标注类型\n\n```js\nfunction handleChange(event) {\n  // `event` 隐式地标注为 `any` 类型\n  console.log(event.target.value)\n}\n```\n\n```html\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个 `event` 参数会隐式地标注为 `any` 类型。这也会在 `tsconfig.json` 中配置了 `\"strict\": true` 或 `\"noImplicitAny\": true` 时报出一个 TS 错误。因此，建议显式地为事件处理器的参数标注类型。此外，你可能需要显式地强制转换 `event` 上的 property：\n\n```js\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n```\n',2,3,115,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(145,'vue项目目录对照','``` bash\n.\n├── vue.config.js/                      # webpack 配置文件；\n├── config/                     # 与项目构建相关的常用的配置选项；\n│   ├── index.js                # 主配置文件\n│   ├── dev.env.js              # 开发环境变量\n│   ├── prod.env.js             # 生产环境变量\n│   └── test.env.js             # 测试环境变量\n│\n├── src/\n│   ├── main.js                 # 的入口文件；\n│   ├── assets/                 # 共用的代码以外的资源，如：图片、图标、视频 等；\n│   ├── api/                    # 网络模块，如：接口；\n│   ├── router/                 # 路由模块\n│   ├── I18n/                   # 国际化模块\n│   ├── pages/                  # 单页页面\n│   ├── vuex/                   # 组件共享状态\n│   ├── components/             # 共用的组件；； 这里的存放的组件应该都是展示组件\n│   │   ├── base/               # 基本组件，如：共用的弹窗组件，loading加载组件，提示组件。\n│   │   ├── common/             # 共用的全局组件，封装的导航条，底部组件等等\n│   │   ├── temp/               # 模板组件，如：相同的页面封装成一个组件。\n│   │   ├── UItemp/             # UI组件，如：项目中特定的按钮，消息数字，等等一些样式可以封装成组件的。\n│   ├── common/                 # 共用的资源，如：常用的图片、图标，共用的组件、模块、样式，常量文件等等；\n│   │   ├── compatible/         # 兼容模块，如：适合App和微信各种接口的模块；\n│   │   ├── extension/          # 已有类的扩展模块，如：对 Array 类型进行扩展的模块；\n│   │   ├── libraries/          # 存放自己封装的或者引用的库；\n│   │   ├── tools/              # 自己封装的一些工具\n│   │   ├── constant.js         # 存放js的常量；\n│   │   ├── constant.scss       # 存放scss的常量；\n│   │   └── ...\n│   └── app/                    # 存放项目业务代码；\n│       ├── App.vue             # app 的根组件；\n├── public/                     # 纯静态资源，该目录下的文件不会被webpack处理，该目录会被拷贝到输出目录下；\n├── .babelrc                    # babel 的配置文件\n├── .editorconfig               # 编辑器的配置文件；可配置如缩进、空格、制表类似的参数；\n├── .eslintrc.js                # eslint 的配置文件\n├── .eslintignore               # eslint 的忽略规则\n├── .gitignore                  # git的忽略配置文件\n├── .postcssrc.js               # postcss 的配置文件\n├── CHAGNELOG.md                # 版本更新变更release\n├── index.html                  # HTML模板\n├── package.json                # npm包配置文件，里面定义了项目的npm脚本，依赖包等信息\n└── README.md                   # 项目信息文档\n```\n',2,143,234,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(146,'组件使用规范','- 使用时以`v-`开头\n- 命名遵循组件命名规范\n- 推荐使用单标签闭合\n\n``` html\n<v-BaseButton :data=\"data\"/>\n<script>\n export default{\n     components:{\n         \"v-BaseButton\":BaseButton\n     }\n }\n</srcipt\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(147,'目录命名','**参照项目命名规则，有复数结构时，要采用复数命名法**。例：docs、assets、components、directives、mixins、utils、views。\n- 文件名统一采用小写\n- 特殊缩写名称可大写开头\n\n```\n│   ├── pages/                 \n│   ├── components/\n│   │   ├── UItemp/\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(148,'命名原则','祖先模块不能出现下划线，除了是全站公用模块，如 `mod_` 系列的命名：\n\n**推荐：**\n```html\n<div class=\"modulename\">\n    <div class=\"modulename_info\">\n        <div class=\"modulename_son\"></div>\n        <div class=\"modulename_son\"></div>\n        ...\n    </div>\n</div>\n\n<!-- 这个是全站公用模块，祖先模块允许直接出现下划线 -->\n<div class=\"mod_info\">\n    <div class=\"mod_info_son\"></div>\n    <div class=\"mod_info_son\"></div>\n    ...        \n</div>\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(149,'模块命名','全站公共模块：以 `mod_` 开头\n\n```html\n<div class=\"mod_yours\"></div>\n```\n\n业务公共模块：以 `业务名_mod_` 开头\n\n```html\n<div class=\"paipai_mod_yours\"></div>\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(150,'图片命名','- 图片文件夹一般遵从页面或者模块命名,如：`login/`）\n- 图片不可随意命名，且严禁使用0，1，等数字直接命名图片。\n- 图片命名可遵循：用途+描述，多个单词用下划线隔开，如：`login_icon.png`,`pwd_icon.png`\n- 10k以下图片建议放置`assets/img`下（webpack打包时直接转为base64嵌入）\n- 大图且不常更换的图片放置`public/img`下\n- 可用css编写的样式严禁使用图片\n- 国际化图片，后缀使用简体`-cn`,英文`-en`,繁体`-tw`\n\n```\n│   ├── assets/               \n│   │   ├── img/                          # 图片\n│   │   │    ├── common/                  # 公共图片\n│   │   │    │    ├── default_avatar.png  # 默认头像\n│   │   │    ├── login/                   # 登录模块\n│   │   │    │    ├── login1.png          # 登录模块图片\n│   │   │    │    ├── login_icon-en.png      \n│   │   │    │    ├── login_icon-cn.png     \n│   │   │    │    ├── login_icon-tw.png      \n│   │   │    ├── userInfo/                # 用户中心模块的图片\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(151,'v-once','- v-once 用于指定元素或者组件只渲染一次\n- 当数据发生变化时，元素或者组件以及其所有的子元素将视为静态内容并且跳过；\n- 该指令可以用于性能优化；\n- 如果是子节点，也是只会渲染一次\n\n```html\n<span v-once>这个将不会改变: {{ msg }}</span>\n```\n',2,3,590,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(152,'v-if','用于按条件渲染一个区块。这个区块只会在指令的表达式为真时才被渲染。\n\nv-if\n\n- 是“真实的”按条件渲染，因为它确保了条件区块内的事件监听器和子组件都会在切换时被销毁与重建。\n- 是**懒加载**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块会直到条件首次变为 true 时才渲染。\n\n```html\n<h1 v-if=\"awesome\">Vue is awesome!</h1>\n```\n\n',2,3,591,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(153,'v-else','v-else 元素必须跟在一个 v-if 或者 v-else-if 元素后面，否则将不会识别它\n```html\n<h1 v-else>Oh no </h1>\n```\n',2,3,593,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(154,'template上的v-if','`v-if` 是一个指令，他必须依附某个元素。但想要切换不只一个元素呢？在这种情况下我们可以在一个 `<template>` 元素上使用 `v-if`，这只是一个不可见的包裹元素，最后渲染的结果并不会包含这个 `<template>` 元素。\n```html\n<template v-if=\"ok\">\n  <h1>Title</h1>\n  <p>Paragraph 1</p>\n  <p>Paragraph 2</p>\n</template>\n```\n`v-else` 和 `v-else-if` 也可以在 `<template>` 上使用。',2,3,591,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(155,'v-show','按条件显示一个元素\n\n`v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的CSS 属性。\n`v-show` 不支持在 `<template>` 元素上使用，也没有 `v-else` 来配合。\n\n```html\n<h1 v-show=\"ok\">Hello!</h1>\n```\n',2,3,596,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(156,'v-for','v-for的基本格式是 \"item in 数组\nv-for也支持遍历对象，并且支持有一二三个参数\n\n一个参数： \"value in object\";\n二个参数： \"(value, key) in object\";\n三个参数： \"(value, key, index) in object\";\n\nv-for同时也支持数字的遍历',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(157,'定义数组循环列表','```js\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n```html\n<li v-for=\"item in items\" :key=\"item.message\">\n    {{ item.message }}\n</li>\n```\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(158,'v-for中的可选参数','在 `v-for` 块中可以完整地访问父作用域内的属性。`v-for` 也支持使用可选的第二个参数，表示当前项的位置索引。\n\n```js\nconst parentMessage = ref(''Parent'')\nconst items = ref([{ message: ''Foo'' }, { message: ''Bar'' }])\n```\n\n```html\n<li v-for=\"(item, index) in items\">\n    {{ parentMessage }} - {{ index }} - {{ item.message }}\n</li>\n```\n\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(159,'for中的变量别名解构','使用*解构*，和解构函数参数类似：\n```html\n<li v-for=\"{ message } in items\">\n  {{ message }}\n</li>\n\n<!-- 有 index 索引时 -->\n<li v-for=\"({ message }, index) in items\">\n  {{ message }} {{ index }}\n</li>\n```\n\n\n\n',2,3,597,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(160,'用of替代in分隔符(v-for)','```html\n<div v-for=\"item of items\"></div>\n```\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(161,'对象遍历','遍历一个对象的所有属性。\n\n```vue\n<li v-for=\"value in myObject\">\n  {{ value }}\n</li>\n```\n\n```js\nconst myObject = reactive({\n  title: ''如何在 Vue 中渲染列表'',\n  author: ''王小明'',\n})\n```\n\n提供第二个的参数为 property 名称 (键名)\n\n```html\n<li v-for=\"(value, key) in myObject\">\n  {{ key }}: {{ value }}\n</li>\n```\n\n用第三个参数作为索引\n\n```html\n<li v-for=\"(value, key, index) in myObject\">\n  {{ index }}. {{ key }}: {{ value }}\n</li>\n```\n\n唯一key\n\n```html\n<div v-for=\"item in items\" v-bind:key=\"item.id\">\n  <!-- 内容 -->\n</div>\n```\n\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(162,'使用for值范围','`v-for` 也可以接受整数。在这种情况下，它会把模板重复对应次数。\n```html\n<div>\n  <span v-for=\"n in 10\">{{ n }} </span>\n</div>\n```\n 在template使用\n```html\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n```\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(163,'组件上使用v-for','直接在组件上使用`v-for`，和其他任何一般的元素没有区别\n\n```html\n<my-component v-for=\"item in items\" :key=\"item.id\"></my-component>\n```\n\n但是，这不会自动将任何数据传递给组件，因为组件有自己独立的作用域。为了将迭代后的数据传递到组件中，还是应该使用 props：\n\n```html\n<my-component\n  v-for=\"(item, index) in items\"\n  :item=\"item\"\n  :index=\"index\"\n  :key=\"item.id\"\n></my-component>\n```\n\n',2,3,597,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(164,'for&if同时使用','它们处于同一节点，`v-if` 的优先级比 `v-for` 更高，这意味着 `v-if` 将没有权限访问 `v-for` 里的变量，这时，可以把 v-for 移到 template 中\n\n\n\n新包裹一层`<template>`再在其上使用`v-for`\n\n```html\n//示例1\n<template v-for=\"(item, index) in ResultList\" :key=\"index\">\n   <a @click=\"onk(item.path)\" v-if=\"item.identity\">\n    {{item.title}}\n   </a>\n</template>\n\n//示例2\n<template v-for=\"todo in todos\" :key=\"todo.name\">\n  <li v-if=\"!todo.isComplete\">\n    {{ todo.name }}\n  </li>\n</template>\n```\n\n',2,3,597,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(165,'v-text','都是用于将数据显示在界面中，但是通常只接受一个string类型\n用于更新元素的 textContent\n```html\n<div v-text=\"message\"></div>\n<div v-text=\"msg\"></div> 等价于 <div>{{msg}}</div>\n```\n',2,3,609,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(166,'v-pre','- v-pre用于跳过元素和它的子元素的编译过程，显示原始的Mustache标签\n- 跳过不需要编译的节点，加快编译的速度\n```html\n<h2 v-pre>{{massage}}</h2> <!-- {{massage}} -->\n```\n\n',2,3,607,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(167,'v-cloak','保持在元素上直到关联组件实例结束编译； 和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到组件实 例准备完毕。',2,3,608,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(168,'自定义指令','注册一个全局指令 v-focus, 指令的功能在页面加载时，元素获得焦点：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n\n<script>\nconst app = Vue.createApp({})\n// 注册一个全局自定义指令 `v-focus`\napp.directive(''focus'', {\n  // 当被绑定的元素挂载到 DOM 中时……\n  mounted(el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\napp.mount(''#app'')\n</script>\n```\n\n我们也可以在实例使用 directives 选项来注册局部指令，这样指令只能在这个实例中使用：\n\n```html\n<div id=\"app\">\n    <p>页面载入时，input 元素自动获取焦点：</p>\n    <input v-focus>\n</div>\n<script>\nconst app = {\n   data() {return {}},\n   directives: {\n      focus: {\n         // 指令的定义\n         mounted(el) {\n            el.focus()\n         }\n      }\n   }\n}\nVue.createApp(app).mount(''#app'')\n```',11,3,620,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(169,'循环指定次数','```html\n<a-button type=\"primary\" shape=\"round\" @click=\"GetMonth(index)\" \n          v-for=\"index of 12\" :key=\"index\">{{ index }}月\n</a-button>\n```\n\n\n\n',2,3,597,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(174,'获取本日开始时间','```csharp\n/// <summary>\n/// 获取本日开始时间（0点0分0秒）\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetDayStart(this DateTime dateTime)\n{\n  return dateTime.Date;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(175,'获取本日结束时间','```csharp\n/// <summary>\n/// 获取本日结束时间（23点59分59秒）\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetDayEnd(this DateTime dateTime)\n{\n  return dateTime.Date.AddDays(1).AddMilliseconds(-1);\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(176,'获取本周开始时间','```csharp\n/// <summary>\n/// 获取本周开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetWeekStart(this DateTime dateTime)\n{\n  return dateTime.AddDays(-(int) dateTime.DayOfWeek + 1).GetDayStart();\n}    \n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(177,'获取本周结束时间','```csharp\n/// <summary>\n/// 获取本周结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetWeekEnd(this DateTime dateTime)\n{\n  return dateTime.AddDays(7 - (int) dateTime.DayOfWeek).GetDayEnd();\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(178,'获取本月开始时间','```csharp\n/// <summary>\n/// 获取本月开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetMonthStart(this DateTime dateTime)\n{\n  return new DateTime(dateTime.Year, dateTime.Month, 1, 0, 0, 0, 0);\n}\n\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(179,'获取本月结束时间','```csharp\n /// <summary>\n /// 获取本月结束时间\n /// </summary>\n /// <param name=\"dateTime\"></param>\n /// <returns></returns>\n public static DateTime GetMonthEnd(this DateTime dateTime)\n {\n   return GetMonthStart(dateTime).AddMonths(1).AddMilliseconds(-1);\n }\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(180,'获取本季度开始时间','```csharp\n/// <summary>\n/// 获取本季度开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetSeasonStart(this DateTime dateTime)\n{\n  var time = dateTime.AddMonths(0 - ((dateTime.Month - 1) % 3));\n  return DateTime.Parse(time.AddDays(-time.Day + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(181,'获取本季度结束时间','```csharp\n/// <summary>\n/// 获取本季度结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetSeasonEnd(this DateTime dateTime)\n{\n  var time = dateTime.AddMonths((3 - ((dateTime.Month - 1) % 3) - 1));\n  return DateTime.Parse(time.AddMonths(1).AddDays(-time.AddMonths(1).Day + 1).AddDays(-1).ToString(\"yyyy/MM/dd 23:59:59\"));\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(182,'获取本年开始时间','```csharp\n/// <summary>\n/// 获取本年开始时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetYearStart(this DateTime dateTime)\n{\n  return DateTime.Parse(dateTime.AddDays(-dateTime.DayOfYear + 1).ToString(\"yyyy/MM/dd 00:00:00\"));\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(183,'获取本年结束时间','```csharp\n/// <summary>\n/// 获取本年结束时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime GetYearEnd(this DateTime dateTime)\n{\n  var time2 = dateTime.AddYears(1);\n  return DateTime.Parse(time2.AddDays(-time2.DayOfYear).ToString(\"yyyy/MM/dd 23:59:59\"));\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(184,'北京时间转换成unix时间戳','```csharp\n/// <summary>\n/// 北京时间转换成unix时间戳(10位/秒)\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static long BeijingTimeToUnixTimeStamp10(this DateTime dateTime)\n{\n  return(long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalSeconds;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(186,'北京时间转换成unix时间戳(13位/毫秒)','```csharp\n/// <summary>\n/// 北京时间转换成unix时间戳(13位/毫秒)\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static long BeijingTimeToUnixTimeStamp13(this DateTime dateTime)\n{\n  return(long)(dateTime - new DateTime(1970, 1, 1, 8, 0, 0)).TotalMilliseconds;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(188,'10位unix时间戳转换成北京时间','```csharp\n/// <summary>\n/// 10位unix时间戳转换成北京时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime UnixTimeStamp10ToBeijingTime(this long unixTimeStamp)\n{\n  return new DateTime(1970, 1, 1, 8, 0, 0).AddSeconds(unixTimeStamp);\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(190,'13位unix时间戳转换成北京时间','```csharp\n/// <summary>\n/// 13位unix时间戳转换成北京时间\n/// </summary>\n/// <param name=\"dateTime\"></param>\n/// <returns></returns>\npublic static DateTime UnixTimeStamp13ToBeijingTime(this long unixTimeStamp)\n{\n  return new DateTime(1970, 1, 1, 8, 0, 0).AddMilliseconds(unixTimeStamp);\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(192,'当前日期所在月份第一个指定星期几的日期','```csharp\n/// <summary>\n/// 当前日期所在月份第一个指定星期几的日期\n/// </summary>\n/// <param name=\"date\">给定日期</param>\n/// <param name=\"dayOfWeek\">星期几</param>\n/// <returns>所对应的日期</returns>\npublic static DateTime GetFirstWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n{\n  var dt = date.GetMonthStart();\n  while(dt.DayOfWeek != dayOfWeek) dt = dt.AddDays(1);\n  return dt;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(193,'当前日期所在月份最后1个指定星期几的日期','```csharp\n/// <summary>\n/// 当前日期所在月份最后1个指定星期几的日期\n/// </summary>\n/// <param name=\"date\">给定日期</param>\n/// <param name=\"dayOfWeek\">星期几</param>\n/// <returns>所对应的日期</returns>\npublic static DateTime GetLastWeekDayOfMonth(this DateTime date, DayOfWeek dayOfWeek)\n{\n  var dt = date.GetMonthEnd();\n  while(dt.DayOfWeek != dayOfWeek) dt = dt.AddDays(-1);\n  return dt;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(196,'给定日期所在月份共有多少天','```csharp\n/// <summary>\n/// 给定日期所在月份共有多少天\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static int GetCountDaysOfMonth(this DateTime date)\n{\n  return date.GetMonthEnd().Day;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(197,'当前日期与给定日期是否是同一天','```csharp\n/// <summary>\n/// 当前日期与给定日期是否是同一天\n/// </summary>\n/// <param name=\"date\">当前日期</param>\n/// <param name=\"dateToCompare\">给定日期</param>\n/// <returns></returns>\npublic static bool IsDateEqual(this DateTime date, DateTime dateToCompare)\n{\n  return date.Date == dateToCompare.Date;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(198,'是否是周未','```csharp\n/// <summary>\n/// 是否是周未\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsWeekend(this DateTime date)\n{\n  return date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(199,'是否是工作日','```csharp\n/// <summary>\n/// 是否是工作日\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsWeekDay(this DateTime date)\n{\n  return !date.IsWeekend();\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(200,'判断是否为今天','```csharp\n/// <summary>\n/// 判断是否为今天\n/// </summary>\n/// <param name=\"date\"></param>\n/// <returns></returns>\npublic static bool IsToday(this DateTime date)\n{\n  return date.Date == DateTime.Now.Date;\n}\n```\n\n\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(201,'ShellExecute使用','### ShellExecute\n\n若ShellExecute函数调用成功，则返回值为被执行程序的实例句柄。若返回值小于32，则表示出现错误。\n\n```csharp\n  /// <summary>\n        /// ShellExecute\n        /// </summary>\n        /// <param name=\"hwnd\">指定父窗口句柄:ntPtr.Zero</param>\n        /// <param name=\"lpszOp\">指定要进行的操作:Open</param>\n        /// <param name=\"lpszFile\">指定要打开的文件名|路径</param>\n        /// <param name=\"lpszParams\">指定命令行参数: 0 | \"\"</param>\n        /// <param name=\"lpszDir\">用于指定默认目录:0 | \"\"</param>\n        /// <param name=\"FsShowCmd\">显示模式: 0:隐藏 1~11</param>\n        /// <returns></returns>\n        [DllImport(\"shell32.dll\")]\n        private static extern int ShellExecute(IntPtr hwnd, StringBuilder lpszOp, StringBuilder lpszFile, StringBuilder lpszParams, StringBuilder lpszDir, int FsShowCmd);\n\n\n        /// <summary>\n        /// 打开程序/文件夹\n        /// </summary>\n        /// <param name=\"path\">路径</param>\n        /// <param name=\"FsShow\">显示模式 默认1</param>\n        public static void OpenFile(string path, int FsShow = 1)\n        {\n            ShellExecute(IntPtr.Zero, new StringBuilder(\"Open\"), new StringBuilder(@path), new StringBuilder(\"\"), new StringBuilder(\"\"), FsShow);\n        }\n```\n\n',1,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(202,'WindiCSS','## WindiCSS\n\n[指令 | Windi CSS](https://cn.windicss.org/features/directives.html)\n\n**Windi CSS** 是下一代工具优先的 CSS 框架。\n\n如果你已经熟悉了 [Tailwind CSS](https://tailwindcss.com/docs)，可以把 Windi CSS 看作是**按需供应的** Tailwind 替代方案，它为你提供了更快的加载体验，**完美兼容 Tailwind v2.0**，并且拥有很多额外的酷炫功能',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(203,'自动值推导',' Windi CSS 提供自动值推导功能，可以在类名中使用任意值，然后生成相应的样式，用起来比使用标准的 sass 要方便很多。例如：\n\n- `w-192px` 可以自动解析为 `width: 192px;`\n- `w-[25%]` 可以自动解析为 `width: 25%;` ，也相当于 `width: 48px;`\n- `h-12` 可以自动解析为 `height: 3rem;` ，根据当前的根元素的字体大小也相当于 `height: 48px;',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(204,'Important前缀','### Important前缀\n\n使用 important 也是非常方便，只需在任意工具类的前面使用 `!` 前缀，使它们变为 `!important`，就可以覆盖之前的样式规则中指定的属性了。\n\n如 `w-192px` 添加 `!` 前缀为 `!w-192px',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(205,'Shortcuts','使用相同的工具类合集时，出现很多重复性代码， Shortcuts 特性可以工具类的名字组合在一起定义成一个新的名字，在任何地方使用，就免去了大量重复冗余的代码。\n\n配置文件 `windi.config.ts` 中添加 `shortcuts` 字段：\n\n```typescript\nexport default {\n  theme: {\n    /* ... */\n  },\n  shortcuts: {\n    ''box view'': ''w-[25%] h-12 rounded-md m-4px'',\n  },\n}\n```\n\n就可以把页面代码修改为下面这样，页面展示效果是一样的，但是代码更加简洁明了。\n\n```html\n<div class=\"bg-blue-400 box-view\"></div>\n```',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(206,'响应式设计','Windi CSS 中轻松实现响应式设计。将可变修饰（variant）的前缀加到对应的工具类前，比如 `md:`、`lg:`。\n\n> |      | 默认                | 带有 `<` 前缀         | 带有 `@` 前缀                                 |\n> | ---- | ------------------- | --------------------- | --------------------------------------------- |\n> | sm   | (min-width: 640px)  | (max-width: 639.9px)  | (min-width: 640px) and (max-width: 767.9px)   |\n> | md   | (min-width: 768px)  | (max-width: 767.9px)  | (min-width: 768px) and (max-width: 1023.9px)  |\n> | lg   | (min-width: 1024px) | (max-width: 1023.9px) | (min-width: 1024px) and (max-width: 1279.9px) |\n> | xl   | (min-width: 1280px) | (max-width: 1279.9px) | (min-width: 1280px) and (max-width: 1535.9px) |\n> | 2xl  | (min-width: 1536px) | (max-width: 1535.9px) | (min-width: 1536px)                           |\n\n```html\n<div class=\"lg:bg-red-400 md:bg-red-200 sm:bg-red-100 box-view\"></div>\n\n<div class=\"phone:(bg-red-400 text-light-100 p-10) iPad:(p-50 bg-blue-700) lg:(p-100 bg-cyan-800 text-50px)\">\n    响应式\n</div>\n\n <div\n    w:phone=\"bg-red-400 text-light-100 p-10\"\n    w:iPad=\"bg-blue-700 p-50\"\n    w:lg=\"p-100 bg-cyan-800 text-50px\"\n>\n    响应式\n</div>\n\n@screen <xp {\n}\n```\n\n根据业务需求来自定义断点，在 `windi.config.ts` 中配置\n\n```tsx\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  theme: {\n    screens: {\n      tablet: ''640px'',\n      laptop: ''1024px'',\n      desktop: ''1280px'',\n    },\n  },\n})\n\n```',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(207,'@apply','将 `@apply` 在 style 块中同一行的、一些已存在的工具类上使用，和 Shortcuts 效果差不多，适合抽取成一个通用工具类。\n\n```html\n<style lang=\"scss\" scoped>\n...\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n</style>\n```\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(208,'@variants','通过把 css 工具类定义包装在 `@variants` 中，用来生成带有一些屏幕可变修饰，状态可变修饰，主题可变修饰的工具类。\n\n```html\n<template>\n    <h3>使用 Windi CSS</h3>\n    <div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n      <div class=\"bg-red-400 box-view2\"></div>\n      <div class=\"bg-green-400 box-view2\"></div>\n      <div class=\"bg-blue-400 box-view2\"></div>\n    </div>\n    <br>\n</template>\n\n<style lang=\"scss\" scoped>\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n@variants focus, hover {\n  .box-view2 {\n    @apply bg-red-200;\n  }\n}\n</style>\n```\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(209,'@screen','`@screen` 媒体查询，通过名称来引用断点，以此来取代通过复制你 CSS 里面的值来实现。\n\n```html\n<style lang=\"scss\" scoped>\n...\n\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n// lg 就是上文响应式设计中的断点 (min-width: 1024px)\n@screen lg {\n  .box-view2 {\n    @apply bg-red-200;\n  }\n}\n\n// 上下效果一样\n@media (min-width: 1024px) {\n  .box-view2{\n    // background-color: rgba(254, 202, 202) = bg-red-200\n    background-color: rgba(254, 202, 202)\n  }\n}\n</style>\n```\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(210,'@layer','`@layer` 指令用来确认每个 class 的排序。合法的层级为 `基础 (base)`, `组件 (components)` 和 `工具类 (utilities)`。',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(211,'theme()','`theme()` 函数可以让我们通过 `.` 运算符来获取想要设置的值。\n\n```html\n<template> \n    <h3>使用 Windi CSS</h3>\n    <div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n      <div class=\"bg-red-400 box-view2 light-red\"></div>\n      <div class=\"bg-green-400 box-view2\"></div>\n      <div class=\"bg-blue-400 box-view2\"></div>\n    </div>\n</template>\n\n<style lang=\"scss\" scoped>\n.box-view2 {\n  @apply w-[25%] h-12 rounded-md m-4px;\n}\n\n.light-red {\n  background-color: theme(\"colors.red.200\");\n}\n</style>\n```\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(212,'属性化模式','属性化在 Windi CSS 中默认下是可选的，在 `windi.config.ts` 配置中开启，并根据需求使用。\n\n```typescript\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  attributify: true,\n})\n```\n\n把上面的代码改为下面的方式，效果和上面讲到的响应式设计是一样的，这样写可以让我们的目录更加清晰。\n\n```html\n<h3>使用 Windi CSS</h3>\n<div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n    <div\n        lg=\"bg-red-400 box-view\"\n        md=\"bg-red-200 box-view\"\n        sm=\"bg-red-100 box-view\"\n      ></div>\n    <div class=\"bg-green-400 box-view\"></div>\n    <div class=\"bg-blue-400 box-view\"></div>\n</div>\n```\n\n如果担心命名冲突，可以在 `windi.config.ts` 配置中通过属性化方式添加自定义前缀：\n\n```html\nimport { defineConfig } from ''windicss/helpers''\n\nexport default defineConfig({\n  attributify: {\n    prefix: ''w:'',\n  },\n})\n<h3>使用 Windi CSS</h3>\n<div class=\"flex items-center justify-around bg-teal-100 rounded-md p-4px w-192px\">\n    <div\n        w:lg=\"bg-red-400 box-view\"\n        w:md=\"bg-red-200 box-view\"\n        w:sm=\"bg-red-100 box-view\"\n      ></div>\n    <div class=\"bg-green-400 box-view\"></div>\n    <div class=\"bg-blue-400 box-view\"></div>\n</div>\n```\n\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(213,'Plugin插件','[Windi CSS](https://link.juejin.cn?target=https%3A%2F%2Fcn.windicss.org%2Fplugins%2Finterfaces.html) 官方以及社区提供了很多 plugin 插件使用，让我们操作 css 更加方便和高效，而且我们也可以通过 Windi CSS 的接口，来开发自己的插件。\n\n插件同样需要在 Windi CSS 的配置文件 `windi.config.ts` 中引入即可。\n\n```typescript\nexport default {\n  theme: {\n    // ...\n  },\n  // 引入插件\n  plugins: [\n    require(''windicss/plugin/typography''),\n    // ...\n  ],\n}\n```\n',14,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(214,'选择器选择','- 尽量少用通用选择器\n- 不使用 ID 选择器\n- 不使用无具体语义定义的标签选择器\n\n```css\n/* 推荐Class */\n.jdc {}\n.jdc li {}\n.jdc li p{}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(215,'属性值引号','css属性值用到引号时，统一用单引号\n\n```css\n/* 推荐 */\n.jdc { \n    font-family: ''Hiragino Sans GB'';\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(216,'属性书写顺序','建议遵循以下顺序：\n\n1. 布局定位属性：display / position / float / clear / visibility / overflow\n2. 自身属性：width / height / margin / padding / border / background\n3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(217,'CSS注释','### CSS注释\n\n```css\n/*这是个注释*/\np\n{\n    text-align:center;\n    /*这是另一个注释*/\n    color:black;\n    font-family:arial;\n}\n```',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(218,'文件信息注释','在样式文件编码声明 `@charset` 语句下面注明页面名称、作者、创建日期等信息\n\n```css\n@charset \"UTF-8\";\n/**\n * @desc File Info\n * @author Author Name\n * @date 2015-10-10\n */\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(219,'常用命名','| **CSS类名**           | **说明**               |\n| --------------------- | ---------------------- |\n| **布局**              |                        |\n| layout                | 布局容器               |\n| wrapper/wrap          | 控制布局宽度的外围容器 |\n| header/head/hd        | 头部/顶部              |\n| main/bd               | 主体部分               |\n| footer/foot/ft        | 底部                   |\n| sidebar               | 侧边栏                 |\n| **容器**              |                        |\n| banner                | 广告栏                 |\n| content               | 内容部分               |\n| copyright             | 版权                   |\n| list                  | 列表                   |\n| menu/submenu          | 菜单/二级菜单          |\n| nav/subnav            | 导航栏/二级导航        |\n| **组件/细节**         |                        |\n| arrow                 | 箭头                   |\n| btn                   | 按钮                   |\n| download              | 下载                   |\n| logo                  | 徽标                   |\n| message/msg           | 信息                   |\n| news                  | 新闻                   |\n| product               | 产品                   |\n| search                | 搜索                   |\n| status                | 状态                   |\n| summary               | 摘要                   |\n| tab                   | 标签页                 |\n| tag                   | 标签                   |\n| text/txt              | 文本                   |\n| tip                   | 提示                   |\n| title/subtitle        | 标题/二级标题          |\n| **尺寸**              |                        |\n| large                 | 大                     |\n| middle                | 中等                   |\n| small                 | 小                     |\n| mini                  | 迷你                   |\n| **位置**              |                        |\n| top/right/bottom/left | 上/右/下/左            |\n| **关系**              |                        |\n| first                 | 第一个                 |\n| last                  | 最后一个               |\n| prev                  | 上一个                 |\n| current               | 当前项                 |\n| next                  | 下一个                 |\n| forward               | 向前                   |\n| back                  | 向后                   |\n| **状态**              |                        |\n| primary               | 主要                   |\n| info                  | 提示信息               |\n| success               | 成功                   |\n| warning               | 一般警告               |\n| danger/error          | 严重警告/错误警告      |\n| link                  | 文字链接               |\n| plain/ghost           | 按钮是否镂空           |\n| light                 | 亮模式                 |\n| dark                  | 暗模式                 |\n| disabled              | 禁用                   |\n| active                | 激活                   |\n| checked               | 选中                   |\n| loading               | 加载中                 |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(220,'选择器使用情况','| 选择器         | 作用                   | 用法及隔开代码                      | 使用情况 |\n| -------------- | ---------------------- | ----------------------------------- | -------- |\n| 后代选择器     | 用来选择后代元素       | 符号是空格 .nav a                   | 较多     |\n| 子代选择器     | 选择最近一级元素       | 符号是大于 .nav>p                   | 较少     |\n| 并集选择器     | 选择某些相同样式的元素 | 符号是逗号 .nav，header             | 较多     |\n| 链接伪类选择器 | 选择不同状态的链接     | 重点记住a{}和a：hover实际开发的写法 | 较多     |\n| ：focus        | 选择获得光标的表单     | input：focus记住这个写法            | 较少     |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(221,'CSS的三种样式表','按照CSS样式书写的位置（或者引入方式）\n\n- 行业样式表（行内式）\n- 内部样式表（嵌入式）\n- 外部样式表（链接式）',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(222,'行内样式表','行内样式表是在元素标签内部的style属性中设置CSS样式，适合于修改简单样式。\n\n```css\n<div style=\"color:red; font-size:12px;\">青春不常在，抓紧谈恋爱</div>\n```\n\n- style其实就是标签的属性\n- 在双引号中间，写法要符合CSS规范。\n- 可以控制当前的标签设置样式。\n- 由于书写繁琐，并且没有体现出结构与样式相分离的思想，所以不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用。\n- 使用行内样式表设定CSS，通常也被成为行内式引入。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(223,'外部样式表','实际开发都是外部样式表，适合于样式比较多的情况，核心是：样式单独写到CSS文件中，之后把CSS文件引入到HTML页面中使用。\n\n引入外部样式表分为两步：\n\n- 新建一个后缀名为CSS的样式文件，把所有CSS代码都放入此文件中。\n- 在HTML页面中，使用<link>标签引入这个文件。\n\n```css\nlink rel=\"style sheet\" href\"CSS文件路径\"\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(224,'CSS引入方式总结','| 样式表     | 优点                     | 缺点         | 使用情况   | 控制范围     |\n| ---------- | ------------------------ | ------------ | ---------- | ------------ |\n| 行内样式表 | 书写方便；权重高         | 结构样式混写 | 较少       | 控制一个标签 |\n| 内部样式表 | 部分结构和样式相分离     | 没有彻底分离 | 较多       | 控制一个页面 |\n| 外部样式表 | 完全实现结构和样式相分离 | 需要引入     | 最多(推荐) | 控制多个页面 |',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(225,'变量','### 变量\n\n变量用来存储需要在CSS中复用的信息，如颜色和字体,通过$符号去声明一个变量。\n可复用属性尽量抽离为页面变量，易于统一维护\n\n```css\n$color: red;\n.jdc {\n    color: $color;\n    border-color: $color;\n}\n```\n转换全局变量可添加 `!global` 声明：\n```css\n $width: 5em !global;\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(226,'混合(mixin)','根据功能定义模块，然后在需要使用的地方通过 `@include` 调用，避免编码时重复输入代码段\n\n```css\n@mixin icon($x:0, $y:0) {\n    background: url(/img/icon.png) no-repeat $x, $y;\n}\n.test {\n   @include icon(-10px, 0);\n}\n```\n查看: [混合(Mixins)](http://ref.ecdata.cn/docs/sass.html#sass-混合mixins)',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(227,'占位选择器(%) ','以 `%` 标识定义，通过 `@extend` 调用\n\n```css\n%borderbox {\n    box-sizing: border-box;\n}\n.jdc {\n    @extend %borderbox;\n}\n```\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(228,'继承(extend)','通过@extend指令在选择器之间复用CSS属性，并且不会产生冗余的代码\n```css\n.jdc_1 {\n    color: red;\n}\n.jdc_2 {\n    @extend .jdc_1;\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(229,'循环(for)','```\n结束值不执行：\n@for 变量 from 开始值 through 结束值 {}\n结束值也执行：\n@for 变量 from 开始值 to 结束值 {}\n```\n\n注意：`#{}` 是连接符，变量连接使用时需要依赖\n\n```scss\n@for $i from 1 through 3 {\n    .jdc_#{$i} {\n        background-position: 0 (-20px) * $i;\n    }\n}\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(230,'循环(each)','```scss\n@each $name in list, detail {\n    .jdc_#{$name} {\n        ...\n    }\n}\n@each $name, $color in (list, red), (detail, blue) {\n    .jdc_#{$name} {\n      ...\n    }\n}\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(231,'函数(function)','```css\n@function pxToRem($px) {\n    @return $px / 10px * 1rem;\n}\n.jdc {\n    font-size: pxToRem(12px);\n}\n```\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(232,'运算规范','### 运算规范\n\n运算符之间空出一个空格\n\n```scss\n.jdc {\n    width: 100px - 50px;\n    height: 30px / 5;\n}\n```\n\n单位同时参与运算，所以 10px 不等于 10，乘除运算时需要特别注意\n\n```scss\n// 正确的运算格式\n.jdc {\n    width: 100px - 50px;\n    width: 100px + 50px;\n    width: 100px * 2;\n    width: 100px / 2;\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(233,'居中(flex)','使用 Flexbox 实现子元素的居中效果\n```css\n@mixin center-children {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n```\n\n```css\n.parent {\n    @include center-children;\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(235,'插值(#{})','通过 `#{}` 语句在选择器或属性名中使用变量：\n```css\n$name: foo;\n$attr: border;\np.#{$name} {\n  #{$attr}-color: blue;\n}\n```\n\n编译为\n\n```css\np.foo {\n  border-color: blue; }\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(236,'嵌套(Nesting)','```css\n.container{\n  .left-area{\n    ...\n  }\n}\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(237,'父选择器(&)','& 表示自身的意思。\n```css\n.container{\n  &.right-area{\n   background-color : #0000\n }\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(238,'Mixin(混合)','### Mixin(混合)\n\n用来分组那些需要在页面中复用的CSS声明，开发人员可以通过向Mixin传递变量参数来让代码更加灵活，该特性在添加浏览器兼容性前缀的时候非常有用，SASS目前使用@mixin name指令来进行混合操作。\n\n```scss\n@mixin 名字（参数1，参数2，...）\n{\n........样式.......\n}\n\ndiv{\n    @include 名字;  \n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(242,'循环(while)','### while循环\n\n``` css\n$gao: 1;\n@while $gao<4 {\n    .div#{$gao}{\n        height: $gao*10px;\n    }\n   $gao : $gao+1;\n}\n```\n\n\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(243,'v-model','在处理表单时，常常需要将表单输入框的内容同步给 JavaScript 中相应的变量。v-model 在表单 `<input>`、`<textarea>` 及 `<select>` 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n#### 基本使用\n```html\n<input v-model=\"text\">\n```\n#### 多行文本\n```html\n<textarea v-model=\"message\"></textarea>\n```\n',2,3,621,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(244,'复选框中使用v-model','单一的复选框，绑定的是布尔类型值：\n\n```js\nconst checked= ref(false)\n```\n\n```html\n<input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\" />\n<label for=\"checkbox\">{{ checked }}</label>\n```\n\n\n\n',2,3,621,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(245,'多个复选框使用v-model','绑定同一个数组：\n```js\nconst checkedNames = ref([])\n```\n```html\n<div>选择的名字有：{{ checkedNames }}</div>\n<input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\">\n<label for=\"jack\">Jack</label>\n\n<input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\">\n<label for=\"john\">John</label>\n```\n',2,3,621,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(246,'选择框中使用v-model','单选时：\n\n```js\nconst selected = ref('''')\n```\n\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\">\n  <option disabled value=\"\">请选择</option>\n  <option>A</option>\n  <option>B</option>\n</select\n```\n\n多选时 (绑定到一个数组)：\n\n```js\nconst selected = ref('''')\n```\n\n```html\n<div>选择的是：{{ selected }}</div>\n<select v-model=\"selected\" multiple>\n  <option>A</option>\n  <option>B</option>\n</select>\n```\n\n用 `v-for` 渲染的动态选项：\n\n```html\n<select v-model=\"selected\">\n  <option v-for=\"option in options\" :value=\"option.value\">\n    {{ option.text }}\n  </option>\n</select>\n<div>选择的是：{{ selected }}</div>\n```\n\n```js\nconst selected = ref(''A'')\nconst options = ref([\n  { text: ''One'', value: ''A'' },\n  { text: ''Two'', value: ''B'' },\n])\n```\n\n',2,3,621,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(247,'值绑定v-model','对于单选按钮，复选框和选择器选项，`v-model` 绑定的值通常是静态的字符串 (或者对复选框是布尔值)：\n\n```html\n<!-- `picked` 在被选择时是字符串 \"a\" -->\n<input type=\"radio\" v-model=\"picked\" value=\"a\" />\n\n<!-- `toggle` 只会为 true 或 false -->\n<input type=\"checkbox\" v-model=\"toggle\" />\n\n<!-- `selected` 在第一项被选中时为字符串 \"abc\" -->\n<select v-model=\"selected\">\n  <option value=\"abc\">ABC</option>\n</select\n```\n',2,3,621,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(248,'修饰符v-model','默认情况下，`v-model` 在每次 `input` 事件触发后将输入框的值与数据进行同步。添加 `lazy` 修饰符，从而转为在 `change` 事件_之后_进行同步：\n```html\n<!-- 在 \"change\" 事件后同步更新而不是 \"input\" -->\n<input v-model.lazy=\"msg\" />\n```\n.number：如果想自动将用户的输入值转为数值类型，可以给 `v-model` 添加 `number` 修饰符：\n```html\n<input v-model.number=\"age\" />\n```\n.trim：如果要自动过滤用户输入的首尾空白字符，可以给 `v-model` 添加 `trim` 修饰符：\n```html\n<input v-model.trim=\"msg\" />\n```\n',2,3,621,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(249,'vue-tsc','vue3 命令行类型检查工具基于 IDE 插件 [Volar](https://github.com/johnsoncodehk/volar)。\n\n- noEmit的作用是只进行检查，不进行编译输出。如果我们的代码无错，会直接退出，否则报错。\n\n```bash\n//安装\nnpm i vue-tsc -D\n//用法\nvue-tsc --noEmit && vite build\n```\n\n\n\n```bash\n//类型检查：\nvue-tsc --noEmit\n//构建 dts\nvue-tsc --declaration --emitDeclarationOnly\n```\n\n',2,145,654,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(250,'normalize','统一浏览器的初始样式\n\n```js\n//安装\nnpm install --save normalize.css\n\n//main中引入\nimport ''normalize.css/normalize.css''\n```\n\n',2,145,655,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(251,'unplugin-vue-components','自动引入组件\n```\nnpm unplugin-vue-components -D\n```\n```js\n// vite.config.js\nimport Components from ''unplugin-vue-components/vite''\nimport { AntDesignVueResolver } from ''unplugin-vue-components/resolvers''\n  Components({\n    dts: true, // ts支持\n    dirs: [''src/components'', ''src/views''], // 自定义路径按需导入\n    resolvers: [AntDesignVueResolver()] // antd直接使用组件,无需在任何地方导入组件\n  }),\n```\n\n',9,152,767,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(252,'${}模版字符串','```JS\nconsole.info(`大家好，我叫${name}，今年${age}岁了`)\n// 等价于\nconsole.info(''大家好，我叫'' + name + ''，今年'' + age + ''岁了'')\nreturn get(`${Api.FY}/${identity}/${type}/${pageindex}/${pagesize}`);\n```',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(253,'console.log','console.log({name})取代console.log(''name'', name)\n\n```js\nconsole.log({name})\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(254,'globalProperties','globalProperties\n- 类型：[key: string]: any\n- 默认：undefined\n\n#### 全局使用\n```javascript\n//main.js\nimport { createApp } from ''vue''\nimport App from ''./App.vue''\nconst app = createApp(App)\n// 获取原型\nconst prototype = app.config.globalProperties\n// 绑定参数\nprototype.name = ''Jerry''\n```\n#### 组件内使用\n```js\n<script setup>\n  import { getCurrentInstance } from ''vue''\n  // 获取原型 获取上下文实例，ctx=vue2的this\n  const { proxy } = getCurrentInstance()\n  // 输出\n  console.log(proxy.name)\n</script>\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(255,'vue3对await的支持','不必再配合 async 就可以直接使用 await 了，这种情况下，组件的 setup 会自动变成 async setup 。\n\n```js\n<script setup>\n  const post = await fetch(''/api'').then(() => {})\n</script>\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(256,'CSS变量注入','```html\n<template>\n  <span>Jerry</span>  \n</template>\n\n<script setup>\n  import { reactive } from ''vue''\n  const state = reactive({\n    color: ''red''\n  })\n</script>\n\n<style scoped>\n  span {\n    // 使用v-bind绑定state中的变量\n    color: v-bind(''state.color'');\n  }  \n</style>\n```',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(257,'定义倒计时','```ts\nsetTimeout(async () => {\n   await ConutSort();//方法\n  }, 2000);//间隔2秒\n });\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(258,'is动态组件切换','```html\n  <div>\n    <a href=\"#\" @click.prevent=\"comName = ''login''\">登录</a>\n    <a href=\"#\" @click.prevent=\"comName = ''register''\">注册</a>\n    <a href=\"#\" @click.prevent=\"comName = ''logOut''\">退出</a>\n     <!--  <component></component>来展示对应名称的组件,相当于一个占位符 // :is 属性指定 组件名称 -->\n    <component :is=\"comName\"></component>\n  </div>\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(259,'清除缓存组件','```js\n// beforeRouteLeave()钩子\n// 判断是否要到详情页\n  beforeRouteLeave(to, from, next) {\n      if (to.path === \"/goods_detail\") {\n        from.meta.keepAlive = true;\n      } else {\n        from.meta.keepAlive = false;\n      }\n      next();\n    }\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(260,'传值编码/解码','```js\n//编码\nlet paths = encodeURIComponent(path)\n//解码\nlet paths = decodeURIComponent(path)\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(261,'回调顶部','```html\n <div id=\"backtop\">\n   <p @click=\"backtop\"></p>\n </div>\n```\n\n```js\n  static BackTop() {\n    // eslint-disable-next-line func-names\n    const timer = setInterval(function () {\n      const osTop = document.documentElement.scrollTop || document.body.scrollTop\n      const isPeed = Math.floor(-osTop / 5)\n      document.body.scrollTop = osTop + isPeed\n      document.documentElement.scrollTop = document.body.scrollTop\n      if (osTop === 0) {\n        clearInterval(timer)\n      }\n    }, 30)\n  }\n```',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(262,'日期格式化(moment)','`moment` 是一个 `JavaScript` 日期处理类库。\n\n```\nnpm install moment --save\n```\n\n```js\n /**\n   * 日期格式化\n   * @param time\n   */\n  static MomentTime(time: any) {\n    moment(time).format(''YYYY-MM-DD- H:mm:ss'')\n  }\n\n  /**\n   *  日期格式化\n   * @param time\n   */\n  static async MomentTimeList(time: any) {\n    await time.data.forEach((res: any) => {\n      res.timeCreate = moment(res.timeCreate).format(''YYYY-MM-DD- H:mm:ss'')\n    })\n  }\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(263,'随机数(Random)','```js\n  /**\n   * 随机数\n   * @param minNum 最小值\n   * @param maxNum 最大值\n   * @param counts 循环次数\n   * @returns\n   */\n  static Random(minNum: number, maxNum: number, counts: number) {\n    let i = 0\n    let count\n    do {\n      i += 1\n      const res = `${Math.random() * (maxNum - minNum + 1) + minNum}`\n      count = parseInt(res, 10)\n    } while (i < counts)\n    return count\n  }\n```',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(264,'vue-router使用','vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。\n\n### 功能\n\n- 嵌套路由映射\n- 动态路由选择\n- 模块化、基于组件的路由配置\n- 路由参数、查询、通配符\n- 展示由 Vue.js 的过渡系统提供的过渡效果\n- 细致的导航控制\n- 自动激活 CSS 类的链接\n- HTML5 history 模式或 hash 模式\n- 可定制的滚动行为\n- URL 的正确编码\n\n```\nnpm install vue-router@4\nor\nyarn add vue-router@4\n```\n\n## 基本使用\n\n### 定义路由\n\n新建router/routes.ts\n\n```js\nimport { RouteRecordRaw } from ''vue-router''\ndeclare module ''vue-router'' {\n  interface _RouteRecordBase {\n    hidden?: boolean | string | number\n  }\n}\nconst routes: RouteRecordRaw[] = [\n  {\n    path: ''/index'',\n    name: ''index'',\n    component: () => {\n      return import(''../views/page/Index.vue'')\n    },\n    meta: {\n      keepAlive: true\n    },\n    children: [\n      // 添加子路由\n      {\n        path: ''article'',\n        name: ''article'',\n        component: () => {\n          return import(''../views/page/article/index.vue'')\n        }\n      },\n      {\n        path: ''TestTool'',\n        name: ''TestTool'',\n        component: () => {\n          return import(''../views/page/testTool/TestTool.vue'')\n        },\n        children: [\n          // 添加子路由\n          {\n            path: ''TestToolConvert'',\n            name: ''TestToolConvert'',\n            component: () => {\n              return import(''@/views/page/testTool/TestToolConvert.vue'')\n            }\n          }\n        ]\n      }\n    ]\n  },\n  { path: ''/'', redirect: { name: ''home'' } },\n]\nexport default routes\n```\n\n### 创建路由实例\n\n新建router/index.ts\n\n```csharp\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { createRouter, createWebHistory, _RouteRecordBase } from ''vue-router''\nimport routes from ''./routes''\nimport NProgress from ''nprogress''\n\nconst router = createRouter({\n  history: createWebHistory(), //历史模式会制造页面刷新\n  routes\n})\n// 页面切换之前取消上一个路由中未完成的请求\nrouter.beforeEach((_to: any, _from: any, next: () => void) => {\n  NProgress.start()\n  next()\n})\nrouter.afterEach(() => {\n  // 进度条\n  NProgress.done()\n})\nexport default router\n\n```\n\n### 路由注册\n\nmain.ts引入\n\n```tsx\n//main.ts引入\nimport router from ''./router/index''\nconst app = createApp(App)\napp.use(router)\n```\n\n### 路由出口\n\n```vue\n<template>\n  <div id=\"app\">\n    <router-view v-slot=\"{ Component }\">\n      <keep-alive>\n        <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n      </keep-alive>\n      <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n    </router-view>\n  </div>\n</template>\n```\n\n',2,155,787,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(265,'路由导航流程','1. 导航被触发\n2. 在失活的组件里调用  beforeRouteLeave 守卫\n3. 调用全局 beforeEach 前置守卫\n4. 重用的组件调用 beforeRouteUpdate 守卫（2.2+）\n5. 路由配置调用 beforeEnter\n6. 解析异步路由组件\n7. 在被激活的组件里调用 beforeRouteEnter 守卫\n8. 调用全局的 beforeResolve 守卫（2.5+）\n9. 导航被确认\n10. 调用全局的 afterEach\n11. 触发 DOM 更新\n12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入',2,155,789,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(266,'Hash路由模式','hash 历史模式是用 `createWebHashHistory()` 创建的不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHashHistory } from ''vue-router''\nconst router = createRouter({\n  history: createWebHashHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n',2,155,791,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(267,'history路由模式','history:用 `createWebHistory()` 创建 HTML5 模式，推荐使用这个模式不会有历史，不会制造页面刷新\n\n```tsx\nimport { createRouter, createWebHistory } from ''vue-router''\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes: [\n    //...\n  ],\n})\n```\n\n',2,155,790,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(268,'router-link','router-link 组件默认为a标签，在vue router 3.x中，可通过tag属性更改标签名，event属性更改事件名\n\n在vue router 4.x中，这两个属性已被删除，通过作用域插槽（子组件给父组件传值的插槽）实现自定义导航标签\n\n示例：将导航标签改为div，且需双击触发\n\nactive-class\n\n```vue\n<router-link v-slot=\"{ href, navigate, isExactActive }\" to=\"/home/user\" custom>\n  <div :class=\"{ active: isExactActive }\" :href=\"href\" @dblclick=\"navigate\">跳转user</div>\n</router-link>\n```\n\n```vue\n<!-- 字符串 -->\n<router-link to=\"home\">Home</router-link>\n\n<!-- 使用 v-bind 的 JS 表达式 -->\n<router-link v-bind:to=\"''home''\">Home</router-link>\n\n<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->\n<router-link :to=\"''home''\">Home</router-link>\n\n<!-- 同上 -->\n<router-link :to=\"{ path: ''home'' }\">Home</router-link>\n\n<!-- 命名的路由 -->\n<router-link :to=\"{ name: ''user'', params: { userId: 123 }}\">User</router-link>\n\n<!-- 带查询参数，下面的结果为 /register?plan=private -->\n<router-link :to=\"{ path: ''register'', query: { plan: ''private'' }}\">Register</router-link>\n```\n\n设置 replace 属性,点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录。\n\n```html\n<router-link :to=\"{ path: ''/abc''}\" replace></router-link>\n```\n\n设置 append 属性后，则在当前 (相对) 路径前添加其路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b\n\n```html\n<router-link :to=\"{ path: ''relative/path''}\" append></router-link>\n```\n\nexact-active-class\n\n配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代。\n\n```html\n<p>\n   <router-link v-bind:to = \"{ path: ''/route1''}\" exact-active-class = \"_active\">Router Link 1</router-link>\n   <router-link v-bind:to = \"{ path: ''/route2''}\" tag = \"span\">Router Link 2</router-link>\n</p>\n```\n\n',2,155,798,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(276,'useRoute/useRouter','```html\n<script setup>\n  import { useRoute, useRouter } from ''vue-router''\n  const route = useRoute()  // 路由信息\n  console.log(route.query)\n  const router = useRouter()// 路由跳转\n  router.push(''/newPage'')\n</script>\n```\n\n',2,155,799,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(277,'路由导航守卫','```html\n<script setup>\n  import { onBeforeRouteLeave, onBeforeRouteUpdate } from ''vue-router''\n\n  // 添加一个导航守卫，在当前组件将要离开时触发。\n  onBeforeRouteLeave((to, from, next) => {\n    next()\n  })\n\n  // 添加一个导航守卫，在当前组件更新时触发。\n  // 在当前路由改变，但是该组件被复用时调用。\n  onBeforeRouteUpdate((to, from, next) => {\n    next()\n  })\n</script>\n```\n\n',2,155,807,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(278,'全局前置守卫','在路由跳转前触发，可在执行 next 方法前做登录判断，未登陆用户跳转到登录页\n\n```js\nconst router = new createRouter({})\n//to: 即将要进入的目标 用一种标准化的方式\n//from: 当前导航正要离开的路由 用一种标准化的方式\nrouter.beforeEach((to, from, next) => {\n    if (to.path === ''/login'') {\n      //在登录页做清除操作，如清除token等\n    }\n    \n    if (!localStorage.getItem(''token'') && to.path !== ''/login'') {\n      // 未登陆且访问的不是登录页，重定向到登录页面\n      return ''/login'';\n    }\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n  // 返回 false 以取消导航\n  return false\n})\n\n// 含有异步操作的方法\nrouter.beforeEach(async (to, from, next) => {\n  const res = await fetch(\"****\");\n  // to: 跳转到哪个路由\n  // from: 从哪个路由跳转过来\n  // next: 跳转函数，可以跳转到具体的 url\n});\n```\n\n',2,155,795,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(279,'全局解析守卫','与 beforeEach 类似，也是路由跳转前触发，区别是还需在`所有组件内守卫和异步路由组件被解析之后`，也就是在组件内 beforeRouteEnter 之后被调用。\n\n```js\nrouter.beforeResolve((to, from, next) => {\n  ...\n  // 必须执行 next 方法来触发路由跳转 \n  next() \n})\n```\n',2,155,806,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(280,'全局后置钩子','和守卫不同的是，这些钩子不会接受 `next` 函数也不会改变导航本身。它们对于分析、更改页面标题、声明页面等辅助功能以及许多其他事情都很有用。\n\n```js\nrouter.afterEach((to, from) => {\n  // ...\n})\n```\n\n',2,155,743,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(281,'路由独享守卫','使用场景：部分页面不需要登录，部分页面需要登录才能访问\n\n可在路由配置上直接定义 beforeEnter\n\n```js\nconst auth = () => {\n  if (!localStorage.getItem(\"token\")) {\n    // 未登陆,重定向到登录页面\n    return \"/login\";\n  }\n};\n\nconst routes = [\n  ...{\n    path: \"/home\",\n    component: () => import(\"@/pages/home.vue\"),\n    redirect: \"/home/user\",\n    children: [\n      {\n        path: \"/home/user\",\n        component: () => import(\"@/pages/user.vue\"),\n      },\n      {\n        path: \"/home/manage\",\n        component: () => import(\"@/pages/manage.vue\"),\n        beforeEnter: auth, //路由独享守卫\n      },\n    ],\n  },\n];\n\n```\n\n',2,155,796,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(282,'组件内的守卫','使用情景：预防用户在还未保存修改前突然离开。该导航可以通过返回 false 来取消\n\n组件内可直接定义如下路由导航守卫\n\n```vue\n<script setup lang=\"ts\">\nimport { onBeforeRouteLeave } from ''vue-router'';\n\n// 与 beforeRouteLeave 相同，无法访问 `this`\nonBeforeRouteLeave((to, from) => {\n  const answer = window.confirm(''确定离开吗'');\n  // 取消导航并停留在同一页面上\n  if (!answer) return false;\n});\n</script>\n```\n\n',2,155,797,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(284,'路由传参','query传参\n\n```vue\n//页面传参\n<script setup lang=\"ts\">\nimport { useRouter } from ''vue-router'';\n\nconst router = useRouter();\n\nconst handleManage = () => {\n  router.push({\n    path: ''/home/manage'',\n    query: {\n      plan: ''123'', // t: +new Date()\n    },\n  });\n};\n</script>\n\n//页面接参\n<script setup lang=\"ts\">\nimport { useRoute } from ''vue-router'';\nconst route = useRoute();\n\nconsole.log(route.query.plan); //query接参 \n</script>\n\n```\n\n',2,155,792,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(285,'无参跳转','```js\n// 字符串\nrouter.push(''home'')\n// 对象\nrouter.push({ path: ''home'' })\n```\n\n',2,155,789,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(286,'带参跳转','```js\n/**\n * 传值跳转\n * @param path 路径\n * @param value 值\n */\nconst routerId = async (path: string, value: number | string) => {\n  await router.push({\n    path: path,\n    query: {\n      id: value,\n      t: +new Date()\n    }\n  })\n}\n```\n获取跳转过来的参数\n\n```tsx\nimport { useRoute } from ''vue-router''\n const route = useRoute()\n const state = reactive({\n      id: route.query.id,\n })\n```\n',2,155,789,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(287,'刷新当前路由','```js\n//+new Date()保证每次点击路由的query项都是不一样的，确保会重新刷新view\nconst routers = async (path: string) => {\n  await router.push({\n    path: path,\n    query: {\n      t: +new Date()\n    }\n  })\n}\n```\n\n',2,155,800,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(289,'router.go(n)','这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 `window.history.go(n)`。\n\n```js\n// 在浏览器记录中前进一步，等同于 history.forward()\nrouter.go(1)\n// 后退一步记录，等同于 history.back()\nrouter.go(-1)\n// 前进 3 步记录\nrouter.go(3)\n// 如果 history 记录不够用，那就默默地失败呗\nrouter.go(-100)\nrouter.go(100)\n```\n\n',2,7,802,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(290,'子路由','```html\n<a-menu-item key=\"1\" @click=\"Routers(''/Admin-index/ArticleTable'')\">\n文章列表</a-menu-item>\n<router-view></router-view>\n```\n\n路由配置\n\n```tsx\n{\n  path: ''/Admin-index'',\n  name: ''Admin-index'',\n  component: () => import(''@/views/admin/index/index.vue''),\n  children: [   // 添加子路由\n    {\n      path: ''ArticleTable'',\n      name: ''ArticleTable'',\n      component: () => import(''@/views/admin/article/ArticleTable.vue''),\n    },\n  ]\n},\n```\n\n',2,155,803,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(291,'404页面','修改router/routes.ts\n\n\\* 代表通配符，若放在任意路由前，会被先匹配，导致跳转到 404 页面，所以需将如下配置置于最后。\n\n```js\nconst routes = [\n  ...//添加（放在最后）\n  {\n    path: \"/:pathMatch(.*)*\",\n    component: () => import(\"@/pages/notFound.vue\"),\n  },\n  {\n  path: ''*'',\n  name: ''404''\n  component: () => import(''./404.vue'')  \n  }\n];\n```\n\n',2,155,788,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(292,'路由对象/属性类型报错','引入 _RouteRecordBase 定义 hidden\n\n```js\nimport {\n    createRouter,\n    createWebHashHistory,\n    RouteRecordRaw,\n    _RouteRecordBase \n} from ''vue-router''\n\ndeclare module ''vue-router''{\n    interface _RouteRecordBase {\n        hidden?: boolean | string | number\n    }\n}\n\nconst routes: Array<RouteRecordRaw> = [\n {\n        path: ''/'',\n        redirect: ''/login'',\n    },\n    {\n        path: ''/login'',\n        name:''login'',\n       	hidden: false,\n        component: () => import(''@/views/login.vue''), // 懒加载组件\n    }\n]\n\n```\n',2,155,804,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(294,'CSS文件名','全部采用小写方式， 优先选择单个单词命名，多个单词命名以**短横线**分隔。\n\n```lua\n|- normalize.less\n|- base.less\n|- date-picker.scss\n|- input-number.scss\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(295,'单例组件名','只拥有单个活跃实例的组件应该以 `The` 前缀命名，以示其唯一性。\n\n这不意味着组件只可用于一个单页面，而是*每个页面*只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，*只是目前*在每个页面里只使用一次。\n\n比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。\n\n```\ncomponents/\n|- TheHeading.vue\n|- TheSidebar.vue\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(296,'基础组件名','> 基础组件：不包含业务，独立、具体功能的基础组件，比如**日期选择器**、**模态框**等。这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。\n\n特定样式和约定的基础组件(展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。**基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。**\n\n```\ncomponents/\n|- BaseButton.vue\n|- BaseTable.vue\n|- BaseIcon.vue\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(297,'业务组件','> 业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。\n\n**掺杂了复杂业务的组件（拥有自身 `data`、`prop` 的相关处理）即业务组件**应该以 `Custom` 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。\n\n```\ncomponents/\n|- CustomCard.vue\n```\n\n\n\n\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(298,'紧密耦合的组件名','**和父组件紧密耦合的子组件应该以父组件名作为前缀命名。**  因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。\n\n```\ncomponents/\n|- TodoList.vue\n|- TodoListItem.vue\n|- TodoListItemButton.vue\n```\n\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(299,'变量命名','- 命名方法：camelCase\n- 命名规范：类型 + 对象描述或属性的方式\n\n``` js\nlet tableTitle = \"LoginTable\"\nlet mySchool = \"我的学校\"\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(300,'常量命名','- 命名方法：全部大写下划线分割\n- 命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词\n\n```javascript\nconst MAX_COUNT = 10\nconst URL = ''http://test.host.com''\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(301,'方法命名','- 命名方法：camelCase\n- 命名规范：统一使用动词或者动词 + 名词形式\n\n```js\n// 1、普通情况下，使用动词 + 名词形式\njumpPage、openCarInfoDialog\n// 2、请求数据方法，以 data 结尾\ngetListData、postFormData\n// 3、单个动词的情况\ninit、refresh\n```\n\n| 动词 | 含义                         | 返回值                                                  |\n| ---- | ---------------------------- | ------------------------------------------------------- |\n| can  | 判断是否可执行某个动作 (权 ) | 函数返回一个布尔值。true：可执行；false：不可执行；     |\n| has  | 判断是否含有某个值           | 函数返回一个布尔值。true：含有此值；false：不含有此值； |\n| is   | 判断是否为某个值             | 函数返回一个布尔值。true：为某个值；false：不为某个值； |\n| get  | 获取某个值                   | 函数返回一个非布尔值                                    |\n| set  | 设置某个值                   | 无返回值、返回是否设置成功或者返回链式对象              |\n\n\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(302,'指令缩写(:@#)','- **用 `:` 表示 `v-bind:`**\n- **用 `@` 表示 `v-on:`**\n- **用 `#` 表示 `v-slot:`**',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(303,'img默认设置','#### 让图片元素隐藏\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.style.display=''none''\"/>\n1\n```\n\n#### 设置默认图\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.src=''默认图片的url地址''\"/>\n1\n```\n\n第二种方式为常用的方法，但当onerror中设置的图片路径也不存在时就会导致浏览器一直加载这个图，造成堆栈溢出错误。\n所以，通常在后面加上 **this.οnerrοr=null;** 保证onerror里的事件只执行一次。所以完整的写法为：\n\n```html\n<img src=\"图片的url地址\" alt=\"图片XX\" onerror=\"this.src=''默认图片的url地址'';this.οnerrοr=null\"/>\n```\n\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(306,'scss简介','- [Sass 官方文档](https://sass-lang.com/documentation) *(sass-lang.com)*\n- [Sass 中文文档](https://www.sass.hk/docs/) *(sass.hk)*\n\nSass 是一种 CSS 的预编译语言\n\n```bash\n$ npm install -g sass\n```\n\n在 Node.js 环境中使用 Sass\n\n```bash\n$ sass source/index.scss build/index.css\n$ sass --watch input.scss output.css\n$ sass --watch app/sass:public/css\n```\n\n\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(307,'注释','```\n/*\n 多行注释\n 块注释\n 块注释\n*/\n\n// 单行注释\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(308,'字符串插值','``` css\n$wk: -webkit-;\n.rounded-box {\n  #{$wk}border-radius: 4px;\n}\n```\n\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(309,'模块(片段)','```css\n// _base.scss\n$font-stack:    Helvetica, sans-serif;\n$primary-color: #333;\n注意以下划线开头的 Sass 文件\n\n// styles.scss\n@use ''base'';\n\n.inverse {\n  background-color: base.$primary-color;\n  color: white;\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(310,'@import','```css\n@import ''./other_sass_file'';\n@import ''/code'', ''lists'';\n// 纯 CSS @imports\n@import \"theme.css\";\n@import url(theme);\n```\n\n`.sass` 或 `.sass` 扩展名是可选的。',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(311,'混合(Mixins默认值)','```css\n@mixin pad($n: 10px) {\n    padding: $n;\n}\nbody {\n    @include pad(15px);\n}\n```\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(313,'混合(Mixins默认变量)',' ```css\n$default-padding: 10px;\n@mixin pad($n: $default-padding) {\n  padding: $n;\n}\nbody {\n  @include pad(15px);\n}\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(314,'@media','```css\n/* 超小设备 (手机, 600px 以下屏幕设备) */\n@media only screen and (max-width: 600px) {   \n}\n/* 小设备 (平板电脑和大型手机，600 像素及以上) */\n@media only screen and (min-width: 600px) { \n}\n/* 中型设备（平板电脑，768 像素及以上） */\n@media only screen and (min-width: 768px) {\n} \n/* 大型设备（笔记本电脑/台式机，992 像素及以上） */\n@media only screen and (min-width: 992px) {\n} \n/* 超大型设备（大型笔记本电脑和台式机，1200 像素及以上） */\n@media only screen and (min-width: 1200px) {\n}\n```\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(315,'循环(each嵌套)','\n```scss\n$icons: (\"eye\": \"\\f112\", \"start\": \"\\f12e\");\n\n@each $name, $glyph in $icons {\n  .icon-#{$name}:before {\n    display: inline-block;\n    font-family: \"Icon Font\";\n    content: $glyph;\n  }\n}\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(316,'条件(if)','```css\n@mixin avatar($size, $circle: false) {\n  width: $size;\n  height: $size;\n  @if $circle {\n    border-radius: $size / 2;\n  }\n}\n.square-av {\n  @include avatar(100px, $circle: false);\n}\n.circle-av {\n  @include avatar(100px, $circle: true);\n}\n```',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(317,'Map','\n```css\n$map: (key1: value1, key2: value2, key3: value3);\nmap-get($map, key1)\n```\n\n',10,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(318,'基础指令','指令是带有 v- 前缀的特殊属性。\n\n指令用于在表达式的值改变时，将某些行为应用到 DOM 上。',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(319,'v-else-if','```html\n<div v-if=\"type === ''A''\">\n  A\n</div>\n<div v-else-if=\"type === ''B''\">\n  B\n</div>\n<div v-else-if=\"type === ''C''\">\n  C\n</div>\n<div v-else>\n  Not A/B/C\n</div>\n```\n',2,3,594,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(320,'基础类型','JavaScript 的类型分为两种：原始数据类型（Primitive data types）和对象类型（Object types）。\n\n- 常用：boolean、number、string、array、enum、any、void\n- 不常用：tuple、null、undefined、never',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(321,'Boolean','布尔值是最基础的数据类型，在 TypeScript 中，使用 `boolean` 定义布尔值类型：\n\n\n```ts\nlet isDone: boolean = false;\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(322,'Number','双精度 64 位浮点值。它可以用来表示整数和分数。\n\n\n```ts\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// ES6 中的二进制表示法\nlet binaryLiteral: number = 0b1010;\n// ES6 中的八进制表示法\nlet octalLiteral: number = 0o744;\nlet notANumber: number = NaN;\nlet infinityNumber: number = Infinity;\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(323,'任意类型(Any)','声明为 any 的变量可以赋予任意类型的值。\n\n```tsx\nlet myFavoriteNumber: any = ''seven'';\nmyFavoriteNumber = 7;\n```\n\n\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(324,'元组[]','数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。\n\n定义一对值分别为 `string` 和 `number` 的元组：\n\n```tsx\nlet x: [string, number];\nx = [''Runoob'', 1];    // 运行正常\nx = [1, ''Runoob''];    // 报错\nconsole.log(x[0]);    // 输出 Runoob\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(325,'访问元组[]','元组中元素使用索引来访问，第一个元素的索引值为 0，第二个为 1，以此类推第 n 个为 n-1，语法格式如下:\n\n```\ntuple_name[index]\n```\n\n以下实例定义了元组，包含了数字和字符串两种类型的元素：\n\n```tsx\nvar mytuple = [10,\"Runoob\"]; // 创建元组\nconsole.log(mytuple[0]) \nconsole.log(mytuple[1])\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(326,'元组运算[]','我们可以使用以下两个函数向元组添加新元素或者删除元素：\n\n- push() 向元组添加元素，添加在最后面。\n- pop() 从元组中移除元素（最后一个），并返回移除的元素。\n\n```tsx\nvar mytuple = [10,\"Hello\",\"World\",\"typeScript\"]; \nconsole.log(\"添加前元素个数：\"+mytuple.length)    // 返回元组的大小\n \nmytuple.push(12)                                    // 添加到元组中\nconsole.log(\"添加后元素个数：\"+mytuple.length) \nconsole.log(\"删除前元素个数：\"+mytuple.length) \nconsole.log(mytuple.pop()+\" 元素从元组中删除\") // 删除并返回删除的元素\n        \nconsole.log(\"删除后元素个数：\"+mytuple.length)\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(327,'更新元组[]','元组是可变的，这意味着我们可以对元组进行更新操作：\n\n```js\nvar mytuple = [10, \"Runoob\", \"Taobao\", \"Google\"]; // 创建一个元组\nconsole.log(\"元组的第一个元素为：\" + mytuple[0]) \n \n// 更新元组元素\nmytuple[0] = 121     \nconsole.log(\"元组中的第一个元素更新为：\"+ mytuple[0])\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(328,'解构元组[]','我们也可以把元组元素赋值给变量，如下所示：\n\n``` js\nvar a =[10,\"Runoob\"] \nvar [b,c] = a \nconsole.log( b )    \nconsole.log( c )\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(329,'数组(Array)','Array数组对象是使用单独的变量名来存储一系列的值。\n#### 数组定义\n\n简单的方法使用「类型 + 方括号」来表示数组：\n\n```js\ninterface IItem {\n  id: number;\n  name: string;\n  isGod: boolean;\n}\nconst objectArr: IItem[] = [{ id: 1, name: ''俊劫'', isGod: true }];\n// or\nconst objectArr: Array<IItem> = [{ id: 1, name: ''俊劫'', isGod: true }];\nconst numberArr: number[] = [1, 2, 3];\nconst arr: (number | string)[] = [1, \"string\", 2];\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(330,'忽略不要的元素(Array)','如果需要从数组或元组中取出某个或某几个特定的元素的话，可以在解构语句中插入额外的逗号，忽略掉不需要的元素：\n\n```tsx\nconst [a, , b] = [1, 5, 10];  // a <- 1, b <- 10\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(331,'数组泛型(Array)','我们也可以使用数组泛型（Array Generic） `Array<elemType>` 来表示数组：\n\n```ts\nlet fibonacci: Array<number> = [1, 1, 2, 3, 5];\nlet arr2:Array<string> = [\"1\",\"2\"]\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(332,'联合类型数组(Array)','```js\nlet arr:(number | string)[];\n// 表示定义了一个名称叫做arr的数组, \n// 这个数组中将来既可以存储数值类型的数据, 也可以存储字符串类型的数据\narr3 = [1, ''b'', 2, ''c''];\n\nconst arr: (number | string)[] = [1, \"string\", 2];\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(333,'交叉&类型(Array)','- 交叉类型：由多个类型组成，用 `&` 连接\n\n```tsx\ninterface Waiter {\n  anjiao: boolean;\n  say: () => {};\n}\n\ninterface Teacher {\n  anjiao: boolean;\n  skill: () => {};\n}\n\n// 交叉类型 \n// 同名类型会进行合并，同名基础类型属性的合并返回：never\n// 同名非基础类型属性可以正常合并\nfunction judgeWho(jishi: Waiter & Teacher) {}\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(334,'指定对象成员的数组(Array)','```js\n// interface是接口,后面会讲到\ninterface Arrobj{\n    name:string,\n    age:number\n}\nlet arr3:Arrobj[]=[{name:''jimmy'',age:22}]\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(335,'数组解构(Array)','```js\nlet x: number, let y: number ,let z: number;\nlet five_array = [0,1,2,3,4];\n[x,y,z] = five_array;\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(336,'数组展开运算符(Array)','```javascript\nlet two_array = [0,1];\nlet five_array = [...two_array,2,3,4];\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(337,'数组循环(Array)','```javascript\nlet colors: string[] = [\"red\", \"green\", \"blue\"];\nfor(let i in colors) {\n  console.log(i);\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(338,'多维数组(Array)','一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。\n\n最简单的多维数组是二维数组，定义方式如下：\n\n``` js\nvar arr_name:datatype[][]=[ [val1,val2,val3],[v1,v2,v3] ]\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(339,'数组.concat()','连接两个或更多的数组，并返回结果。\n\n```tsx\nvar alpha = [\"a\", \"b\", \"c\"]; \nvar numeric = [1, 2, 3];\n\nvar alphaNumeric = alpha.concat(numeric); \nconsole.log(\"alphaNumeric : \" + alphaNumeric );    // a,b,c,1,2,3   \n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(340,'数组.every()','检测数值元素的每个元素是否都符合条件。\n\n```tsx\nfunction isBigEnough(element, index, array) { \n        return (element >= 10); \n}        \nvar passed = [12, 5, 8, 130, 44].every(isBigEnough); \nconsole.log(\"Test Value : \" + passed ); // false\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(341,'数组.filter()',' 检测数值元素，并返回符合条件所有元素的数组。\n\n```tsx\nfunction isBigEnough(element, index, array) { \n   return (element >= 10); \n}         \nvar passed = [12, 5, 8, 130, 44].filter(isBigEnough); \nconsole.log(\"Test Value : \" + passed ); // 12,130,44\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(342,'数组.forEach()','数组每个元素都执行一次回调函数。\n\n```tsx\nlet num = [7, 8, 9]; num.forEach(function (value) {\n    console.log(value); });\n`编译成 JavaScript 代码：`\nvar num = [7, 8, 9]; num.forEach(function (value) {  \n    console.log(value);  \n    // 7   8   9 });\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(343,'数组.indexOf()','搜索数组中的元素，并返回它所在的位置。如果搜索不到，返回值 -1，代表没有此项。\n\n```tsx\nvar index = [12, 5, 8, 130, 44].indexOf(8);\nconsole.log(\"index is : \" + index );  // 2\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(344,'数组.join()','把数组的所有元素放入一个字符串。         \n\n```tsx\nvar arr = new Array(\"Google\",\"Runoob\",\"Taobao\"); \n          \nvar str = arr.join(); \nconsole.log(\"str : \" + str );  // Google,Runoob,Taobao\n          \nvar str = arr.join(\", \"); \nconsole.log(\"str : \" + str );  // Google, Runoob, Taobao\n          \nvar str = arr.join(\" + \"); \nconsole.log(\"str : \" + str );  // Google + Runoob + Taobao\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(345,'数组.lastIndexOf()','返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。\n\n```tsx\nvar index = [12, 5, 8, 130, 44].lastIndexOf(8); \nconsole.log(\"index is : \" + index );  // 2\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(346,'数组.map()','通过指定函数处理数组的每个元素，并返回处理后的数组。\n\n```tsx\nvar numbers = [1, 4, 9]; \nvar roots = numbers.map(Math.sqrt); \nconsole.log(\"roots is : \" + roots );  // 1,2,3\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(347,'数组.pop()','删除数组的最后一个元素并返回删除的元素。              \n\n```tsx\nvar numbers = [1, 4, 9]; \n          \nvar element = numbers.pop(); \nconsole.log(\"element is : \" + element );  // 9\n          \nvar element = numbers.pop(); \nconsole.log(\"element is : \" + element );  // 4\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(348,'数组.push()','向数组的末尾添加一个或更多元素，并返回新的长度。      \n\n```tsx\nvar numbers = new Array(1, 4, 9); \nvar length = numbers.push(10); \nconsole.log(\"new numbers is : \" + numbers );  // 1,4,9,10 \nlength = numbers.push(20); \nconsole.log(\"new numbers is : \" + numbers );  // 1,4,9,10,20\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(349,'数组.reduce()','将数组元素计算为一个值（从左到右）。              \n\n```tsx\nvar total = [0, 1, 2, 3].reduce(function(a, b){ return a + b; }); \nconsole.log(\"total is : \" + total );  // 6\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(350,'数组.reduceRight()','将数组元素计算为一个值（从右到左）。        \n\n``` tsx\nvar total = [0, 1, 2, 3].reduceRight(function(a, b){ return a + b; }); \nconsole.log(\"total is : \" + total );  // 6\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(351,'数组.reverse()','反转数组的元素顺序。                             \n\n```tsx\nvar arr = [0, 1, 2, 3].reverse(); \nconsole.log(\"Reversed array is : \" + arr );  // 3,2,1,0\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(352,'数组.shift()','删除并返回数组的第一个元素。                          \n\n```tsx\nvar arr = [10, 1, 2, 3].shift(); \nconsole.log(\"Shifted value is : \" + arr );  // 10\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(353,'数组.slice()','选取数组的的一部分，并返回一个新数组。             \n\n```tsx\nvar arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"]; \nconsole.log(\"arr.slice( 1, 2) : \" + arr.slice( 1, 2) );  // mango\nconsole.log(\"arr.slice( 1, 3) : \" + arr.slice( 1, 3) );  // mango,banana\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(354,'数组.some()','检测数组元素中是否有元素符合指定条件。             \n\n```tsx\nfunction isBigEnough(element, index, array) { \n   return (element >= 10);     \n} \nvar retval = [2, 5, 8, 1, 4].some(isBigEnough);\nconsole.log(\"Returned value is : \" + retval );  // false\n          \nvar retval = [12, 5, 8, 1, 4].some(isBigEnough); \nconsole.log(\"Returned value is : \" + retval );  // true\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(355,'数组.sort()','对数组的元素进行排序。                                \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); \nvar sorted = arr.sort(); \nconsole.log(\"Returned string is : \" + sorted );  // banana,mango,orange,sugar\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(356,'数组.splice()','从数组中添加或删除元素。                           \n\n```tsx\nvar arr = [\"orange\", \"mango\", \"banana\", \"sugar\", \"tea\"];  \nvar removed = arr.splice(2, 0, \"water\");  \nconsole.log(\"After adding 1: \" + arr );    // orange,mango,water,banana,sugar,tea \nconsole.log(\"removed is: \" + removed); \n          \nremoved = arr.splice(3, 1);  \nconsole.log(\"After removing 1: \" + arr );  // orange,mango,water,sugar,tea \nconsole.log(\"removed is: \" + removed);  // banana\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(357,'数组.toString()','把数组转换为字符串，并返回结果。                \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\");         \nvar str = arr.toString(); \nconsole.log(\"Returned string is : \" + str );  // orange,mango,banana,sugar\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(358,'数组.unshift()','向数组的开头添加一个或更多元素，并返回新的长度。   \n\n```tsx\nvar arr = new Array(\"orange\", \"mango\", \"banana\", \"sugar\"); \nvar length = arr.unshift(\"water\"); \nconsole.log(\"Returned array is : \" + arr );  // water,orange,mango,banana,sugar \nconsole.log(\"Length of the array is : \" + length ); // 5\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(359,'空值(Void)','JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 `void` 表示没有任何返回值的函数：\n\n```ts\nfunction alertName(): void {\n    alert(''My name is Tom'');\n}\n```\n\n声明一个 `void` 类型的变量没有什么用，因为你只能将它赋值为 `undefined` 和 `null`（只在 --strictNullChecks 未指定时）：\n\n```ts\nlet unusable: void = undefined;\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(360,'Null和Undefined','可以使用 `null` 和 `undefined` 来定义这两个原始数据类型：\n\n```ts\nlet u: undefined = undefined;\nlet n: null = null;\n```\n\n与 `void` 的区别是，`undefined` 和 `null` 是所有类型的子类型。也就是说 `undefined` 类型的变量，可以赋值给 `number` 类型的变量：\n\n```ts\n// 这样不会报错\nlet num: number = undefined;\n// 这样也不会报错\nlet u: undefined;\nlet num: number = u;\n```\n而 `void` 类型的变量不能赋值给 `number` 类型的变量：\n\n```ts\nlet u: void;\nlet num: number = u;\n// Type ''void'' is not assignable to type ''number''.\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(361,'枚举(Enum)','提高代码可维护性，统一维护某些枚举值，避免 `JiShi === 1`这种魔法数字。`JiShi === JiShiEnum.BLUEJ`这样写，老板一眼就知道我想找谁。\n\n```javascript\n// 初始值默认为 0\nenum JiShiEnum {\n     REDJ,\n     BLUEJ,\n}\n// 设置初始值\nenum JiShiEnum {\n     REDJ = 8,\n     BLUEJ,\n}\nconst jishi: JiShiEnum = JiShiENUM.BLUE\nconsole.log(jishi) // 9\n// 字符串枚举，每个都需要声明\nenum JiShiEnum {\n     REDJ = \"8号\",\n     BLUEJ = \"9号\",\n}\n\n```\n\n默认情况下，初始值为 0，其余的成员会从 1 开始自动增长。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(362,'常数枚举(Enum)','常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。\n\n常数枚举是使用 `const enum` 定义的枚举类型：\n\n```ts\nconst enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n假如包含了计算成员，则会在编译阶段报错：\n\n```ts\nconst enum Color {Red, Green, Blue = \"blue\".length};\n// index.ts(1,38): error TS2474: In ''const'' enum declarations member initializer must be constant expression.\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(363,'外部枚举(Enum)','`declare` 定义的类型只会用于编译时的检查，编译结果中会被删除。\n\n外部枚举（Ambient Enums）是使用 `declare enum` 定义的枚举类型：\n\n```ts\ndeclare enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n上例的编译结果是：\n\n```js\nvar directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n外部枚举与声明语句一样，常出现在声明文件中。\n\n同时使用 `declare` 和 `const` 也是可以的：\n\n```ts\ndeclare const enum Directions {\n    Up,\n    Down,\n    Left,\n    Right\n}\nlet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right];\n```\n\n编译结果：\n```js\nvar directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */];\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(364,'Never','`never` 类型表示的是那些永不存在的值的类型。 例如，`never` 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。\n\n```javascript\n// 返回never的函数必须存在无法达到的终点\nfunction error(message: string): never {\n    throw new Error(message);\n}\n\n// 返回never的函数必须存在无法达到的终点\nfunction infiniteLoop(): never {\n    while (true) {}\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(365,'类型断言','通过这种方式可以告诉编译器，”相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。\n\n类型断言有两种形式：\n\n- “尖括号”语法\n\n```javascript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (<string>someValue).length;\n```\n\n- as 语法\n\n```javascript\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length;\n```\n\n\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(366,'交叉类型(&)','交叉类型是将多个类型合并为一个类型, 表示\"并且\"的关系,用&连接多个类型, 常用于对象合并:\n\n其返回类型既要符合 `T` 类型也要符合 `U` 类型\n\n```tsx\n//1\ninterface A {a:number};\ninterface B {b:string};\n\nconst a:A = {a:1};\nconst b:B = {b:''1''};\nconst ab:A&B = {...a,...b};\n\n//2\ninterface Ant {\n    name: string;\n    weight: number;\n}\n\ninterface Fly {\n    flyHeight: number;\n    speed: number;\n}\n\n// 少了任何一个属性都会报错\nconst flyAnt: Ant & Fly = {\n    name: ''蚂蚁呀嘿'',\n    weight: 0.2,\n    flyHeight: 20,\n    speed: 1,\n};\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(367,'联合类型(|)','- 联合类型：某个变量可能是多个 interface 中的其中一个，用 `|` 分割\n\n  其返回类型为连接的多个类型中的任意一个\n\n```ts\nlet name: string | number;\nconsole.log(name.toString());\nname = 1;\nconsole.log(name.toFixed(2));\nname = \"hello\";\nconsole.log(name.length);\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(368,'类型别名','类型别名用来给一个类型起个新名字。\n\n```tsx\ntype Message = string | string[];\n\nlet greet = (message: Message) => {\n  // ...\n};\n}\n```\n上例中，我们使用 `type` 创建类型别名。\n类型别名常用于联合类型',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(369,'Unknown类型','就像所有类型都可以赋值给 `any`，所有类型也都可以赋值给 `unknown`。这使得 `unknown` 成为 TypeScript 类型系统的另一种顶级类型（另一种是 `any`）。下面我们来看一下 `unknown` 类型的使用示例：\n\n```typescript\nlet value: unknown;\n\nvalue = true; // OK\nvalue = 42; // OK\nvalue = \"Hello World\"; // OK\nvalue = []; // OK\nvalue = {}; // OK\nvalue = Math.random; // OK\nvalue = null; // OK\nvalue = undefined; // OK\nvalue = new TypeError(); // OK\nvalue = Symbol(\"type\"); // OK\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(370,'函数声明(Function)','两种常见的定义函数的方式\n+ 函数声明（Function Declaration）\n+ 和函数表达式（Function Expression）：\n\n```tsx\n// 函数声明（Function Declaration）\nfunction sum(x, y) {\n    return x + y;\n}\nasync function clickName(id: number) {\n ...\n}\n// 函数表达式（Function Expression）\nlet mySum = function (x, y) {\n    return x + y;\n};  \n```\n\n一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型定义较简单：\n\n```tsx\nfunction sum(x: number, y: number): number {\n    return x + y;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(371,'箭头函数(Function)','### 箭头函数(Function)\n\n在 TypeScript 的类型定义中，`=>` 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。\n\n```tsx\nmyBooks.forEach(() => console.log(''Done reading''));\n\nmyBooks.forEach(title => console.log(title));\n\nmyBooks.forEach((title, idx, arr) => \n  console.log(idx + ''-'' + title);\n);\n\nmyBooks.forEach((title, idx, arr) => {\n  console.log(idx + ''-'' + title);\n});\n```\n\n使用示例\n\n```javascript\n// 未使用箭头函数\nfunction Book() {\n  let self = this;\n  self.publishDate = 2016;\n  setInterval(function() {\n    console.log(self.publishDate);\n  }, 1000);\n}\n\n// 使用箭头函数\nfunction Book() {\n  this.publishDate = 2016;\n  setInterval(() => {\n    console.log(this.publishDate);\n  }, 1000);\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(372,'参数类型和返回类型(Function)','### 参数类型和返回类型(Function)\n\n```tsx\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(373,'函数类型(Function)','```tsx\nlet IdGenerator: (chars: string, nums: number) => string;\nfunction createUserId(name: string, id: number): string {\n  return name + id;\n}\nIdGenerator = createUserId;\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(374,'可选参数及默认参数(Function)','输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？\n\n与接口中的可选属性类似，用 `?` 表示可选的参数\n可选参数必须接在必需参数后面\n```tsx\n// 可选参数\nfunction createUserId(name: string, age?: number, \n  id: number): string {\n    return name + id;\n}\n\n// 默认参数\nfunction createUserId(name: string = ''Semlinker'', age?: number, \n  id: number): string {\n    return name + id;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(375,'剩余参数(Function)','有一种情况，我们不知道要向函数传入多少个参数，这时候我们就可以使用剩余参数来定义。\n\n使用 `...rest` 的方式获取函数中的剩余参数（rest 参数）\n\n```tsx\nfunction push(array, ...items) {\n  items.forEach(function(item) {\n    array.push(item);\n  });\n}\n\nlet a = [];\npush(a, 1, 2, 3);\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(376,' 匿名函数(Function)','### 匿名函数(Function)\n\n匿名函数是一个没有函数名的函数。\n\n匿名函数在程序运行时动态声明，除了没有函数名外，其他的与标准函数一样。\n\n我们可以将匿名函数赋值给一个变量，这种表达式就成为函数表达式。\n\n语法格式如下：\n\n```tsx\nvar res = function( [arguments] ) { ... }\n```\n\n#### 不带参数\n\n```tsx\nvar msg = function() {\nreturn \"hello world\"; \n} \nconsole.log(msg())\n```\n\n#### 带参数\n\n```tsx\nvar res = function(a:number,b:number) {\nreturn a*b;  \n}; \nconsole.log(res(12,2))\n```\n\n#### 匿名函数自调用\n\n匿名函数自调用在函数后使用 () 即可：\n\n```tsx\n(function () {   \nvar x = \"Hello!!\";      \nconsole.log(x)  \n})()\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(377,'重载','重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n\n使用重载定义多个 `reverse` 的函数类型：\n\n```ts\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string | void {\n    ///\n}\n```\n\n我们重复定义了多次函数 `reverse`，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。\n\n注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(378,'类(Class)','在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n### 类的概念\n\n这里对类相关的概念做一个简单的介绍。\n\n- 类（Class）：定义了一件事物的抽象特点，包含它的属性和方法\n- 对象（Object）：类的实例，通过 `new` 生成\n- 面向对象（OOP）的三大特性：封装、继承、多态\n- 封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据\n- 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性\n- 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 `Cat` 和 `Dog` 都继承自 `Animal`，但是分别实现了自己的 `eat` 方法。此时针对某一个实例，我们无需了解它是 `Cat` 还是 `Dog`，就可以直接调用 `eat` 方法，程序会自动判断出来应该如何执行 `eat`\n- 存取器（getter & setter）：用以改变属性的读取和赋值行为\n- 修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 `public` 表示公有属性或方法\n- 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现\n- 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(379,'定义类(Class)','```tsx\nclass Greeter {\n   static cname: string = ''Greeter''; // 静态属性\n   greeting: string; // 成员属行\n\n    //构造函数 会在对象创建时调用\n   constructor(message: string) { // 构造函数 - 执行初始化操作\n     this.greeting = message; //通过 this 向新建的对象中添加属性\n   }\n    static getClassName() { // 静态方法\n      return ''Class name is Greeter'';\n    }\n    greet() { // 成员方法\n      return \"Hello, \" + this.greeting;\n    }\n}\n//定义实例属性   需要通过对象的实例去访问\nlet greeter = new Greeter(\"world\");\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(380,'类的继承(Class)','使用 `extends` 关键字实现继承，子类中使用 `super` 关键字来调用父类的构造函数和方法。\n\n```tsx\nclass Cat extends Animal {\n  constructor(name) {\n     // 调用父类的 constructor(name)\n    super(name); \n    console.log(this.name);\n  }\n  sayHi() {\n    return ''Meow, '' + super.sayHi(); // 调用父类的 sayHi()\n  }\n}\n\nlet c = new Cat(''Tom''); // Tom\nconsole.log(c.sayHi()); // Meow, My name is Tom\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(381,'方法重写(Class)','类继承后，子类可以对父类的方法重新定义，这个过程称之为方法的重写。\n\n其中 super 关键字是对父类的直接引用，该关键字可以引用父类的属性和方法。\n\n```tsx\nclass PrinterClass { \n   doPrint():void {\n      console.log(\"父类的 doPrint() 方法。\") \n   } \n} \nclass StringPrinter extends PrinterClass { \n   doPrint():void { \n      super.doPrint() // 调用父类的函数\n      console.log(\"子类的 doPrint()方法。\")\n   } \n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(382,'属性存取器(Class)','- 对于一些不希望被任意修改的属性，可以将其设置为 `private`，直接将其设置为 `private` 将导致无法再通过对象修改其中的属性\n\n使用 getter 和 setter 可以改变属性的赋值和读取行为：\n\n```js\nclass Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  get name() {\n    return ''Jack'';\n  }\n  set name(value) {\n    console.log(''setter: '' + value);\n  }\n}\n\nlet a = new Animal(''Kitty''); // setter: Kitty\na.name = ''Tom''; // setter: Tom\nconsole.log(a.name); // Jack\n```',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(383,'静态方法(Class)','使用 `static` 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：\n\n```tsx\nclass Animal {\n  static isAnimal(a) {\n    return a instanceof Animal;\n  }\n}\n\nlet a = new Animal(''Jack'');\nAnimal.isAnimal(a); // true\na.isAnimal(a); // TypeError: a.isAnimal is not a function\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(384,'实例属性(Class)','ES6 中实例的属性只能通过构造函数中的 `this.xxx` 来定义，ES7 提案中可以直接在类里面定义：\n\n```js\nclass Animal {\n  name = ''Jack'';\n\n  constructor() {\n    // ...\n  }\n}\n\nlet a = new Animal();\nconsole.log(a.name); // Jack\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(385,'静态属性(Class)','ES7 提案中，可以使用 `static` 定义一个静态属性：\n\n```tsx\nclass Animal {\n  static num = 42;\n\n  constructor() {\n    // ...\n  }\n}\n\nconsole.log(Animal.num); // 42\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(386,'类和接口','类可以实现接口，使用关键字 implements，并将 interest 字段作为类的属性使用。\n\n以下实例红 AgriLoan 类实现了 ILoan 接口：\n\n```tsx\ninterface ILoan { \n   interest:number \n} \nclass AgriLoan implements ILoan { \n   interest:number \n   rebate:number \n   constructor(interest:number,rebate:number) { \n      this.interest = interest \n      this.rebate = rebate \n   } \n} \n \nvar obj = new AgriLoan(10,1) \nconsole.log(\"利润为 : \"+obj.interest+\"，抽成为 : \"+obj.rebate )\n```\n\n一个类可以实现多个接口：\n\n```tsx\ninterface Alarm {\n    alert(): void;\n}\ninterface Light {\n    lightOn(): void;\n    lightOff(): void;\n}\n\nclass Car implements Alarm, Light {\n    alert() {\n        console.log(''Car alert'');\n    }\n    lightOn() {\n        console.log(''Car light on'');\n    }\n    lightOff() {\n        console.log(''Car light off'');\n    }\n}\n```\n\n上例中，`Car` 实现了 `Alarm` 和 `Light` 接口，既能报警，也能开关车灯。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(387,'访问修饰符','分别是 `public`、`private` 和 `protected`。\n\n- `public` 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 `public` 的\n- `private` 修饰的属性或方法是私有的，不能在声明它的类的外部访问\n- `protected` 修饰的属性或方法是受保护的，它和 `private` 类似，区别是它在子类中也是允许被访问的\n\n一些例子：\n\n```tsx\nclass Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name); // Jack\na.name = ''Tom'';\nconsole.log(a.name); // Tom\n```\n\n上面的例子中，`name` 被设置为了 `public`，所以直接访问实例的 `name` 属性是允许的。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(389,'访问修饰符(private)','很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 `private` 了：\n\n```tsx\nclass Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name);\na.name = ''Tom'';\n\n// index.ts(9,13): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n// index.ts(10,1): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n```\n\n需要注意的是，TypeScript 编译之后的代码中，并没有限制 `private` 属性在外部的可访问性。\n\n使用 `private` 修饰的属性或方法，在子类中也是不允许访问的：\n\n```tsx\nclass Animal {\n  private name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n// index.ts(11,17): error TS2341: Property ''name'' is private and only accessible within class ''Animal''.\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(390,'访问修饰符(protected)','而如果是用 `protected` 修饰，则允许在子类中访问：\n\n```ts\nclass Animal {\n  protected name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n    console.log(this.name);\n  }\n}\n```\n\n当构造函数修饰为 `private` 时，该类不允许被继承或者实例化：\n\n```tsx\nclass Animal {\n  public name;\n  private constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\nlet a = new Animal(''Jack'');\n// index.ts(7,19): TS2675: Cannot extend a class ''Animal''. Class constructor is marked as private.\n// index.ts(13,9): TS2673: Constructor of class ''Animal'' is private and only accessible within the class declaration.\n```\n\n当构造函数修饰为 `protected` 时，该类只允许被继承：\n\n```tsx\nclass Animal {\n  public name;\n  protected constructor(name) {\n    this.name = name;\n  }\n}\nclass Cat extends Animal {\n  constructor(name) {\n    super(name);\n  }\n}\nlet a = new Animal(''Jack'');\n// index.ts(13,9): TS2674: Constructor of class ''Animal'' is protected and only accessible within th\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(391,'参数属性','修饰符和`readonly`还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。\n\n```tsx\nclass Animal {\n  // public name: string;\n  public constructor(public name) {\n    // this.name = name;\n  }\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(392,'只读(readonly)','只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。\n\n```tsx\nclass Animal {\n  readonly name;\n  public constructor(name) {\n    this.name = name;\n  }\n}\n\nlet a = new Animal(''Jack'');\nconsole.log(a.name); // Jack\na.name = ''Tom'';\n\n// index.ts(10,3): TS2540: Cannot assign to ''name'' because it is a read-only property.\n```\n\n注意如果 `readonly` 和其他访问修饰符同时存在的话，需要写在其后面。\n\n```tsx\nclass Animal {\n  // public readonly name;\n  public constructor(public readonly name) {\n    // this.name = name;\n  }\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(393,'抽象类','`abstract` 用于定义抽象类和其中的抽象方法。\n\n什么是抽象类？\n\n首先，抽象类是不允许被实例化的：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nlet a = new Animal(''Jack'');\n// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class ''Animal''.\n```\n\n上面的例子中，我们定义了一个抽象类 `Animal`，并且定义了一个抽象方法 `sayHi`。在实例化抽象类的时候报错了。\n\n其次，抽象类中的抽象方法必须被子类实现：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\n\nclass Cat extends Animal {\n  public eat() {\n    console.log(`${this.name} is eating.`);\n  }\n}\n\nlet cat = new Cat(''Tom'');\n// index.ts(9,7): error TS2515: Non-abstract class ''Cat'' does not implement inherited abstract member ''sayHi'' from class ''Animal''.\n```\n\n上面的例子中，我们定义了一个类 `Cat` 继承了抽象类 `Animal`，但是没有实现抽象方法 `sayHi`，所以编译报错了。\n\n下面是一个正确使用抽象类的例子：\n\n```ts\nabstract class Animal {\n  public name;\n  public constructor(name) {\n    this.name = name;\n  }\n  public abstract sayHi();\n}\nclass Cat extends Animal {\n  public sayHi() {\n    console.log(`Meow, My name is ${this.name}`);\n  }\n}\nlet cat = new Cat(''Tom'');\n```\n\n上面的例子中，我们实现了抽象方法 `sayHi`，编译通过了。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(394,'类的类型(Class)','给类加上 TypeScript 的类型很简单，与接口类似：\n\n```tsX\nclass Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n  sayHi(): string {\n    return `My name is ${this.name}`;\n  }\n}\nlet a: Animal = new Animal(''Jack'');\nconsole.log(a.sayHi()); // My name is Jack\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(395,'接口(interface)','interface 接口是一系列抽象方法的声明，是一些方法特征的集合，这些方法都应该是抽象的，需要由具体的类去实现，然后第三方就可以通过这组抽象方法调用，让具体的类执行具体的方法。\n\n### 基础示例\n\n接口一般首字母大写\n\n定义的变量比接口少了一些属性是不允许的\n\n多一些属性也是不允许的\n\n```tsx\ninterface Person {\n    name: string;\n    age: number;\n}\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25\n};\n```\n\n定义了一个接口 `Person`，接着定义了一个变量 `tom`，它的类型是 `Person`。这样，我们就约束了 `tom` 的形状必须和接口 `Person` 一致。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(396,'可选属性(interface)','有时我们希望不要完全匹配一个形状\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n}\n\nlet tom: Person = {\n    name: ''Tom''\n};\n\ninterface Person {\n    name: string;\n    age?: number;\n}\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25\n};\n```\n\n可选属性的含义是该属性可以不存在。\n\n这时**仍然不允许添加未定义的属性**',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(397,'任意属性(interface)','有时候我们希望一个接口允许有任意的属性，可以使用如下方式：\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: ''Tom'',\n    gender: ''male''\n};\n```\n\n使用 `[propName: string]` 定义了任意属性取 `string` 类型的值。\n\n\n\n一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n\n```ts\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string | number;\n}\n\nlet tom: Person = {\n    name: ''Tom'',\n    age: 25,\n    gender: ''male''\n};\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(398,'只读属性(interface)','有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 `readonly` 定义只读属性：\n\n```tsx\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: ''Tom'',\n    gender: ''male''\n};\n\ntom.id = 9527;\n\n// index.ts(14,5): error TS2540: Cannot assign to ''id'' because it is a constant or a read-only property.\n```\n\n上例中，使用 `readonly` 定义的属性 `id` 初始化后，又被赋值了，所以报错了。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(399,'函数类型(interface)','为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。\n\n```tsx\ninterface SearchFunc {\n  (source: string, subString: string): boolean;\n}\n```\n\n下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。\n\n```tsx\nlet mySearch: SearchFunc;\nmySearch = function(source: string, subString: string) {\n  let result = source.search(subString);\n  return result > -1;\n};\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(400,'可索引的类型(interface)','与使用接口描述函数类型差不多，我们也可以描述那些能够 “通过索引得到” 的类型，比如 `a[10]` 或 `ageMap[\"daniel\"]` 。 可索引类型具有一个_索引签名_，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：\n\n```tsx\ninterface StringArray {\n  [index: number]: string;\n}\n\nlet myArray: StringArray;\nmyArray = [\"Bob\", \"Fred\"];\n\nlet myStr: string = myArray[0];\n```\n\n上面例子里，我们定义了 `StringArray` 接口，它具有索引签名。 这个索引签名表示了当用 `number` 去索引 `StringArray` 时会得到 `string` 类型的返回值。\n\nTypescript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(401,'混合类型(interface)','先前我们提过，接口能够描述 JavaScript 里丰富的类型。 因为 JavaScript 其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。\n\n一个例子就是，一个对象可以同时作为函数和对象使用，并带有额外的属性。\n\n```tsx\ninterface Counter {\n  (start: number): string;\n  interval: number;\n  reset(): void;\n}\n\nfunction getCounter(): Counter {\n  let counter = function(start: number) {} as Counter;\n  counter.interval = 123;\n  counter.reset = function() {};\n  return counter;\n}\n\nlet c = getCounter();\nc(10);\nc.reset();\nc.interval = 5.0;\n```\n\n在使用 JavaScript 第三方库的时候，你可能需要像上面那样去完整地定义类型。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(402,'接口继承(interface)','接口继承就是说接口可以通过其他接口来扩展自己。\n\nTypescript 允许接口继承多个接口。\n\n继承使用关键字 **extends**。\n\n单接口继承语法格式：\n\n```\nChild_interface_name extends super_interface_name\n```\n\n多接口继承语法格式：\n\n```\nChild_interface_name extends super_interface1_name, super_interface2_name,…,super_interfaceN_name\n```\n\n继承的各个接口使用逗号 **,** 分隔。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(403,'单继承实例(interface)','```tsx\ninterface Person { \nage:number \n}   \ninterface Musician extends Person { \ninstrument:string \n}  \nvar drummer = <Musician>{};\ndrummer.age = 27  \ndrummer.instrument = \"Drums\"\nconsole.log(\"年龄:  \"+drummer.age) \nconsole.log(\"喜欢的乐器:  \"+drummer.instrument)\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(404,'多继承实例(interface)','```tsx\ninterface IParent1 { \n    v1:number \n} \ninterface IParent2 { \n    v2:number \n} \ninterface Child extends IParent1, IParent2 { } \nvar Iobj:Child = { v1:12, v2:23} \nconsole.log(\"value 1: \"+Iobj.v1+\" value 2: \"+Iobj.v2)\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(405,'接口定义函数(interface)','接口不仅可以定义对象, 还可以定义函数:\n\n```tsx\n// 声明接口\ninterface Core {\n    (n:number, s:string):[number,string]\n}\n\n// 声明函数遵循接口定义\nconst core:Core = (a,b)=>{\n    return [a,b];\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(406,'接口定义类(interface)','先简单看下如何给类定义接口, 后面的课程具体讲类:\n\n```tsx\n// 定义\ninterface Animate {\n    head:number;\n    body:number;\n    foot:number;\n    eat(food:string):void;\n    say(word:string):string;\n}\n```\n\n```tsx\n// implements\nclass Dog implements Animate{\n    head=1;\n    body=1;\n    foot=1;\n    eat(food){\n        console.log(food);\n    }\n    say(word){\n        return word;\n    }\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(407,'类型声明','使用 **类型声明** 来描述一个对象的类型\n\n```tsx\ntype myType = {\n  name: string;\n  age: number;\n};\nconst person1: myType = {\n  name: ''hzw'',\n  age: 18,\n};\n```\n\n类型声明不可以重复写 接口可以重复写,内容会自动合并',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(408,'instanceof','instanceof 运算符用于判断对象是否是指定的类型，如果是返回 true，否则返回 false。\n\n```tsx\nclass Person{ } \nvar obj = new Person() \nvar isPerson = obj instanceof Person; \nconsole.log(\"obj 对象是 Person 类实例化来的吗？ \" + isPerson);\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(409,'typeof','typeof 操作符可以用来获取一个变量或对象的类型\n\n```tsx\ninterface Hero {\n  name: string;\n  skill: string;\n}\n\nconst zed: Hero = { name: \"影流之主\", skill: \"影子\" };\ntype LOL = typeof zed; // type LOL = Hero\n```\n\n在上面代码中，我们通过 typeof 操作符获取 zed 变量的类型并赋值给 LOL 类型变量，之后我们就可以使用 LOL 类型\n\n```tsx\nconst ahri: LOL = { name: \"阿狸\", skill: \"魅惑\" };\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(410,'keyof','keyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键\n\n```tsx\ninterface Point {\n    x: number;\n    y: number;\n}\n\n// type keys = \"x\" | \"y\"\ntype keys = keyof Point;\n```\n\n用 keyof 可以更好的定义数据类型\n\n```js\nfunction get<T extends object, K extends keyof T>(o: T, name: K): T[K] {\n  return o[name]\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(411,'Partial<T>','将T中所有属性转换为可选属性。返回的类型可以是T的任意子集\n\n```tsx\nexport interface UserModel {\n  name: string;\n  age?: number;\n  sex: number;\n}\n\ntype JUserModel = Partial<UserModel>\n// =\ntype JUserModel = {\n    name?: string | undefined;\n    age?: number | undefined;\n    sex?: number | undefined;\n}\n\n// 源码解析\ntype Partial<T> = { [P in keyof T]?: T[P]; };\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(412,'Required<T>','通过将T的所有属性设置为必选属性来构造一个新的类型。与Partial相反\n\n```tsx\ntype JUserModel2 = Required<UserModel>\n// =\ntype JUserModel2 = {\n    name: string;\n    age: number;\n    sex: number;\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(413,'Readonly<T>','将T中所有属性设置为只读\n\n```tsx\ntype JUserModel3 = Readonly<UserModel>\n\n// =\ntype JUserModel3 = {\n    readonly name: string;\n    readonly age?: number | undefined;\n    readonly sex: number;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(414,'Record<K,T>','构造一个类型，该类型具有一组属性K，每个属性的类型为T。可用于将一个类型的属性映射为另一个类型。Record 后面的泛型就是对象键和值的类型。\n\n简单理解：K对应对应的key，T对应对象的value，返回的就是一个声明好的对象\n\n```tsx\ntype TodoProperty = ''title'' | ''description'';\ntype Todo = Record<TodoProperty, string>;\n// =\ntype Todo = {\n    title: string;\n    description: string;\n}\n\ninterface IGirl {\n  name: string;\n  age: number;\n}\n\ntype allGirls = Record<string, IGirl>\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(415,'Pick<T,K>','在一个声明好的对象中，挑选一部分出来组成一个新的声明对象\n\n```tsx\ninterface Todo {\n  title: string;\n  description: string;\n  done: boolean;\n}\ntype TodoBase = Pick<Todo, \"title\" | \"done\">;\n// =\ntype TodoBase = {\n    title: string;\n    done: boolean;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(416,'Exclude<T,U>','从T中排除可分配给U的属性，剩余的属性构成新的类型\n\n```tsx\ntype T0 = Exclude<''a'' | ''b'' | ''c'', ''a''>; \n\n// = \n\ntype T0 = \"b\" | \"c\"\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(417,'Extract<T,U>','从T中抽出可分配给U的属性构成新的类型。与Exclude相反\n\n```tsx\ntype T0 = Extract<''a'' | ''b'' | ''c'', ''a''>; \n\n// = \n\ntype T0 = ''a''\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(418,'Parameters<T>','返回类型为T的函数的参数类型所组成的数组\n\n```tsx\ntype T0 = Parameters<() => string>;  // []\n\ntype T1 = Parameters<(s: string) => void>;  // [string]\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(419,'ReturnType<T>','function T的返回类型\n\n```tsx\ntype T0 = ReturnType<() => string>;  // string\n\ntype T1 = ReturnType<(s: string) => void>;  // void\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(420,'InstanceType<T>','返回构造函数类型T的实例类型\n\n```tsx\nclass C {\n  x = 0;\n  y = 0;\n}\n\ntype T0 = InstanceType<typeof C>;  // C\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(421,'字符串字面量类型','### 字符串字面量类型\n\n字符串字面量类型用来约束取值只能是某几个字符串中的一个。\n\n```ts\ntype EventNames = ''click'' | ''scroll'' | ''mousemove'';\nfunction handleEvent(ele: Element, event: EventNames) {\n    // do something\n}\n\nhandleEvent(document.getElementById(''hello''), ''scroll'');  // 没问题\nhandleEvent(document.getElementById(''world''), ''dblclick''); // 报错，event 不能为 ''dblclick''\n\n// index.ts(7,47): error TS2345: Argument of type ''\"dblclick\"'' is not assignable to parameter of type ''EventNames''.\n```\n\n上例中，使用 `type` 定了一个字符串字面量类型 `EventNames`，它只能取三种字符串中的一种。\n\n注意，**类型别名与字符串字面量类型都是使用 `type` 进行定义。**',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(422,'泛型(Generics)','泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(423,'泛型接口(Generics)','```tsx\ninterface GenericIdentityFn<T> {\n    (arg: T): T;\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(424,'泛型类(Generics)','```tsx\nclass GenericNumber<T> {\n    zeroValue: T;\n    add: (x: T, y: T) => T;\n}\n\nlet myGenericNumber = new GenericNumber<number>();\nmyGenericNumber.zeroValue = 0;\nmyGenericNumber.add = function(x, y) { return x + y; };\n```\n\n### 使用示例\n\n```tsx\nfunction createArray<T>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\ncreateArray<string>(3, ''x''); // [''x'', ''x'', ''x'']\n\n// T 自定义名称\nfunction myFun<T>(params: T[]) {\n  return params;\n}\nmyFun <string> ([\"123\", \"456\"]);\n\n// 定义多个泛型\nfunction join<T, P>(first: T, second: P) {\n  return `${first}${second}`;\n}\njoin <number, string> (1, \"2\");\n```\n\n上例中，我们在函数名后添加了 <T>，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array<T> 中即可使用了\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(425,'多个类型参数(Generics)','定义泛型的时候，可以一次定义多个类型参数：\n\n```tsx\nfunction swap<T, U>(tuple: [T, U]): [U, T] {\n    return [tuple[1], tuple[0]];\n}\nswap([7, ''seven'']); // [''seven'', 7]\n```\n\n上例中，我们定义了一个 `swap` 函数，用来交换输入的元组',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(426,'泛型约束(Generics)','在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：\n\n泛型进行约束\n\n```ts\ninterface Lengthwise {\n    length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n    console.log(arg.length);\n    return arg;\n}\n```\n\n上例中，我们使用了 `extends` 约束了泛型 `T` 必须符合接口 `Lengthwise` 的形状，也就是必须包含 `length` 属性。\n\n\n\n多个类型参数之间也可以互相约束：\n\n```ts\nfunction copyFields<T extends U, U>(target: T, source: U): T {\n    for (let id in source) {\n        target[id] = (<T>source)[id];\n    }\n    return target;\n}\nlet x = { a: 1, b: 2, c: 3, d: 4 };\ncopyFields(x, { b: 10, d: 20 });\n```\n\n上例中，我们使用了两个类型参数，其中要求 `T` 继承 `U`，这样就保证了 `U` 上不会出现 `T` 中不存在的字段。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(427,'泛型参数的默认类型(Generics)','TypeScript 2.3 以后，可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。\n\n```ts\nfunction createArray<T = string>(length: number, value: T): Array<T> {\n    let result: T[] = [];\n    for (let i = 0; i < length; i++) {\n        result[i] = value;\n    }\n    return result;\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(428,'泛型继承(Generics)','也可以对泛型的范围进行约束\n\n使用 `T extends MyInter` 表示泛型 `T` 必须是 `MyInter` 的子类，不一定非要使用接口类和抽象类同样适用；\n\n```tsx\ninterface MyInter{\n  length: number;\n}\n\nfunction test<T extends MyInter>(arg: T): number{\n  return arg.length;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(429,'模块','TypeScript 代码必须使用路径进行导入。这里的路径既可以是相对路径，以 `.` 或 `..` 开头，也可以是从项目根目录开始的绝对路径，如 `root/path/to/file` 。\n\n```tsx\nimport {Symbol1} from ''google3/path/from/root'';\nimport {Symbol2} from ''../parent/file'';\nimport {Symbol3} from ''./sibling'';\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(430,'导出','代码中必须使用具名的导出声明。\n\n```tsx\n// 1\nexport class Foo { ... }\n```\n\n```tsx\n// 2\nconst someVar = 123;\ntype someType = {\n  type: string;\n};\nexport { someVar, someType };\n```\n\n也可以用重命名变量的方式导出：\n\n```tsx\n// foo.ts\nconst someVar = 123;\nexport { someVar as aDifferentName };\n```\n\n#### 导出可见性\n\nTypeScript 不支持限制导出符号的可见性。因此，不要导出不用于模块以外的符号。一般来说，应当尽量减小模块的外部 API 的规模。\n\n#### 可变导出\n\n虽然技术上可以实现，但是可变导出会造成难以理解和调试的代码，尤其是对于在多个模块中经过了多次重新导出的符号。这条规则的一个例子是，不允许使用 `export let` 。\n\n```tsx\n// 不要这样做！\nexport let foo = 3;\n// 在纯 ES6 环境中，变量 foo 是一个可变值，导入了 foo 的代码会观察到它的值在一秒钟之后发生了改变。\n// 在 TypeScript 中，如果 foo 被另一个文件重新导出了，导入该文件的代码则不会观察到变化。\nwindow.setTimeout(() => {\n    foo = 4;\n}, 1000 /* ms */);\n```\n\n如果确实需要允许外部代码对可变值进行访问，应当提供一个显式的取值器。\n\n```tsx\n// 应当这样做！\nlet foo = 3;\nwindow.setTimeout(() => {\n    foo = 4;\n}, 1000 /* ms */);\n// 使用显式的取值器对可变导出进行访问。\nexport function getFoo() { return foo; };\n```\n\n有一种常见的编程情景是，要根据某种特定的条件从两个值中选取其中一个进行导出：先检查条件，然后导出。这种情况下，应当保证模块中的代码执行完毕后，导出的结果就是确定的。\n\n```tsx\nfunction pickApi() {\n    if (useOtherApi()) return OtherApi;\n    return RegularApi;\n}\nexport const SomeApi = pickApi();\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(431,'容器类','不要为了实现命名空间创建含有静态方法或属性的容器类。\n\n```tsx\n// 不要这样做！\nexport class Container {\n    static FOO = 1;\n    static bar() { return 1; }\n}\n```\n\n应当将这些方法和属性设为单独导出的常数和函数。\n\n```tsx\n// 应当这样做！\nexport const FOO = 1;\nexport function bar() { return 1; }\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(432,'导入','在 ES6 和 TypeScript 中，导入语句共有四种变体：\n\n| 导入类型 | 示例                             | 用途                                       |\n| -------- | -------------------------------- | ------------------------------------------ |\n| 模块     | `import * as foo from ''...'';`    | TypeScript 导入方式                        |\n| 解构     | `import {SomeThing} from ''...'';` | TypeScript 导入方式                        |\n| 默认     | `import SomeThing from ''...'';`   | 只用于外部代码的特殊需求                   |\n| 副作用   | `import ''...'';`                  | 只用于加载某些库的副作用（例如自定义元素） |\n\n```tsx\n// 应当这样做！从这两种变体中选择较合适的一种（见下文）。\nimport * as ng from ''@angular/core'';\nimport {Foo} from ''./foo'';\nimport { someVar as aDifferentName } from ''./foo'';\n\n// 只在有需要时使用默认导入。\nimport Button from ''Button'';\n\n// 有时导入某些库是为了其代码执行时的副作用。\nimport ''jasmine'';\nimport ''@polymer/paper-button'';\n```\n\n从其他模块导入后整体导出：\n\n```tsx\nexport * from ''./foo'';\n```\n\n从其他模块导入后，部分导出：\n\n```tsx\nexport { someVar } from ''./foo'';\n```\n\n通过重命名，部分导出从另一个模块导入的项目：\n\n```tsx\nexport { someVar as aDifferentName } from ''./foo'';\n```\n\n#### 选择模块导入还是解构导入？\n\n根据使用场景的不同，模块导入和解构导入分别有其各自的优势。\n\n虽然模块导入语句中出现了通配符 `*` ，但模块导入并不能因此被视为其它语言中的通配符导入。相反，模块导入语句为整个模块提供了一个名称，模块中的所有符号都通过这个名称进行访问，这为代码提供了更好的可读性，同时令模块中的所有符号可以进行自动补全。模块导入减少了导入语句的数量，降低了命名冲突的出现几率，同时还允许为被导入的模块提供一个简洁的名称。在从一个大型 API 中导入多个不同的符号时，模块导入语句尤其有用。\n\n解构导入语句则为每一个被导入的符号提供一个局部的名称，这样在使用被导入的符号时，代码可以更简洁。对那些十分常用的符号，例如 Jasmine 的 `describe` 和 `it` 来说，这一点尤其有用。\n\n```tsx\n// 不要这样做！无意义地使用命名空间中的名称使得导入语句过于冗长。\nimport {TableViewItem, TableViewHeader, TableViewRow, TableViewModel,\nTableViewRenderer} from ''./tableview'';\nlet item: TableViewItem = ...;\n\n// 应当这样做！使用模块作为命名空间。\nimport * as tableview from ''./tableview'';\nlet item: tableview.Item = ...;\n```\n\n#### 重命名导入\n\n在代码中，应当通过使用模块导入或重命名导出解决命名冲突。此外，在需要时，也可以使用重命名导入（例如 `import {SomeThing as SomeOtherThing}` ）。\n\n在以下几种情况下，重命名导入可能较为有用：\n\n1. 避免与其它导入的符号产生命名冲突。\n2. 被导入符号的名称是自动生成的。\n3. 被导入符号的名称不能清晰地描述其自身，需要通过重命名提高代码的可读性，如将 RxJS 的 `from` 函数重命名为 `observableFrom` 。\n\n#### 默认导入／导出\n\n- 使用\n\n  ```tsx\n  export default\n  ```\n\n  - 在一个变量之前（不需要使用 `let/const/var`）；\n  - 在一个函数之前；\n  - 在一个类之前。\n\n```ts\n// some var\nexport default (someVar = 123);\n\n// some function\nexport default function someFunction() {}\n\n// some class\nexport default class someClass {}\n```\n\n- 导入使用 `import someName from ''someModule''` 语法（你可以根据需要为导入命名）：\n\n```ts\nimport someLocalNameForThisFile from ''./foo'';\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(433,'函数的合并','我们可以使用重载定义多个函数类型：\n\n```tsx\nfunction reverse(x: number): number;\nfunction reverse(x: string): string;\nfunction reverse(x: number | string): number | string {\n    if (typeof x === ''number'') {\n        return Number(x.toString().split('''').reverse().join(''''));\n    } else if (typeof x === ''string'') {\n        return x.split('''').reverse().join('''');\n    }\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(434,'接口的合并','接口中的属性在合并时会简单的合并到一个接口中：\n\n```tsx\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    weight: number;\n}\n```\n\n相当于：\n\n```tsx\ninterface Alarm {\n    price: number;\n    weight: number;\n}\n```\n\n注意，**合并的属性的类型必须是唯一的**：\n\n```tsx\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: number;  // 虽然重复了，但是类型都是 `number`，所以不会报错\n    weight: number;\n}\ninterface Alarm {\n    price: number;\n}\ninterface Alarm {\n    price: string;  // 类型不一致，会报错\n    weight: number;\n}\n\n// index.ts(5,3): error TS2403: Subsequent variable declarations must have the same type.  Variable ''price'' must be of type ''number'', but here has type ''string''.\n```\n\n接口中方法的合并，与函数的合并一样：\n\n```tsx\ninterface Alarm {\n    price: number;\n    alert(s: string): string;\n}\ninterface Alarm {\n    weight: number;\n    alert(s: string, n: number): string;\n}\n```\n\n相当于：\n\n```tsx\ninterface Alarm {\n    price: number;\n    weight: number;\n    alert(s: string): string;\n    alert(s: string, n: number): string;\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(435,'类的合并','类的合并与接口的合并规则一致',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(436,'tsconfig.json','### tsconfig.json 的作用\n\n- 用于标识 TypeScript 项目的根路径；\n- 用于配置 TypeScript 编译器；\n- 用于指定编译的文件。\n\n### tsconfig.json 重要字段\n\n- files - 设置要编译的文件的名称；\n- include - 设置需要进行编译的文件，支持路径模式匹配；\n- exclude - 设置无需进行编译的文件，支持路径模式匹配；\n- compilerOptions - 设置与编译流程相关的选项。\n\ncompilerOptions 支持很多选项，常见的有 `baseUrl`、 `target`、`baseUrl`、 `moduleResolution` 和 `lib` 等。\n\n### 文件配置选项\n\n#### 1. include\n\n- 用来指定哪些目录下的ts文件需要被编译\n- 默认值：`[\"**/*\"]`\n- `**` 表示任意目录 \n- `*` 表示任意文件\n\n```js\n//表示根目录下src目录下任意目录任意文件\n\"include\": [\n  \"./src/**/*\" \n],\n```\n\n#### 2. exclude\n\n- 用来指定哪些目录下的 `ts` 文件不需要被编译\n- 默认值：`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`\n\n```js\n//表示不编译根目录下src目录下test目录下任意目录任意文件\n\"exclude\":[\n  \"./src/test/**/*\"  \n],\n```\n\n#### 3. extends\n\n- 用来定义 **被继承的配置文件**\n- 引入后,当前配置文件中会自动包含引入文件中的所有配置信息\n\n```js\n//当前配置文件中会自动包含根目录下base.json中的所有配置信息\n\"extends\": \"./base.json\",\n```\n\n#### 4. files\n\n- 用来指定被编译的文件列表,需要把文件一个个列出来比较麻烦,只有需要编译的文件少时才会用到.\n\n```js\n //只会编译根目录下01目录下的hello.ts\n\"files\": [\"./01/hello.ts\"],\n```\n\n### compilerOptions\n\n- 编译选项是配置文件中非常重要也比较复杂的配置选项\n- 在 `compilerOptions` 中包含多个子选项，用来完成对编译的配置\n\n#### 1. target\n\n- 用来指定 `TS` 被编译为的 `ES` 版本\n- 可选值：`ES3`（**默认**）、`ES5`、`ES6/ES2015`、`ES7/ES2016`、`ES2017`、`ES2018`、`ES2019`、`ES2020`、`ESNext`(**最新版本的ES**)\n\n```js\n//我们所编写的ts代码将会被编译为ES6版本的js代码\n\"compilerOptions\": {\n    \"target\": \"ES6\"\n}\n复制代码\n```\n\n#### 2. module\n\n- 用来指定要使用的模块化的解决方案\n- 可选值：`CommonJS`、`UMD`、`AMD`、`System`、`ES2020`、`ESNext`、`None`\n\n```js\n\"compilerOptions\": {\n    \"module\": \"CommonJS\"\n}\n复制代码\n```\n\n#### 3. lib\n\n- 用来指定项目中要使用的库 一般浏览器情况下不需要设置\n- 可选值：`ES5`、`ES6/ES2015`、`ES7/ES2016`、`ES2017`、`ES2018`、`ES2019`、`ES2020`、`ESNext`、`DOM`、`WebWorker`、`ScriptHost` `......`\n\n```js\n\"compilerOptions\": {\n    \"lib\": [\"ES6\", \"DOM\"],\n}\n复制代码\n```\n\n#### 4. outDir,rootDir\n\n- `outDir` 用来指定编译后文件所在的目录\n- `rootDir` 用来指定代码的根目录\n\n- 默认情况下，编译后的 `js` 文件会和 `ts` 文件位于相同的目录，设置 `outDir` 后可以改变编译后文件的位置\n\n```js\n\"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n}\n复制代码\n```\n\n#### 5. outFile\n\n- 将编译后的代码合并为一个文件\n- 设置 `outFile` 后,所有的全局作用域中的代码会合并到同一个文件中\n\n- 如果 `module` 制定了 `None`、`System` 或 `AMD` 则会将模块一起合并到文件之中\n\n```js\n\"compilerOptions\": {\n    \"outFile\": \"dist/app.js\"\n}\n复制代码\n```\n\n#### 6.allowJs\n\n- 是否对 `js` 文件进行编译,默认为 `false`\n\n#### 7.checkJs\n\n- 是否检测 `js` 代码是否符合语法规范,默认为 `false`\n\n#### 8.removeComments\n\n- 是否移除注释,默认为 `false`\n\n#### 9.noEmit\n\n- 是否不生成编译后的文件,默认为 `false`\n\n#### 10.noEmitOnError\n\n- 是否不生成编译后的文件(**当出现错误时**),默认为 `false`\n\n```js\n\"compilerOptions\": {\n     \"allowJs\": true,\n     \"checkJs\": true,\n     \"removeComments\": false,\n     \"noEmit\": false,\n     \"noEmitOnError\": true\n}\n```\n\n#### 11.严格检查\n\n- **strict**\n- - 启用所有的严格检查，默认值为 `true`，设置后相当于开启了所有的严格检查\n\n- **alwaysStrict**\n\n- - 总是以严格模式对代码进行编译\n\n- **noImplicitAny**\n\n- - 禁止隐式的 `any` 类型\n\n- **noImplicitThis**\n\n- - 禁止类型不明确的 `this`\n\n- **strictBindCallApply**\n\n- - 严格检查 `bind`、`call` 和 `apply` 的参数列表\n\n- **strictFunctionTypes**\n\n- - 严格检查函数的类型\n\n- **strictNullChecks**\n\n- - 严格的空值检查\n\n- **strictPropertyInitialization**\n\n- - 严格检查属性是否初始化\n\n#### 12.额外检查\n\n- **noFallthroughCasesInSwitch**\n\n- - 检查 `switch` 语句包含正确的 `break`\n\n- **noImplicitReturns**\n\n- - 检查函数没有隐式的返回值\n\n- **noUnusedLocals**\n\n- - 检查未使用的局部变量\n\n- **noUnusedParameters**\n\n- - 检查未使用的参数\n\n- **allowUnreachableCode**\n\n- - 检查不可达代码\n  - 可选值：`true`，忽略不可达代码;`false`，不可达代码将引起错误\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(437,'tsconfig.json示例','```javascript\n{\n  \"compilerOptions\": {\n    \"target\": \"esnext\",\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"node\",\n    \"isolatedModules\": false,\n    \"strict\": true,\n    \"noUnusedLocals\": true,\n    \"noUnusedParameters\": true,\n    \"experimentalDecorators\": true,\n    \"allowSyntheticDefaultImports\": true,\n    \"skipLibCheck\": true,\n    \"types\": [\"vite/client\"],\n    \"baseUrl\": \".\",\n    \"lib\": [\"dom\", \"esnext\"],\n    \"paths\": {\n      \"@/*\": [\"src/*\"],\n      \"@comp/*\": [\"src/components/*\"],\n      \"@api/*\": [\"src/api/*\"],\n      \"@vi/*\": [\"src/views/*\"],\n      \"@h/*\": [\"src/hooks/*\"]\n    }\n  },\n  \"exclude\": [\"node_modules\", \"dist\"]\n}\n\n```\n\n### compilerOptions 选项\n\n```ts\n{\n  \"compilerOptions\": {\n\n    /* 基本选项 */\n    \"target\": \"es5\",                       // 指定 ECMAScript 目标版本: ''ES3'' (default), ''ES5'', ''ES6''/''ES2015'', ''ES2016'', ''ES2017'', or ''ESNEXT''\n    \"module\": \"commonjs\",                  // 指定使用模块: ''commonjs'', ''amd'', ''system'', ''umd'' or ''es2015''\n    \"lib\": [],                             // 指定要包含在编译中的库文件\n    \"allowJs\": true,                       // 允许编译 javascript 文件\n    \"checkJs\": true,                       // 报告 javascript 文件中的错误\n    \"jsx\": \"preserve\",                     // 指定 jsx 代码的生成: ''preserve'', ''react-native'', or ''react''\n    \"declaration\": true,                   // 生成相应的 ''.d.ts'' 文件\n    \"sourceMap\": true,                     // 生成相应的 ''.map'' 文件\n    \"outFile\": \"./\",                       // 将输出文件合并为一个文件\n    \"outDir\": \"./\",                        // 指定输出目录\n    \"rootDir\": \"./\",                       // 用来控制输出目录结构 --outDir.\n    \"removeComments\": true,                // 删除编译后的所有的注释\n    \"noEmit\": true,                        // 不生成输出文件\n    \"importHelpers\": true,                 // 从 tslib 导入辅助工具函数\n    \"isolatedModules\": true,               // 将每个文件做为单独的模块 （与 ''ts.transpileModule'' 类似）.\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                        // 启用所有严格类型检查选项\n    \"noImplicitAny\": true,                 // 在表达式和声明上有隐含的 any类型时报错\n    \"strictNullChecks\": true,              // 启用严格的 null 检查\n    \"noImplicitThis\": true,                // 当 this 表达式值为 any 类型的时候，生成一个错误\n    \"alwaysStrict\": true,                  // 以严格模式检查每个模块，并在每个文件里加入 ''use strict''\n\n    /* 额外的检查 */\n    \"noUnusedLocals\": true,                // 有未使用的变量时，抛出错误\n    \"noUnusedParameters\": true,            // 有未使用的参数时，抛出错误\n    \"noImplicitReturns\": true,             // 并不是所有函数里的代码都有返回值时，抛出错误\n    \"noFallthroughCasesInSwitch\": true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）\n\n    /* 模块解析选项 */\n    \"moduleResolution\": \"node\",            // 选择模块解析策略： ''node'' (Node.js) or ''classic'' (TypeScript pre-1.6)\n    \"baseUrl\": \"./\",                       // 用于解析非相对模块名称的基目录\n    \"paths\": {},                           // 模块名到基于 baseUrl 的路径映射的列表\n    \"rootDirs\": [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容\n    \"typeRoots\": [],                       // 包含类型声明的文件列表\n    \"types\": [],                           // 需要包含的类型声明文件名列表\n    \"allowSyntheticDefaultImports\": true,  // 允许从没有设置默认导出的模块中默认导入。\n\n    /* Source Map Options */\n    \"sourceRoot\": \"./\",                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置\n    \"mapRoot\": \"./\",                       // 指定调试器应该找到映射文件而不是生成文件的位置\n    \"inlineSourceMap\": true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件\n    \"inlineSources\": true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性\n\n    /* 其他选项 */\n    \"experimentalDecorators\": true,        // 启用装饰器\n    \"emitDecoratorMetadata\": true          // 为装饰器提供元数据的支持\n  }\n}\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(438,'命名规范','| 命名法                                 | 分类                                   |\n| -------------------------------------- | -------------------------------------- |\n| 帕斯卡命名法（ `UpperCamelCase` ）     | 类、接口、类型、枚举、装饰器、类型参数 |\n| 驼峰式命名法（ `lowerCamelCase` ）     | 变量、参数、函数、方法、属性、模块别名 |\n| 全大写下划线命名法（ `CONSTANT_CASE`） | 全局常量、枚举值                       |\n| 私有成员命名法（ `#ident` ）           | 不允许使用                             |\n\n1. 不要使用`I`做为接口名前缀。\n2. 不要为私有属性名添加`_`前缀。\n3. 尽可能使用完整的单词拼写命名。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(439,'导入模块','导入模块的命名空间时使用驼峰命名法（`lowerCamelCase`），文件名则使用蛇形命名法（`snake_case`）。例如：\n\n```ts\nimport * as fooBar from ''./foo_bar'';\n```\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(440,'常量','常量命名（`CONSTANT_CASE`）表示某个值不可被修改。它还可以用于虽然技术上可以实现，但是用户不应当试图修改的值，比如并未进行深度冻结（deep frozen）的值。\n\n```tsx\nconst UNIT_SUFFIXES = {\n    ''milliseconds'': ''ms'',\n    ''seconds'': ''s'',\n};\n// UNIT_SUFFIXES 使用了常量命名，\n// 这意味着用户不应试图修改它，\n// 即使它实际上是一个可变的值。\n```\n\n这里所说的常量，也包括类中的静态只读属性：\n\n```tsx\nclass Foo {\n    private static readonly MY_SPECIAL_NUMBER = 5;\n\n    bar() {\n        return 2 * Foo.MY_SPECIAL_NUMBER;\n    }\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(441,'组件','1. 1个文件对应一个逻辑组件 （比如：解析器，检查器）。\n2. 不要添加新的文件。\n3. `.generated.*`后缀的文件是自动生成的，不要手动改它。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(442,'类型','1. 不要导出类型/函数，除非你要在不同的组件中共享它。\n2. 不要在全局命名空间内定义类型/值。\n3. 共享的类型应该在`types.ts`里定义。\n4. 在一个文件里，类型定义应该出现在顶部。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(443,'错误提示信息','1. 在句子结尾使用`.`。\n2. 对不确定的实体使用不定冠词。\n3. 确切的实体应该使用名字（变量名，类型名等）\n4. 当创建一条新的规则时，主题应该使用单数形式（比如：An external module cannot...而不是External modules cannot）。\n5. 使用现在时态。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(444,'错误提示信息代码','提示信息被划分类成了一般的区间。如果要新加一个提示信息，在上条代码上加1做为新的代码。\n\n- 1000 语法信息\n- 2000 语言信息\n- 4000 声明生成信息\n- 5000 编译器选项信息\n- 6000 命令行编译器信息\n- 7000 noImplicitAny信息',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(445,'普通方法','由于种种原因，我们避免使用一些方法，而使用我们自己定义的。\n\n1. 不使用ECMAScript 5函数；而是使用[core.ts](https://github.com/Microsoft/TypeScript/blob/master/src/compiler/core.ts)这里的。\n2. 不要使用`for..in`语句；而是使用`ts.forEach`，`ts.forEachKey`和`ts.forEachValue`。注意它们之间的区别。\n3. 如果可能的话，尝试使用`ts.forEach`，`ts.map`和`ts.filter`代替循环。\n\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(446,'用 JSDoc 还是注释？','TypesScript 中有两种类型的注释：\n\nJSDoc `/** ... */` \n\n普通注释 `// ... 或者 /* ... */` 。\n\n- 对于文档，也就是用户应当阅读的注释，使用 `/** JSDoc */` 。\n- 对于实现说明，也就是只和代码本身的实现细节有关的注释，使用 `// 行注释` 。\n\nJSDoc 注释能够为工具（例如编辑器或文档生成器）所识别，而普通注释只能供人阅读。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(447,'对所有导出的顶层模块进行注释','使用 `/** JSDoc */` 注释为代码的用户提供信息。这些注释应当言之有物，切忌仅仅将属性名或参数名重抄一遍。如果代码的审核人认为某个属性或方法的作用不能从它的名字上一目了然地看出来的话，这些属性和方法同样应当使用 `/** JSDoc */` 注释添加说明文档，无论它们是否被导出，是公开还是私有的。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(448,'不要使用@override','不要在 TypeScript 代码中使用 `@override` 注释。 `@override` 并不会被编译器视为强制性约束，这会导致注释与实现上的不一致性。如果纯粹为了文档添加这一注释，反而令人困惑。',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(449,'注释必须言之有物','虽然大多数情况下文档对代码十分有益，但对于那些并不用于导出的符号，有时其函数或参数的名称与类型便足以描述自身了。\n\n注释切忌照抄参数类型和参数名，如下面的反面示例：\n\n```tsx\n// 不要这样做！这个注释没有任何有意义的内容。\n/** @param fooBarService Foo 应用的 Bar 服务 */\n```\n\n因此，只有当需要添加额外信息时才使用 `@param` 和 `@return` 注释，其它情况下直接省略即可。\n\n```tsx\n/**\n * 发送 POST 请求，开始煮咖啡\n * @param amountLitres 煮咖啡的量，注意和煮锅的尺寸对应！\n */\nbrew(amountLitres: number, logger: Logger) {\n    // ...\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(450,'参数属性注释','通过为构造函数的参数添加访问限定符，参数属性同时创建了构造函数参数和类成员。例如，如下的构造函数\n\n```tsx\nclass Foo {\n    constructor(private readonly bar: Bar) { }\n}\n```\n\n为 `Foo` 类创建了 `Bar` 类型的成员 `bar` 。\n\n如果要为这些成员添加文档，应使用 JSDoc 的 `@param` 注释，这样编辑器会在调用构造函数和访问属性时显示对应的文档描述信息。\n\n```tsx\n/** 这个类演示了如何为参数属性添加文档 */\nclass ParamProps {\n    /**\n     * @param percolator 煮咖啡所用的咖啡壶。\n     * @param beans 煮咖啡所用的咖啡豆。\n     */\n    constructor(\n        private readonly percolator: Percolator,\n        private readonly beans: CoffeeBean[]) {}\n}\n/** 这个类演示了如何为普通成员添加文档 */\nclass OrdinaryClass {\n    /** 下次调用 brew() 时所用的咖啡豆。 */\n    nextBean: CoffeeBean;\n\n    constructor(initialBean: CoffeeBean) {\n        this.nextBean = initialBean;\n    }\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(451,'函数调用注释','如果有需要，可以在函数的调用点使用行内的 `/* 块注释 */` 为参数添加文档，或者使用字面量对象为参数添加名称并在函数声明中进行解构。注释的格式和位置没有明确的规定。\n\n```tsx\n// 使用行内块注释为难以理解的参数添加说明：\nnew Percolator().brew(/* amountLitres= */ 5);\n\n// 或者使用字面量对象为参数命名，并在函数 brew 的声明中将参数解构：\nnew Percolator().brew({amountLitres: 5});\n/** 一个古老的咖啡壶 {@link CoffeeBrewer} */\nexport class Percolator implements CoffeeBrewer {\n    /**\n     * 煮咖啡。\n     * @param amountLitres 煮咖啡的量，注意必须和煮锅的尺寸对应！\n     */\n    brew(amountLitres: number) {\n        // 这个实现煮出来的咖啡味道差极了，不管了。\n        // TODO(b/12345): 优化煮咖啡的过程。\n    }\n}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(452,'将文档置于装饰器之前','文档、方法或者属性如果同时具有装饰器（例如 `@Component`）和 JSDoc 注释，应当将 JSDoc 置于装饰器之前。\n\n禁止将 JSDoc 置于装饰器和被装饰的对象之间。\n\n```tsx\n// 不要这样做！JSDoc 被放在装饰器 @Component 和类 FooComponent 中间了！\n@Component({\n    selector: ''foo'',\n    template: ''bar'',\n})\n/** 打印 \"bar\" 的组件。 */\nexport class FooComponent {}\n```\n\n应当将 JSDoc 置于装饰器之前。\n\n```tsx\n/** 打印 \"bar\" 的组件。 */\n@Component({\n    selector: ''foo'',\n    template: ''bar'',\n})\nexport class FooComponent {}\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(453,'对象解构','```tsx\nlet person = {\n  name: ''Semlinker'',\n  gender: ''male''\n};\n\nlet {name, gender} = person;\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(454,'对象展开运算符','```tsx\nlet person = {\n  name: ''Semlinker'',\n  gender: ''male'',\n  address: ''Xiamen''\n};\n// 组装对象\nlet personWithAge = {...person, age: 31};\n// 获取除了某些项外的其它项\nlet {name, ...rest} = person;\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(455,'延时设定','```tsx\nsetTimeout(async () => {\ndataList.show = false\n}, 1200)\n```\n',5,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(456,'布尔型Attribute','布尔型 attribute 依据`true/false`值，决定 attribute 是否应该存在于该元素上。`disabled`就是最常见的例子之一。\n```html\n<button :disabled=\"isButtonDisabled\">\n  Button\n</button>\n```\n',2,3,405,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(457,'动态参数绑定','```html\n<a v-bind:[attributeName]=\"url\"> ... </a>\n<!-- 简写 -->\n<a :[attributeName]=\"url\"> ... </a>\n这里的 attributeName 会作为一个 JS 表达式被动态执行\n```\n',2,3,405,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(458,'什么是CSS','- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)\n- 样式定义**如何显示** HTML 元素\n- 样式通常存储在**样式表**中\n- 把样式添加到 HTML 4.0 中，是为了**解决内容与表现分离的问题**\n- **外部样式表**可以极大提高工作效率\n- 外部样式表通常存储在 **CSS 文件**中\n- 多个样式定义可**层叠**为一个',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(459,'后代选择器','后代选择器又称为包含选择器，可以选择父元素里面子元素，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n```CSS\nul li{\n    border: 1px solid red;\n}\n\n语法：元素1 元素2{样式声明}\n```\n\n上述语法表示选择元素1里面的所有元素2（后代元素）。\n\n注意：\n\n- 元素1与元素2中间用空格隔开\n- 元素1是父级，元素2是子级，最终选择是元素2.',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(460,'背景透明(background)','```css\nbackground-color: hsla(0,0%,100%,.7);\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(461,'背景渐变','使用方式:\n```css\n//渐变(方向)\nbackground: linear-gradient(to right, rgba(255, 255, 255, 0),#3FB6F7,rgba(255,255,255,0));\n\n//渐变(角度)\nbackground: linear-gradient(88deg, #4DF7BF 0%, rgba(77, 247, 191, 0.26) 12%, rgba(77, 247, 191, 0) 100%);\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(462,'边框渐变','```css\n.border-grident{\n  margin-top: 20px;\n  width: 200px;\n  height: 200px;\n  border: 4px solid;\n  border-image: linear-gradient(to right, #8f41e9, #578aef) 4;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(463,'瀑布流(column)','```html\n      <div class=\"w-full h-800px overflow-auto\">\n        <div class=\"test\">\n          <div v-for=\"(item, index) in rSnippet\" :key=\"index\" class=\"item\">\n            <div class=\"text-xl text-center\">{{ item.name }}</div>\n            <v-md-preview ref=\"preview\" :text=\"item.text\" />\n          </div>\n        </div>\n      </div>\n```\n\n```css\n.test {\n  margin: 0 auto;\n  column-count: 2;\n  column-gap: 10px;\n  counter-reset: count;\n\n  .item {\n    position: relative;\n    margin-bottom: 10px;\n    // page-break-inside: avoid;\n    // -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n这种方式超出宽高度使用 overflow-y-scroll 只能左右滑动',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(464,'瀑布流(grid)','超出宽高度使用 overflow-y-scroll 可以上下滑动\n\n```html\n    <div class=\"test mt-4\">\n        <div class=\"bg-warm-gray-600 w-80 h-40\" t2></div>\n        <div class=\"bg-warm-gray-700 w-80 h-40 text2\"></div>\n        <div class=\"bg-slate-500\" w-80 h-50></div>\n        <div class=\"bg-warm-gray-500 w-80 h-50\"></div>\n        <div class=\"bg-warm-gray-800 w-80 h-20\"></div>\n        <div class=\"bg-warm-gray-100 w-80 h-70\"></div>\n        <div class=\"bg-warm-gray-200 w-80 h-40\"></div>\n        <div class=\"bg-warm-gray-500 w-80 h-60\"></div>\n      </div>\n```\n\n```css\n.test {\n  display: grid;\n  grid-gap: 10px;\n\n  /* 可以看到，网格大小，占据位置是需要提前设定的 */\n  grid-template-columns: repeat(3, 1fr);\n  box-sizing: border-box;\n  width: 80%;\n  height: 800px;\n  padding: 10px;\n  background-color: rgb(189 100 100);\n\n  @apply overflow-y-scroll;\n\n  div {\n    /* 避免子元素被分割的 2种方式 */\n    page-break-inside: avoid;\n    -webkit-column-break-inside: avoid;\n  }\n}\n```\n\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(465,'居中(flex)','```css\n.center-layout {\n	display: flex;\n	justify-content: center; // 内容自适应：上下居中\n	align-items: center; // 子项对齐方式：左右居中\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(466,'居中(fixed)','```css\n   .fixed-c {\n            height: 80px;\n            width: 90%;\n            position: fixed;\n            margin: auto;\n            bottom: 0; /*底部固定*/\n            left: 0; /*实现div的居中*/\n            right: 0; /*实现div的居中*/\n            text-align: center; /*div的内容居中*/\n            background: red;\n            line-height: 80px; /*垂直居中*/\n          }\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(467,'平滑滚动','```css\n html {\n  scroll-behavior: smooth;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(468,'绝对居中','```css\n.Absolute-Center {\n  margin: auto;\n  position: absolute;\n  top: 0; left: 0; bottom: 0; right: 0;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(469,'文字居中','```css\n<div class=\"container\">\n    <div class=\"item\"></div>\n</div>\n\n.container {\n    text-align: center;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(470,'块级元素居中','适用于块级元素，其实就是把要居中的子元素的 margin-left、margin-right 都设置为 auto，该方法能让子元素水平居中，但是对浮动元素和绝对定位的元素无效。\n\n```css\n.item {\n    margin: auto;\n}\n```\n',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(471,'绝对定位','```css\n.parent {\n    position: relative;\n}\n.child {\n    position: absolute;\n    /* top和left是以左上角为坐标原点 */\n    top: 50%;\n    left: 50%;\n    /* transform：translate的属性值为百分数时，是以元素自身为参考 */\n    transform: translate(-50%,-50%);\n}\n\n/* 或者 */\n.child {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n}\n```\n\n值得说明的是，`top`和`left`是以左上角为坐标原点的，这样就会导致虽然设置为50%，但实际上是实现了左上角这个点的居中，因此需要再移动一下这个元素。而当`transform`的`translate`的属性值为百分数的时候，是以元素自身作为参考的，因此向左和向上移动自身长宽的50%即可实现水平垂直居中。',8,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(472,'svue3','```json\n  \"vue3+ts+scss\": {\n    \"prefix\": \"svue3\",\n    \"body\": [\n      \"<script lang=\\\"ts\\\" setup></script>\",\n      \"<template>\",\n      \"  <div></div>\",\n      \"</template>\",\n      \"\",\n      \"<style lang=\\\"scss\\\" scoped></style>\"\n    ],\n    \"description\": \"vue3\"\n  }\n```',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(473,'smounted','```json\n\"组件挂载完成后执行的函数\": {\n  \"prefix\": \"smounted\",\n  \"body\": [\n    \"onMounted(async () => {})\"\n  ],\n  \"description\": \"组件挂载完成后执行的函数\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(474,'sdefineAsyncComponent','```json\n\"异步组件加载\": {\n  \"prefix\": \"sdefineAsyncComponent\",\n  \"body\": [\n    \"const xxxx= defineAsyncComponent(() => {\",\n    \"  return import(''@/components/editor/xxxx.vue'')\",\n    \"})\",\n    \"<xxxx></xxxx>\"\n  ],\n  \"description\": \"异步组件加载\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(475,'sRefNumber','```json\n\"响应式变量\": {\n  \"prefix\": \"sRefNumber\",\n  \"body\": [\n    \"const rNumber= ref(0)\"\n  ],\n  \"description\": \"响应式变量\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(476,'sInterface','```json\n\"接口定义\": {\n  \"prefix\": \"sInterface \",\n  \"body\": [\n    \"export interface Ixxx {\",\n    \"  id: number\",\n    \"  name: ''''\",\n    \"}\",\n    \"export const xxxForm: Ixxx = reactive({\",\n    \"  id: 0,\",\n    \"  name: ''''\",\n    \"})\"\n  ],\n  \"description\": \"接口定义\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(477,'sDefinePropsStr','```json\n\"vue3中父子传值\": {\n  \"prefix\": \"sDefinePropsStr\",\n  \"body\": [\n    \"defineProps({\",\n    \"  nameStr: {\",\n    \"    type: String,\",\n    \"    required: true\",\n    \"  }\",\n    \"})\",\n    \" <p>{{ nameStr}}</p>\"\n  ],\n  \"description\": \"vue3中父子传值\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(478,'sAxiosAsync','```json\n\"Axios请求\": {\n  \"prefix\": \"sAxiosAsync\",\n  \"body\": [\n    \"await xxx.GetFun(xxx).then((res: any) => {})\"\n  ],\n  \"description\": \"Axios请求\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(479,'sAxiosAll','```json\n\"axios并发执行\": {\n  \"prefix\": \"sAxiosAll\",\n  \"body\": [\n    \"  axios.all([1, 2]).then(\",\n    \"    axios.spread((res: any,res2: any) => {\",\n    \"     //\",\n    \"    })\",\n    \"  )\"\n  ],\n  \"description\": \"axios并发执行\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(480,'sReactive','```json\n\"返回对象的响应式副本\": {\n  \"prefix\": \"sReactive\",\n  \"body\": [\n    \"const rData = reactive({\",\n    \"  id: number,\",\n    \"  name: ''''\",\n    \"})\"\n  ],\n  \"description\": \"返回对象的响应式副本\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(481,'sApply','```json\n\"CSS @apply\": {\n  \"prefix\": \"sApply\",\n  \"body\": [\n    \"@apply ;\"\n  ],\n  \"description\": \"CSS @apply\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(482,'sGetCurrentInstance','```json\n\"获取全局挂载的内容\": {\n  \"prefix\": \"sGetCurrentInstance\",\n  \"body\": [\n    \"const { proxy }: any = getCurrentInstance()\"\n  ],\n  \"description\": \"获取全局挂载的内容\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(483,'sEnun_Api','```json\n\"定义枚举api字段\": {\n  \"prefix\": \"sEnun_Api\",\n  \"body\": [\n    \"enum Api {\",\n    \"  FY = '''',\",\n    \"  SUM = '''',\",\n    \"  BYID = '''',\",\n    \"  CONTAINS = '''',\",\n    \"  ADD = '''',\",\n    \"  UPDATE = '''',\",\n    \"  DELETE = ''''\",\n    \"}\"\n  ],\n  \"description\": \"定义枚举api字段\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(484,'sFunAsync','```json\n\"定义异步方法\": {\n  \"prefix\": \"sFunAsync\",\n  \"body\": [\n    \"const name = async (data: any) => {\",\n    \"  //\",\n    \"}\"\n  ],\n  \"description\": \"定义异步方法\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(485,'sFun','```json\n\"定义方法\": {\n  \"prefix\": \"sFun\",\n  \"body\": [\n    \"const name = (data: any) => {\",\n    \"  //\",\n    \"}\"\n  ],\n  \"description\": \"定义方法\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(486,'sSvg','```json\n\"导入svg图片\": {\n  \"prefix\": \"sSvg\",\n  \"body\": [\n    \"import svg from ''@assets/svg/xxx.svg?component''\",\n    \"<svg />\"\n  ],\n  \"description\": \"导入svg图片\"\n}\n```\n',13,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(487,'sApply','sApply--\n\n``` json\n\"unocss @apply\": {\n  \"prefix\": \"sApply--\",\n  \"body\": [\n    \"--at-apply:\"\n  ],\n  \"description\": \"unocss @apply\"\n}\n```\n',13,16,29,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(488,'跳转新窗口','```ts\n/**\n * @description: 跳转新页面\n * @param {string} url\n * @return {*}\n */\nfunction winUrl(url: string): any {\n  window.open(url)\n}\n\nasync function resolveId(path: string, id: number) {\n  const { href } = resolve(path, id)\n  await winUrl(href)\n}\n```\n',2,155,801,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(489,'ref问底层DOM元素','虽然 Vue 的声明性渲染模型为你抽象了大部分对 DOM 的直接操作，但在某些情况下，我们仍然需要直接访问底层 DOM 元素\n\n```html\n<input ref=\"input\">\n```\n\n',2,147,285,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(490,'使用ref访问模板','### 访问模板(ref)\n\n利用`ref`函数获取组件中的标签元素。\n\n声明一个同名的 ref：\n\n```html\n<script setup>\nimport { ref, onMounted } from ''vue''\n// 声明一个 ref 来存放该元素的引用\n// 必须和模板 ref 同名\nconst input = ref(null)\nonMounted(() => {\n  input.value.focus()\n})\n</script>\n\n<template>\n  <input ref=\"input\" />\n</template>\n```\n\n注意，你只可以**在组件挂载后**才能访问 ref。如果你想在模板中的表达式上访问 `$refs.input`，在初次渲染时会是 `null`\n\n如果你正试图观察一个模板 ref 的变化，确保考虑到 ref 的值为 `null` 的情况：\n\n```tsx\nwatchEffect(() => {\n  if (input.value) {\n    input.value.focus()\n  } else {\n    // 此时还未挂载，或此元素已经被卸载（例如经过 v-if 控制）\n  }\n})\n```\n\n利用`ref`函数获取组件中的标签元素。\n\n```html\n<template>\n  <input type=\"text\" ref=\"inputRef\">\n</template>\n\n<script>\nimport { onMounted, ref } from ''vue''\nexport default {\n  setup() {\n    // 定义dom元素\n    const inputRef = ref<HTMLElement|null>(null)\n    // 自动获取焦点\n    onMounted(() => {\n      inputRef.value && inputRef.value.focus()\n    })\n\n    return {\n      inputRef\n    }\n  },\n}\n</script>\n```\n\n',2,147,285,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(491,'使用ref设置窗口高度','```html\n<template>\n    <div class=\"demo1-container\">\n        <p>通过ref直接拿到dom</p>\n        <div ref=\"sectionRef\" class=\"ref-section\"></div>\n        <button @click=\"higherAction\" class=\"btn\">变高</button>\n    </div>\n</template>\n```\n\n```tsx\nimport {ref} from ''vue''\nconst sectionRef = ref()\nlet height = 100;\nconst higherAction = () => {\n    height += 50;\n    sectionRef.value.style = `height: ${height}px`;\n}\n```\n\n',2,147,285,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(492,'将dom引用放到数组中(ref)','### 将dom引用放到数组中(ref)\n\n```html\n<template>\n    <div class=\"demo2-container\">\n        <div class=\"list-section\">\n            <div :ref=\"setRefAction\" @click=\"higherAction(index)\" class=\"list-item\" v-for=\"(item, index) in state.list\" :key=\"index\">\n                <span>{{item}}</span>\n            </div>\n        </div>\n    </div>\n</template>\n```\n\nscript setup\n\n```tsx\nimport { reactive } from ''vue''\nconst state = reactive({\n    list: [1, 2, 3, 4, 5, 6, 7],\n    refList: [] as Array<any>\n})\nconst setRefAction = (el: any) => {\n    state.refList.push(el);\n}\n```\n',2,7,1,4,0,'2023-08-04 09:43:08','2023-08-04 09:43:08'),
(493,'通过子组件中emit传递ref','template\n```html\n<template>\n    <div ref=\"cellRef\" @click=\"cellAction\" class=\"cell-item\">\n        <span>{{item}}</span>\n    </div>\n</template>\n```\n\nscript setup\n\n```tsx\nimport {ref} from ''vue'';\n\nconst props = defineProps({\n    item: Number\n})\nconst emit = defineEmits([''cellTap'']);\nconst cellRef = ref();\nconst cellAction = () => {\n    emit(''cellTap'', cellRef.value);\n}\n```\n\n',2,147,717,1,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(494,'v-for中使用ref','当 `ref` 在 `v-for` 中使用时，相应的 ref 中包含的值是一个数组，它将在元素被挂载后填充：\n\n```html\n<template>\n  <ul>\n    <li v-for=\"item in list\" ref=\"itemRefs\">\n      {{ item }}\n    </li>\n  </ul>\n</template>\n```\n\n```tsx\nimport { ref, onMounted } from ''vue''\n\nconst list = ref([\n  /* ... */\n])\nconst itemRefs = ref([])\nonMounted(() => console.log(itemRefs.value))\n```\n\n注意的是，ref 数组**不能**保证与源数组相同的顺序。\n\n',2,147,285,1,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(495,'函数型ref','`ref` attribute 还可以绑定为函数，每次组件更新时被调用。函数接受该元素引用作为第一个参数：\n\n```html\n<input :ref=\"(el) => { /* assign el to a property or ref */ }\">\n```\n\n如果使用一个动态的 `:ref` 绑定，也可以传一个函数。当元素卸载时，这个 `el` 参数会是 `null`。你当然也可以使用一个方法而不是内联函数。',2,147,285,1,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(496,'组件上的ref','script setup\n\n```tsx\nimport { ref, onMounted } from ''vue''\nimport Child from ''./Child.vue''\n\nconst child = ref(null)\nonMounted(() => {\n  // child.value 为 <Child /> 这个组件实例\n})\n```\n\n```html\n<template>\n  <Child ref=\"child\" />\n</template>\n```\n\n一个子组件使用的是选项式 API 或没有使用 `<script setup>`，被引用的组件实例和该子组件的 `this` 完全一致，意味着父组件对子组件每个属性和方法都有完全的访问权。这使得在父组件和子组件之间创建紧密耦合的实现细节变得很容易，应该只在绝对需要时才使用组件引用。多数情况下，应该使用标准的 props 和 emit 接口来实现父子组件交互。\n\n有一个例外的情况，使用了 `<script setup>` 的组件时**默认私有**的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 `defineExpose` 宏显式暴露：\n\nscript setup\n\n```tsx\nimport { ref } from ''vue''\nconst a = 1\nconst b = ref(2)\ndefineExpose({\n  a,\n  b\n})\n```\n\n当父组件通过模板 ref 获取到了该组件的实例，得到的实例类型为 `{ a: number, b: number }` (ref 都会自动解套，和一般的实例一样)。\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(497,'插槽slot','向一个组件传递内容，可使用插槽。通过插槽来分发内容，即插槽作为分发内容的出口。使用`<slot>`作为想要插入内容的占位符。\n\n插槽 `slot` 通常用于两个父子组件之间，最常见的应用就是我们使用一些 `UI` 组件库中的弹窗组件时，弹窗组件的内容是可以让我们自定义的，这就是使用了插槽的原理。\n\n- `slot` 是 `Vue3` 中的内置标签。\n- `slot` 相当于给子组件挖出了一个槽，可以用来填充内容。\n- 父组件中调用子组件时，子组件标签之间的内容元素就是要放置的内容，它会把 `slot` 标签替换掉。\n\n## 认识插槽Slot\n\n开发中经常封装一个个可复用的组件：\n\n- 为了让这个组件具备更强的通用性，不能将组件中的内容限制为固定的div、span等等元素；\n- 比如某种情况下希望组件显示的是一个按钮，某种情况下希望显示的是一张图片；\n- 所以，应该让使用者可以决定某一块区域到底存放什么内容和元素；\n\n## 如何使用插槽slot\n\n- 定义插槽slot：\n\n- - 插槽的使用过程其实是抽取共性、预留不同；\n  - 将共同的元素、内容依然在组件内进行封装；\n  - 同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素；\n\n- 如何使用slot呢？\n\n- - Vue中将 <slot> 元素作为承载分发内容的出口；\n  - 在封装组件中，使用特殊的元素<slot>就可以为封装组件开启一个插槽；\n  - 该插槽插入什么内容取决于父组件如何使用；\n\n## 基本使用slot\n\n在子组件放置插槽\n\n子组件**child.vue**\n\n```html\n<template>\n  // 匿名插槽\n  <slot/>\n  // 具名插槽\n  <slot name=''title''/>\n  // 作用域插槽\n  <slot name=\"footer\" :scope=\"state\" />\n</template>\n```\n\n父组件\n\n```html\n<template>\n  <child>\n    // 匿名插槽\n    <span>我是默认插槽</span>\n    // 具名插槽\n    <template #title>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n    </template>\n    // 作用域插槽\n    <template #footer=\"{ scope }\">\n      <footer>作用域插槽——姓名：{{ scope.name }}，年龄{{ scope.age }}</footer>\n    </template>\n  </child> \n</template>\n<script setup>\n  // 引入子组件\n  import child from ''./child.vue''\n</script>\n```\n\n',2,117,367,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(498,'slot基本使用','在子组件放置插槽\n\n子组件**child.vue**\n\n```html\n<template>\n  // 匿名插槽\n  <slot/>\n  // 具名插槽\n  <slot name=''title''/>\n  // 作用域插槽\n  <slot name=\"footer\" :scope=\"state\" />\n</template>\n```\n\n父组件\n\n```html\n<template>\n  <child>\n    // 匿名插槽\n    <span>我是默认插槽</span>\n    // 具名插槽\n    <template #title>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n      <h1>我是具名插槽</h1>\n    </template>\n    // 作用域插槽\n    <template #footer=\"{ scope }\">\n      <footer>作用域插槽——姓名：{{ scope.name }}，年龄{{ scope.age }}</footer>\n    </template>\n  </child> \n</template>\n<script setup>\n  // 引入子组件\n  import child from ''./child.vue''\n</script>\n```\n',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(500,'渲染作用域slot','插槽内容可以访问到父组件的数据，因为插槽内容本身也是在父组件模板的一部分。\n\n```html\n<span>{{ message }}</span>\n<FancyButton>{{ message }}</FancyButton>\n```\n\n这里的两个 `{{ message }}` 插值表达式渲染的内容都是一样的。\n\n插槽内容**无法访问**子组件的数据，请牢记一条规则：\n\n> 任何父组件模板中的东西都是被编译到父组件的作用域中；而任何子组件模板中的东西都只被编译到子组件的作用域中',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(501,'默认插槽slot','经常会遇到外部没有提供任何内容的情况，此时可能会为插槽提供一个默认的内容来渲染。 SubmitButton组件\n\n```html\n<button type=\"submit\">\n  <slot></slot>\n</button>\n```\n\n如果外部没有提供任何插槽内容，我们可能想在 `<button>` 中渲染“提交”这两个字。要让这两个字成为默认内容，需要写在 `<slot>` 标签之间：\n\n```html\n<button type=\"submit\">\n  <slot>\n    提交 <!-- 默认内容 -->\n  </slot>\n</button>\n```\n\n当在父组件中使用 `<submit-button>` 但不提供任何插槽内容：\n\n```html\n<SubmitButton />\n```\n\n那么将渲染出下面这样的 DOM 结构，包含默认的“提交”二字：\n\n```html\n<button type=\"submit\">提交</button>\n```\n\n如果提供了别的内容给插槽,那么渲染的 DOM 中会选择使用提供的插槽内容',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(502,'多个插槽slot','一个组件中可能会有多个插槽的插口。\n\n```html\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n，`<slot>` 元素可以有一个特殊的 attribute `name`，可以是一个独一无二的标识符，用来区分各个插槽，确定每一处最终会渲染的内容：\n\n```html\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n没有提供 `name` 的 `<slot>` 插口会隐式地命名为“default”。\n\n在父组件中使用到 `<BaseLayout>` 时，我们需要给各个插槽传入内容，为了模板片段让各入各门、各寻其所。此时就需要用到**具名插槽**了：\n\n要为具名插槽传入内容，我们需要使用一个含 `v-slot` 指令的 `<template>` 元素，并将目标插槽的名字传给该指令：\n\n```html\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(503,'插槽简写slot','`v-slot` 有对应的简写 `#`，\n\n向 `<BaseLayout>` 传递内容的代码，指令均使用的是缩写形式：\n\n```html\n<BaseLayout>\n  <template #header>\n    <h1>这里是一个页面标题</h1>\n  </template>\n\n  <template #default>\n    <p>一个文章内容的段落</p>\n    <p>另一个段落</p>\n  </template>\n\n  <template #footer>\n    <p>这里有一些联系方式</p>\n  </template>\n</BaseLayout>\n```\n\n',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(504,'动态插槽名slot','动态指令参数在 `v-slot` 上也是有效的，即可以定义下面这样的动态插槽名：\n\n插槽可以是一个变量名 const name = ref(''header'')\n\n```html\n<base-layout>\n  <template v-slot:[dynamicSlotName]>\n    ...\n  </template>\n\n  <!-- 缩写为 -->\n  <template #[dynamicSlotName]>\n    ...\n  </template>\n</base-layout>\n```\n\n注意这里的表达式和动态指令参数受相同的语法限制',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(505,'作用域插槽','在上面的渲染作用域中我们讨论到，插槽的内容无法访问到子组件的状态。\n\n然而在某些场景下插槽的内容可能想要同时利用父组件域内和子组件域内的数据。要做到这一点，需要让子组件将一部分数据在渲染时提供给插槽。\n\n我们可以像对组件传递 props 那样，向一个插槽的插口上传递 attribute：\n\n```html\n子级中的模板代码\n<!-- <MyComponent> template -->\n<div>\n  <slot :text=\"greetingMessage\" :count=\"1\"></slot>\n</div>\n```\n\n当需要接收插槽props时，默认插槽和具名插槽的使用方式有点不同。\n\n### 默认作用域插槽\n\n下面我们将先展示默认插槽如何接受props。父级组件的模板中，通过子组件标签上的`v-slot`指令，直接接收到了一个插槽props对象：\n\n```html\n父级组件模板中，设置子组件标签\n<MyComponent v-slot=\"slotProps\">\n  {{ slotProps.text }} {{ slotProps.count }}\n</MyComponent>\n```\n\n子组件传入插槽的 props 作为了 `v-slot` 指令的值，可以在插槽内的表达式中访问。',2,117,367,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(506,'具名作用域插槽','在一个组件中，包含多个插槽出口是很有用的。例如，在`<BaseLayout>`的组件中，具有以下模板\n\n```html\n子级\n<div class=\"container\">\n  <header>\n    <!-- 标题内容放这里 -->\n  </header>\n  <main>\n    <!-- 主要内容放这里 -->\n  </main>\n  <footer>\n    <!-- 底部内容放这里 -->\n  </footer>\n</div>\n```\n\n对于这些情况，`<slot>`元素有一个特殊的属性`name`，它可以用来为不同的插槽分配一个**唯一ID**，这样你就可以确定应该在哪里呈现内容：\n\n```html\n子级\n<div class=\"container\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <main>\n    <slot></slot>\n  </main>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```\n\n这类带`name`的插槽，被称为具名插槽(named slots)。没有提供`name`的`<slot>`出口会隐式地具名为`*name*:default`。\n\n\n\n在父组件中，使用`<BaseLayout>`时，我们需要一种方式，将多个插槽内容，传入到各自目标插槽的出口。此时就需要用到**具名插槽**。要为具名插槽传入内容，我们需要使用一个含`v-slot`指令的`<template>`元素，并将目标插槽的名字传给该`v-slot`指令\n\n```html\n父级\n<BaseLayout>\n  <template v-slot:header>\n    <!-- header 插槽的内容放这里 -->\n  </template>\n</BaseLayout>\n```\n\n`v-slot`有专门的缩写`#`。\n\n```html\n<template v-slot:header>\n\n简写为:\n<template #header>\n```\n\n其意思就是“将这部分模板片段传入子组件的 header 插槽中”。\n\n ![image-20231123165144167](http://kai.snblogs.cn/typora/image-20231123165144167.png)\n\n使用缩写语法的代码：\n\n```html\n父级\n<BaseLayout>\n  <template #header>\n    <h1>Here might be a page title</h1>\n  </template>\n\n  默认槽\n  <template #default>\n    <p>A paragraph for the main content.</p>\n    <p>And another one.</p>\n  </template>\n\n  <template #footer>\n    <p>Here''s some contact info</p>\n  </template>\n</BaseLayout>\n```\n\n',2,117,367,4,3,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(507,'vue依赖注入','inject与provide其实就是祖孙组件传值,provide用于祖组件传,inject用于孙组件接\n\n在多层嵌套组件中使用，不需要将数据一层一层地向下传递,可以实现跨层级组件通信\n\n ![image-20231123154141005](http://kai.snblogs.cn/typora/image-20231123154141005.png)\n\n提供数据Provide\n\n```tsx\n// 祖组件\nconst info = reactive({\n   title: ''test''\n })\n//提供的数据名，数据值\nprovide(''info'', info)\n```\n\n注入inject\n\n```js\n//孙组件\n//获取对应数据的值\nconst color = inject(''info'')\n```\n\n',2,148,705,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(508,'Provide(提供)','### 提供数据Provide\n\n要为组件后代提供数据，需要使用到*provide()*函数：\n\n```vue\n<script setup>\nimport { provide } from ''vue''\n\nprovide(''message'', ''hello!'')\n</script>\n```\n\n如果不使用`<script setup>`，请确保*provide()*是在`setup()`同步调用的：\n\n```vue\n<script>\nimport { provide } from ''vue''\n\nexport default {\n  setup() {\n    provide(''message'', ''hello!'')\n  }\n}\n</script>\n```\n\n`provide()`函数接收两个参数：\n\n- 第一个参数，是**注入名**，可以是一个字符串或是一个Symbol。后代组件会注入名用来查找期望注入的值。一个组件可以**多次**调用`provide()`，使用不同的注入名，注入不同的依赖值。\n- 第二个参数，提供的值，可以是任意类型，包括响应式的状态。比如一个ref：\n\n```js\nimport { ref, provide } from ''vue''\n\nconst count = ref(0)\nprovide(''key'', count)\n```\n\n提供的响应式状态，使后代组件，可以由此和提供者，建立响应式的联系。\n\n\n\n### 应用层Provide.\n\n要为组件后代供给数据，需要使用到 `provide()`函数：\n\n```tsx\nimport { provide } from ''vue''\n\nprovide(/* 注入名 */ ''message'', /* 值 */ ''hello!'')\n```\n\n接收两个参数。第一个参数被称为**注入名**，\n\n第二个参数是供给的值，值可以是任意类型，包括响应式的状态，比如一个 ref：\n\n```tsx\nimport { ref, provide } from ''vue''\n\nconst count = ref(0)\nprovide(''key'', count)\n```\n\n供给的响应式状态使后代组件可以由此和供给者建立响应式的联系。',2,148,707,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(509,'Inject(注入)','要注入祖先组件供给的数据，需使用 `inject()`函数：\n\n```tsx\nimport { inject } from ''vue''\n\nconst message = inject(''message'')\n```\n\n如果供给的值是一个 ref，注入进来的就是它本身，而**不会**自动解套。这使得被注入的组件保持了和供给者的响应性链接。\n\n同样的，如果没有使用 `<script setup>`，`inject()` 需要在 `setup()` 同步调用：\n\n```tsx\nimport { inject } from ''vue''\nexport default {\n  setup() {\n    const message = inject(''message'')\n    return { message }\n  }\n}\n```\n\n### 注入默认值\n\n默认情况下，假设`inject`传入的注入名会被某个祖先链上的组件提供。如果该注入名的确没有任何组件提供，则会抛出一个运行时警告。\n\n如果在提供的一侧看来属性是可选提供的，那么注入时我们应该声明一个默认值，和props类似：\n\n```js\n// 如果没有祖先组件提供 \"message\"，`value` 会是 \"这是默认值\"\nconst value = inject(''message'', ''这是默认值'')\n```\n\n在一些场景中，默认值可能需要通过调用一个函数或初始化一个类来取得。为了避免在不使用可选值的情况下，进行不必要的计算或产生effects副作用，我们可以使用工厂函数来创建默认值：\n\n```js\nconst value = inject(''key'', () => new ExpensiveClass())\n```\n\n',2,148,708,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(510,'依赖注入中的标注类型','provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型， Vue 提供了一个 `InjectionKey` 接口，它是一个继承自 `Symbol` 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型：\n\n```tsx\nimport { provide, inject, InjectionKey } from ''vue''\n\nconst key = Symbol() as InjectionKey<string>\n      \nprovide(key, ''foo'') // 若提供的是非字符串值会导致错误\n\nconst foo = inject(key) // foo 的类型：string | undefined\n```\n\n建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。\n\n当使用字符串注入 key 时，注入值的类型是 `unknown`，需要通过泛型参数显式声明：\n\n```tsx\nconst foo = inject<string>(''foo'') // 类型：string | undefined\n```\n\n注意注入的值仍然可以是 `undefined`，因为无法保证提供者一定会在运行时 provide 这个值。\n\n当提供了一个默认值后，这个 `undefined` 类型就可以被移除：\n\n```tsx\nconst foo = inject<string>(''foo'', ''bar'') // 类型：string\n```\n\n如果你确定该值将始终被提供，则还可以强制转换该值：\n\n```tsx\nconst foo = inject(''foo'') as string\n```\n\n',2,148,705,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(511,'依赖注入中传递函数','```tsx\n// 获取歌手详情\nconst getArtistDetail = async () => {\n    let params = {\n        id: route.query.id\n    }\n    await artistDetail(params).then(res => {\n        state.list = res.data.data\n        state.artistName = state.list.artist.name\n    })\n}\n// 获取歌手名称，使用 provide 传递给孙子组件使用\nconst getArtistName = () => {\n    return state.artistName\n}\n// provide 传值\nprovide(\"getArtistName\", getArtistName())\n```\n',2,148,705,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(513,'数组语法绑定','1- 数组语法：`[''rose'', ''abc'']`\n2- 三元运算： `[''rose'', ''abc'', isActive ? ''active'': '''']`\n3- 数组中添加对象： `[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]`,这里其实写三元有点复杂，所以数组语法中也支持嵌套对象语法。\n\n```html\n<template id=\"my-app\">\n  <div class=\"cos\" :class=\"[''rose'', ''abc'']\">数组语法1</div>\n  <div class=\"cos\" :class=\"[''rose'', ''abc'', isActive ? ''active'': '''']\">\n    三元运算\n  </div>\n  <div\n       class=\"cos\"\n       :class=\"[''rose'', ''abc'', isActive ? ''active'': '''', {current: isActive}]\"\n       >\n    数组中添加对象\n  </div>\n</template>\n```\n\n```tsx\n<script>\n  const App = {\n    template: \"#my-app\",\n    data() {\n      return {\n        isActive: false,\n        classObj: { active: true, rose: true },\n      };\n    },\n  };\n  Vue.createApp(App).mount(\"#app\");\n</script>\n```\n',2,3,405,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(514,'绑定一个对象','如果将一个对象的所有属性，绑定到元素上的所有属性, 可以直接使用 v-bind 绑定一个 对象；\n\n这种写法在高阶组件中常用。\n\n案例：info对象会被拆解成div的各个属性\n\n```html\n<div v-bind=\"cos\">属性直接绑定一个对象</div>\n<!-- \n这里是数据：\ncos: {\n    name: ''wang'',\n    age: 28,\n    job: ''web'',\n},\n-->\n```\n\n',2,3,405,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(517,'Transition组件','Vue 提供了两个内置组件，可以帮助你制作基于状态变化的过渡和动画：\n\n- `<Transition>`：在一个元素或组件，进入和离开 DOM 时，应用动画。\n- `<TransitionGroup>`：在一个元素或组件，在`v-for`列表中，被插入、移动或被移除时，应用动画。\n\n- 条件渲染 (使用 v-if)\n- 条件展示 (使用 v-show)\n- 动态组件\n- 组件根节点\n\n基本示例：\n\n```html\n<button @click=\"show = !show\">切换</button>\n<Transition>\n  <p v-if=\"show\">你好！</p>\n</Transition>\n```\n\n```css\n/* 下面我们会解释这些类是做什么的 */\n.v-enter-active,\n.v-leave-active {\n  transition: opacity 0.5s ease;\n}\n.v-enter-from,\n.v-leave-to {\n  opacity: 0;\n}\n```\n\n`<Transition>` 仅支持单个元素或组件作为其插槽内容。如果是一个组件，组件必须仅有一个根元素。\n\n当一个 `<Transition>` 组件中的元素被插入或移除时，会发生下面这些事情：\n\n1. Vue 会自动检测目标元素是否应用了 CSS 过渡或动画。如果是，则一些 CSS 过渡类会在适当的时机被添加和移除。\n2. 如果有作为监听器的 JavaScript 钩子，这些钩子函数会在适当时机被调用。\n3. 如果没有探测到 CSS 过渡或动画、没有提供 JavaScript 钩子，那么 DOM 的插入、删除操作将在浏览器的下一个动画帧上执行。',2,153,721,4,4,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(519,'为过渡命名','可以通过一个 `name` prop 来声明一种过渡：\n\n```html\n<Transition name=\"fade\">\n  ...\n</Transition>\n```\n\n对于一个有名字的过渡，它的过渡相关 CSS 类会以其名字而不是 `v` 作为前缀。举个例子，上面被应用的 CSS 类将会是 `fade-enter-active` 而不是 `v-enter-active`。这个“fade”过渡的 CSS 类将会是这样：\n\n```css\n.fade-enter-active,\n.fade-leave-active {\n  transition: opacity 0.5s ease;\n}\n\n.fade-enter-from,\n.fade-leave-to {\n  opacity: 0;\n}\n```\n',2,2,358,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(520,'Transition搭配CSS','`<Transition>` 一般都会搭配原生 CSS 过渡一起使用，正如你在上面的例子中所看到的那样。这个 `transition` CSS 属性是一个简写形式，使我们可以一次定义一个过渡的各个方面，包括需要执行动画的属性、持续时间和速度曲线。\n\n下面是一个更高级的例子，使用不同的持续时间和速度曲线来过渡多个属性：\n\n```html\n<Transition name=\"slide-fade\">\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 0.3s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 0.8s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translateX(20px);\n  opacity: 0;\n}\n```\n',2,2,722,4,3,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(521,'CSS中的Animation','原生 CSS 动画和 CSS trasition 的应用方式基本上是相同的，只有一点不同，那就是 `*-enter-from` 不是在元素插入后立即移除，而是在一个 `animationend` 事件触发时被移除。\n\n对于大多数的 CSS 动画，我们可以简单地在 `*-enter-active` 和 `*-leave-active` 类下面声明它们。下面是一个示例：\n\n```html\n<Transition name=\"bounce\">\n  <p v-if=\"show\" style=\"text-align: center;\">\n    你好！你会看到这里正在跳跃！\n  </p>\n</Transition>\n```\n\n```css\n.bounce-enter-active {\n  animation: bounce-in 0.5s;\n}\n.bounce-leave-active {\n  animation: bounce-in 0.5s reverse;\n}\n@keyframes bounce-in {\n  0% {\n    transform: scale(0);\n  }\n  50% {\n    transform: scale(1.25);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n```\n',2,2,388,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(522,'自定义过渡类','你也可以向 `<Transition>` 传递以下的 props 来指定自定义的过渡类：\n\n- `enter-from-class`\n- `enter-active-class`\n- `enter-to-class`\n- `leave-from-class`\n- `leave-active-class`\n- `leave-to-class`\n\n你传入的这些类会覆盖相应阶段的默认类名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如Animate.css\n\n```html\n<!-- 假设你已经引入了 Animate.css -->\n<Transition\n  name=\"custom-classes\"\n  enter-active-class=\"animate__animated animate__tada\"\n  leave-active-class=\"animate__animated animate__bounceOutRight\"\n>\n  <p v-if=\"show\">hello</p>\n</Transition>\n```\n',2,2,366,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(523,'同时使用Transition和Animation','Vue 需要附加事件侦听器，以便知道过渡何时结束。可以是 `transitionend` 或 `animationend`，这取决于你所应用的 CSS 规则。如果你仅仅使用二者其中之一，Vue 可以自动探测到正确的类型。\n\n然而在某些场景中，你或许想要在同一个元素上同时使用它们两个，举个例子，触发了一个 CSS 动画的同时，由于副作用触发了另一个 CSS 过渡。此时你需要显式地传入 `type` prop 来声明，告诉 Vue 需要关心哪种类型，传入的值是 `animation` 或 `transition`：\n\n```html\n<Transition type=\"animation\">...</Transition>\n```\n',2,2,360,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(525,'JavaScript钩子','你可以通过监听 `<Transition>` 组件事件的方式在过渡过程中挂上钩子函数：\n\n```html\n<Transition\n  @before-enter=\"onBeforeEnter\"\n  @enter=\"onEnter\"\n  @after-enter=\"onAfterEnter\"\n  @enter-cancelled=\"onEnterCancelled\"\n  @before-leave=\"onBeforeLeave\"\n  @leave=\"onLeave\"\n  @after-leave=\"onAfterLeave\"\n  @leave-cancelled=\"onLeaveCancelled\"\n>\n  <!-- ... -->\n</Transition>\n\n```\n\n```tsx\n// 在元素被插入到 DOM 之前被调用\n// 用这个来设置元素的 \"enter-from\" 状态\nfunction onBeforeEnter(el) {},\n\n// 在元素被插入到 DOM 之后的下一帧被调用\n// 用这个来开始进入动画\nfunction onEnter(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 当进入过渡完成时调用。\nfunction onAfterEnter(el) {}\nfunction onEnterCancelled(el) {}\n\n// 在 leave 钩子之前调用\n// 大多数时候，你应该只会用到 leave 钩子\nfunction onBeforeLeave(el) {}\n\n// 在离开过渡开始时调用\n// 用这个来开始离开动画\nfunction onLeave(el, done) {\n  // 调用回调函数 done 表示过渡结束\n  // 如果与 CSS 结合使用，则这个回调是可选参数\n  done()\n}\n\n// 在离开过渡完成、\n// 且元素已从 DOM 中移除时调用\nfunction onAfterLeave(el) {}\n\n// 仅在 v-show 过渡中可用\nfunction leaveCancelled(el) {}\n```\n\n这些钩子可以与 CSS 过渡/动画结合使用，也可以单独使用。\n\n在使用仅由 JavaScript 执行的动画时，最好是添加一个 `:css=\"false\"` prop。这显式地向 Vue 表明跳过 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡。\n\n```html\n<Transition\n  ...\n  :css=\"false\"\n>\n  ...\n</Transition>\n```\n\n在有了 `:css=\"false\"` 后，我们就全权自己负责控制什么时候过渡结束了。这种情况下对于 `@enter` 和 `@leave` 钩子来说，回调函数 `done` 就是必须的。否则，钩子将被同步调用，过渡将立即完成。',2,2,358,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(526,'可重用过渡','得益于 Vue 的组件系统，过渡是可以被重用的。要创建一个可被重用的过渡，我们需要为 `<Transition>` 组件创建一个包裹组件，并向内传入插槽内容：\n\n```html\n<!-- MyTransitio.vue -->\n<script>\n// JavaScript 钩子逻辑...\n</script>\n\n<template>\n  <!-- 包裹内置的 Transition 组件 -->\n  <Transition\n    name=\"my-transition\"\n    @enter=\"onEnter\"\n    @leave=\"onLeave\">\n    <slot></slot> <!-- 向内传递插槽内容 -->\n  </Transition>\n</tempalte>\n\n<style>\n/*\n  必要的 CSS...\n  注意：避免在这里使用 <style scoped>\n  因为那不会应用到插槽内容上\n*/\n</style>\n```\n\n现在 `MyTransition` 可以在导入后像内置组件那样使用了：\n\n```html\n<MyTransition>\n  <div v-if=\"show\">Hello</div>\n</MyTransition>\n```\n\n',2,2,358,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(527,'出现时过渡','如果你想在某个节点初次渲染时应用一个过渡效果，你可以添加 `appear` attribute：\n\n```html\n<Transition appear>\n  ...\n</Transition>\n```\n',2,2,357,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(530,'组件间过渡','`<Transition>` 也可以用在动态组件之间：\n\n```html\n<Transition name=\"fade\" mode=\"out-in\">\n  <component :is=\"activeComponent\"></component>\n</Transition>\n```\n\n',2,2,340,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(531,'动态过渡','`<Transition>` 的 props (比如 `name`) 也可以是动态的！这让我们可以根据状态变化动态地应用不同类型的过渡：\n\n```html\n<Transition :name=\"transitionName\">\n  <!-- ... -->\n</Transition>\n```\n\n当你使用 Vue 的过渡类约定规则定义了 CSS 过渡/动画，并想在它们之间切换时，这可能很有用。\n\n你也可以根据你的组件的当前状态在 JavaScript 过渡钩子中应用不同的行为。在此篇的最后，我们可以得出结论，创建动态过渡的终极方式是创建可重用的过渡组件，这些组件接受 prop 来改变过渡的性质。现在在编写动画时，就只有你想不到，没有做不到的了。',2,2,99,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(532,'控制动画时长','就是我们不管CSS中的动画和过渡时长，以标签为准。可以绑定属性`<transition :duration=\"1000\">` 来控制时长，意思是1秒后，结束动画和过渡。',2,2,342,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(533,'过度&动画的使用','```html\n<template>\n  <div id=\"app\">\n    <router-view v-slot=\"{ Component }\">\n      <transition name=\"fade\">\n        <keep-alive>\n          <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n        </keep-alive>\n      </transition>\n      <transition name=\"fade\">\n        <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n      </transition>\n    </router-view>\n  </div>\n</template>\n```\n\n```js\n\n<style lang=\"scss\">\n\n/* 可以为进入和离开动画设置不同的持续时间和动画函数 */\n.fade-enter-active {\n  //进入过程\n  animation: fade-in 0.8s cubic-bezier(0.39, 0.575, 0.565, 1) both;\n}\n.fade-leave-active {\n  //离开过程\n  animation: fade-out 0.3s ease-out both;\n}\n//进入开始和离开结束的状态\n.fade-enter-to {\n  opacity: 0;\n}\n//进入开始和离开结束的状态\n.fade-leave-to {\n  opacity: 0;\n}\n\n@keyframes fade-in {\n  0% {\n    opacity: 0;\n  }\n\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes fade-out {\n  0% {\n    opacity: 1;\n  }\n\n  100% {\n    opacity: 0;\n  }\n}\n</style>\n```\n',2,2,341,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(534,'动态切换组件','```html\n<template>\n    <div class=\"dynamicComponent\">\n        <ul>\n            <li v-for=\"(item, index) in tabList\" :key=\"index\" @click=\"change(index)\">{{ item.name }}</li>\n        </ul>\n        <!-- is的值是哪个组件的名称就显示哪个组件 -->\n        <component :is=\"state.com\"></component>\n    </div>\n</template>\n```\n\n```tsx\n//<script setup name=\"funcDynamicComponent\">\nimport A from ''./component/A.vue''\nimport B from ''./component/B.vue''\nimport C from ''./component/C.vue''\n\n// 因为 reactive 是响应式数据 proxy 但是组件确不需要响应式，所有需要使用 markRaw 或者 shallowRef 来避免\nconst tabList = reactive([\n    { name: ''A 组件'', com: markRaw(A) },\n    { name: ''B 组件'', com: markRaw(B) },\n    { name: ''C 组件'', com: markRaw(C) },\n])\nconst state = reactive({\n    com: tabList[0].com,\n})\n\n// 切换组件\nconst change = (index) => {\n    state.com = tabList[index].com\n}\n//</script>\n```\n',2,2,340,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(535,'动态切换组件2','```html\n<template>\n    <component :is=\"component[state.activeName]\" @closeDialog=\"closeDialog\" />\n</template>\n```\n\n```tsx\n//<script setup>\nimport Dashboard from ''./component/dashboard.vue'' // 登录指示板\nimport Code from ''./component/code.vue'' // 扫码登录\nimport Email from ''./component/email.vue'' // 邮箱登录\n\n// 跟踪自身 .value 变化的 ref，配合 component 使用\nconst component = shallowRef({\n	dashboard: Dashboard,\n	code: Code,\n	email: Email,\n})\n\n// 定义响应式数据\nconst state = reactive({\n	activeName: ''dashboard'', // 登录方式\n})\n//</script>\n```\n\n',2,2,290,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(536,'滚动属性','| 属性             | 说明                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| **clientWidth**  | 获取元素可视部分的宽度，即 CSS 的 width 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域。 |\n| **clientWidth**  | 获取元素可视部分的高度，即 CSS 的 height 和 padding 属性值之和，元素边框和滚动条不包括在内，也不包含任何可能的滚动区域。 |\n| **offsetWidth**  | 元素在页面中占据的宽度总和，包括 width、padding、border 以及滚动条的宽度。 |\n| **offsetHeight** | 只读属性，返回该元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。 |\n| **scrollWidth**  | 只读属性，是元素内容宽度的一种度量，括由于溢出导致的视图中不可见内容。 |\n| **scrollHeight** | 只读属性，是元素内容宽度的一种度量，括由于溢出导致的视图中不可见内容。 |\n| **scrollTop**    | 可以获取或设置一个元素的内容垂直滚动的像素数。               |\n| **scrollLeft**   | 可以读取或设置元素滚动条到元素左边的距离。                   |\n\n\n',2,93,275,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(537,'横向滚动','```js\n// HTML\n<div ref=\"xxxRef\"></div>\n<button @click=\"onScroll(''left'')\"></button>\n<button @click=\"onScroll(''right'')\"></button>\n \n// JS\nimport { ref, nextTick } from ''vue''\nconst xxxRef = ref(null)\nconst onScroll = (type) => {\n  nextTick(() => {\n    const distance = type === ''left'' ? 0 : xxxRef.value.scrollWidth;\n    xxxRef.value.scrollLeft = distance\n  })\n}\n```\n',2,93,1,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(538,'竖向滚动','```js\n// HTML\n<div ref=\"xxxRef\"></div>\n<button @click=\"onScroll(''top'')\">顶部</button>\n<button @click=\"onScroll(''bottom'')\">底部</button>\n \n// JS\nimport { ref, nextTick } from ''vue''\nconst xxxRef = ref(null)\nconst onScroll = (type) => {\n  nextTick(() => {\n    const distance = type === ''top'' ? 0 : xxxRef.value.scrollHeight;\n    xxxRef.value.scrollTop = distance\n  })\n}\n```\n',2,93,276,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(539,'滑动指定位置','```js\n  <button @click=\"onScroll2(200)\">下滑</button>\n  <button @click=\"onScroll3(200)\">上划</button>\n  <div ref=\"xxxRef\"></div>\n  \n  const onScroll2 = (type: number) => {\n  nextTick(() => {\n    xxxRef.value.scrollTop += type\n  })\n}\nconst onScroll3 = (type: number) => {\n  nextTick(() => {\n    xxxRef.value.scrollTop -= type\n  })\n}\n```\n',2,93,274,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(540,'丝滑滚动','``` css\nscroll-behavior: smooth;\n```\n\n\n',8,98,273,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(541,'网页文件下载','```tsx\nconst confirm = async (names: string, path: string) => {\n  let fileName = names + path.slice(-4)\n  await common.FileDownload(path).then((res: any) => {\n    // 地址转换\n    let url = window.URL.createObjectURL(res.data)\n    console.log(''%c [ url ]-32'', ''font-size:13px; background:pink; color:#bf2c9f;'', url)\n    // 文件名\n\n    const a = document.createElement(''a'')\n    a.setAttribute(''href'', url)\n    a.setAttribute(''download'', fileName)\n    document.body.append(a)\n    a.click()\n    document.body.removeChild(a)\n  })\n  message.success(''Click on Yes'')\n}\n```\n',2,94,289,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(542,'axios方法调用','```tsx\n //常用\n await computer.Get(data).then(r => {\n    rData = r.data\n  })\n  //简化\nrData = await (await computer.Get(data)).data\n```\n\n',3,97,272,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(543,'CSS变量注入','```tsx\n<template>\n  <span>变量注入</span>  \n</template>\n<script lang=\"ts\" setup>\n  import { ref } from ''vue''\n  const color = ref(''red'')\n</script>\n<style scoped>\n  span {\n    /* 使用v-bind绑定组件中定义的变量 */\n    color: v-bind(''color'');\n  }  \n</style>\n```\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(544,'JS隐式类型转换','// 字符串转数字代码对比 \n\n```js\nconst price = parseInt(''32''); //传统方式\nconst price = Number(''32''); //传统方式\nconst price = +''32''; //新方式\n```\n\n// 日期转换为时间戳代码对比 \n\n```js\nconst timeStamp = new Date().getTime(); //传统方式\nconst timeStamp = +new Date(); //新方式\n```\n\n//布尔转数字新方式\n\n```js\nconsole.log(+true); // Return: 1\nconsole.log(+false); // Return: 0\n```\n\n',6,53,271,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(545,'动态导入css样式','**dynamicScss.ts**\n\n```ts\nconst SCSS: number = 1\nasync function toScss(nameCss: string) {\n  switch (nameCss) {\n    case ''sAbout'':\n      if (SCSS === 1) {\n        import(''../views/sAbout/index.scss'')\n      }\n      break\n    case ''index'':\n      if (SCSS === 1) {\n        import(''../views/sAbout/index.scss'')\n      }\n  }\n}\nexport default toScss\n```\n\n```tsx\nimport { toScss } from \"../../hooks/dynamicScss\";\nawait toScss(\"sAbout\");\n```\n\n',2,96,270,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(546,'封装ts属性','**data.ts**\n\n```tsx\nimport { reactive } from \"vue\";\nexport interface BlogsList {\n  rData: any, // 显示的数据\n  page: number, //页码\n  pagesize: number, //每页条数\n  count: number, //总数\n}\n\nexport const blogsList: BlogsList = reactive({\n  rData: [],\n  page: 1,\n  pagesize: 10,\n  count: 0,\n})\n```\n\n **vue**\n\n```tsx\nimport { blogsList } from \"../Blogs/components/data\";\n```\n',2,94,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(547,'函数封装',' **index.ts**\n\n```tsx\nexport class blogs {\n\n  static async Getxxx() {\n    await article.GetFyAsync(page,pagesize).then((r: any) => {\n      return rData = r.data;\n    });\n  }\n}\n```\n\n**index.vue**\n\n```ts\nimport { blogs } from \"./index\";\nawait blogs.Getxxx();\n```\n\n',2,96,87,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(548,'模板调试','场景:在Vue开发过程中, 经常会遇到template模板渲染时JavaScript变量出错的问题, 此时也许你会通过console.log来进行调试 这时可以在开发环境挂载一个 log 函数\n\n```html\n// main.js\napp.config.globalProperties.$log = window.console.log\n// 组件内部\n<div>{{$log(info)}}</div>\n```\n',2,94,268,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(549,'校验数据类型','```js\nexport const typeOf = function(obj) {\n  return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()\n}\n```\n\n```js\ntypeOf(''树哥'')  // string\ntypeOf([])  // array\ntypeOf(new Date())  // date\ntypeOf(null) // null\ntypeOf(true) // boolean\ntypeOf(() => { }) // function\n```\n\n',6,53,266,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(550,'大小写转换','**参数：**\n\n- str 待转换的字符串\n- type 1-全大写 2-全小写 3-首字母大写\n\n```js\nexport const turnCase = (str, type) => {\n  switch (type) {\n    case 1:\n      return str.toUpperCase()\n    case 2:\n      return str.toLowerCase()\n    case 3:\n      //return str[0].toUpperCase() + str.substr(1).toLowerCase() // substr 已不推荐使用\n      return str[0].toUpperCase() + str.substring(1).toLowerCase()\n    default:\n      return str\n  }\n}\n```\n\n```js\nturnCase(''vue'', 1) // VUE\nturnCase(''REACT'', 2) // react\nturnCase(''vue'', 3) // Vue\n```\n',2,94,265,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(551,'解析URL参数','```js\nexport const getSearchParams = () => {\n  const searchPar = new URLSearchParams(window.location.search)\n  const paramsObj = {}\n  for (const [key, value] of searchPar.entries()) {\n    paramsObj[key] = value\n  }\n  return paramsObj\n}\n```\n\n```js\n// 假设目前位于 https://****com/index?id=154513&age=18;\ngetSearchParams(); // {id: \"154513\", age: \"18\"}\n```\n',6,89,135,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(552,'判断手机是Andoird还是IOS','```js\n/** \n * 1: ios\n * 2: android\n * 3: 其它\n */\nexport const getOSType=() => {\n  let u = navigator.userAgent, app = navigator.appVersion;\n  let isAndroid = u.indexOf(''Android'') > -1 || u.indexOf(''Linux'') > -1;\n  let isIOS = !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/);\n  if (isIOS) {\n    return 1;\n  }\n  if (isAndroid) {\n    return 2;\n  }\n  return 3;\n}\n```\n',6,53,107,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(553,'生成UUID','```js\nfunction uuid() {\n  var temp_url = URL.createObjectURL(new Blob());\n  var uuid = temp_url.toString(); // blob:https://xxx.com/b250d159-e1b6-4a87-9002-885d90033be3\n  URL.revokeObjectURL(temp_url);\n  return uuid.substr(uuid.lastIndexOf(\"/\") + 1);\n}\n```\n',6,89,262,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(555,'使用&&替代if','```js\nconst doSometions = () => {}\nconst isTrue = true\nlet temp = ''''\nif(isTrue){\n    doSometings()\n    temp = ''isTrue''\n}\n\n// 替代方案\nisTrue && this.doSometings()\nisTrue && (temp == ''isTrue'')\n```\n',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(556,'数组对象根据字段去重','**参数：**\n\n- arr 要去重的数组\n- key 根据去重的字段名\n\n```js\nexport const uniqueArrayObject = (arr = [], key = ''id'') => {\n  if (arr.length === 0) return\n  let list = []\n  const map = {}\n  arr.forEach((item) => {\n    if (!map[item[key]]) {\n      map[item[key]] = item\n    }\n  })\n  list = Object.values(map)\n\n  return list\n}\n```\n\n```js\nconst responseList = [\n    { id: 1, name: ''树哥'' },\n    { id: 2, name: ''黄老爷'' },\n    { id: 3, name: ''张麻子'' },\n    { id: 1, name: ''黄老爷'' },\n    { id: 2, name: ''张麻子'' },\n    { id: 3, name: ''树哥'' },\n    { id: 1, name: ''树哥'' },\n    { id: 2, name: ''黄老爷'' },\n    { id: 3, name: ''张麻子'' },\n]\n\nuniqueArrayObject(responseList, ''id'')\n// [{ id: 1, name: ''树哥'' },{ id: 2, name: ''黄老爷'' },{ id: 3, name: ''张麻子'' }]\n```\n\n',6,47,261,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(557,'滚动到元素位置','```js\nexport const smoothScroll = element =>{\n    document.querySelector(element).scrollIntoView({\n        behavior: ''smooth''\n    });\n};\n```\n\n```js\nsmoothScroll(''#target''); // 平滑滚动到 ID 为 target 的元素\n```\n',6,84,260,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(559,'三元运算符简化ifelse','```js\n//Longhand \nlet marks = 26; \nlet result; \nif (marks >= 30) {\n   result = ''Pass''; \n} else { \n   result = ''Fail''; \n} \n//Shorthand \nlet result = marks >= 30 ? ''Pass'' : ''Fail'';\n```\n',6,92,258,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(560,'||运算符给变量指定默认值','本质是利用了`||`运算符的特点，当前面的表达式的结果转成布尔值为`false`时，则值为后面表达式的结果\n\n短路运算有时候可以用来代替一些比较简单的 `if else`\n\n```js\n//Longhand\nlet imagePath;\nlet path = getImagePath();\n\nif (path !== null && path !== undefined && path !== '''') {\n    imagePath = path;\n} else {\n    imagePath = ''default.jpg'';\n}\n\n//Shorthand\nlet imagePath = getImagePath() || ''default.jpg'';\nlet c = a || b\n```\n\n',6,92,257,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(561,'使用字符串模板简化代码','```js\n//Longhand\nconsole.log(''You got a missed call from '' + number + '' at '' + time);\n//Shorthand\nconsole.log(`You got a missed call from ${number} at ${time}`);\n```\n\n',6,53,256,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(562,'网页跳转','```tsx\n  //当前窗口跳转\n   self.location.href=url\n  //新窗口跳转\n   window.open(url)\n  //跳转链接 返回上一页\n   window.history.back(-1);\n```\n\n self 指代当前窗口对象，属于window 最上层的对象。\n\n  location.href 指的是某window对象的url的地址\n\n  self.location.href 指当前窗口的url地址，去掉self默认为当前窗口的url地址，一般用于防止外部的引用\n\ntop.location.href:为引用test.html页面url的**父窗口对象的url**',6,53,255,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(563,'取最后一位数字','```javascript\nconst num = 12345\nconst num2 = ''54321''\nconsole.log(num%10) // 5\nconsole.log(num2%10) // 1 当然隐式转换也是可以的\n```\n\n',6,53,254,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(564,'滚动到页面顶部','```js\nconst goToTop = () => window.scrollTo(0, 0);\ngoToTop();\n```\n',6,84,176,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(565,'判断简化','如果有下面的这样的一个判断：\n\n```javascript\nif(a === undefined || a === 10 || a=== 15 || a === null) {\n    //...\n}\n```\n\n就可以使用数组来简化这个判断逻辑：\n\n```javascript\nif([undefined, 10, 15, null].includes(a)) {\n    //...\n}\n```\n\n这样代码就会简洁很多，并且便于扩展，如果还有需要等于a的判断，直接在数组中添加即可。',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(566,'一元运算符简化字符串转数字','```js\n//Longhand\nlet total = parseInt(''453'');\nlet average = parseFloat(''42.6'');\n\n//Shorthand\nlet total = +''453'';\nlet average = +''42.6'';\n```\n\n',6,72,211,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(567,'清空数组','如果想要清空一个数组，可以将数组的length置于0:\n\n```javascript\nlet array = [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"]\narray.length = 0 \nconsole.log(array)  // []\n```\n\n',6,47,250,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(568,'验证undefined和null','如果有这样一段代码：\n\n```javascript\nif(a === null || a === undefined) {\n    doSomething()\n}\n```\n\n也就是如果需要验证一个值如果等于null或者undefined时，需要执行一个操作时，可以使用空值合并运算符来简化上面的代码：\n\n```javascript\na ?? doSomething()\n```\n',6,87,235,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(569,'组元素转化为数字','如果有一个数组，想要把数组中的元素转化为数字，可以使用map方法来实现：\n\n```javascript\nconst array = [''12'', ''1'', ''3.1415'', ''-10.01''];\narray.map(Number);  // [12, 1, 3.1415, -10.01]\n```\n',6,47,167,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(570,'检查日期是否有效','该方法用于检测给出的日期是否有效：\n\n```javascript\nconst isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());\n\nisDateValid(\"December 17, 1995 03:24:00\");  // true\n```\n',6,53,94,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(571,'计算两个日期之间的间隔','该方法用于计算两个日期之间的间隔时间：\n\n```javascript\nconst dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\n\ndayDif(new Date(\"2021-11-3\"), \n       new Date(\"2022-2-1\"))  // 90\n```\n\n距离过年还有90天~',6,53,246,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(572,'查找日期位于一年中的第几天','该方法用于检测给出的日期位于今年的第几天：\n\n```javascript\nconst dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayOfYear(new Date());   // 307\n```\n\n2021年已经过去300多天了~',6,53,245,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(573,'全局挂载','```tsx\n//main\nimport axios from ''./api/axios''\nconst app = createApp(App);\n// 全局ctx(this) 上挂载 $axios\napp.config.globalProperties.$api = axios\n\n//vue\nconst { proxy }: any = getCurrentInstance() //获取上下文实例，ctx=vue2的this\n proxy.$api\n```\n',2,94,244,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(574,'简化consolelog','\n\n进行调试时书写很多console.log()就会比较麻烦，使用以下形式来简化：\n\n```javascript\nconst c = console.log.bind(document) \nc(996) \nc(\"hello world\")\n```\n',6,53,243,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(575,'生成长度为N的数组','\n```js\n// 生成长度为100的数组\nconst arrN = [...Array(100).keys()]\n// [0,1,2,3,...,99]\n```\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(576,'取整','```javascript\nconst num = 123.456\nconsole.log(num | 0) // 123\n```\n',6,72,241,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(577,'邮箱验证','```js\nexport const isEmail = (e) => {\nreturn /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/.test(e)\n}\n```\n',6,53,240,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(578,'手机号码','\n\n```js\nexport const isMobile = (e) => {\nreturn /^1[0-9]{10}$/.test(e)\n}\n```\n',6,53,202,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(579,'带有多个条件的 if 语句','```js\n//longhand\nif (x === ''abc'' || x === ''def'' || x === ''ghi'' || x ===''jkl'') {\n    //logic\n}\n//shorthand\nif ([''abc'', ''def'', ''ghi'', ''jkl''].includes(x)) {\n   //logic\n}\n```\n',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(580,'简化 if true...else','对于不包含大逻辑的 if-else 条件，可以使用下面的快捷写法。我们可以简单地使用三元运算符来实现这种简化。\n\n```js\n// Longhand\nlet test: boolean;\nif (x > 100) {\n  test = true;\n} else {\n  test = false;\n}\n// Shorthand\nlet test = x > 10 ? true : false;\n//或者我们也可以直接用\nlet test = x > 10;\nconsole.log(test);\n```',6,91,237,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(581,'声明变量','想要声明两个具有相同的值或相同类型的变量时，可以使用这种简写。\n\n```js\n//Longhand\nlet test1;\nlet test2 = 1;\n//Shorthand\nlet test1,\n  test2 = 1;\n```',6,72,96,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(582,'null,undefined和空值检查','我们创建了新变量，有时候想要检查引用的变量是不是为非 null 或 undefined。JavaScript 确实有一个很好的快捷方式来实现这种检查。\n\n```js\n// Longhand\nif (test1 !== null || test1 !== undefined || test1 !== '''') {\n  let test2 = test1;\n}\n// Shorthand\nlet test2 = test1 || '''';\n```',6,53,235,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(583,'滚动监听','\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop\n  // 可视区的高度\n  const { clientHeight } = document.documentElement\n  if (scrollTop > clientHeight) {\n    hHead.value = false\n  } else {\n    hHead.value = true\n  }\n}\n\nonDeactivated(() => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll)\n})\nonMounted(async () => {\n  await GetType()\n  // 给window添加一个滚动监听事件\n  window.addEventListener(''scroll'', scroll)\n})\n```\n\n',2,93,233,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(584,'给多个变量赋值','想给多个不同的变量赋值时，这种技巧非常有用。\n\n```js\n//Longhand\nlet test1, test2, test3;\ntest1 = 1;\ntest2 = 2;\ntest3 = 3;\n//Shorthand\nlet [test1, test2, test3] = [1, 2, 3];\n```',6,72,103,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(585,'简便的赋值操作符','编程过程中，我们要处理大量的算术运算符。这是 JavaScript 变量赋值操作符的有用技巧之\n\n```js\n// Longhand\ntest1 = test1 + 1;\ntest2 = test2 - 1;\ntest3 = test3 * 20;\n// Shorthand\ntest1++;\ntest2--;\ntest3 *= 20;\n```',6,92,121,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(586,'if判断值是否存在','这是我们都在使用的一种常用的简便技巧，在这里仍然值得再提一下。\n\n```js\n// Longhand\nif (test1 === true) or if (test1 !== \"\") or if (test1 !== null)\n// Shorthand //检查空字符串、null或者undefined\nif (test1)\n```\n\n注意：如果 test1 有值，将执行 if 之后的逻辑，这个操作符主要用于 null 或 undefinded 检查。',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(587,'用于多个条件判断的 && 操作符','如果只在变量为 true 时才调用函数，可以使用 && 操作符。\n\n```js\n//Longhand\nif (test1) {\n  callMethod();\n}\n//Shorthand\ntest1 && callMethod();\n```',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(588,'for each循环','这是一种常见的循环简化技巧。\n\n```js\n// Longhand\nfor (var i = 0; i < testData.length; i++)\n// Shorthand\nfor (let i in testData) or  for (let i of testData)\n```\n\n遍历数组的每一个变量。\n\n```js\nfunction testData(element, index, array) {\n  console.log(''test['' + index + ''] = '' + element);\n}\n[11, 24, 32].forEach(testData);\n// logs: test[0] = 11, test[1] = 24, test[2] = 32\n```',6,90,225,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(589,'比较后返回函数','我们也可以在 return 语句中使用比较，它可以将 5 行代码减少到 1 行。\n\n```javascript\n// Longhand\nlet test;\nfunction checkReturn() {\n  if (!(test === undefined)) {\n    return test;\n  } else {\n    return callMe(''test'');\n  }\n}\nvar data = checkReturn();\nconsole.log(data); //output test\nfunction callMe(val) {\n  console.log(val);\n}\n// Shorthand\nfunction checkReturn() {\n  return test || callMe(''test'');\n}\n```',6,90,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(590,'箭头函数','```js\n//Longhand\nfunction add(a, b) {\n  return a + b;\n}\n//Shorthand\nconst add = (a, b) => a + b;\n```\n\n更多例子：\n\n```js\nfunction callMe(name) {\n  console.log(''Hello'', name);\n}\ncallMe = (name) => console.log(''Hello'', name);\n```',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(591,'简短的函数调用','我们可以使用三元操作符来实现多个函数调用。\n\n```js\n// Longhand\nfunction test1() {\n  console.log(''test1'');\n}\nfunction test2() {\n  console.log(''test2'');\n}\nvar test3 = 1;\nif (test3 == 1) {\n  test1();\n} else {\n  test2();\n}\n// Shorthand\n(test3 === 1 ? test1 : test2)();\n```',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(592,'switch简化','我们可以将条件保存在键值对象中，并根据条件来调用它们。\n\n```js\n// Longhand\nswitch (data) {\n  case 1:\n    test1();\n    break;\n  case 2:\n    test2();\n    break;\n  case 3:\n    test();\n    break;\n  // ...\n}\n// Shorthand\nvar data = {\n  1: test1,\n  2: test2,\n  3: test\n};\ndata[something] && data[something]();\n```',6,53,221,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(593,'隐式返回','通过使用箭头函数，我们可以直接返回值，不需要 return 语句。\n\n```javascript\n//longhand\nfunction calculate(diameter) {\n  return Math.PI * diameter\n}\n//shorthand\ncalculate = diameter => (\n  Math.PI * diameter;\n)\n```',6,89,92,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(594,'指数表示法','```js\n// Longhand\nfor (var i = 0; i < 10000; i++) { ... }\n// Shorthand\nfor (var i = 0; i < 1e4; i++) {\n```',6,90,220,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(595,'默认参数值','```js\n//Longhand\nfunction add(test1, test2) {\n  if (test1 === undefined) test1 = 1;\n  if (test2 === undefined) test2 = 2;\n  return test1 + test2;\n}\n//shorthand\nadd = (test1 = 1, test2 = 2) => test1 + test2;\nadd(); //输出结果: 3\n```',6,89,219,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(596,'undefined检查和默认赋值','```js\nlet test1 = undefined,\n    test2 = test1 || '''';\nconsole.log(\"undefined check\", test2); // 输出 \"\"\n```\n\n一般值检查\n\n```js\nlet test1 = ''test'',\n  test2 = test1 || '''';\nconsole.log(test2); // 输出: ''test''\n```\n\n**另外，对于上述的 4、5、6 点，都可以使用?? 操作符。**\n\n如果左边值为 null 或 undefined，就返回右边的值。默认情况下，它将返回左边的值。\n\n```js\nconst test = null ?? ''default'';\nconsole.log(test);\n// 输出结果: \"default\"\nconst test1 = 0 ?? 2;\nconsole.log(test1);\n// 输出结果: 0  \n```',6,53,216,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(597,'延展操作符简化','```js\n//longhand\n// 使用concat连接数组\nconst data = [1, 2, 3];\nconst test = [4, 5, 6].concat(data);\n//shorthand\n// 连接数组\nconst data = [1, 2, 3];\nconst test = [4, 5, 6, ...data];\nconsole.log(test); // [ 4, 5, 6, 1, 2, 3]\n```\n\n我们也可以使用延展操作符进行克隆。\n\n```js\n//longhand\n// 克隆数组\nconst test1 = [1, 2, 3];\nconst test2 = test1.slice();\n//shorthand\n//克隆数组\nconst test1 = [1, 2, 3];\nconst test2 = [...test1];\n```',6,47,121,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(598,'模板字面量','如果你厌倦了使用 + 将多个变量连接成一个字符串，那么这个简化技巧将让你不再头痛。\n\n```js\n//longhand\nconst welcome = ''Hi '' + test1 + '' '' + test2 + ''.'';\n//shorthand\nconst welcome = `Hi ${test1} ${test2}`;\n```',6,53,214,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(599,'跨行字符串','当我们在代码中处理跨行字符串时，可以这样做。\n\n```js\n//longhand\nconst data = ''abc abc abc abc abc abc\\n\\t'' + ''test test,test test test test\\n\\t'';\n//shorthand\nconst data = `abc abc abc abc abc abc\n         test test,test test test test`;\n```',6,72,213,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(600,'对象属性赋值','```js\nlet test1 = ''a'';\nlet test2 = ''b'';\n//Longhand\nlet obj = { test1: test1, test2: test2 };\n//Shorthand\nlet obj = { test1, test2 };\n```',6,87,73,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(601,'将字符串转成数字','\n```js\n//Longhand\nlet test1 = parseInt(''123'');\nlet test2 = parseFloat(''12.3'');\n//Shorthand\nlet test1 = +''123'';\nlet test2 = +''12.3'';\n```',6,72,211,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(602,'解构赋值','```js\n//longhand\nconst test1 = this.data.test1;\nconst test2 = this.data.test2;\nconst test2 = this.data.test3;\n//shorthand\nconst { test1, test2, test3 } = this.data;\n```',6,72,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(603,'数组find简化','当我们有一个对象数组，并想根据对象属性找到特定对象，find 方法会非常有用。\n\n```js\nconst data = [\n  {\n    type: ''test1'',\n    name: ''abc''\n  },\n  {\n    type: ''test2'',\n    name: ''cde''\n  },\n  {\n    type: ''test1'',\n    name: ''fgh''\n  }\n];\nfunction findtest1(name) {\n  for (let i = 0; i < data.length; ++i) {\n    if (data[i].type === ''test1'' && data[i].name === name) {\n      return data[i];\n    }\n  }\n}\n//Shorthand\nfilteredData = data.find((data) => data.type === ''test1'' && data.name === ''fgh'');\nconsole.log(filteredData); // { type: ''test1'', name: ''fgh'' }\n```',6,47,209,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(604,'条件查找简化','如果我们要基于不同的类型调用不同的方法，可以使用多个 else if 语句或 switch，但有没有比这更好的简化技巧呢？\n\n```js\n// Longhand\nif (type === ''test1'') {\n  test1();\n} else if (type === ''test2'') {\n  test2();\n} else if (type === ''test3'') {\n  test3();\n} else if (type === ''test4'') {\n  test4();\n} else {\n  throw new Error(''Invalid value '' + type);\n}\n// Shorthand\nvar types = {\n  test1: test1,\n  test2: test2,\n  test3: test3,\n  test4: test4\n};\nvar func = types[type];\n!func && throw new Error(''Invalid value '' + type);\nfunc();\n```',6,53,208,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(605,'indexOf的按位操作简化','在查找数组的某个值时，我们可以使用 indexOf() 方法。但有一种更好的方法，让我们来看一下这个例子。\n\n```js\n//longhand\nif (arr.indexOf(item) > -1) {\n  // item found\n}\nif (arr.indexOf(item) === -1) {\n  // item not found\n}\n//shorthand\nif (~arr.indexOf(item)) {\n  // item found\n}\nif (!~arr.indexOf(item)) {\n  // item not found\n}\n```\n\n按位 ( ~ ) 运算符将返回 true（-1 除外），反向操作只需要!~。另外，也可以使用 include() 函数。\n\n```js\nif (arr.includes(item)) {\n  // 如果找到项目，则为true\n}\n```',6,53,207,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(606,'重复字符串多次','为了重复操作相同的字符，我们可以使用 for 循环，但其实还有一种简便的方法。\n\n```js\n//longhand\nlet test = '''';\nfor (let i = 0; i < 5; i++) {\n  test += ''test '';\n}\nconsole.log(str); // test test test test test\n//shorthand\n''test ''.repeat(5);\n```',6,72,206,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(607,'时间格式化','该方法可以用于将时间转化为 hour:minutes:seconds 的格式：\n\n```javascript\nconst timeFromDate = (date) => date.toTimeString().slice(0, 8);\n\ntimeFromDate(new Date(2021, 11, 2, 12, 30, 0)); // 12:30:00\ntimeFromDate(new Date()); // 返回当前时间 09:00:00\n```',6,53,205,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(608,'查找数组的最大值和最小值','```js\nconst arr = [1, 2, 3];\nMath.max(…arr); // 3\nMath.min(…arr); // 1\n```',6,47,204,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(609,'获取字符串的字符','```js\nlet str = ''abc'';\n//Longhand\nstr.charAt(2); // c\n//Shorthand\nstr[2]; // c\n```',6,72,203,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(611,'号码判断','```js\nexport const isPhone = (e) => {\n  return /^([0-9]{3,4}-)?[0-9]{7,8}$/.test(e);\n};\n```',6,53,202,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(612,'是否url地址','```js\nexport const isURL = (e) => {\n  return /^http[s]?:\\/\\/.*/.test(e);\n};\n```',6,53,201,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(613,'是否字符串','```js\nexport const isNumber = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''String'';\n};\n```',6,53,200,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(614,'是否数字','```js\nexport const isNumber = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Number'';\n};\n```',6,53,199,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(615,'是否boolean','```js\nexport const isBoolean = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Boolean'';\n};\n```',6,53,198,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(616,'是否函数','```js\nexport const isFunction = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Function'';\n};\n```',6,53,197,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(617,'是否为null','```js\nexport const isNull = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Null'';\n};\n```',6,72,113,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(620,'是否数组','```js\nexport const isArray = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Array'';\n};\n```',6,53,196,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(621,'是否正则','```js\nexport const isRegExp = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''RegExp'';\n};\n```',6,53,195,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(622,'是否错误对象','```js\nexport const isError = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Error'';\n};\n```',6,53,73,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(623,'是否Symbol函数','```js\nexport const isSymbol = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Symbol'';\n};\n```',6,53,130,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(624,'是否Promise对象','```js\nexport const isPromise = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Promise'';\n};\n```',6,53,192,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(625,'是否Set对象','```js\nexport const isSet = (e) => {\n  return Object.prototype.toString.call(e).slice(8, -1) === ''Set'';\n};\nexport const us = navigator.userAgent.toLowerCase();\n```',6,53,191,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(626,'是否是微信浏览器','```js\nexport const isWeiXin = () => {\n  return ua.match(/microMessenger/i) == ''micromessenger'';\n};\n```',6,53,188,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(627,'是否是QQ浏览器','```js\nexport const isQQBrowser = () => {\n  return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i);\n};\n```',6,53,188,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(628,'是否是移动端','```js\nexport const isDeviceMobile = () => {\n  return /android|webos|iphone|ipod|balckberry/i.test(ua);\n};\n```',6,53,106,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(629,'是否是爬虫','```js\nexport const isSpider = () => {\n  return /adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sougou orion spider/.test(\n    ua\n  );\n};\n```',6,53,187,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(631,'是否PC端','```js\nexport const isPC = () => {\n  var userAgentInfo = navigator.userAgent;\n  var Agents = [''Android'', ''iPhone'', ''SymbuanOS'', ''Windows Phone'', ''iPad'', ''iPod''];\n  var flag = true;\n  for (var i = 0; i < Agents.length; i++) {\n    if (userAgentInfo.indexOf(Agents[i]) > 0) {\n      flag = false;\n      break;\n    }\n  }\n  return flag;\n};\n```',6,53,185,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(632,'去除 html 标签','```js\nexport const removehtmltag = (str) => {\n  return str.replace(/<[^>]+>/g, '''');\n};\n```',6,53,57,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(633,'获取url参数','```js\nexport const getQueryString = (name) => {\n  const reg = new RegExp(''(^|&)'' + name + ''=([^&]*)(&|$)'', ''i'');\n  const search = window.location.search.split(''?'')[1] || '''';\n  const r = search.match(reg) || [];\n  return r[2];\n};\n```',6,53,155,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(634,'动态引入 js','```js\nexport const injectScript = (src) => {\n  const s = document.createElement(''script'');\n  s.type = ''text/JavaScript'';\n  s.async = true;\n  s.src = src;\n  const t = document.getElentsByTagName(''script'')[0];\n  t.parentNode.insertBefore(s, t);\n};\n```',6,53,174,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(635,'根据url地址下载','```js\nexport const download = (url) => {\n  var isChrome = navigator.userAgent.toLowerCase().indexOf(''chrome'') > -1;\n  var isSafari = navigator.userAgent.toLowerCase().indexOf(''safari'') > -1;\n  if (isChrome || isSafari) {\n    var link = document.createElement(''a'');\n    link.href = url;\n    if (link.download !== undefined) {\n      var fileName = url.substring(url.lastIndexOf(''/'') + 1, url.length);\n      link.download = fileName;\n    }\n    if (document.createEvent) {\n      var e = document.createEvent(''MouseEvents'');\n      e.initEvent(''click'', true, true);\n      link.dispatchEvent(e);\n      return true;\n    }\n  }\n  if (url.indexOf(''?'') === -1) {\n    url += ''?download'';\n  }\n  window.open(url, ''_self'');\n  return true;\n};\n```',6,53,182,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(636,'el 是否包含某个 class','```js\nexport const hasClass = (el, className) => {\n  let reg = new RegExp(''(^|\\\\s)'' + className + ''(\\\\s|$)'');\n  return reg.test(el.className);\n};\n```',6,53,53,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(637,'el 添加某个 class','```js\nexport const addClass = (el, className) => {\n  if (hasClass(el, className)) {\n    return;\n  }\n  let newClass = el.className.split('' '');\n  newClass.push(className);\n  el.className = newClass.join('' '');\n};\n```',6,53,53,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(638,'el 去除某个 class','```js\nexport cosnt removeClass = (el,className)=>{\nif(!hasClass(el,className)){\nreturn\n}\nlet reg = new RegExp(''(^|\\\\s)''+className+''(\\\\s|$)'',''g'')\nel.className = el.className.replace(reg,'''')\n}\n```',6,53,53,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(639,'获取滚动的坐标','```js\nexport const getScrollPosition = (el = window) => ({\n  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,\n  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop\n});\n```',6,84,178,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(640,'滚动到顶部','```js\nexport cosnt scrollToTop = ()=>{\nconst c = document.documentElement.scrollTop || document.body.scrollTop;\nif(c>0){\nwindow.requestAnimationFrame(scrollToTop);\nwindow.scrollTo(0,c-c/8);\n}\n}\n```\n',6,84,177,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(641,'el 是否在视口范围','```js\nexport const elementIsVisibleInViewport = (el,partiallyVisib = false)=>{\ncosnt {top,left,right,bottom} = el.getBoundingClienRect();\nconst {innerHeight,innerWidth} = window;\nreturn partiallyVisible\n? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) && ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth)) : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;\n}\n```',6,53,176,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(643,'判断类型的集合','```js\nexport const checkStr = (str, type) => {\nswitch (type) {\ncase ''phone'':\n//手机号码\nreturn /^1[3|4|5|6|7|8|9][0-9]{9}$/.test(str);\ncase ''tel'':\n//座机\nreturn /^(0\\d{2,3}-\\d{7,8})(-\\d{1,4})?$/.test(str);\ncase ''card'':\n//身份证\nreturn /(^\\d{15}$)|(^\\d{18}$)|(^\\d{17}(\\d|X|x)$)/.test(str);\ncase ''pwd'':\n//密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线\nreturn /^[a-zA-Z]\\w{5,17}$/.test(str)\ncase ''postal'':\n//邮政编码\nreturn /[1-9]\\d{5}(?!\\d)/.test(str);\ncase ''QQ'':\n//QQ号\nreturn /^[1-9][0-9]{4,9}$/.test(str);\ncase ''email'':\n//邮箱\nreturn /^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/.test(str);\ncase ''money'':\n//金额(小数点2位)\nreturn /^\\d*(?:\\.\\d{0,2})?$/.test(str);\ncase ''URL'':\n//网址\nreturn /(http|ftp|https):\\/\\/[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^=%&:/~\\+#]*[\\w\\-\\@?^=%&/~\\+#])?/.test(str)\ncase ''IP'':\n//IP\nreturn /((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.){3}(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))/.test(str);\ncase ''date'':\n//日期时间\nreturn /^(\\d{4})\\-(\\d{2})\\-(\\d{2}) (\\d{2})(?:\\:\\d{2}|:(\\d{2}):(\\d{2}))$/.test(str) || /^(\\d{4})\\-(\\d{2})\\-(\\d{2})$/.test(str) case ''number'':\n//数字\nreturn /^[0-9]$/.test(str);\ncase ''english'':\n//英文\nreturn /^[a-zA-Z]+$/.test(str);\ncase ''chinese'':\n//中文\nreturn /^[\\\\u4E00-\\\\u9FA5]+$/.test(str);\ncase ''lower'':\n//小写\nreturn /^[a-z]+$/.test(str);\ncase ''upper'':\n//大写\nreturn /^[A-Z]+$/.test(str);\ncase ''HTML'':\n//HTML标记\nreturn /<(\"[^\"]*\"|''[^'']*''|[^''\">])*>/.test(str);\ndefault:\nreturn true;\n}\n}\n```',6,53,175,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(645,'随机数范围','```js\nexport const random = (min, max) => {\nif (arguments.length === 2) {\nreturn Math.floor(min + Math.random() * ((max + 1) - min))\n} else {\nreturn null;\n}\n```',6,53,153,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(646,'将阿拉伯数字翻译成中文的大写数字','```js\nexport const numberToChinese = (num) => {\n  var AA = new Array(''零'', ''一'', ''二'', ''三'', ''四'', ''五'', ''六'', ''七'', ''八'', ''九'', ''十'');\n  var BB = new Array('''', ''十'', ''百'', ''仟'', ''萬'', ''億'', ''点'', '''');\n  var a = ('''' + num).replace(/(^0*)/g, '''').split(''.''),\n    k = 0,\n    re = '''';\n  for (var i = a[0].length - 1; i >= 0; i--) {\n    switch (k) {\n      case 0:\n        re = BB[7] + re;\n        break;\n      case 4:\n        if (!new RegExp(''0{4}//d{'' + (a[0].length - i - 1) + ''}$'').test(a[0])) re = BB[4] + re;\n        break;\n      case 8:\n        re = BB[5] + re;\n        BB[7] = BB[5];\n        k = 0;\n        break;\n    }\n    if (k % 4 == 2 && a[0].charAt(i + 2) != 0 && a[0].charAt(i + 1) == 0) re = AA[0] + re;\n    if (a[0].charAt(i) != 0) re = AA[a[0].charAt(i)] + BB[k % 4] + re;\n    k++;\n  }\n  if (a.length > 1) {\n    re += BB[6];\n    for (var i = 0; i < a[1].length; i++) re += AA[a[1].charAt(i)];\n  }\n  if (re == ''一十'') re = ''十'';\n  if (re.match(/^一/) && re.length == 3) re = re.replace(''一'', '''');\n  return re;\n};\n```',6,53,172,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(647,'将数字转换为大写金额','```js\nexport const changeToChinese = (Num) => {\n//判断如果传递进来的不是字符的话转换为字符\nif (typeof Num == \"number\") {\nNum = new String(Num);\n};\nNum = Num.replace(/,/g, \"\")\n//替换tomoney()中的“,”\nNum = Num.replace(/ /g, \"\")\n//替换tomoney()中的空格\nNum = Num.replace(/￥/g, \"\")\n//替换掉可能出现的￥字符\nif (isNaN(Num)) {\n//验证输入的字符是否为数字\n//alert(\"请检查小写金额是否正确\");\nreturn \"\";\n};\n//字符处理完毕后开始转换，采用前后两部分分别转换\nvar part = String(Num).split(\".\");\nvar newchar = \"\";\n//小数点前进行转化\nfor (var i = part[0].length - 1; i >= 0; i--) {\nif (part[0].length > 10) {\nreturn \"\";\n//若数量超过拾亿单位，提示\n}\nvar tmpnewchar = \"\"\nvar perchar = part[0].charAt(i);\nswitch (perchar) {\ncase \"0\":\ntmpnewchar = \"零\" + tmpnewchar;\nbreak;\ncase \"1\":\ntmpnewchar = \"壹\" + tmpnewchar;\nbreak;\ncase \"2\":\ntmpnewchar = \"贰\" + tmpnewchar;\nbreak;\ncase \"3\":\ntmpnewchar = \"叁\" + tmpnewchar;\nbreak;\ncase \"4\": tmpnewchar = \"肆\" + tmpnewchar;\nbreak;\ncase \"5\": tmpnewchar = \"伍\" + tmpnewchar;\nbreak;\ncase \"6\": tmpnewchar = \"陆\" + tmpnewchar;\nbreak;\ncase \"7\": tmpnewchar = \"柒\" + tmpnewchar;\nbreak;\ncase \"8\": tmpnewchar = \"捌\" + tmpnewchar;\nbreak;\ncase \"9\": tmpnewchar = \"玖\" + tmpnewchar;\nbreak;\n}\nswitch (part[0].length - i - 1) {\ncase 0:\ntmpnewchar = tmpnewchar + \"元\";\nbreak;\ncase 1:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"拾\";\nbreak;\ncase 2:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"佰\";\nbreak;\ncase 3:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"仟\";\nbreak;\ncase 4:\ntmpnewchar = tmpnewchar + \"万\";\nbreak;\ncase 5:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"拾\";\nbreak;\ncase 6:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"佰\";\nbreak;\ncase 7:\nif (perchar != 0) tmpnewchar = tmpnewchar + \"仟\";\nbreak;\ncase 8:\ntmpnewchar = tmpnewchar + \"亿\";\nbreak;\ncase 9:\ntmpnewchar = tmpnewchar + \"拾\";\nbreak;\n}\nvar newchar = tmpnewchar + newchar;\n}\n//小数点之后进行转化\nif (Num.indexOf(\".\") != -1) {\nif (part[1].length > 2) {\n// alert(\"小数点之后只能保留两位,系统将自动截断\"\n);\npart[1] = part[1].substr(0, 2) }\nfor (i = 0; i < part[1].length; i++) {\ntmpnewchar = \"\" perchar = part[1].charAt(i)\nswitch (perchar) {\ncase \"0\":\ntmpnewchar = \"零\" + tmpnewchar;\nbreak;\ncase \"1\":\ntmpnewchar = \"壹\" + tmpnewchar;\nbreak;\ncase \"2\":\ntmpnewchar = \"贰\" + tmpnewchar;\nbreak;\ncase \"3\":\ntmpnewchar = \"叁\" + tmpnewchar;\nbreak;\ncase \"4\":\ntmpnewchar = \"肆\" + tmpnewchar;\nbreak;\ncase \"5\":\ntmpnewchar = \"伍\" + tmpnewchar;\nbreak;\ncase \"6\":\ntmpnewchar = \"陆\" + tmpnewchar;\nbreak;\ncase \"7\": tmpnewchar = \"柒\" + tmpnewchar;\nbreak;\ncase \"8\":\ntmpnewchar = \"捌\" + tmpnewchar;\nbreak;\ncase \"9\":\ntmpnewchar = \"玖\" + tmpnewchar;\nbreak;\n}\nif (i == 0) tmpnewchar = tmpnewchar + \"角\";\nif (i == 1) tmpnewchar = tmpnewchar + \"分\";\nnewchar = newchar + tmpnewchar; } }\n//替换所有无用汉字\nwhile (newchar.search(\"零零\") != -1)\nnewchar = newchar.replace(\"零零\", \"零\");\nnewchar = newchar.replace(\"零亿\", \"亿\");\nnewchar = newchar.replace(\"亿万\", \"亿\");\nnewchar = newchar.replace(\"零万\", \"万\");\nnewchar = newchar.replace(\"零元\", \"元\");\nnewchar = newchar.replace(\"零角\", \"\");\nnewchar = newchar.replace(\"零分\", \"\");\nif (newchar.charAt(newchar.length - 1) == \"元\") {\nnewchar = newchar + \"整\"\n}\nreturn newchar;\n}\n```',6,53,171,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(648,'判断一个元素是否在数组中','```js\nexport const contains = (arr, val) => {\n  return arr.indexOf(val) != -1 ? true : false;\n};\n```',6,47,168,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(649,'数组排序','{type}1:从小到大2:从大到小3:随机\n```js\nexport const sort = (arr, type = 1) => {\n  return arr.sort((a, b) => {\n    switch (type) {\n      case 1:\n        return a - b;\n      case 2:\n        return b - a;\n      case 3:\n        return Math.random() - 0.5;\n      default:\n        return arr;\n    }\n  });\n};\n```',6,47,169,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(650,'数组去重','```js\nexport const unique = (arr) => {\n  if (Array.hasOwnProperty(''from'')) {\n    return Array.from(new Set(arr));\n  } else {\n    var n = {},\n      r = [];\n    for (var i = 0; i < arr.length; i++) {\n      if (!n[arr[i]]) {\n        n[arr[i]] = true;\n        r.push(arr[i]);\n      }\n    }\n    return r;\n  }\n};\n```',6,47,112,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(651,'删除其中一个元素','```js\nexport const remove = (arr, ele) => {\n  var index = arr.indexOf(ele);\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n  return arr;\n};\n```',6,53,168,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(652,'将类数组转换为数组','```js\nexport const formArray = (ary) => {\n  var arr = [];\n  if (Array.isArray(ary)) {\n    arr = ary;\n  } else {\n    arr = Array.prototype.slice.call(ary);\n  }\n  return arr;\n};\n```',6,47,167,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(653,'数组最大值','```js\nexport const max = (arr) => {\n  return Math.max.apply(null, arr);\n};\n```',6,47,78,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(654,'数组最小值','```js\nexport const min = (arr) => {\n  return Math.min.apply(null, arr);\n};\n```',6,47,146,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(655,'数组求和','```js\nexport const sum = (arr) => {\n  return arr.reduce((pre, cur) => {\n    return pre + cur;\n  });\n};\n```',6,47,164,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(656,'数组平均值','```js\nexport const average = (arr) => {\n  return this.sum(arr) / arr.length;\n};\n```',6,47,163,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(657,'去除空格','type: 1-所有空格 2-前后空格 3-前空格 4-后空格\n\n```js\nexport const trim = (str, type) => {\n  type = type || 1;\n  switch (type) {\n    case 1:\n      return str.replace(/\\s+/g, '''');\n    case 2:\n      return str.replace(/(^\\s*)|(\\s*$)/g, '''');\n    case 3:\n      return str.replace(/(^\\s*)/g, '''');\n    case 4:\n      return str.replace(/(\\s*$)/g, '''');\n    default:\n      return str;\n  }\n};\n```',6,72,162,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(658,'字符转换','type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写\n\n```js\nexport const changeCase = (str, type) => {\n  type = type || 4;\n  switch (type) {\n    case 1:\n      return str.replace(/\\b\\w+\\b/g, function (word) {\n        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();\n      });\n    case 2:\n      return str.replace(/\\b\\w+\\b/g, function (word) {\n        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();\n      });\n    case 3:\n      return str\n        .split('''')\n        .map(function (word) {\n          if (/[a-z]/.test(word)) {\n            return word.toUpperCase();\n          } else {\n            return word.toLowerCase();\n          }\n        })\n        .join('''');\n    case 4:\n      return str.toUpperCase();\n    case 5:\n      return str.toLowerCase();\n    default:\n      return str;\n  }\n};\n```',6,72,161,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(659,'检测密码强度','```js\nexport const checkPwd = (str) => {\n  var Lv = 0;\n  if (str.length < 6) {\n    return Lv;\n  }\n  if (/[0-9]/.test(str)) {\n    Lv++;\n  }\n  if (/[a-z]/.test(str)) {\n    Lv++;\n  }\n  if (/[A-Z]/.test(str)) {\n    Lv++;\n  }\n  if (/[\\.|-|_]/.test(str)) {\n    Lv++;\n  }\n  return Lv;\n};\n```',6,53,160,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(660,'函数节流器','```js\nexport const debouncer = (fn, time, interval = 200) => {\n  if (time - (window.debounceTimestamp || 0) > interval) {\n    fn && fn();\n    window.debounceTimestamp = time;\n  }\n};\n```',6,53,159,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(661,'在字符串中插入新字符串','```js\nexport const insertStr = (soure, index, newStr) => {\n  var str = soure.slice(0, index) + newStr + soure.slice(index);\n  return str;\n};\n```',6,53,71,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(662,'判断两个对象是否键值相同','```js\nexport const isObjectEqual = (a, b) => {\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n  return true;\n};\n```\n',6,53,123,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(663,'16进制颜色转RGBRGBA字符串','```js\nexport const colorToRGB = (val, opa) => {\n  var pattern = /^(#?)[a-fA-F0-9]{6}$/;\n  //16进制颜色值校验规则\n  var isOpa = typeof opa == ''number'';\n  //判断是否有设置不透明度\n  if (!pattern.test(val)) {\n    //如果值不符合规则返回空字符\n    return '''';\n  }\n  var v = val.replace(/#/, '''');\n  //如果有#号先去除#号\n  var rgbArr = [];\n  var rgbStr = '''';\n  for (var i = 0; i < 3; i++) {\n    var item = v.substring(i * 2, i * 2 + 2);\n    var num = parseInt(item, 16);\n    rgbArr.push(num);\n  }\n  rgbStr = rgbArr.join();\n  rgbStr = ''rgb'' + (isOpa ? ''a'' : '''') + ''('' + rgbStr + (isOpa ? '','' + opa : '''') + '')'';\n  return rgbStr;\n};\n```',6,53,156,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(664,'追加 url 参数','```js\nexport const appendQuery = (url, key, value) => {\n  var options = key;\n  if (typeof options == ''string'') {\n    options = {};\n    options[key] = value;\n  }\n  options = $.param(options);\n  if (url.includes(''?'')) {\n    url += ''&'' + options;\n  } else {\n    url += ''?'' + options;\n  }\n  return url;\n};\n```',6,53,155,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(665,'字符串首字母大写','该方法用于将英文字符串的首字母大写处理：\n\n```javascript\nconst capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);\n\ncapitalize(''hello world''); // Hello world\n```',6,72,116,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(666,'翻转字符串','该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\n```javascript\nconst reverse = (str) => str.split('''').reverse().join('''');\n\nreverse(''hello world''); // ''dlrow olleh''\n```',6,72,154,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(667,'随机字符串','该方法用于生成一个随机的字符串：\n\n```javascript\nconst randomString = () => Math.random().toString(36).slice(2);\n\nrandomString();\n```',6,72,153,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(668,'截断字符串','该方法可以从指定长度处截断字符串:\n\n```javascript\nconst truncateString = (string, length) => (string.length < length ? string : `${string.slice(0, length - 3)}...`);\n\ntruncateString(''Hi, I should be truncated because I am too loooong!'', 36); // ''Hi, I should be truncated because...''\n```',6,72,152,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(669,'去除字符串中的HTML','该方法用于去除字符串中的 HTML 元素：\n\n```javascript\nconst stripHtml = (html) => new DOMParser().parseFromString(html, ''text/html'').body.textContent || '''';\n```',6,72,151,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(670,'从数组中移除重复项','该方法用于移除数组中的重复项：\n\n```javascript\nconst removeDuplicates = (arr) => [...new Set(arr)];\n\nconsole.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n```',6,47,150,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(671,'判断数组是否为空','该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\n```javascript\nconst isNotEmpty = (arr) => Array.isArray(arr) && arr.length > 0;\n\nisNotEmpty([1, 2, 3]); // true\n```',6,47,149,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(672,'合并两个数组','可以使用下面两个方法来合并两个数组：\n\n```javascript\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n```',6,47,148,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(673,'判断一个数是奇数还是偶数','该方法用于判断一个数字是奇数还是偶数：\n\n```javascript\nconst isEven = (num) => num % 2 === 0;\n\nisEven(996);\n```',6,53,107,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(674,'获得一组数的平均值','```javascript\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5); // 3\n```',6,47,114,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(675,'获取两个整数之间的随机整数','该方法用于获取两个整数之间的随机整数\n\n```javascript\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n```',6,53,146,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(676,'指定位数四舍五入','该方法用于将一个数字按照指定位进行四舍五入：\n\n```javascript\nconst round = (n, d) => Number(Math.round(n + ''e'' + d) + ''e-'' + d);\n\nround(1.005, 2); //1.01\nround(1.555, 2); //1.56\n```',6,53,145,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(677,'将 RGB 转化为十六机制','该方法可以将一个 RGB 的颜色值转化为 16 进制值：\n\n```javascript\nconst rgbToHex = (r, g, b) => ''#'' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\nrgbToHex(255, 255, 255); // ''#ffffff''\n```',6,53,144,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(678,'获取随机十六进制颜色','该方法用于获取一个随机的十六进制颜色值：\n\n```javascript\nconst randomHex = () =>\n  `#${Math.floor(Math.random() * 0xffffff)\n    .toString(16)\n    .padEnd(6, ''0'')}`;\n\nrandomHex();\n```',6,53,142,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(679,'复制内容到剪切板','该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：\n\n```javascript\nconst copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\ncopyToClipboard(''Hello World'');\n```',6,53,141,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(680,'清除所有cookie','该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\n```javascript\nconst clearCookies = document.cookie\n  .split('';'')\n  .forEach(\n    (cookie) =>\n      (document.cookie = cookie.replace(/^ +/, '''').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`))\n  );\n```',6,46,68,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(681,'获取选中的文本','该方法通过内置的 getSelection 属性获取用户选择的文本：\n\n```javascript\nconst getSelectedText = () => window.getSelection().toString();\n\ngetSelectedText();\n```',6,53,138,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(682,'滚动到页面顶部','该方法用于在页面中返回顶部：\n\n```javascript\nconst goToTop = () => window.scrollTo(0, 0);\n\ngoToTop();\n```',6,84,140,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(683,'判断当前标签页是否激活','该方法用于检测当前标签页是否已经激活：\n\n```javascript\nconst isTabInView = () => !document.hidden;\n```',6,53,57,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(684,'判断当前是否是苹果设备','该方法用于检测当前的设备是否是苹果的设备：\n\n```javascript\nconst isAppleDevice = () => /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n\nisAppleDevice();\n```',6,53,137,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(685,'是否滚动到页面底部','该方法用于判断页面是否已经底部：\n\n```javascript\nconst scrolledToBottom = () =>\n  document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n```',6,84,136,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(686,'重定向到一个 URL','该方法用于重定向到一个新的 URL：\n\n```javascript\nconst redirect = (url) => (location.href = url);\n\nredirect(''https://www.google.com/'');\n```',6,53,135,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(687,'打开浏览器打印框','该方法用于打开浏览器的打印框：\n\n```javascript\nconst showPrintDialog = () => window.print();\n```',6,53,134,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(688,'随机布尔值','该方法可以返回一个随机的布尔值，使用 Math.random()可以获得 0-1 的随机数，与 0.5 进行比较，就有一半的概率获得真值或者假值。\n\n```javascript\nconst randomBoolean = () => Math.random() >= 0.5;\n\nrandomBoolean();\n```',6,53,133,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(689,'获取变量的类型','该方法用于获取一个变量的类型：\n\n```javascript\nconst trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n\ntrueTypeOf(''''); // string\ntrueTypeOf(0); // number\ntrueTypeOf(); // undefined\ntrueTypeOf(null); // null\ntrueTypeOf({}); // object\ntrueTypeOf([]); // array\ntrueTypeOf(0); // number\ntrueTypeOf(() => {}); // function\n```',6,53,131,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(690,'检测对象是否为空','该方法用于检测一个 JavaScript 对象是否为空：\n\n```javascript\nconst isEmpty = (obj) => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;\n```',6,53,73,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(691,'截取字符串slice()','slice() 方法用于提取字符串的某个部分，并以新的字符串返回被提取的部分。其语法如下：\n\n```javascript\nstring.slice(start, end);\n```\n\n该方法有两个参数：\n\n- start：必须。 要截取的片断的起始下标，第一个字符位置为 0。如果为负数，则从尾部开始截取。\n- end：可选。 要截取的片段结尾的下标。若未指定此参数，则要提取的子串包括 start 到原字符串结尾的字符串。如果该参数是负数，那么它规定的是从字符串的尾部开始算起的位置。\n\n上面说了，如果 start 是负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推：\n\n```javascript\nlet str = ''abcdefg'';\nstr.slice(1, 6); // 输出结果：\"bcdef\"\nstr.slice(1); // 输出结果：\"bcdefg\"\nstr.slice(); // 输出结果：\"abcdefg\"\nstr.slice(-2); // 输出结果：\"fg\"\nstr.slice(6, 1); // 输出结果：\"\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。',6,72,71,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(692,'截取字符串substr','substr() 方法用于在字符串中抽取从开始下标开始的指定数目的字符。其语法如下：\n\n```javascript\nstring.substr(start, length);\n```\n\n该方法有两个参数：\n\n- start 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。\n- length：可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。\n\n```javascript\nlet str = ''abcdefg'';\nstr.substr(1, 6); // 输出结果：\"bcdefg\"\nstr.substr(1); // 输出结果：\"bcdefg\" 相当于截取[1,str.length-1]\nstr.substr(); // 输出结果：\"abcdefg\" 相当于截取[0,str.length-1]\nstr.substr(-1); // 输出结果：\"g\"\n```',6,72,71,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(693,'截取字符串substring','substring() 方法用于提取字符串中介于两个指定下标之间的字符。其语法如下：\n\n```javascript\nstring.substring(from, to);\n```\n\n该方法有两个参数：\n\n- from：必需。一个非负的整数，规定要提取的子串的第一个字符在 string 中的位置。\n- to：可选。一个非负的整数，比要提取的子串的最后一个字符在 string 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。\n\n**注意：** 如果参数 from 和 to 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。如果 from 比 to 大，那么该方法在提取子串之前会先交换这两个参数。并且该方法不接受负的参数，如果参数是个负数，就会返回这个字符串。\n\n```javascript\nlet str = ''abcdefg'';\nstr.substring(1, 6); // 输出结果：\"bcdef\" [1,6)\nstr.substring(1); // 输出结果：\"bcdefg\" [1,str.length-1]\nstr.substring(); // 输出结果：\"abcdefg\" [0,str.length-1]\nstr.substring(6, 1); // 输出结果 \"bcdef\" [1,6)\nstr.substring(-1); // 输出结果：\"abcdefg\"\n```\n\n注意，该方法返回的子串**包括开始处的字符**，但**不包括结束处的字符**。',6,48,70,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(694,'箭头函数','箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作**构造函数**。\n\n简洁的函数\n\n```js\nconst addOne = (num) => {\n  return num + 1;\n};\n```\n\n箭头语法对于创建[单行函数](https://www.zhihu.com/search?q=单行函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"article\"%2C\"sourceId\"%3A440172288})更加简洁友好。\n\n```js\nconst addOne = (num) => num + 1;\n```',16,62,92,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(695,'数组转化为用逗号分隔','\n```js\nfunction test(a, b) {\n  console.log(a); // 1\n  console.log(b); // 2\n}\n\nvar arr = [1, 2];\ntest(...arr);\n```',16,64,111,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(696,'数组拼接','```js\nvar arr1 = [1, 2, 3, 4];\nvar arr2 = [...arr1, 4, 5, 6];\nconsole.log(arr2); // [1, 2, 3, 4, 4, 5, 6]\n```',16,64,110,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(697,'Symbol','基本数据类型 Symbol，表示独一无二的值。它是一种类似于字符串的数据类型，它的特点如下：\n\n- Symbol 的值是唯一的，用来解决命名冲突的问题\n- Symbol 值不能与其他类型数据进行运算\n- Symbol 定义的对象属性不能使用`for...in`遍历循环，但是可以使用`Reflect.ownKeys` 来获取对象的所有键名\n\n```js\nlet s1 = Symbol();\nconsole.log(typeof s1); // \"symbol\"\n\nlet s2 = Symbol(''hello'');\nlet s3 = Symbol(''hello'');\nconsole.log(s2 === s3); // false\n```',16,71,130,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(698,'includes','**includes()** 方法用来判断一个数组是否包含一个指定的值，如果包含则返回 true，否则返回 false。该方法不会改变原数组。\n\n```js\narr.includes(searchElement, fromIndex);\n```\n\nsearchElement：必须，需要查找的元素值。\n\nfromIndex：可选，从 fromIndex 索引处开始查找目标值。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。\n\n```js\n[1, 2, 3].includes(2); //  true\n[1, 2, 3].includes(4); //  false\n[1, 2, 3].includes(3, 3); // false\n[1, 2, 3].includes(3, -1); // true\n```\n\n```\nif( [1,2,3,4,5].includes(type) ){\n   //...\n}\n```',16,71,129,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(699,'补齐字符串的长度','padStart()和 padEnd()\n\n```js\n''1''.padStart(3, ''0''); // 输出结果： ''001''\n''15''.padStart(3, ''0''); // 输出结果： ''015''\n```',16,71,128,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(700,'Object 返回数组','```js\nlet obj = {\n  id: 1,\n  name: ''hello'',\n  age: 18\n};\nconsole.log(Object.keys(obj)); // 输出结果: [''id'', ''name'', ''age'']\nconsole.log(Object.values(obj)); // 输出结果: [1, ''hello'', 18]\nconsole.log(Object.entries(obj)); // 输出结果: [[''id'', 1], [''name'', ''hello''], [''age'', 18]\n```',16,64,123,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(701,'for await…of','方法被称为**异步迭代器**，该方法是主要用来遍历异步对象。只能在 `async function`内使用\n\n```js\nfunction Gen(time) {\n  return new Promise((resolve, reject) => {\n    setTimeout(function () {\n      resolve(time);\n    }, time);\n  });\n}\n\nasync function test() {\n  let arr = [Gen(2000), Gen(100), Gen(3000)];\n  for await (let item of arr) {\n    console.log(Date.now(), item);\n  }\n}\ntest();\n```',16,79,122,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(702,'空值合并运算符（??）','```js\nconst dogName = false;\nconst name = dogName ?? ''default''; // name = false;\n```',16,65,87,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(703,'可选链操作符（?.）','```js\nconst name = system?.user?.addr?.province?.name || ''default'';\n```\n\n当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。在探索一个对象的内容时，如果不能确定哪些属性必定存在，可选链操作符也是很有帮助的。\n\n```js\na?.[x];\n// 等同于\na == null ? undefined : a[x];\n\na?.b();\n// 等同于\na == null ? undefined : a.b();\n\na?.();\n// 等同于\na == null ? undefined : a();\n```',16,65,121,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(704,'String.prototype.replaceAll()','replaceAll()方法会返回一个全新的字符串，所有符合匹配规则的字符都将被替换掉，替换规则可以是字符串或者正则表达式。\n\n```javascript\nlet string = ''hello world, hello ES12'';\nstring.replace(/hello/g, ''hi''); // hi world, hi ES12\nstring.replaceAll(''hello'', ''hi''); // hi world, hi ES12\n```',16,63,120,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(705,'数字分隔符','数字分隔符可以在数字之间创建可视化分隔符，通过 \\_ 下划线来分割数字，使数字更具可读性，可以放在数字内的任何地方：\n\n```javascript\nconst money = 1_000_000_000;\n//等价于\nconst money = 1000000000;\n```\n\n该新特性同样支持在八进制数中使用：\n\n```javascript\nconst number = 0o123_456;\n//等价于\nconst number = 0o123456;\n```',16,71,109,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(706,'.repeat()','\n\n 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。\n\n```js\nconst str = ''DevPoint ''.repeat(3);\nconsole.log(str); // DevPoint DevPoint DevPoint\n```',16,71,127,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(707,'.startsWith()','用来判断当前字符串是否以另外一个给定的子字符串开头（区分大小写），并根据判断结果返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.startsWith(''D'');\nconst str2 = ''DevPoint''.startsWith(''d'');\nconsole.log(str); // true\nconsole.log(str2); // false\n```',16,71,126,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(708,'.endsWith()','\n 用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.endsWith(''t'');\nconsole.log(str); // true\n```',16,71,106,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(709,'.includes()','\n 用于判断一个字符串是否包含在另一个字符串中，根据情况返回 `true` 或 `false`。\n\n```js\nconst str = ''DevPoint''.includes(''P'');\nconsole.log(str); // true\n```',16,71,105,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(710,'.find()   ','返回数组中满足提供的过滤函数的**第一个元素**的值，否则返回 `undefined`。\n\n```js\nconst arrNumbers = [5, 12, 8, 130, 44];\nconst foundNumbers = arrNumbers.find((number) => number > 10);\nconsole.log(foundNumbers); // 12是数组第一个大于10的数\n```',16,62,104,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(711,'取值','```js\n//老的取值方式\nconst a = obj.a;\nconst b = obj.b;\nconst c = obj.c;\n\nES6的解构赋值一行就能搞定\nconst {a,b,c} = obj;\n```',16,57,103,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(712,'获取对象属性值','在编程的过程中经常会遇到获取一个值并赋给另一个变量的情况，在获取这个值时需要先判断一下这个对象是否存在，才能进行赋值\n\n```ini\nif(obj && obj.name){\n  const name = obj.name\n}\n```\n\nES6 提供了可选连操作符`?.`，可以简化操作\n\n```ini\nconst name = obj?.name;\n```',16,65,101,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(713,'反转字符串','将一个字符串进行翻转操作，返回翻转后的字符串\n\n```perl\nconst reverse = str => str.split('''').reverse().join('''');\n\nreverse(''hello world'');   // ''dlrow olleh''\n```',16,71,100,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(714,'合并数据','当我们需要合并数据，并且去除重复值时，你是不是要用 for 循环？ ES6 的扩展运算符一行就能搞定！！！\n\n```ini\nconst a = [1,2,3];\nconst b = [1,5,6];\nconst c = [...new Set([...a,...b])];//[1,2,3,5,6]\n```',16,65,98,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(715,'判断数组是否为空','判断一个数组是否为空数组，它将返回一个布尔值\n\n```ini\nconst notEmpty = arr => Array.isArray(arr) && arr.length > 0;\n\nnotEmpty([1, 2, 3]);  // true\n```',16,64,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(716,'交换两个变量','```ini\n//旧写法\nlet a=1;\nlet b=2;\nlet temp;\ntemp=a\na=b\nb=temp\n\n//新写法\n[a, b] = [b, a];\n```',16,63,96,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(717,'获取两个数之间的随机整数','```lua\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n```',16,63,95,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(718,'检查日期是否为工作日','传入日期，判断是否是工作日\n\n```js\nconst isWeekday = (date) => date.getDay() % 6 !== 0;\nconsole.log(isWeekday(new Date(2021, 11, 11)));\n// false\nconsole.log(isWeekday(new Date(2021, 11, 13)));\n// true\n```',16,63,94,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(720,'浏览器是否支持触摸事件','通过判断浏览器是否有`ontouchstart`事件来判断是否支持触摸\n\n```javascript\nconst touchSupported = () => {\n  ''ontouchstart'' in window || (window.DocumentTouch && document instanceof window.DocumentTouch);\n};\nconsole.log(touchSupported());\n```',16,63,93,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(721,'集合Set','| size   | 返回集合的元素个数                   |\n| ------ | ------------------------------------ |\n| add    | 增加一个新的元素，返回当前的集合     |\n| delete | 删除元素，返回布尔值                 |\n| has    | 检查集合中是否包含某元素，返回布尔值 |\n| clear  | 清空集合，返回 undefined             |\n\n```js\n//创建一个空集合\nlet s = new Set();\n//创建一个非空集合\nlet s1 = new Set([1,2,3,1,2,3]);\n//返回集合的元素个数\nconsole.log(s1.size);       // 3\n//添加新元素\nconsole.log(s1.add(4));     // {1,2,3,4}\n//删除元素\nconsole.log(s1.delete(1));  //true\n//检测是否存在某个值\nconsole.log(s1.has(2));     // true\n//清空集合\nconsole.log(s1.clear());    //undefined\n```\n',16,80,91,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(722,'数组与集合的相互转化','```js\n// Set集合转化为数组\nconst arr = [...mySet];\nconst arr = Array.from(mySet);\n\n// 数组转化为Set集合\nconst mySet = new Set(arr);\n```',6,47,69,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(723,'Map','如果需要“ 键值对” 的数据结构， Map 比 Object 更合适。Map 也实现了 iterator 接口，所以可以使用扩展运算符和 for…of 进行遍历。\n\n| size | 返回 Map 的元素个数 |\n| --- | --- |\n| set | 增加一个新的元素，返回当前的 Map |\n| get | 返回键名对象的键值 |\n| has | 检查 Map 中是否包含某元素，返回布尔值 |\n| clear | 清空 Map，返回 undefined |\n\n```js\n//创建一个空 map\nlet m = new Map();\n//创建一个非空 map\nlet m2 = new Map([[''name'', ''hello'']]);\n//获取映射元素的个数\nconsole.log(m2.size); // 1\n//添加映射值\nconsole.log(m2.set(''age'', 6)); // {\"name\" => \"hello\", \"age\" => 6}\n//获取映射值\nconsole.log(m2.get(''age'')); // 6\n//检测是否有该映射\nconsole.log(m2.has(''age'')); // true\n//清除\nconsole.log(m2.clear()); // undefined\n```',16,60,90,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(725,'export导出模块','- **正常导出：**\n\n```javascript\n// 方式一\nexport var first = ''test'';\nexport function func() {\n  return true;\n}\n\n// 方式二\nvar first = ''test'';\nvar second = ''test'';\nfunction func() {\n  return true;\n}\nexport { first, second, func };\n```\n\n- **as 关键字:**\n\n```javascript\nvar first = ''test'';\nexport { first as second };\n```\n\nas 关键字可以重命名暴露出的变量或方法，经过重命名后同一变量可以多次暴露出去。\n\n- **export default**\n\nexport default 会导出默认输出，即用户不需要知道模块中输出的名字，在导入的时候为其指定任意名字。\n\n```javascript\n// 导出\nexport default function () {\n  console.log(''foo'');\n}\n// 导入\nimport customName from ''./export-default'';\n```\n\n**注意：** 导入默认模块时不需要大括号，导出默认的变量或方法可以有名字，但是对外无效。export default 只能使用一次。',16,83,88,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(726,'import导入模块','- **正常导入：**\n\n```javascript\nimport { firstName, lastName, year } from ''./profile'';\n```\n\n导入模块位置可以是相对路径也可以是绝对路径，.js 可以省略，如果不带路径只是模块名，则需要通过配置文件告诉引擎查找的位置。\n\n- **as 关键字：**\n\n```javascript\nimport { lastName as surname } from ''./profile'';\n```\n\nimport 命令会被提升到模块头部，所以写的位置不是那么重要，但是不能使用表达式和变量来进行导入。\n\n- **加载整个模块（无输出）**\n\n```javascript\nimport ''lodash''; //仅仅是加载而已，无法使用\n```\n\n- **加载整个模块（有输出）**\n\n```javascript\nimport * as circle from ''./circle'';\nconsole.log(''圆面积：'' + circle.area(4));\nconsole.log(''圆周长：'' + circle.circumference(14));\n```\n\n**注意：** import \\* 会忽略 default 输出',16,59,88,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(727,'导入导出复合用法','- **先导入后导出**\n\n```javascript\nexport { foo, bar } from ''my_module'';\n// 等同于\nimport { foo, bar } from ''my_module'';\nexport { foo, boo };\n```\n\n- **整体先导入再输出以及 default**\n\n```javascript\n// 整体输出\nexport * from ''my_module'';\n// 导出default，正如前面所说，export default 其实导出的是default变量\nexport { default } from ''foo'';\n// 具名接口改default\nexport { es6 as default } from ''./someModule'';\n```',16,83,87,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(728,'模块的继承','```javascript\nexport * from ''circle'';\nexport var e = 2.71828182846;\nexport default function (x) {\n  return Math.exp(x);\n}\n```\n\n**注意：** export \\* 会忽略 default。',16,83,86,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(729,'解构语法','解构赋值语法是一种 Javascript 表达式。通过解构赋值, 可以将属性/值从对象/数组中取出，赋值给其他变量。\n\n如果要将对象传递给函数，则可以轻松选择对象的属性，然后使用 ES6 分解语法将它们放在单独的变量中：\n\n```js\nfunction foo({ a, b }) {\n  console.log(a, b); // 1, 2\n}\n\nfoo({ a: 1, b: 2 });\n```\n\n赋值：\n\n```js\nfunction foo(obj) {\n  const { a, b } = obj;\n  console.log(a, b); // 1, 2\n}\n\nor;\nconst { title, text } = res.data[0];\nstate.dataOne = { title, text };\n```\n\n在解构数组时，可以使用 `...` 语法来获取数组中的所有其他项。\n\n```js\nfunction foo([a, b, ...c]) {\n    console.log(c); // [3, 4, 5]\n}\nfoo([1, 2, 3, 4, 5]);\n\n赋值：\nfunction foo(arr) {\n    const [a, b, ...c] = arr;\n    console.log(c); // [3, 4, 5]\n}\nfoo([1, 2, 3, 4, 5]);\n\n//rest操作符也可以单独使用，无需解构：\nfunction foo(...nums) {\n    console.log(nums); // [1, 2, 3, 4, 5]\n}\nfoo(1, 2, 3, 4, 5);\n```\n\nrest 语法 `...` 与另一个 ES6 特性操作符扩展完全相同。\n\n例如，如果要将两个数组合并为一个\n\n```js\nconst a = [1, 2];\nconst b = [3, 4];\nconst c = [...a, ...b];\nconsole.log(c); // [1, 2, 3, 4]\n```\n\n`spread`也适用于对象：\n\n```js\nconst obj = { a: 1, b: 2 };\nconst obj2 = { ...obj, c: 3 };\nconsole.log(obj2); // { a: 1, b: 2, c: 3 }\n```',16,57,85,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(730,'KeepAlive','内置组件，可以在动态切换多个组件时视情况缓存组件实例。\n\n- 当组件在 keep-alive 内被切换时组件的 **activated**、**deactivated** 这两个生命周期钩子函数会被执行\n- 被包裹在 keep-alive 中的组件的状态将会被保留，例如我们将某个列表类组件内容滑动到第 100 条位置，那么我们在切换到一个组件后再次切换回到该组件，该组件的位置状态依旧会保持在第 100 条列表处\n- 被 keep-alive 包裹的动态组件或 router-view 会缓存不活动的实例，再次被调用这些被缓存的实例会被再次复用，对于我们的某些不是需要实时更新的页面来说大大减少了性能上的消耗，不需要再次发送 HTTP 请求，但是同样也存在一个问题就是被 keep-alive 包裹的组件我们请求获取的数据不会再重新渲染页面，这也就出现了例如我们使用动态路由做匹配的话页面只会保持第一次请求数据的渲染结果，所以需要我们在特定的情况下强制刷新某些组件',2,55,83,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(731,'认识keep-alive','组件切换后，组件会被销毁掉，再次回来时会重新创建组件，所以在离开组件之前所有的数据都会丢失。\n\n我们希望继续保持组件的状态，而不是销毁掉，这个时候就可以使用一个**内置组件：**`keep-alive`。\n\nkeep-alive 有一些属性：\n\n- `include` - string | RegExp | Array。只有名称匹配的组件会被缓存；\n- `exclude` - string | RegExp | Array。任何名称匹配的组件都不会被缓存；\n- `max`- number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁；\n\ninclude 和 exclude prop 可以筛选组件地缓存，匹配首先检查组件自身的 name 选项。',2,55,83,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(732,'默认缓存','```html\n<router-view class=\"content\" v-slot=\"{ Component }\">\n  <keep-alive>\n    <component :is=\"Component\" />\n  </keep-alive>\n</router-view>\n```',2,55,76,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(733,'slot搭配路由使用','vue3 配合的 slot 插槽使用，使用 is 来绑定对应路由的组件。\n\n```html\n<template>\n  <router-view v-slot=\"{ Component }\">\n    <keep-alive>\n      <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" />\n    </keep-alive>\n    <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" />\n  </router-view>\n</template>\n```\n\nrouter 添加 meta 配置\n\n可以注释哪一页面需要使用缓存，但是也可以不设置，不设置的情况需要将上面的属性都删掉。如果需要更多的缓存限制，可以看底下的参考网站。\n\n```js\nconst routes = [\n  {\n    path: ''/keepalive'',\n    name: ''keepalive'',\n    component: () => import(''../views/keepalive.vue''),\n    meta: {\n      keepAlive: false //是否需要使用缓存\n    }\n  }\n];\n```',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(734,'清除缓存组件','```js\n // beforeRouteLeave()钩子\n  beforeRouteLeave(to, from, next) {\n      if (to.path === \"/goods_detail\") {\n        from.meta.keepAlive = true;\n      } else {\n        from.meta.keepAlive = false;\n        // this.$destroy()\n      }\n      next();\n    }\n```',2,55,76,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(735,'component使用','使用特殊的 `<component>` 元素：\n\n```html\n<component :is=\"activeComponent\" />\n```\n\n默认情况下，一个正活跃的组件实例会在切走后被卸载。这会导致它丢失其中所有的状态变化。\n\n在切换时创建新的组件实例通常是有用的行为，但在这个例子中，我们是的确想要组件能在非活跃状态时保留它们的状态。要解决这个问题，我们可以将动态组件用 `<KeepAlive>` 这个内置组件进行包裹：\n\n```html\n<!-- 非活跃状态的组件将会被缓存！ -->\n<KeepAlive>\n  <component :is=\"activeComponent\" />\n</KeepAlive>\n```\n\n现在，在切换时组建的状态也能被保留了',2,2,77,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(736,'包含/排除','默认情况下，`<KeepAlive>` 会不作区分地缓存它之中任何组件。但我们可以通过 `include` 和 `exclude` prop 来定制该行为。这两个 prop 的值都是一个以英文逗号分隔的字符串、一个正则表达式，或是包含这两个类型的一个数组：\n\n```html\n<!-- 以英文逗号分隔的字符串 -->\n<KeepAlive include=\"a,b\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n\n<!-- 正则表达式（需使用 `v-bind`） -->\n<KeepAlive :include=\"/a|b/\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n\n<!-- 数组（需使用 `v-bind`）-->\n<KeepAlive :include=\"[''a'', ''b'']\">\n  <component :is=\"view\"></component>\n</KeepAlive>\n```\n\n匹配的根据是组件的`name`选项，所以要想通过 `KeepAlive` 有条件地缓存的组件必须显式声明一个 `name` 选项。',2,55,76,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(737,'最大缓存实例','我们可以通过传入 `max` prop 来限制组件缓存的最大数量。当指定了 `max` 时，`<KeepAlive>` 会像一个 LRU 缓存：如果缓存实例的数量即将超过指定的最大数量，最近访问次数最少的缓存实例将被销毁，以便为新的实例腾出空间。\n\n```html\n<KeepAlive :max=\"10\">\n  <component :is=\"activeComponent\" />\n</KeepAlive>\n```',2,55,78,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(738,'缓存实例的生命周期','当一个组件实例从 DOM 上移除但因为被 `<KeepAlive>` 缓存而仍作为组件树的一部分时，它将变为**不活跃**状态而不是被卸载。当一个组件实例作为缓存树的一部分插入到 DOM 中时，它就是被重新**恢复活跃**了。\n\n一个持续存在的组件可以通过 `onActivated()` 和 `onDeactivated()`注册相应的两个状态的生命周期钩子：\n\n```html\n<script setup>\nimport { onActivated, onDeactivated } from ''vue''\n\nonActivated(() => {\n  // 在首次挂载、\n  // 以及每次从缓存中重新被插入回 DOM 的时候调用\n})\n\nonDeactivated(() => {\n  // 在从 DOM 上移除、进入缓存\n  // 以及组件卸载时调用\n})\n</script>\n```\n\n请注意：\n\n- `onActivated` 在组件挂载时也会调用，并且 `onDectivated` 在组件卸载时也会调用。\n- 这两个钩子不仅适用于 `<KeepAlive>` 缓存的根组件，也适用于缓存树中的后代组件。',2,55,76,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(739,'Teleport传送','元素最好要挂载到#app 的外面，原理其实是解析到 teleport 的时候，需要能获取到 to 指向的 dom 元素。\n\n是 vue3 中的一个内置组件，实现的就是将一个元素传送给指定的 DOM 节点下,把组件进行传送\n\n```html\n<button @click=\"open = true\">打开模态框</button>\n\n<Teleport to=\"body\">\n  <div v-if=\"open\" class=\"modal\">\n    <p>你好！</p>\n    <button @click=\"open = false\">关闭</button>\n  </div>\n</Teleport>\n```\n\n`to` 是目标的地址 `body` , `#XXX` , `.XXX` 这些都是 `css` 选择器为 `<Teleport>` 指定的目标 `to` 期望接收一个 CSS 选择器字符串或者一个真实的 DOM 节点。其实就是让 Vue 去“**传送**这部分模板片段**到 `body`** 标签下”。',2,78,75,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(740,'禁用传送门','在某些场景中，你们可能需要视情况禁用 `<Teleport>`。举个例子，我们想要在桌面端将一个组件当做浮层来渲染，但在移动端则当作行内组件。可以对 `<Teleport>` 动态地传入一个 `disabled` prop 来处理这两种不同情况。\n\n```html\n<Teleport :disabled=\"isMobile\">\n  ...\n</Teleport>\n```\n\n这里的 `isMobile` 状态可以根据媒体查询的不同结果动态地更新。',2,78,1,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(741,'同一目标上多个传送门','一个常见的应用场景写一个可重用的 `<Modal>` 组件，可能同时存在多个实例。对于此类场景，多个 `<teleport>` 组件可以将其内容挂载在同一个目标元素上，而顺序就是简单的顺次追加，后挂载的将排在目标元素下更后面的位置上。\n\n我们给出下面这样的用例：\n\n```html\n<Teleport to=\"#modals\">\n  <div>A</div>\n</Teleport>\n<Teleport to=\"#modals\">\n  <div>B</div>\n</Teleport>\n```\n\n渲染的结果为：\n\n```html\n<div id=\"modals\">\n  <div>A</div>\n  <div>B</div>\n</div>\n```',2,78,74,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(742,'实现模态对话框的组件','#### 定义组件\n\nc-modal-dialog.vue\n\n指向 body dom\n\n```html\n// model\n<template>\n  <teleport to=\"body\">\n    <div v-show=\"visible\" class=\"model-bg\">\n      <div class=\"modal-content\">\n        <button class=\"close\" @click=\"emit(''close-model'')\">X</button>\n        <div class=\"model-title\">{{ title }}</div>\n        <div class=\"model-body\">\n          <slot>第一个对话框</slot>\n        </div>\n      </div>\n    </div>\n  </teleport>\n</template>\n\n<script setup lang=\"ts\">\nconst emit = defineEmits([''close-model'']); // 使用 emit需要把自定义的事件在defineEmits定义，要不会有警告\ndefineProps({\n  title: String, // 标题\n  visible: Boolean // 模态框状态\n});\n</script>\n\n<style lang=\"scss\" scoped>\n.model-bg {\n  position: fixed;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: 2000;\n  height: 100%;\n  overflow: auto;\n  background-color: #00000080;\n}\n\n.modal-content {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  z-index: 999;\n  width: 600px;\n  min-height: 300px;\n  background: #fff;\n  border: 1px solid #eee;\n  transform: translate(-50%, -50%);\n\n  .model-title {\n    height: 32px;\n    color: #000;\n    line-height: 32px;\n    text-align: center;\n    background: #eee;\n  }\n\n  .model-body {\n    padding: 40px;\n  }\n\n  .close {\n    position: absolute;\n    top: 5px;\n    right: 10px;\n    padding: 5px;\n    border: none;\n    cursor: pointer;\n  }\n}\n</style>\n```\n\n#### 父组件使用\n\n```html\nconst cliTest = () => {\n  isVisible.value = true\n}\n<a @click=\"cliTest()\">窗体测试</a>\n<c-modal-dialog :visible=\"isVisible\" title=\"用户登录\" @close-model=\"isVisible = false\"></c-modal-dialog>\n```',2,2,67,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(743,'指定标签实现','元素最好要挂载到#app 的外面，原理其实是解析到 teleport 的时候，需要能获取到 to 指向的 dom 元素。\n\nVue 是从上到下解析并渲染的，先#test，再 Teleport 标签，再.test1。所以执行到 Teleport 标签时，就能获取到.text 标签了。\n\nc-search.vue\n\n```html\n  import { hSearch } from ''@/hooks/data''\n\n  <teleport v-if=\"hSearch\" to=\"#sear\">\n    <div class=\"model-bg\">\n      <div class=\"modal-content\">\n\n      </div>\n    </div>\n  </teleport>\n```\n\n使用\n\n```html\n import { hSearch, hSearchValue } from ''@/hooks/data''\n <div id=\"sear\"></div>\n <c-search @close-model=\"hSearch = false\"></c-search>\n <button @click=\"hSearch = true\">1</button>\n <button @click=\"hSearch = false\">2</button>\n```\n',2,2,66,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(744,'鼠标事件','### mouseover 和 mouseenter 的区别\n\n- mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡过程。对应的移除事件是 mouseout\n  \n- mouseenter：当鼠标移入元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡。对应的移除事件是 mouseleave\n  \n\n### 实例\n\n```html\n<template>\n    <div\n        class=\"hover-view\"\n        @mouseover=\"mouseover\"\n        @mouseenter=\"mouseenter\"\n        @mousemove=\"mousemove\"\n        @mouseout=\"mouseout\"\n        @mouseleave=\"mouseleave\"\n        @mousedown=\"mousedown\"\n        @mouseup=\"mouseup\"\n    >鼠标事件</div>\n</template>\n\n<script setup>\nconst mouseover = (event) => {\n    console.log(''当鼠标移入某元素时触发，移入和移出其子元素时也会触发'')\n}\n\nconst mouseenter = () => {\n    console.log(''当鼠标移入某元素时触发'')\n}\n\nconst mousemove = () => {\n    console.log(''鼠标在某元素上移动时触发，即使在其子元素上也会触发'')\n}\n\nconst mouseout = () => {\n    console.log(''当鼠标移出某元素时触发，移入和移出其子元素时也会触发'')\n}\n\nconst mouseleave = () => {\n    console.log(''当鼠标移出某元素时触发'')\n}\n\nconst mousedown = () => {\n    console.log(''鼠标在元素上 按下'')\n}\n\nconst mouseup = () => {\n    console.log(''鼠标在元素上 抬起'')\n}\n</script>\n```',2,45,65,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(745,'watch与watchEffect区别','`watch`和`watchEffect`都能响应式地执行有*effect*（副作用）的回调。它们之间的主要区别是追踪响应式依赖的方式：\n\n- `watch`只追踪明确侦听的源。它不会追踪任何在回调中访问到的东西。另外，仅在响应源确实改变时才会触发回调。`watch`会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。\n- `watchEffect`会在*effect*（副作用）发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式 property。这更方便，而且代码往往更简洁，但其响应性依赖关系不那么明确。',2,151,64,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(746,'watch','- 监听函数,监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调\n- 默认初始时不执行回调, 但可以通过配置`immediate`为`true`, 来指定初始时立即执行第一次\n- 通过配置`deep`为`true`, 来指定深度监视\n\n```js\n<script setup>\n  import { watch, reactive } from ''vue''\n  const state = reactive({\n    count: 1\n  })\n\n  // 声明方法\n  const changeCount = () => {\n    state.count = state.count * 2\n  }\n\n  // 监听count\n  watch(\n    () => state.count,\n    (newVal, oldVal) => {\n      console.log(state.count)\n      console.log(`watch监听变化前的数据：${oldVal}`)\n      console.log(`watch监听变化后的数据：${newVal}`)\n    },\n    {\n      immediate: true, // 立即执行\n      deep: true // 深度监听,深度监听,也就是监听复杂数据类型\n    }\n  )\n</script>\n```',2,151,736,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(747,'watch监听路由','```js\n// 正确方式\nimport { reactive, watch } from ''vue''\nconst route = useRoute()\n\n// 监听路由变化\nwatch(route, () => {\n    console.log(route)\n}, { deep: true })\n\n// 监听 vuex 值变化\nwatch(store.state.routesList, () => {\n    setFilterRoutes()\n}, {\n    deep: true,\n})\n```',2,151,63,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(748,'watch监听响应式数据','直接给`watch()`传入一个响应式对象，会隐式地创建一个深层侦听器——该回调函数在所有嵌套的变更时都会被触发：\n\n```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number: 0\n})\n\nwatch(() => [state.number], (newValue, oldValue) => {\n  console.log(newValue, oldValue)\n}, { deep: true })\n```\n\n',2,151,50,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(749,'watch监听多个数据','```js\n// 监听 reactive 中的响应式数据必须加 () =>\nimport { reactive, watch } from ''vue''\n\nconst state = reactive({\n        number1: 10,\n      number2: 20\n})\n\nwatch(() => [state.number1, state.number2], (newVal, oldVal) => {\n    console.log(newVal, oldVal); // 打印结果：[100, 200][10, 20]，两个数组，前面的是改变后的值\n}, { deep: true })\n\nsetInterval(() => {\n       state.number1 = 100;\n    state.number2 = 200;\n}, 2000);\n```\n\n',2,151,50,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(750,'watchEffect','也是用来监听数据变化，默认就会执行一次所以这里就不需要配置，而且不用指定 `data`,使用哪些响应式数据就监听哪些\n\n- 不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据\n- 默认初始时就会执行第一次, 从而可以收集需要监视的数据\n- 监视数据发生变化时回调\n\n```js\nlet user = reactive({\n  name: ''test'',\n  age: 21\n});\n// 只有 user.name 发生改变这个就会执行\nwatchEffect(() => {\n  console.log(user.name);\n});\n```\n\n### 清除副作用.\n\n就是在触发监听之前会调用一个函数可以处理你的逻辑例如防抖\n\n```js\nlet message = ref('''')\nlet message2 = ref('''')\nwatchEffect((oninvalidate) => {\n    //console.log(''message'', message.value);\n    oninvalidate(() => {})\n    console.log(''message2'', message2.value)\n})\n```\n\n### 停止跟踪 watchEffect 返回一个函数 调用之后将停止更新.\n\n```js\nconst stop = watchEffect(\n    (oninvalidate) => {\n        //console.log(''message'', message.value);\n        oninvalidate(() => {})\n        console.log(''message2'', message2.value)\n    },\n    {\n        flush: ''post'',\n        onTrigger() {},\n    }\n)\nstop()\n```\n\n',2,151,50,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(751,'vue组件使用','### 组件使用.\n\n使用一个子组件，要在父组件中导入它。假设我们把计数器组件放在了一个叫做 `ButtonCounter.vue` 的文件中，这个组件将会以默认导出的形式被暴露给外部。\n\n通过 script setup，导入的组件都在模板中直接可用\n\n```vue\n<script setup>\nimport ButtonCounter from ''./ButtonCounter.vue''\n</script>\n\n<template>\n  <h1>这里是一个子组件！</h1>\n  <ButtonCounter />\n</template>\n```\n\n',2,2,43,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(752,'定义组件名称','用单独的`<script>`块来定义\n\n```javascript\n<script>\n  export default {\n    name: ''ComponentName'',\n  }\n</script>\n```',2,2,60,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(753,'通过插槽来分配内容','这可以通过 Vue 的自定义 `<slot>` 元素来实现：\n\n我们使用 `<slot>` 作为一个占位符，之后的内容就会放在这里\n\n```html\n<template>\n  <div class=\"alert-box\">\n    <strong>Error!</strong>\n    <slot />\n  </div>\n</template>\n\n<style scoped>\n  .alert-box {\n    /* ... */\n  }\n</style>\n```',2,117,367,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(754,'动态组件','想要在两个组件间来回切换，比如 Tab 界面：\n\n```vue\n<script setup>\nimport Home from ''./Home.vue''\nimport Posts from ''./Posts.vue''\nimport Archive from ''./Archive.vue''\nimport { ref } from ''vue''\n \nconst currentTab = ref(''Home'')\n\nconst tabs = {\n  Home,\n  Posts,\n  Archive\n}\n</script>\n\n<template>\n  <div class=\"demo\">\n    <button\n       v-for=\"(_, tab) in tabs\"\n       :key=\"tab\"\n       :class=\"[''tab-button'', { active: currentTab === tab }]\"\n       @click=\"currentTab = tab\"\n     >\n      {{ tab }}\n    </button>\n    <component :is=\"tabs[currentTab]\" class=\"tab\"></component>\n  </div>\n</template>\n\n<style></style>\n```\n\n\n\n通过 Vue 的 `<component>` 元素和特殊的 `is` attribute 实现的：\n\n```html\n<!-- currentTab 改变时组件也改变 -->\n<component :is=\"tabs[currentTab]\"></component>\n```\n\n\n\n在上面的例子中，被传给 `:is` 的值可以是以下几种：\n\n- 被注册的组件名\n- 导入的组件对象\n\n你也可以使用 `is` attribute 来创建一般的 HTML 元素。\n\n当使用 `<component :is=\"...\">` 来在多个组件间作切换时，组件会在被切换掉后卸载。我们可以通过组件强制不活跃的组件仍然保持“存活”的状态。\n\n```html\n<!-- 非活跃状态的组件将会被缓存！ -->\n<KeepAlive>\n  <component :is=\"tabs[currentTab]\"></component>\n</KeepAlive>\n```\n\n',2,2,58,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(755,'闭合标签','闭合标签 (self-closing tag)：Vue 的模板解析器将 `/>` 作为标签关闭的标志，无关其类型。\n\n```html\n<MyComponent /> //闭合\n```\n\n在 DOM中，必须显式地关闭标签：\n\n```html\n<my-component></my-component> //显式地关闭\n```\n\n由于 HTML 只允许一小部分特殊的元素省略其关闭标签，常见的有 `<input>` 和 `<img>`。其他的元素来说，如果省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束\n\n举个例子：\n\n```html\n<my-component />\n<!-- 我们想要在这里关闭标-签... -->\n<span>hello</span>\n```\n\nwill be parsed as：\n\n```html\n<my-component>\n  <span>hello</span>\n</my-component>\n<!-- 但浏览器会在这里关闭标签 -->\n```\n\n',2,2,57,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(756,'全局组件注册','使用 `app.component()` 方法，让组件在当前 Vue 应用中全局可用。\n\n```js\nimport { createApp } from ''vue'';\n\nconst app = createApp({});\n\napp.component(\n  // 注册的名字\n  ''MyComponent'',\n  // 组件的实现\n  {\n    /* ... */\n  }\n);\n```\n\n如果使用单文件组件，可以注册被导入的 `.vue` 文件：\n\n```js\nimport MyComponent from ''./App.vue`\n\napp.component(''MyComponent'', MyComponent)\n```\n\n\n\n`app.component()` 方法可以被链式调用：\n\n```js\nimport { createApp } from ''vue''\nconst app = createApp({})\n\napp\n  .component(''ComponentA'', ComponentA)\n  .component(''ComponentB'', ComponentB)\n  .component(''ComponentC'', ComponentC)\n```\n\n\n\n全局注册的组件可以在此应用的任意组件的模板中使用：\n\n```html\n<!-- 这在当前应用的任意组件中都可用 -->\n<ComponentA/>\n<ComponentB/>\n<ComponentC/>\n```\n\n所有的子组件也可以使用全局注册的组件，这意味着这三个组件也都可以在*彼此内部*使用。\n\n',2,2,49,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(757,'局部组件注册','全局注册的组件虽然十分方便，但也有以下几个短板：\n\n1. 全局注册使构建系统无法移除未使用的组件(也叫“tree-shaking”)。如果你全局注册了一个组件，却一次都没有使用，它仍然会出现在最终的构建产物中。\n2. 全局注册在大型项目中使项目的依赖关系变得不那么明确。在父组件中使用子组件时，很难定位子组件的实现。这可能会影响未来长期的可维护性，类似于使用过多的全局变量。\n\n局部注册将注册组件的可用性限定在当前组件的范围内。它使依赖关系更加明确，并且对 tree-shaking 更加友好。\n\n当你在单文件组件中使用了`<script setup>`，导入的组件会*自动*进行**局部注册**：\n\n\n\n```vue\n<script setup>\nimport ComponentA from ''./ComponentA.vue''\n</script>\n\n<template>\n  <ComponentA />\n</template>\n```\n\n不使用 `<script setup>`，需要使用 `components` 选项：\n\n```vue\n<script>\nimport ComponentA from ''./ComponentA.js''\n\nexport default {\n  components: {\n    ComponentA\n  },\n  setup() {\n    // ...\n  }\n}\n</script>\n```\n\n对于每个 `components` 对象里的属性，它们的 key 名就是注册的组件名，而值就是相应组件的实现。上面的例子中使用的是 ES2015 的缩写语法，等价于：\n\n```js\nexport default {\n  components: {\n    ComponentA: ComponentA\n  }\n  // ...\n};\n```\n\n请注意：**局部注册的组件，在后代组件中，不可用**。在这个例子中，ComponentA注册后，仅在当前组件可用，而在任何的子组件或后代组件中，都不可用。',2,2,48,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(759,'组件名格式','PascalCase为组件名：\n\n- PascalCase 是合法的 JavaScript 标识符，同时 IDE 也能提供较好的自动补全。\n\n- `<PascalCase />` 模板中更明显地表明了这是一个 组件，不是原生 HTML 元素。同时也能将组件和自定义元素 (web components) 区分开来。\n\nVue 支持将使用 kebab-case 的标签解析为使用 PascalCase 注册的组件。这意味着一个以 `MyComponent` 为名注册的组件，在模板中可以通过 `<MyComponent>` 或 `<my-component>` 引用。这允许我们在不同来源的模板中始终使用同一份 JavaScript 组件注册代码。',2,2,47,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(760,'组件引用标注类型','为一个子组件添加一个模板 ref，以便调用它公开的方法。如一个 `MyModal` 子组件，它有一个打开模态框的方法：\n\n```vue\n<!-- MyModal.vue -->\n<script setup lang=\"ts\">\n  import { ref } from ''vue'';\n  const isContentShown = ref(false);\n  const open = () => (isContentShown.value = true);\n  defineExpose({\n    open\n  });\n</script>\n```\n\n获取 `MyModal` 的类型，需要通过 `typeof` 得到其类型，使用 TypeScript 内置的 `InstanceType` 工具类型来获取实例类型：\n\n```vue\n<!-- App.vue -->\n<script setup lang=\"ts\">\n  import MyModal from ''./MyModal.vue'';\n\n  const modal = ref<InstanceType<typeof MyModal> | null>(null);\n  const openModal = () => {\n    modal.value?.open();\n  };\n</script>\n```\n\n',2,2,56,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(761,'class与style动态绑定(对象)','```html\n<template>\n <!-- <div class=\"text\" :class=\"{类名: 布尔值}\">对象形式</div> -->\n  <div :class=\"{ active: isActive }\"></div>\n  <div :style=\"{ fontSize: fontSize }\">\n\n  <div class=\"text\" :class=\"{active: isActive, ''text-bg'': !isActive}\">对象形式</div>\n  <button @click=\"isActive = !isActive\">点击取反</button>\n</template>\n```\n\n```js\nexport default {\n  data() {\n    return {\n      isActive: true,\n      fontSize: 30\n  }\n}\n```\n\n```css\n.active {\n  height: 30px;\n  background: #42b883aa;\n}\n.text-bg {\n  height: 30px;\n  background: #f10202aa;\n}\n```\n\n',2,82,54,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(762,'class与style动态绑定(数组)','```html\n<template>\n  <div :class=\"[activeClass]\"></div>\n  <div :style=\"[styleFontSize]\">\n\n  <div class=\"text\" :class=\"[error,color]\">用数组</div>\n</template>\n```\n\n```js\nexport default {\n  data() {\n    return {\n      activeClass: ''active'',\n      styleFontSize: {\n        fontSize: ''12px''\n      },\n      error: ''text-bg'',\n      color: ''text''\n    };\n  }\n};\n```\n```css\n.text {\n  color: aqua;\n}\n.text-bg {\n  height: 30px;\n  background: #f10202aa;\n}\n```\n',2,82,54,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(763,'class三元表达式','### class三元表达式\n\n根据条件切换列表中的 class\n\n始终添加 `errorClass`，但是只有在 `isActive` 为 truthy 时才添加 `activeClass`。\n\n```html\n<div :class=\"[isActive ? activeClass : '''', errorClass]\"></div>\n```\n',2,81,53,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(764,'getCurrentInstance封装','Vue3中，在setup中无法通过this获取组件实例，console.log(this)打印出来的值是undefined。\n\n在Vue3中，getCurrentInstance()可以用来获取**当前组件实例**\n\ngetCurrentInstance是一个function方法，getCurrentInstance()是一个对象，proxy也是一个对象。proxy是getCurrentInstance()对象中的一个属性，通过对象的解构赋值方式拿到proxy。 \n\ngetCurrentInstance只能在**setup**或**生命周期钩子**中使用。 \n\nctx和proxy都是getCurrentInstance()对象中的属性，通过解构赋值的方式拿到。可以看到，2者有所区别。ctx是普通对象，proxy是Proxy对象。\n\n```tsx\nimport { ComponentInternalInstance, getCurrentInstance } from ''vue'';\nexport default function useCurrentInstance() {\n  const { appContext } = getCurrentInstance() as ComponentInternalInstance;\n  const proxy = appContext.config.globalProperties;\n  return {\n    proxy\n  };\n}\n```\n\n```tsx\nimport useCurrentInstance from ''@/utils/common/useCurrentInstance'';\nconst { proxy }: any = useCurrentInstance();\nconsole.log(''proxy'', proxy);\n```\n\n#### 通过getCurrentInstance().refs得到ref\n\n```tsx\nimport { getCurrentInstance } from ''vue''\nconst  proxy  = getCurrentInstance()\n```\n\n',2,2,24,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(765,'组件通信方式','\n| 方式             | Vue2       | Vue3                  |\n| ---------------- | ---------- | --------------------- |\n| 父传子           | props      | props                 |\n| 子传父           | $emit      | emits                 |\n| 父传子           | $attrs     | attrs                 |\n| 子传父           | $listeners | 无(合并到 attrs 方式) |\n| 父传子           | provide    | provide               |\n| 子传父           | inject     | inject                |\n| 子组件访问父组件 | $parent    | 无                    |\n| 父组件访问子组件 | $children  | 无                    |\n| 父组件访问子组件 | $ref       | expose&ref            |\n| 兄弟传值         | EventBus   | mitt                  |',2,2,46,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(767,'传递props','Prop 是你可以在组件上注册的一些自定义 attribute。为了给博文组件传递内容\n\n```js\n<!-- BlogPost.vue -->\ndefineProps([''title''])\n```\n\n```html\n<h4>{{ title }}</h4>\n```\n\n`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props，因此我们在 JavaScript 中使用\n\n```js\nconst props = defineProps([''title'']);\nconsole.log(props.title);\n```\n\n如果你没有使用 `<script setup>`，props 必须以 `props` 选项的方式声明，props 对象会作为 `setup()` 函数的第一个参数：\n\n```js\nexport default {\n  props: [''title''],\n  setup(props) {\n    console.log(props.title);\n  }\n};\n```\n\n当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：\n\n```js\n<BlogPost title=\"我的 Vue 学习之旅\" />\n<BlogPost title=\"Vue 博客文章总集\" />\n<BlogPost title=\"为什么 Vue 这么有趣\" />\n```\n\n然而在某些应用中，你也许在父组件中有如下的一个博客文章数组：\n\n```js\nconst posts = ref([\n  { id: 1, title: ''My journey with Vue'' },\n  { id: 2, title: ''Blogging with Vue'' },\n  { id: 3, title: ''Why Vue is so fun'' }\n]);\n```\n\n则可以使用 `v-for` 来渲染它们：\n\n```js\n<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n  @click=\"TagSkip(post.id)\"\n />\n```\n',2,31,44,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(768,'Props声明','组件需要显式声明 props，这样 Vue 才能知道外部传入的哪些是 props，哪些是透传 attribute\n\n```js\n// 数组:不建议使用\nprops: [''title'', ''likes'', ''isPublished'', ''commentIds'', ''author'']\n\n//但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：\n// 对象\nprops:{\n inpVal:{\n  type:Number, //传入值限定类型\n  // type 值可为String,Number,Boolean,Array,Object,Date,Function,Symbol\n  // type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n  required: true, //是否必传\n  default:200,  //默认值,对象或数组默认值必须从一个工厂函数获取如 default:()=>[]\n  validator:(value) {\n    // 这个值必须匹配下列字符串中的一个\n    return [''success'', ''warning'', ''danger''].indexOf(value) !== -1\n  }\n }\n}\n```\n\n',2,2,42,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(774,'CSS简介','你需要具备的知识\n\n在继续学习之前，你需要对下面的知识有基本的了解：\n\n- HTML / XHTML\n\n### 什么是CSS\n\n- CSS 指层叠样式表 (**C**ascading **S**tyle **S**heets)\n- 样式定义**如何显示** HTML 元素\n- 样式通常存储在**样式表**中\n- 把样式添加到 HTML 4.0 中，是为了**解决内容与表现分离的问题**\n- **外部样式表**可以极大提高工作效率\n- 外部样式表通常存储在 **CSS 文件**中\n- 多个样式定义可**层叠**为一个',8,30,41,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(775,'通过#去锚定对应内容','\n\n实现了一个 tab 切换的效果\n\n```html\n<div>\n  <a href=\"#A\">A</a>\n  <a href=\"#B\">B</a>\n</div>\n<div className=\"scroll-ctn\">\n  <div id=\"A\" className=\"scroll-panel\">\n    A\n  </div>\n  <div id=\"B\" className=\"scroll-panel\">\n    B\n  </div>\n</div>\n\n```\n\n为了实现平滑滚动，我们在滚动容器上设置了如下的 CSS\n\n```css\n.scroll-ctn {\n  display: block;\n  width: 100%;\n  height: 300px;\n  overflow-y: scroll;\n  scroll-behavior: smooth;\n  border: 1px solid grey;\n}\n```\n\n1',8,26,39,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(776,'父容器固定并占位','- 使用相对定位 relative\n- 参照物：元素偏移前自身的位置\n- 相对定位也通过left,right,top,bottom来决定元素偏移的位置',8,77,40,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(777,'网站变灰gray','```\nhtml{\n    filter: grayscale(100%);\n    -webkit-filter: grayscale(100%);\n    -moz-filter: grayscale(100%);\n    -ms-filter: grayscale(100%);\n    -o-filter: grayscale(100%);\n    filter: url(\"data:image/svg+xml;utf8,<svg xmlns=\\''http://www.w3.org/2000/svg\\''><filter id=\\''grayscale\\''><feColorMatrix type=\\''matrix\\'' values=\\''0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0\\''/></filter></svg>#grayscale\");\n    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1);\n    -webkit-filter: grayscale(1);\n}\n```\n',8,22,38,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(778,'div局部滚动','\n\n```\nh-full overflow-y-scroll\n```\n\n但是当元素没有内容时候，设置height:100%，该元素不会被撑开，此时高度为0，\n\n但是设置height:100vh，该元素会被撑开与屏幕高度一致',8,98,37,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(779,'input标签居中','对于inline元素的input标签，将其父元素的text-align属性设置为center。\n\n```html\n<div style=\"text-align: center;\">\n  <input type=\"text\" placeholder=\"输入内容\">\n</div>\n```\n\n',8,23,36,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(780,'初始化onMounted','\n\n在 Vue3 中可以直接放在 `setup` 里，或者放在 `onMounted/onBeforeMount` 里\n\n```vue\n<script setup>\nimport { onMounted } from ''vue''\n\n// 请求接口函数\nconst getData = () => {\n    xxxApi.then(() => { ... })\n}\n\nonMounted(() => {\n    getData()\n})\n</script>\n```',2,4,132,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(781,'全局注册(属性/方法)','在 `main.js` 中做全局注册\n\n```js\n/ main.js\nimport { createApp } from ''vue''\nimport App from ''./App.vue''\nconst app = createApp(App)\n// 添加全局属性\napp.config.globalProperties.name = ''xxx''\n```\n\n在其他组件中调用\n\n```js\n<script setup>\nimport { getCurrentInstance } from ''vue''\nconst { appContext } = getCurrentInstance()\n\nconst global = appContext.config.globalProperties\nconsole.log(global.name) // 沐华\n</script>\n```',2,14,25,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(782,'获取this','Vue2 中每个组件里使用 this 都指向当前组件实例，this 上还包含了全局挂载的东西、路由、状态管理等啥啥都有\n\n而 Vue3 组合式 API 中没有 this，如果想要类似的用法，有两种，一是获取当前组件实例，二是获取全局实例，如下自己可以去打印出来看看\n\n```vue\n<script setup>\nimport { getCurrentInstance } from ''vue''\n\n// proxy 就是当前组件实例，可以理解为组件级别的 this，没有全局的、路由、状态管理之类的\nconst { proxy, appContext } = getCurrentInstance()\n\n// 这个 global 就是全局实例\nconst global = appContext.config.globalProperties\n</script>\n```\n\n',2,2,24,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(783,'vue3获取DOM','```vue\n<template>\n  <el-form ref=\"formRef\"></el-form>\n</template>\n\n<script setup>\n// 1. 变量名和 DOM 上的 ref 属性必须同名，自动形成绑定\nconst formRef = ref(null)\nconsole.log(formRef.value)\n\n// 2. 通过当前组件实例来获取DOM元素\nconst { proxy } = getCurrentInstance()\nproxy.$refs.formRef.validate((valid) => { ... })\n\n// 2. 比如在 ts 里，可以直接获取到组件类型\n// 可以这样获取子组件\nconst formRef = ref<InstanceType<typeof ChildComponent>>()\n// 也可以这样 获取 element ui 的组件类型\nconst formRef = ref<InstanceType<typeof ElForm>>()\nformRef.value?.validate((valid) => { ... })\n\n</script>\n```',2,11,22,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(784,'鼠标不允许点击','`  cursor: not-allowed;`',8,22,35,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(785,'title换行','```\n&#13;\n```\n',8,22,32,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(786,'关闭x符号','```\n&#215;\n```\n\n',8,22,32,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(787,'media封装','定义名为 `media-xxx` 的 mixin，它包含了 `@media` 查询，并且对应的样式块通过 `@content` 占位符传递进来。然后，在 `#app .app-body` 元素的样式块中，调用 `media-xxx` 这个 mixin，并在其内部设置样式。\n\n```css\n/* 大于1366 小于1536 */\n@mixin media-2xl {\n  @media screen and (min-width: 1366px) and (max-width: 1536px) {\n    @content;\n  }\n}\n\n/* 大于1200 小于1366 */\n@mixin media-xl {\n  @media screen and (min-width: 1200px) and (max-width: 1366px) {\n    @content;\n  }\n}\n\n/* 大于992 小于1200 */\n@mixin media-lg {\n  @media screen and (min-width: 992px) and (max-width: 1200px) {\n    @content;\n  }\n}\n\n/* 大于768 小于992 */\n@mixin media-base {\n  @media screen and (min-width: 768px) and (max-width: 992px) {\n    @content;\n  }\n}\n```\n\n使用\n\n```css\n#app {\n  font-family: PuHuiTiBASE, monospace;\n  background: #f3f7fd;\n\n  @apply w-full absolute;\n\n  .app-body {\n    @apply ml-[24%] mt-[4.6%] w-[47%];\n\n    @include media-2xl {\n      @apply bg-yellow-700 ml-[23.3%] mt-[6.5%];\n    }\n\n    @include media-xl {\n      @apply bg-red-400 ml-[23.3%] mt-[6.5%];\n    }\n\n    @include media-lg {\n      @apply bg-teal-600 ml-[23.3%] mt-[7.5%];\n    }\n\n    @include media-base {\n      @apply bg-gray-300 ml-[23.3%] mt-[10%];\n    }\n  }\n}\n```\n\n',10,21,31,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(788,'字体使用','```scss\n@font-face {\n  font-family: PuHuiTiBASE;\n  src: url(''/src/assets/fonts/55_Regular.ttf'');\n}\n\n@font-face {\n  font-family: PuHuiTiXL;\n  src: url(''/src/assets/fonts/55_Bold.ttf'');\n}\n\nbody {\n  font-family: PuHuiTiBASE, monospace;\n}\n```\n',10,76,30,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(789,'常用快捷键','### 工具快捷键\n\n```bash\nCtrl + Shift + P 显示命令面板\nCtrl + B 显示/隐藏左侧边栏\nCtrl + j 显示/隐藏下方控制台/终端\nCtrl + \\ 拆分为多个编辑器\nCtrl + H	替换 Replace\nCtrl + Tab         切换打开的多个文档(下行)\nCtrl + Shift + Tab 切换打开的多个文档(上行)\n```\n\n### 编码快捷键\n\n```bash\nAlt + Shift + 左右  增加、减少选中内容\nAlt + ↑、Alt + ↓ 移动代码向上、向下\nAlt + Shift + ↑、Alt + Shift + ↓  复制代码向上、向下一行\nAlt + 鼠标连续点击任意位置  所选位置出现多个光标\nCtrl + Home 、Ctrl + End 移动第一行、最后一行\n鼠标三击也可以选中整行\nCtrl + D（一次或多次） 光标所在单词+和他相同的都会被选中并出现多个光标，可以同时修改\nCtrl+Shift+K	删除行 Delete line\nCtrl + 左右  照单词移动光标\nCtrl+Enter	在下面插入行 Insert line below\nCtrl+Shift+Enter	在上面插入行 Insert line above\nCtrl+Shift+[	折叠（折叠）区域 Fold (collapse) region\nCtrl+Shift+]	展开（未折叠）区域 Unfold (uncollapse) \n```\n\n### 导航快捷键\n\n```bash\nCtrl + T	显示所有符号 \nCtrl + G	转到行\nCtrl + P 打开搜索面板\nCtrl + Shift + O	转到符号\nCtrl + Shift + M	显示问题面板\nAlt + ←/→	返回/前进 Go back / forward\nCtrl + Shift + N	新窗口 New window/instance\nCtrl + Shift + W	关闭窗口 Close window/instance\nCtrl+`	显示集成终端 Show integrated terminal\nCtrl+Shift+`	创建新终端 Create new terminal\nctrl + +、ctrl + - 将工作区放大/缩小\n```\n',13,18,28,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(790,'css注释','### css注释\n\n```js\n\"css注释\": {\n  \"prefix\": \"scssAnnotation\",\n  \"body\": [\n    \"/* ------------------------ 模块 ------------------------ */\"\n  ],\n  \"description\": \"css注释\"\n}\n```\n\n1',13,16,27,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(791,'ts/js注释','```js\n\"js/t模块注释\": {\n  \"prefix\": \"stsAnnotation\",\n  \"body\": [\n    \"/* ======================== 模块 ======================== */\"\n  ],\n  \"description\": \"js/t模块注释\"\n}\n```\n\n',13,16,26,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(797,'测试12345','![](http://kai.snblogs.cn/blog/navigation/19.jpg)\n  \n12345',5,85,335,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(814,'函数类型','```js\ntype FnType = (x: number, y: number) => number\n\nfunction fn(): number {\n  return 1\n}\n\nconst fn = function (): number {\n  return 1\n}\n\nconst fn = (): number => {\n  return 1\n}\n\nconst obj = {\n  fn (): number {\n    return 1\n  }\n}\n\n\n```\n',5,88,175,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(815,'transition上下滑动','```vue\n<transition name=\"slide-fade\">\n```\n\n```css\n/*\n  进入和离开动画可以使用不同\n  持续时间和速度曲线。\n*/\n.slide-fade-enter-active {\n  transition: all 1s ease-out;\n}\n\n.slide-fade-leave-active {\n  transition: all 1s cubic-bezier(1, 0.5, 0.8, 1);\n}\n\n.slide-fade-enter-from,\n.slide-fade-leave-to {\n  transform: translatey(500px);\n  opacity: 1;\n}\n```\n',2,2,277,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(816,'阻止浏览器默认快捷键行为','```vue\n<template>\n  <div>\n    <input type=\"text\" @keydown.prevent=\"handleKeyDown\" />\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    handleKeyDown(event) {\n      // 检测按下的键码，根据需要进行处理\n      if (event.keyCode === 13) {\n        // 阻止默认回车键行为\n        event.preventDefault();\n      }\n    },\n  },\n};\n</script>\n\n```',2,100,278,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(817,'鼠标事件监听标签','```vue\n<template>\n  <div @mouseover=\"handleMouseOver\" @mouseleave=\"handleMouseLeave\">\n    <!-- 在这里放置你的内容 -->\n  </div>\n</template>\n\n<script>\nexport default {\n  methods: {\n    handleMouseOver() {\n      // 鼠标进入<div>元素时执行的代码\n      // 在这里可以设置相关的状态或执行其他操作\n    },\n    handleMouseLeave() {\n      // 鼠标离开<div>元素时执行的代码\n      // 在这里可以设置相关的状态或执行其他操作\n    }\n  }\n}\n</script>\n\n```\n',2,45,279,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(818,'监听键盘事件','离开vue页面清空事件\n\n```csharp\nconst escKey = (e: any) => {\n  if (e.keyCode === 27) { //e.key === ''Escape''\n    console.log(''[  ]-37'')\n  }\n}\nonMounted(() => {\n  document.addEventListener(''keyup'', escKey)\n})\n//重点是要记得清空它\nonBeforeUnmount(() => {\n  document.removeEventListener(''keyup'', escKey)\n})\n```\n',2,45,260,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(819,'监听esc事件','```js\nconst escKey = (e: any) => {\n  //escape\n  if (e.keyCode === 27) { //e.key === ''Escape''\n    document.removeEventListener(''keyup'', escKey)\n    isVisible.value = false\n  }\n}\nconst snippetVisible = () => {\n  document.addEventListener(''keyup'', escKey)\n  isVisible.value = true\n}\n```',2,45,260,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(820,'setup中的async/await','### setup中的async/await\n\n我们学习async和await进行异步操作的时候，都知道他们要配合使用，否则会报错。 在setup语法糖里面，可以直接使用awiat而不需要再使用async，因为 setup 会自动变成 async setup 这个使用起来还是很方便的。\n\n```vue\n<script setup>\n  import UserApi from ''../api/UserApi''\n  const data = await UserApi.getUserData()\n  console.log(data)\n</script>\n```\n',2,94,282,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(821,' vue_version','暴露当前所使用的 Vue 版本。\n\n```js\nimport { version } from ''vue''\nconsole.log(version)\n```',2,4,283,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(822,'form标签提交','### form标签提交事件\n\n```html\n <c-modal-dialog :visible=\"ui.articleFastVisible\" title=\"快捷发文\" @close-model=\"ui.articleFastVisible = false\">\n    <div class=\"post\">\n      <form @submit.prevent=\"createPost\">\n        <label for=\"title\">标题:</label>\n        <input id=\"title\" v-model=\"title\" type=\"text\" />\n        <label for=\"content\">内容:</label>\n        <textarea id=\"content\" v-model=\"content\"></textarea>\n        <button type=\"submit\">发布文章</button>\n      </form>\n    </div>\n </c-modal-dialog>\n```\n\n```js\nimport { useUiSetStore } from ''@store/modules/uiSettings''\nconst ui = useUiSetStore()\nconst title = ref('''')\nconst content = ref('''')\n\nfunction createPost() {\n  // 这里可以添加请求或提交数据等具体逻辑\n  console.log(''标题：'', title.value)\n  console.log(''内容：'', content.value)\n\n  // 清空表单\n  title.value = ''''\n  content.value = ''''\n}\n</script>\n```\n\n1',2,94,284,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(823,'特殊标记','发现某个可能的 bug，一些原因还没法修复；或者还有一些待完成的功能，这时需要使用相应的特殊标记注释来告知未来的自己。常用的特殊标记有两种：\n\n- `// FIXME` : 说明问题是什么\n- `// TODO` : 说明还要做什么或者问题的解决方案\n\n```javascript\nclass Calculator extends Abacus {\n  constructor () {\n    super ()\n\n      // FIXME: shouldn’t use a global here\n      total = 0\n\n      // TODO: total should be configurable by an options param\n      this.total = 0\n  }\n}\n```\n\n',6,53,286,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(824,'定义全局函数','### 定义全局函数\n\n```js\nconst app = createApp({});\napp.config.globalProperties.$http = () => {};\n// app.config.globalProperties.day = dayjs //全局挂载\n```\n',2,96,287,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(825,'浏览器元素定位','```css\ninspect($(''.rpv-default-layout-main'')); //函数等效于 document.querySelector 函数$\n```',6,72,288,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(826,'条码比对不一致','**问题点**\n\n读取系统条码 : **2327MH0070X2** \n\n读取耳机条码 : **2327MH007A02** \n\n比对出现不一致 , 程序报错属于正常拦截\n\n**方案**\n\n1. 排查绑定测试站是否绑错',18,102,293,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(827,' 工单登录错误','**问题点**\n\n登录工单提示: **跟当前机型名称不一致**\n\n**方案**\n\n1. 排查图程是否建立\n2. 检查料号是否维护，是否维护到错误的机型名称',18,102,294,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(828,'ASCII控制字符对照','### ASCII控制字符对照表\n\nASCII 编码中第 0~31 个字符（开头的 32 个字符）以及第 127 个字符（最后一个字符）都是不可见的（无法显示），但是它们都具有一些特殊功能，所以称为控制字符（ Control Character）或者功能码（Function Code）。\n\n这 33 个控制字符大都与通信、数据存储以及老式设备有关，有些在现代电脑中的含义已经改变了。\n\n| 二进制   | 十进制 | 十六进制 | 字符/缩写                                    | 解释                                       |\n| -------- | ------ | -------- | -------------------------------------------- | ------------------------------------------ |\n| 00000000 | 0      | 00       | NUL (NULL)                                   | 空字符 ,中文意为空操作，就是啥都不做的意思 |\n| 00000001 | 1      | 01       | SOH (Start Of Headling)                      | 标题开始                                   |\n| 00000010 | 2      | 02       | STX (Start Of Text)                          | 正文开始                                   |\n| 00000011 | 3      | 03       | ETX (End Of Text)                            | 正文结束                                   |\n| 00000100 | 4      | 04       | EOT (End Of Transmission)                    | 传输结束                                   |\n| 00000101 | 5      | 05       | ENQ (Enquiry)                                | 请求                                       |\n| 00000110 | 6      | 06       | ACK (Acknowledge)                            | 回应/响应/收到通知                         |\n| 00000111 | 7      | 07       | BEL (Bell)                                   | 响铃                                       |\n| 00001000 | 8      | 08       | BS (Backspace)                               | 退格                                       |\n| 00001001 | 9      | 09       | HT (Horizontal Tab)                          | 水平制表符                                 |\n| 00001010 | 10     | 0A       | LF/NL(Line Feed/New Line)                    | 换行键                                     |\n| 00001011 | 11     | 0B       | VT (Vertical Tab)                            | 垂直制表符                                 |\n| 00001100 | 12     | 0C       | FF/NP (Form Feed/New Page)                   | 换页键                                     |\n| 00001101 | 13     | 0D       | CR (Carriage Return)                         | 回车键                                     |\n| 00001110 | 14     | 0E       | SO (Shift Out)                               | 不用切换                                   |\n| 00001111 | 15     | 0F       | SI (Shift In)                                | 启用切换                                   |\n| 00010000 | 16     | 10       | DLE (Data Link Escape)                       | 数据链路转义                               |\n| 00010001 | 17     | 11       | DC1/XON (Device Control 1/Transmission On)   | 设备控制1/传输开始                         |\n| 00010010 | 18     | 12       | DC2 (Device Control 2)                       | 设备控制2                                  |\n| 00010011 | 19     | 13       | DC3/XOFF (Device Control 3/Transmission Off) | 设备控制3/传输中断                         |\n| 00010100 | 20     | 14       | DC4 (Device Control 4)                       | 设备控制4                                  |\n| 00010101 | 21     | 15       | NAK (Negative Acknowledge)                   | 无响应/非正常响应/拒绝接收                 |\n| 00010110 | 22     | 16       | SYN (Synchronous Idle)                       | 同步空闲                                   |\n| 00010111 | 23     | 17       | ETB (End of Transmission Block)              | 传输块结束/块传输终止                      |\n| 00011000 | 24     | 18       | CAN (Cancel)                                 | 取消                                       |\n| 00011001 | 25     | 19       | EM (End of Medium)                           | 已到介质末端/介质存储已满/介质中断         |\n| 00011010 | 26     | 1A       | SUB (Substitute)                             | 替补/替换                                  |\n| 00011011 | 27     | 1B       | ESC (Escape)                                 | 逃离/取消                                  |\n| 00011100 | 28     | 1C       | FS (File Separator)                          | 文件分割符                                 |\n| 00011101 | 29     | 1D       | GS (Group Separator)                         | 组分隔符/分组符                            |\n| 00011110 | 30     | 1E       | RS (Record Separator)                        | 记录分离符                                 |\n| 00011111 | 31     | 1F       | US (Unit Separator)                          | 单元分隔符                                 |',19,103,295,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(829,'ASCII显示字符对照表','\n\n| 二进制   | 十进制 | 十六进制 | 字符/缩写    | 解释 |\n| -------- | ------ | -------- | ------------ | ---- |\n| 00100000 | 32     | 20       | (Space)      | 空格 |\n| 00100001 | 33     | 21       | !            |      |\n| 00100010 | 34     | 22       | \"            |      |\n| 00100011 | 35     | 23       | #            |      |\n| 00100100 | 36     | 24       | $            |      |\n| 00100101 | 37     | 25       | %            |      |\n| 00100110 | 38     | 26       | &            |      |\n| 00100111 | 39     | 27       | ''            |      |\n| 00101000 | 40     | 28       | (            |      |\n| 00101001 | 41     | 29       | )            |      |\n| 00101010 | 42     | 2A       | *            |      |\n| 00101011 | 43     | 2B       | +            |      |\n| 00101100 | 44     | 2C       | ,            |      |\n| 00101101 | 45     | 2D       | -            |      |\n| 00101110 | 46     | 2E       | .            |      |\n| 00101111 | 47     | 2F       | /            |      |\n| 00110000 | 48     | 30       | 0            |      |\n| 00110001 | 49     | 31       | 1            |      |\n| 00110010 | 50     | 32       | 2            |      |\n| 00110011 | 51     | 33       | 3            |      |\n| 00110100 | 52     | 34       | 4            |      |\n| 00110101 | 53     | 35       | 5            |      |\n| 00110110 | 54     | 36       | 6            |      |\n| 00110111 | 55     | 37       | 7            |      |\n| 00111000 | 56     | 38       | 8            |      |\n| 00111001 | 57     | 39       | 9            |      |\n| 00111010 | 58     | 3A       | :            |      |\n| 00111011 | 59     | 3B       | ;            |      |\n| 00111100 | 60     | 3C       | <            |      |\n| 00111101 | 61     | 3D       | =            |      |\n| 00111110 | 62     | 3E       | >            |      |\n| 00111111 | 63     | 3F       | ?            |      |\n| 01000000 | 64     | 40       | @            |      |\n| 01000001 | 65     | 41       | A            |      |\n| 01000010 | 66     | 42       | B            |      |\n| 01000011 | 67     | 43       | C            |      |\n| 01000100 | 68     | 44       | D            |      |\n| 01000101 | 69     | 45       | E            |      |\n| 01000110 | 70     | 46       | F            |      |\n| 01000111 | 71     | 47       | G            |      |\n| 01001000 | 72     | 48       | H            |      |\n| 01001001 | 73     | 49       | I            |      |\n| 01001010 | 74     | 4A       | J            |      |\n| 01001011 | 75     | 4B       | K            |      |\n| 01001100 | 76     | 4C       | L            |      |\n| 01001101 | 77     | 4D       | M            |      |\n| 01001110 | 78     | 4E       | N            |      |\n| 01001111 | 79     | 4F       | O            |      |\n| 01010000 | 80     | 50       | P            |      |\n| 01010001 | 81     | 51       | Q            |      |\n| 01010010 | 82     | 52       | R            |      |\n| 01010011 | 83     | 53       | S            |      |\n| 01010100 | 84     | 54       | T            |      |\n| 01010101 | 85     | 55       | U            |      |\n| 01010110 | 86     | 56       | V            |      |\n| 01010111 | 87     | 57       | W            |      |\n| 01011000 | 88     | 58       | X            |      |\n| 01011001 | 89     | 59       | Y            |      |\n| 01011010 | 90     | 5A       | Z            |      |\n| 01011011 | 91     | 5B       | [            |      |\n| 01011100 | 92     | 5C       | \\            |      |\n| 01011101 | 93     | 5D       | ]            |      |\n| 01011110 | 94     | 5E       | ^            |      |\n| 01011111 | 95     | 5F       | _            |      |\n| 01100000 | 96     | 60       | `            |      |\n| 01100001 | 97     | 61       | a            |      |\n| 01100010 | 98     | 62       | b            |      |\n| 01100011 | 99     | 63       | c            |      |\n| 01100100 | 100    | 64       | d            |      |\n| 01100101 | 101    | 65       | e            |      |\n| 01100110 | 102    | 66       | f            |      |\n| 01100111 | 103    | 67       | g            |      |\n| 01101000 | 104    | 68       | h            |      |\n| 01101001 | 105    | 69       | i            |      |\n| 01101010 | 106    | 6A       | j            |      |\n| 01101011 | 107    | 6B       | k            |      |\n| 01101100 | 108    | 6C       | l            |      |\n| 01101101 | 109    | 6D       | m            |      |\n| 01101110 | 110    | 6E       | n            |      |\n| 01101111 | 111    | 6F       | o            |      |\n| 01110000 | 112    | 70       | p            |      |\n| 01110001 | 113    | 71       | q            |      |\n| 01110010 | 114    | 72       | r            |      |\n| 01110011 | 115    | 73       | s            |      |\n| 01110100 | 116    | 74       | t            |      |\n| 01110101 | 117    | 75       | u            |      |\n| 01110110 | 118    | 76       | v            |      |\n| 01110111 | 119    | 77       | w            |      |\n| 01111000 | 120    | 78       | x            |      |\n| 01111001 | 121    | 79       | y            |      |\n| 01111010 | 122    | 7A       | z            |      |\n| 01111011 | 123    | 7B       | {            |      |\n| 01111100 | 124    | 7C       | \\|           |      |\n| 01111101 | 125    | 7D       | }            |      |\n| 01111110 | 126    | 7E       | ~            |      |\n| 01111111 | 127    | 7F       | DEL (Delete) | 删除 |',19,103,296,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(830,'错误代码设置','### 错误代码设置\n\n- 标识：0 不用输入错误代码\n- 标识：1 设IP的 Chrome 专用 每次Fail 每次弹窗，每次可以关闭窗体\n- 标识：2 MECH_Chrome 用 每次Fail 每次弹窗，最后一次Fail 窗体不可以关闭。\n\n**config配置**\n\n- ErrorCode字段维护错误代码标识\n- CustomerName字段要维护对应得客户名称（Cisco）\n\n  **设置**\n\n1. 进入后台系统\n\n2. 选择机型对应的站别(如**T2.01**)\n\n3. 点击侧边编辑按钮(**编辑配置**)\n\n4. 找到字段\"**错误代码 ErrorCode**\" 相应机型的 0 1 2\n\n   ![image-20230823163912134](http://kai.snblogs.cn/typora/image-20230823163912134.png)',18,104,297,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(831,'开关屏蔽箱','**RS232串口线**\n\n+ 232的线程需装驱动\n+ 默认端口com1\n+ 地址 \\\\10.55.2.3\\mech部門資料夾\\工程部\\工程課\\TE測試文件\\12_產測輔助軟件\n\n**USB线**\n\n是动态端口属于单独识别\n\n\n\n**API配置**\n\n关屏蔽箱\n\n```\ndllname=Common&method=send_read&串口=COM1&写入字符串=close\n```\n\n开屏蔽箱\n\n```\ndllname=Common&method=send_read&串口=COM1&写入字符串=open\n```\n\n',18,104,298,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(832,'弹窗提示','1. 找到**通用测试类**选项  \n2. 选择**弹框提示信息**\n3. 输入自定提示标题\n\n**API配置**\n\n```\ndllname=Common&method=Forms&显示信息=请先关机，然后开机\n```\n\n![image-20230823165908769](http://kai.snblogs.cn/typora/image-20230823165908769.png)\n\n',18,104,299,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(833,'模板机型图片显示','1. 在机型项目下(testitem\\机型)新建**Image**文件夹 , 图片放入文件中格式化为jpg\n2. 在后台料号中配置字段**ImagePath=xxx.jpg**',18,104,300,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(834,'BLE灵敏度通用算法','successPackets : 成功接收包的数量\n\npacketNumTotal : 预设总接收数\n\n**计算丢包率**\n\n```csharp\nprivate string RFBleRxSmtEnd(string deviceName)\n{\n    var successPackets = RaceApiManager.Inst.GetFirst().LeBRxEnd(deviceName);\n    // MessageBox.Show($\"成功接收的数据包数：{successPackets}\");\n    //计算丢包率 总数1000个包,成功接收的包数999个,丢包率不能超过千分之一%\n    var packetNumTotal = 1000;\n    double ber = ((packetNumTotal - Convert.ToDouble(successPackets)) / packetNumTotal * 100);\n    return ber.ToString(\"0.0\");\n}\n```\n\n1',18,105,301,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(835,'通过api生成测试数据','**生成log**\n\n```csharp\nstring time = DateTime.Now.ToString(\"yyyy/MM/dd HH:mm:ss\");\nvar jsonData = \"{\\\"sns\\\":\\\"\" + sns + \"\\\",\\\"hbd\\\":\\\"\" + \"null\" + \"\\\",\\\"dbd\\\":\\\"\" + dg_bda + \"\\\",\\\"stations\\\":\\\"\" + stations + \"\\\",\\\"times\\\":\\\"\" + time + \"\\\"}\";\nHttpPost(\"http://10.55.2.25:8098/api/te-test-log\", jsonData);\n```\n\n**HttpPost**\n\n```csharp\n/// 发送POST请求\n/// </summary>\n/// <param name=\"url\">请求URL</param>\n/// <param name=\"data\">请求参数</param>\n/// <returns></returns>\nstatic string HttpPost(string url, string data)\n{\n    try\n    {\n        HttpWebRequest httpWebRequest = (HttpWebRequest) HttpWebRequest.Create(url);\n        //字符串转换为字节码\n        byte[] bs = Encoding.UTF8.GetBytes(data);\n        //参数类型，这里是json类型\n        //还有别的类型如\"application/x-www-form-urlencoded\"，不过我没用过(逃\n        httpWebRequest.ContentType = \"application/json\";\n        //参数数据长度\n        httpWebRequest.ContentLength = bs.Length;\n        //设置请求类型\n        httpWebRequest.Method = \"POST\";\n        //设置超时时间\n        httpWebRequest.Timeout = 120000;\n        //将参数写入请求地址中\n        httpWebRequest.GetRequestStream().Write(bs, 0, bs.Length);\n        //发送请求\n        HttpWebResponse httpWebResponse = (HttpWebResponse) httpWebRequest.GetResponse();\n        //读取返回数据\n        StreamReader streamReader = new StreamReader(httpWebResponse.GetResponseStream(), Encoding.UTF8);\n        string responseContent = streamReader.ReadToEnd();\n        streamReader.Close();\n        httpWebResponse.Close();\n        httpWebRequest.Abort();\n        return responseContent;\n    }\n    catch(Exception ex)\n    {\n        return ex.ToString();\n    }\n}\n```\n',18,106,302,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(836,'生成本地log','### 生成本地log\n\n```csharp\n//生成日志文件名，基于当前日期\nstring filename = $ \"log_{DateTime.Now.ToString(\"\nyyyyMMdd \")}.txt\";\n// 创建日志文件，如果文件已存在则追加数据\nusing(StreamWriter sw = File.AppendText(filename))\n{\n    // 生成日志内容\n    string logEntry = $ \"SN: {sns}, BD: {dg_bda}, station: {stations},Time: {DateTime.Now.ToString()}\";\n    // 将日志内容写入文件\n    sw.WriteLine(logEntry);\n    // 关闭StreamWriter对象\n    sw.Close();\n}\n```',18,102,243,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(837,'通过仪器读取LED亮度','代码中使用\n\n1. 定义调用函数 , 需使用到HanOpticSens_V1.dll\n\n   ```csharp\n   private string CallDLL(string command)\n   {\n       Invoke invoke = new Invoke();\n       return invoke.CallMethod(command, new Dictionary<string, object> { });\n   }\n   ```\n\n2. 读取亮度\n\n   ```csharp\n   var value = CallDLL($\"dllname=HanOpticSens_V1&亮度=lux&串口={Config.LedCom}&Channle=1\");\n   ```\n\n   ',18,104,304,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(838,'料号未维护到TE系统','**问题点**\n\n- 登录工单系统提示**未维护**\n\n- 测试过程中某些字段需通过料号写值出现提示**未维护**\n\n**方案**\n\n把料号维护到后台系统\n\n1. 进入后台系统选择**料号配置**\n\n2. 选择对应的配置\n\n   ![image-20230823182309395](http://kai.snblogs.cn/typora/image-20230823182309395.png)\n\n3. 点击添加料号按钮\n\n   ![image-20230823182437148](http://kai.snblogs.cn/typora/image-20230823182437148.png)\n\n4. 输入料号确定即可',18,102,305,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(839,'后台数据出现空异常','**问题点**\n\n在查询后台数据过程中发现某些数据显示空\n\n![image-20230823183252953](http://kai.snblogs.cn/typora/image-20230823183252953.png)\n\n**方案**\n\n经过对后台测试项比对发现有一台电脑引用了带后缀空格的测试项目\n\n![image-20230823183537437](http://kai.snblogs.cn/typora/image-20230823183537437.png) \n\n删除后台测试项空格恢复正常',18,102,306,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(840,'主副条码绑定','1. 主条码通过config[**sn**]获取\n2. 副码调用后台配置 **BarCodeWindow**\n3. 获取完主副码后调用后台配置进行绑定 **Binding**\n\n| Binding The SN Of Dongle and Headset |                                  |\n| ------------------------------------ | -------------------------------- |\n| Bar_code_window                      | dllname=MES&扫条码=BarCodeWindow |\n| Binding                              | dllname=MES&获取BD和=Binding     |',18,104,307,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(841,'soundcheck IP','默认为 TCP/IP **4444**',18,107,308,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(842,'控制台模拟模板初始化验证','1. 定义模板字典值\n2. 创建实例 , 将值设定到字典中\n3. 执行模拟测试项\n\n```csharp\nusing System;\nusing System.Collections.Generic;\n\nnamespace MerryDll.Debug {\n    public class Program {\n        static void Main(string[] args) {\n            \n            //1.模拟模板内容\n           const string LiKey = \"xxxxxx976E93E5F0835F65D867A15969FB6CC8154F822D1DC7A0555Dxxxxx\";\n           const string SN = \"cn01djxrmyh8y36r0005x01\";\n           const string PCBA = \"R916232200472\";\n           const string BDA = \"123456789133\";\n           const string UID = \"D916232300925\";\n           const string UID_D = \"D916232300925\";\n           const string BindingSN = \"D916232300925\";\n            \n            //2.创建MerryDll实例\n            var merryDll = new MerryDllFramework.MerryDll();\n            \n            //模拟模板内容初始化操作\n            merryDll.Interface(new Dictionary<string,object>() {\n                { \"BindingSN\",BindingSN },\n                { \"SN\",SN }, \n                { \"UID_D\",UID_D } ,\n                { \"UID\",UID },\n                {\"BitAddress\",BDA },\n                {\"BarcodeSN\",SN }, \n                { \"PartNumberInfos\",\n                    new Dictionary<string,string>() {\n                        { \"Calibration\",\"black\" },\n                        { \"color\",\"0509\" }\n                    } } });\n            \n            //3.模拟测试项\n            while (true) {\n                var cmd = Console.ReadLine();\n                Console.WriteLine(merryDll.Run(cmd));\n            }\n        }\n    }\n}\n```\n\n',18,108,309,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(843,'字典创建','```csharp\n/// <summary>\n/// 用于存储模板主程序传入的键值对\n/// </summary>\nprivate Dictionary<string, object> _templateConfig = new Dictionary<string, object>();\n```\n\n',18,108,310,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(844,'通过字典获取SN','写入和检测SN,流程跟BDA一致\n\n程序扫码框执行完成后存储在Config[\"**SN**\"]字典中\n\n```csharp\n _templateConfig[\"SN\"]?.ToString()\n```\n\n',18,108,310,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(845,'通过API获取BDA','1. 后台系统中进行配置获取BDA的API\n\n   ```csharp\n   //旧API\n   dllname=MES&method=GetBDFromMES\n   //新API\n   dllname=MES&method=AllotMasterBDAddress\n   ```\n\n ![image-20230824095626670](http://kai.snblogs.cn/typora/image-20230824095626670.png)\n\n2. 执行完成后存储在Config[\"**BitAddress**\"]字典中\n\n   程序中通过**BitAddress**获取到BDA条码\n\n   ```csharp\n   string bitAddress = _templateConfig[\"BitAddress\"].ToString();\n   ```\n\n',18,108,312,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(846,'通过主码查询BD号','正常情况下耳机的条码为主码(SN对应的**BDA**)，Dongle的条码为副码\n\n1. 通过SN扫码后 , 在通过QueryBD获取BDA条码 ,存储在Config[\"**BitAddress**\"]字典中\n\n   ```csharp\n   dllname=MES&主码查询BD号=QueryBD\n   ```\n\n2. 程序中调用\n\n   ```csharp\n   string bitAddress = _templateConfig[\"BitAddress\"]\n   ```\n\n   ',18,108,313,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(847,'通过弹窗读取副条码','1. 读取副条码前 , 需把值存到API\n\n   ```csharp\n   dllname=MES&扫条码=BarCodeWindow\n   //OR\n   dllname=MES&副码扫描弹框=BarCodeWindow&条码长度=12\n   ```\n\n2. 扫码完成后值存储在Config[\"**BarcodeSN** \"]字典中\n\n   ```csharp\n   string BarcodeSN = _templateConfig[\"BarcodeSN\"]\n   ```\n\n   ',18,108,312,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(848,'通过副条码获取BDA','1. 执行dllname=MES&method=QueryBDNoBySN\n\n2. 存储在Config[\"**BitAddressByBarcodeSN** \"]字典中\n\n   ```\n   string BitAddressByBarcodeSN = _templateConfig[\"BitAddressByBarcodeSN\"]\n   ```\n\n',18,108,313,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(849,'主副码绑定','绑定（主码与副码）\n\n1. 弹框扫描副码(BarCodeWindow) ,存储在**BarcodeSN**字典中\n\n2. 检查副码的途程是否结束（就是有没有走完测试站）“dllname=MES&检测副码途程=IsRouteEnd”，程序会自行判断途程是否结束\n\n3. 调用绑定API\n\n   ```csharp\n   dllname=MES&获取BD和=Binding\n   //新api\n   dllname=MES&method=MasterBindingSlave\n   ```\n\n   ',18,108,316,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(850,'注意事项','- 量产firmwareVersion: **20230309 Quake 2 V1.0.4 (new version)**\n- 数据返回值不影响文档注册,上下限变动影响上传必须重新给到客人注册\n- 指令区分**MSB** 大 **LSB**小\n- PID_VID : Headset: **046D 0AF8** Dongle: **046D 0AF7**\n- DLL更新务必查看是否有覆盖替换',18,109,317,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(851,'必备驱动','### 必备驱动\n\n**FW烧录驱动**\n\nL:\\工程部\\工程課\\TE測試文件\\SW\\何文武\\HDT627\\烧录相关\\驱动\n\n  ![image-20230719093453613](http://kai.snblogs.cn/typora/image-20230719093453613.png)\n\n**RT550驱动**\n\n\\\\10.55.2.3\\mech_production_line_sharing\\03_use_by_te_all\\12_產測輔助軟件\\2.RT550\n\n ![image-20230719093431505](http://kai.snblogs.cn/typora/image-20230719093431505.png)',18,109,318,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(852,'获取当前项目下的路径','```csharp\nusing System;  \nusing System.IO;  \n  \nclass Program  \n{  \n    static void Main()  \n    {  \n        // 获取当前项目的路径  \n        string projectPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);  \n        Console.WriteLine(\"当前项目的路径是：\" + projectPath);  \n    }  \n}\n```\n',1,110,319,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(853,'使用Action定义函数','代码提供了一种封装 UART 串口和 RacePort 操作的方式，使得在执行操作时不必每次都打开和关闭设备。\n\n```csharp\n/// <summary>\n/// 执行Uart串口的打开和关闭,\n/// 而不必每次都重复打开和关闭串口。\n/// </summary>\n/// <param name=\"action\"></param>\nprivate void ExecuteUartComPort(Action action)\n    {\n        //开启串口\n        _headsetRace.OpenUartPort(Config.HeadsetComPort);\n        action(); // 执行传入的操作 如:ExecuteUartComPort(() => { ExecuteAtCmd })\n        //关闭串口\n        _headsetRace.CloseUartPort(Config.HeadsetComPort);\n    }\n    //0R\n    /// <summary>\n    /// 执行RacePort操作\n    /// </summary>\n    /// <param name=\"action\">执行方法</param>\n    /// <param name=\"deviceName\">装置名称</param>\n    /// <exception cref=\"Exception\">异常输出</exception>\nprivate void ExecuteRacePort(Action action, string deviceName)\n{\n    switch(deviceName)\n    {\n        case \"HS\":\n            OpenHeadset();\n            action();\n            CloseHeadset();\n            return;\n        case \"DG\":\n            OpenDongle();\n            action();\n            CloseDongle();\n            return;\n        default:\n            throw new Exception(\"deviceName is not HS or DG\");\n    }\n}\n```',1,111,320,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(854,'根据V/PID和GUID定位即插即用设备实体','\n\n```csharp\n/// <summary>\n/// 根据VID和PID及设备安装类GUID定位即插即用设备实体\n/// </summary>\n/// <param name = \"VendorID\" >供应商标识，MinValue忽视</param>\n/// <param name = \"ProductID\" >产品编号，MinValue忽视</param>\n/// < returns >设备列表</ returns >\n/// <remarks>\n/// </remarks>\npublic static string WhoPnPEntity(UInt16 VendorID, UInt16 ProductID, string Name)\n{\n    List < PnPEntityInfo > PnPEntities = new List < PnPEntityInfo > ();\n    // 枚举即插即用设备实体\n    String VIDPID;\n    if(VendorID == UInt16.MinValue)\n    {\n        if(ProductID == UInt16.MinValue) VIDPID = \"''%VID[_]____&PID[_]____%''\";\n        else VIDPID = \"''%VID[_]____&PID[_]\" + ProductID.ToString(\"X4\") + \"%''\";\n    }\n    else\n    {\n        if(ProductID == UInt16.MinValue) VIDPID = \"''%VID[_]\" + VendorID.ToString(\"X4\") + \"&PID[_]____%''\";\n        else VIDPID = \"''%VID[_]\" + VendorID.ToString(\"X4\") + \"&PID[_]\" + ProductID.ToString(\"X4\") + \"%''\";\n    }\n    String QueryString = \"SELECT * FROM Win32_PnPEntity WHERE PNPDeviceID LIKE\" + VIDPID;\n    ManagementObjectCollection PnPEntityCollection = new ManagementObjectSearcher(QueryString).Get();\n    if(PnPEntityCollection != null)\n    {\n        foreach(ManagementObject Entity in PnPEntityCollection)\n        {\n            String PNPDeviceID = Entity[\"PNPDeviceID\"] as String;\n            // 过滤掉没有PID和VID的设备\n            Match match = Regex.Match(PNPDeviceID, \"VID_[0-9|A-F]{4}&PID_[0-9|A-F]{4}\");\n            if(match.Success)\n            {\n                PnPEntityInfo Element;\n                //Element.PNPDeviceID = PNPDeviceID;                      // 设备ID\n                //Element.Name = Entity[\"Name\"] as String;                // 设备名称\n                string name = Entity[\"Name\"] as String;\n                if(name.Equals(Name)) return name;\n                //Element.VendorID = Convert.ToUInt16(match.Value.Substring(4, 4), 16);   // 供应商标识\n                //Element.ProductID = Convert.ToUInt16(match.Value.Substring(13, 4), 16); // 产品编号\n                //PnPEntities.Add(Element);\n            }\n        }\n    }\n    return \"False\";\n    //if (PnPEntities.Count == 0) return null; else return PnPEntities;\n}\n```\n',1,110,321,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(855,'控制台启动不显示',' 创建好控制台程序后，选中项目，右键，属性，输出类型选为“windows 应用程序” 这样就没有dos窗口',1,110,322,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(856,'控制台输出加载条','```csharp\nConsole.WriteLine(\"正在上传，请稍候...\");\n// 设置加载条的长度\nint progressBarWidth = 50;\nfor(int i = 0; i <= progressBarWidth; i++)\n{\n    // 计算加载条的进度百分比\n    float progressPercentage = (float) i / progressBarWidth * 100;\n    // 输出加载条\n    Console.BackgroundColor = ConsoleColor.Green;\n    Console.Write(new string('' '', i));\n    Console.BackgroundColor = ConsoleColor.Black;\n    Console.Write(new string('' '', progressBarWidth - i));\n    Console.Write(progressPercentage + \"%\");\n    Console.SetCursorPosition(0, Console.CursorTop);\n    // 模拟加载过程\n    Thread.Sleep(10);\n}\n```\n\n',1,112,323,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(857,'获取当前程序目录','```csharp\n// 获取当前程序集的执行路径(根目录)D:\\sw\\Console\\FileDownLoad\\DownLoad\\bin\\Debug\nvar currentPath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);\n```\n',1,110,324,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(858,'每两个字符为一组进行反转','\n12345678 => 78 56 34 12\n\n```csharp\n/// <summary>\n/// 将一个字符串中的字符按照每两个字符为一组进行反转\n/// </summary>\n/// <param name=\"str\"></param>\n/// <returns></returns>\npublic string Reverse(string str)\n{\n  //string NewStr = \"\";\n  //for (int i = str.Length - 2 ; i >= 0 ; i -= 2) {\n  //    NewStr += $\"{str.Substring(i,2)}\";\n  //}\n  //使用StringBuilder代替字符串拼接，避免了频繁的内存分配和拷贝，提高了代码的效率\n  StringBuilder newStr = new StringBuilder();\n  // 从字符串的倒数第二个字符开始循环，每次减少2个字符\n  for(int i = str.Length - 2; i >= 0; i -= 2)\n  {\n    // 将每两个字符添加到新字符串变量中\n    newStr.Append(str.Substring(i, 2));\n  }\n  return newStr.ToString();\n}\n```\n\n为了提高代码的可复用性，我们可以将代码封装成一个静态方法，以便在其他地方调用\n\n```csharp\npublic static class StringUtil\n{\n    public static string Reverse(string str)\n    {\n        StringBuilder newStr = new StringBuilder();\n        for (int i = str.Length - 2; i >= 0; i -= 2)\n        {\n            newStr.Append(str.Substring(i, 2));\n        }\n        return newStr.ToString();\n    }\n}\n```',1,113,325,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(859,'反转字符串','```csharp\n/// <summary>\n/// 反转字符串\n/// </summary>\n/// <param name=\"input\"></param>\n/// <returns></returns>\npublic string ReverseString(string input)\n{\n  // 将字符串转换为字符数组\n  char[] charArray = input.ToCharArray();\n  // 反转字符数组\n  Array.Reverse(charArray);\n  // 将字符数组转换为字符串并返回\n  return new string(charArray);\n}\n```\n',1,113,325,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(860,'非空判断','```csharp\npublic static bool IsNotNull(object obj)\n{\n  return obj != null;\n}\n```\n\n',1,110,107,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(861,'转换URL中的信息','```csharp\n/// <summary>\n/// URL字符串进行编码\n/// </summary>\n/// <param name=\"url\"></param>\n/// <returns></returns>\npublic static string UrlEncode(string url)\n    {\n        return HttpUtility.UrlEncode(url);\n    }\n/// <summary>\n/// URL字符串进行解码\n/// </summary>\n/// <param name=\"url\"></param>\n/// <returns></returns>\npublic static string UrlDecode(string url)\n{\n    return HttpUtility.UrlDecode(url);\n}\n```\n',1,113,328,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(862,'读取USB装置','添加引用：System.Management\n引入命名空间：using System.Management;\n```csharp\nManagementObjectCollection collection;\nusing(var searcher = new ManagementObjectSearcher(@\"Select * From Win32_USBHub\"))\ncollection = searcher.Get();\nforeach(var device in collection)\n{\n    Console.WriteLine(\"Device ID: {0}, PNP Device ID: {1}, Description: {2}\", device.Properties[\"DeviceID\"].Value,       device.Properties[\"PNPDeviceID\"].Value, device.Properties[\"Description\"].Value);\n}\n```\n\n',1,110,329,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(863,'获取系统驱动器','```csharp\n/// <summary>\n/// 获取系统驱动器\n/// </summary>\n/// <returns></returns>\npublic static string[] GetLogicalDrivess()\n{\n    //获取系统驱动器\n    return Directory.GetLogicalDrives();\n}\n```\n',1,110,330,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(864,'获得本机所有进程','```csharp\n/// <summary>\n/// 获得本机的进程\n/// </summary>\n/// <returns>Process[]</returns>\npublic static Process[] GetProcesses()\n{\n    //包含所有进程信息的Process类型数组\n    Process[] proList = Process.GetProcesses(\".\");\n    return proList;\n}\n```\n',1,110,331,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(865,'模板程序播放录音失败','- 排查装置是否正确安装 , 测试是否有正常音量输出\n- 卸载当前前耳机驱动 , 重新接入Dongle或耳机安装驱动',18,102,332,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(866,'工单提示没有BD号','工单没有BD号，返回信息 **Part Type not the Product or Semi Product False**\n\n- 排查系统类别是否维护错误\n- 系统问题 , 需MES或PE更新类别操作',18,102,333,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(867,'监听滚动事件','#### 定义函数\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n',2,93,336,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(869,'test1e222ee','#### 定义函数3222y21\n\n```js\nconst scroll = () => {\n  // 滚动条高度\n  const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n  // 可视区的高度\n  const { clientHeight } = document.documentElement;\n  if (scrollTop > clientHeight) {\n    reac.local = false;\n  } else {\n    reac.local = true;e\n  }\n};\n```\n\n#### onMounted中使用\n\n```tsx\n// 给window添加一个滚动监听事件\nwindow.addEventListener(''scroll'', scroll);\n```\n\n#### html\n\n```html\n<nav class=\"sheader\" v-if=\"reac.local\">...</nav>\n```\n\n#### 移除监听事件\n\n```js\nonDeactivated(async () => {\n  // 离开这个界面之后，删除，不然会有问题\n  window.removeEventListener(''scroll'', scroll);\n});\n```\n\n\n',3,97,1,4,39,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(870,'使用hooks封装API函数','从原来的代码段中提取出来\n\n```tsx\nimport { useSnippetApi } from ''@hooks/http''\nimport { message } from ''ant-design-vue''\n\nconst { up } = useSnippetApi()\n\nexport function useSnippetPack() {\n  const upSnippet = async (snippet: any) => {\n    const response = await up(snippet)\n    if (response.data) {\n      message.success(''更新成功'')\n      return true\n    }\n    message.warning(''更新失败'')\n    return false\n  }\n  return {\n    upSnippet\n  }\n}\n```\n\nuseSnippetApi\n\n```tsx\n  function up(entity: any) {\n    return update(`/snippet/edit`, entity)\n  }\n```\n\n',2,94,337,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(871,'字体配置','使用@font-face属性\n在scss中引入字体包\n\n```css\n@font-face {\n  font-family: PuHuiTi; 字体标题\n  src: url(''/src/assets/fonts/Alibaba_PuHuiTi_2.0_55_Regular.ttf''); 字体包\n}\n```\n\n标签中使用字体\n\n```scss\n@layer base {\n  // html {\n  //   @apply antialiased;\n  // }\n  body {\n    font-family: PuHuiTi;\n  }\n}\n```\n\n',10,76,338,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(872,'定时器使用','### 定时器\n\n```js\nsetInterval(() => {\n  //定时查询桌面\n  _exe();\n}, 5000);\n```\n\n### 异步定时\n\n```js\n// 使用watchEffect创建一个响应式的副作用函数\nwatchEffect((onInvalidate) => {\n  // 创建定时器，每三秒执行一次_exe函数\n  const timerId = setInterval(() => {\n    //定时查询桌面\n    _exe();\n  }, 3000);\n  // 在响应式的副作用函数中使用onInvalidate函数监听组件被销毁的时机\n  onInvalidate(() => {\n    // 组件被销毁时清除定时器\n    clearInterval(timerId);\n  });\n});\n```\n\n',6,89,339,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(873,'图片动态加载','\n```js\n//1.封装一个引入图片方法\nfunction QImageUrl(name: string) {\n  return new URL(`/src/assets/img/${name}`, import.meta.url).href\n}\n\n//2.App.vue\n<img :src=\"\" alt=\"QImageUrl(name)\" />\n    \n//3.使用插件\n<img v-lazy=\"QImageUrl(r.img)\" alt=\"\" />\n```\n',2,94,344,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(874,'监听ref节点滚动顶部','```js\n// 创建节点 ref\nconst scrollContainer = ref()\n\nconst onScroll = (type: any) => {\n  //下一次 DOM 更新周期时再执行\n  nextTick(() => {\n    //根据 type 参数的值计算出要滚动到的位置  确保在模板中将其赋值给对应的 DOM 元素，如 <div ref=\"snippetRef\"></div>。\n    const distance = type === ''top'' ? 0 : scrollContainer.value.scrollHeight\n    scrollContainer.value.scrollTop = distance\n  })\n}\n\n//调用\nonScroll(''top'')\n```\n\n```html\n<div ref=\"scrollContainer\"></div>\n```\n\n',2,144,345,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(875,'deep样式穿透','在Vue3中，:deep()是一种用于选择子元素的样式语法。它允许我们在样式中选择父元素下的特定子元素，并对其应用样式\n\n```scss\n<style>\n:deep(.class){\n  /* 在这里添加样式 */\n}\n</style>\n\n//在父元素的class后加上:deep()\n<style>\n.父元素class :deep(.class){\n}\n</style>\n\n//在scss下的父元素里用:deep()语法\n<style lang=scss>\n.父元素{\n 	:deep(.class){\n	}\n}\n</style>\n```\n\n',2,94,346,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(876,'异步组件封装','封装前调用\n\n```js\nconst ArticleSideSearchModule = defineAsyncComponent(() => {\n  return import(''./components/sidebar/ArticleSideSearch.vue'')\n})\n```\n\n封装调用\n\n```js\n// 定义异步组件函数\nconst AsyncComponent = (name: any) => {\n  return defineAsyncComponent(() => {\n    return import(/* @vite-ignore */`./components/sidebar/${name}.vue`)\n  })\n}\n\n// 定义异步组件\nconst ArticleSideInputModule = AsyncComponent(''ArticleSideInput'')\nconst ArticleSideInputModule = AsyncComponent(''ArticleSideInput'')\n```',2,2,347,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(877,'监听ref节点是否到底部','```tsx\n// 创建节点 ref\nconst scrollContainer = ref()\n\n// 定义触发底部函数\nconst handleScroll = () => {\n  const containerEl = scrollContainer.vlue\n  if (containerEl) {\n    const isAtBottom = containerEl.scrollHeight - containerEl.scrollTop === containerEl.clientHeight\n    console.log(isAtBottom)\n    if (isAtBottom) {\n      GetAll()\n    }\n  }\n}\n// 监听函数\nwatchEffect(() => {\n  handleScroll()\n})\n```\n\n```html\n <div ref=\"scrollContainer\" @scroll=\"handleScroll\"</div>\n```',2,144,348,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(878,'判断内容是否是纯数字','该函数返回一个布尔值，如果字符串 `str` 只包含数字，则返回 `true`；否则返回 `false`。\n\n```js\nfunction isNumeric(str: string): boolean {\n  return /^\\d+$/.test(str);\n}\n```\n\n',6,91,349,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(879,'获取当前路径的父路径','```csharp\n//获取当前运行路径的上级目录（父目录）\nSystem.IO.DirectoryInfo topDir = System.IO.Directory.GetParent(System.Environment.CurrentDirectory);\n\n//继续获取上级的上级的上级的目录。\nstring pathto = topDir.Parent.Parent.FullName;//D:\\项目\\测试\\test\n\n//获取路径中最后一个文件夹的名字\nstring fileName = Path.GetFileNameWithoutExtension(\"E:\\dyl190909\\Demo\\CulculateTest\\Culculate\\View.cs\");\n//fileName结果为Culculate\n```\n\n',1,110,350,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(880,'捕获堆栈信息','```csharp\nstatic string GetCustomStackTrace(Exception ex)\n{\n    var stackTrace = new StackTrace(ex, true); // 第二个参数表示捕获源文件信息\n    var frames = stackTrace.GetFrames();\n    if(frames == null) return \"无法获取堆栈帧\";\n    var result = new System.Text.StringBuilder();\n    foreach(var frame in frames)\n    {\n        var method = frame.GetMethod();\n        var fileName = frame.GetFileName();\n        var lineNumber = frame.GetFileLineNumber();\n        result.AppendFormat(\"   在 {0}.{1}\", method.ReflectedType.FullName, method.Name);\n        if(!string.IsNullOrEmpty(fileName) && lineNumber > 0)\n        {\n            result.AppendFormat(\"({0}:{1})\", fileName, lineNumber);\n        }\n        result.AppendLine();\n    }\n    return result.ToString();\n}\n```\n\n```csharp\nstatic void Main(string[] args)\n{\n    try\n    {\n        throw new InvalidOperationException(\"演示异常\");\n    }\n    catch(Exception ex)\n    {\n        Console.WriteLine($ \"异常: {ex.Message}\");\n        Console.WriteLine(\"堆栈跟踪:\");\n        Console.WriteLine(GetCustomStackTrace(ex));\n    }\n}\ntry\n{}\ncatch(Exception ex)\n{}\n```\n\n`GetCustomStackTrace` 方法接收一个 `Exception` 参数，并使用 `StackTrace` 类来获取堆栈跟踪信息。遍历所有堆栈帧，获取方法、文件名和行号等信息，并将其格式化为一个字符串，最后在控制台输出。',1,110,351,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(881,'读取当前系统信息','```csharp\n/// <summary>\n/// 读取当前系统信息\n/// </summary>\n/// <returns></returns>\npublic static string[] GetWindows()\n{\n    string[] name = new string[8];\n    //获取系统信息\n    try\n    {\n        name[0] = \"用户名：\" + SystemInformation.UserName;\n        name[1] = \"计算机名：\" + SystemInformation.ComputerName;\n        name[2] = \"操作系统：\" + Environment.OSVersion.Platform;\n        name[3] = \"版本号：\" + Environment.OSVersion.Version;\n        if(SystemInformation.BootMode.ToString() == \"Normal\") name[4] = \"启动方式：正常启动\";\n        if(SystemInformation.BootMode.ToString() == \"FailSafe\") name[4] = \"启动方式：安全启动\";\n        if(SystemInformation.BootMode.ToString() == \"FailSafeWithNetwork\") name[4] = \"启动方式：通过网络服务启动\";\n        if(SystemInformation.Network == true) name[5] = \"网络连接：已连接\";\n        else name[5] = \"网络连接：未连接\";\n        name[6] = \"显示器数量：\" + SystemInformation.MonitorCount.ToString();\n        name[7] = \"显示器分辨率：\" + SystemInformation.PrimaryMonitorMaximizedWindowSize.Width.ToString() + \"X\" + SystemInformation.PrimaryMonitorMaximizedWindowSize.Height.ToString();\n    }\n    catch\n    {\n        MessageBox.Show(\"获取系统信息发生错误！\", \"信息提示\", MessageBoxButtons.OK, MessageBoxIcon.Information);\n    }\n    return name;\n}\n```',1,110,352,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(882,'获取当前进程信息','```csharp\n/// <summary>\n/// 获取当前进程信息\n/// </summary>\n/// <returns></returns>\npublic static Process GetCurrentProcess()\n{\n    //string[] process = new string[10];\n    Process cur = Process.GetCurrentProcess();\n    //process[0] = \"进程的id:\" + cur.Id;\n    //process[0] = \"关联进程的终端服务会话标识符:\" + cur.SessionId;\n    //process[0] = \"当前进程名称:\" + cur.ProcessName;\n    //process[0] = \"当前进程启动时间:\" + cur.StartTime;\n    //process[0] = \"当前机器名称:\" + cur.MachineName;\n    //process[0] = \"主窗口标题:\" + cur.MainWindowTitle;\n    return cur;\n}\n```',1,110,331,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(883,'检查进程是否重复启动','```csharp\n/// <summary>\n/// 检查重复启动\n/// </summary>\n/// <param name=\"name\">进程名称</param>\npublic static void CheckProcessesByName(string name)\n{\n    Process[] pro = Process.GetProcessesByName(name);\n    var process = pro.Where(p => p.ProcessName.Equals(Process.GetCurrentProcess().ProcessName));\n    int n = process.Count();\n    if(n > 1)\n    {\n        MessageBox.Show(\"线程已启动\");\n        Environment.Exit(0);\n    }\n}\n```\n',1,110,331,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(884,'反射函数使用','```csharp\n/// <summary>\n/// 反射函数\n/// </summary>\n/// <param name=\"dictPara\">传入的值</param>\n/// <returns></returns>\npublic virtual void Test(string dictPara)\n{\n    string result = string.Empty;\n    try\n    {\n        //传入指定类构造函数的值\n        string strPara = \"this is parameter\";\n        //加载程序集(dll文件地址)，使用Assembly类\n        byte[] file = File.ReadAllBytes(AppDomain.CurrentDomain.BaseDirectory + \"MechTE.dll\");\n        System.Reflection.Assembly assembly = System.Reflection.Assembly.Load(file);\n        //获取类型，参数（名称空间+类）\n        Type type = assembly.GetType(\"MechTE.MechDll\") !;\n        //创建该对象的实例，object类型，参数（名称空间+类）\n        object instance = assembly.CreateInstance(\"MechTE.MechDll\", true, System.Reflection.BindingFlags.Default, null, new object[]\n        {\n            strPara\n        }, null, null) !;\n        //方法的类型 string\n        Type[] params_type = {\n            typeof(string)\n        };\n        //方法参数\n        Object[] params_obj = {\n            dictPara\n        };\n        //执行方法\n        result = (string) type.GetMethod(\"Run\", params_type) !.Invoke(instance, params_obj) !;\n    }\n    catch(Exception ex)\n    {\n        DispListBoxMsg(ex.Message);\n    }\n    DispListBoxMsg(result);\n}\n```',1,110,355,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(885,'清空文件内容','```csharp\n/// <summary>\n/// 清空文件内容\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>\npublic static void ClearFile(string filePath)\n{\n    //删除文件\n    File.Delete(filePath);\n    //重新创建该文件\n    CreateFile(filePath);\n}\n```\n\n',1,114,356,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(886,'删除指定目录','```csharp\n/// <summary>\n/// 删除指定目录及其所有子目录\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>\npublic static void DeleteDirectory(string directoryPath)\n{\n    if(IsExistDirectory(directoryPath))\n    {\n        Directory.Delete(directoryPath, true);\n    }\n}\n```\n\n',1,114,356,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(887,'泛型声明','```c#\n//泛型类\npublic class GenericClass<T> where T : ISports\n{\n}\n//泛型接口\npublic interface GenericInterface<S>\n{\n}\n//泛型委托\npublic delegate void Do<T>() where T : ISports;\n\n//泛型方法\npublic void test<T>(T param)\n{\n}\n```',1,115,362,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(888,'泛型类封装使用','定义一个泛型类就是指的是，定义一个类，这个类中某些字段的类型是不确定的，这些类型可以在类构造的时候确定下来,举例:\n\n```c#\nusing System.Collections.Generic;\n\nnamespace Snblog.Util.components\n{\n    public class Tool<T>\n    {\n        public T result = default;\n        private List<T> resultList = default;\n        public T resultDto = default;\n        private List<T> resultListDto = default;\n        private int resulInt;\n\n    }\n}\n```\n\n使用\n\n```c#\nTool < SnArticle > data = new Tool < SnArticle > ();\nTool < SnArticleDto > datas = new Tool < SnArticleDto > ();\n```\n\n',1,115,363,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(889,'文件的绝对路径获取扩展名','```csharp\n/// <summary>\n/// 从文件的绝对路径中获取扩展名\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static string GetExtension(string filePath)\n{\n    //获取文件的名称\n    FileInfo fi = new FileInfo(filePath);\n    return fi.Extension;\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(890,'从文件的绝对路径获取文件名','(不包含扩展名)\n\n```csharp\n/// <summary>\n/// 从文件的绝对路径中获取文件名( 不包含扩展名 )\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static string GetFileNameNoExtension(string filePath)\n{\n    //获取文件的名称\n    FileInfo fi = new FileInfo(filePath);\n    return fi.Name.Split(''.'')[0];}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(891,'将文件的内容复制到新文件中','```csharp\n/// <summary>\n/// 将源文件的内容复制到目标文件中\n/// </summary>\n/// <param name=\"sourceFilePath\">源文件的绝对路径</param>\n/// <param name=\"destFilePath\">目标文件的绝对路径</param>\npublic static void Copy(string sourceFilePath, string destFilePath)\n{\n    File.Copy(sourceFilePath, destFilePath, true);\n}\n```',1,114,371,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(892,'向文本文件的尾部追加内容','```csharp\n/// <summary>\n/// 向文本文件的尾部追加内容\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>\n/// <param name=\"content\">写入的内容</param>\npublic static void AppendText(string filePath, string content)\n{\n    File.AppendAllText(filePath, content);\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(893,'向文本文件写入内容','```csharp\n/// <summary>\n/// 向文本文件中写入内容\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>\n/// <param name=\"text\">写入的内容</param>\n/// <param name=\"encoding\">编码</param>\npublic static void WriteText(string filePath, string text, Encoding encoding)\n{\n    //向文件写入内容\n    File.WriteAllText(filePath, text, encoding);\n}\n```',1,114,373,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(894,'获取目录中的子目录列表','```csharp\n/// <summary>\n/// 获取指定目录及子目录中所有子目录列表\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>\n/// <param name=\"searchPattern\">模式字符串，\"*\"代表0或N个字符，\"?\"代表1个字符。\n/// 范例：\"Log*.xml\"表示搜索所有以Log开头的Xml文件。</param>\n/// <param name=\"isSearchChild\">是否搜索子目录</param>\npublic static string[] GetDirectories(string directoryPath, string searchPattern, bool isSearchChild)\n{\n    try\n    {\n        if(isSearchChild)\n        {\n            return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.AllDirectories);\n        }\n        else\n        {\n            return Directory.GetDirectories(directoryPath, searchPattern, SearchOption.TopDirectoryOnly);\n        }\n    }\n    catch(IOException ex)\n    {\n        throw ex;\n    }\n}\n```\n\n',1,110,374,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(895,' 获取文件的长度','```csharp\n/// <summary>\n/// 获取一个文件的长度,单位为Byte\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static int GetFileSize(string filePath)\n{\n    //创建一个文件对象\n    FileInfo fi = new FileInfo(filePath);\n    //获取文件的大小\n    return(int) fi.Length;\n}\n```\n\n',1,114,375,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(896,'获取文本文件的行数','```csharp\n/// <summary>\n/// 获取文本文件的行数\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static int GetLineCount(string filePath)\n{\n    //将文本文件的各行读到一个字符串数组中\n    string[] rows = File.ReadAllLines(filePath);\n    //返回行数\n    return rows.Length;\n}\n```\n\n',1,114,376,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(897,'创建一个文件','```csharp\n/// <summary>\n/// 创建一个文件\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>\npublic static void CreateFile(string filePath)\n    {\n        try\n        {\n            //如果文件不存在则创建该文件\n            if(!IsExistFile(filePath))\n            {\n                //创建一个FileInfo对象\n                FileInfo file = new FileInfo(filePath);\n                //创建文件\n                FileStream fs = file.Create();\n                //关闭文件流\n                fs.Close();\n            }\n        }\n        catch(Exception ex)\n        {\n            //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n            throw ex;\n        }\n    }\n    /// <summary>\n    /// 创建一个文件,并将字节流写入文件。\n    /// </summary>\n    /// <param name=\"filePath\">文件的绝对路径</param>\n    /// <param name=\"buffer\">二进制流数据</param>\npublic static void CreateFile(string filePath, byte[] buffer)\n{\n    try\n    {\n        //如果文件不存在则创建该文件\n        if(!IsExistFile(filePath))\n        {\n            //创建一个FileInfo对象\n            FileInfo file = new FileInfo(filePath);\n            //创建文件\n            FileStream fs = file.Create();\n            //写入二进制流\n            fs.Write(buffer, 0, buffer.Length);\n            //关闭文件流\n            fs.Close();\n        }\n    }\n    catch(Exception ex)\n    {\n        //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n        throw ex;\n    }\n}\n```',1,114,377,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(898,'创建一个目录','```csharp\n/// <summary>\n/// 创建一个目录\n/// </summary>\n/// <param name=\"directoryPath\">目录的绝对路径</param>\npublic static void CreateDirectory(string directoryPath)\n{\n    //如果目录不存在则创建该目录\n    if(!IsExistDirectory(directoryPath))\n    {\n        Directory.CreateDirectory(directoryPath);\n    }\n}\n```',1,114,378,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(899,'定位居中','使用绝对定位\n\n```css\n@apply absolute top-[50%] left-[50%];\ntransform: translate(-50%, -50%); /* 将div向上和向左移动其自身宽度和高度的50%以居中 */\n```\n\n',20,118,36,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(900,'fixed居中','```css\n@apply top-1/2 left-1/2 fixed;\ntransform: translate(-50%, -50%);\n```\n\n',20,118,124,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(901,'从文件的绝对路径中获取文件名',' 包含扩展名\n\n```csharp\n/// <summary>\n/// 从文件的绝对路径中获取文件名( 包含扩展名 )\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static string GetFileName(string filePath)\n{\n    //获取文件的名称\n    FileInfo fi = new FileInfo(filePath);\n    return fi.Name;\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(902,'删除指定文件夹对应其他文件夹里的文件','```csharp\n/// <summary>\n/// 删除指定文件夹对应其他文件夹里的文件\n/// </summary>\n/// <param name=\"varFromDirectory\">指定文件夹路径</param>\n/// <param name=\"varToDirectory\">对应其他文件夹路径</param>\npublic static void DeleteFolderFiles(string varFromDirectory, string varToDirectory)\n{\n    Directory.CreateDirectory(varToDirectory);\n    if(!Directory.Exists(varFromDirectory)) return;\n    string[] directories = Directory.GetDirectories(varFromDirectory);\n    if(directories.Length > 0)\n    {\n        foreach(string d in directories)\n        {\n            DeleteFolderFiles(d, varToDirectory + d.Substring(d.LastIndexOf(\"\\\\\")));\n        }\n    }\n    string[] files = Directory.GetFiles(varFromDirectory);\n    if(files.Length > 0)\n    {\n        foreach(string s in files)\n        {\n            File.Delete(varToDirectory + s.Substring(s.LastIndexOf(\"\\\\\")));\n        }\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(903,'检查文件如果不存在则创建','```csharp\n/// <summary>\n/// 检查文件,如果文件不存在则创建  \n/// </summary>\n/// <param name=\"FilePath\">路径,包括文件名</param>\npublic static void ExistsFile(string FilePath)\n{\n    if(!File.Exists(FilePath))\n    {\n        FileStream fs = File.Create(FilePath);\n        fs.Close();\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(904,'复制文件夹','```csharp\n/// <summary>\n/// 复制文件夹(递归)\n/// </summary>\n/// <param name=\"varFromDirectory\">源文件夹路径</param>\n/// <param name=\"varToDirectory\">目标文件夹路径</param>\npublic static void CopyFolder(string varFromDirectory, string varToDirectory)\n{\n    Directory.CreateDirectory(varToDirectory);\n    if(!Directory.Exists(varFromDirectory)) return;\n    string[] directories = Directory.GetDirectories(varFromDirectory);\n    if(directories.Length > 0)\n    {\n        foreach(string d in directories)\n        {\n            CopyFolder(d, varToDirectory + d.Substring(d.LastIndexOf(\"\\\\\")));\n        }\n    }\n    string[] files = Directory.GetFiles(varFromDirectory);\n    if(files.Length > 0)\n    {\n        foreach(string s in files)\n        {\n            File.Copy(s, varToDirectory + s.Substring(s.LastIndexOf(\"\\\\\")), true);\n        }\n    }\n}\n```\n\n',1,114,384,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(905,'检测目录中是否存在指定的文件','```csharp\n/// <summary>\n/// 检测指定目录中是否存在指定的文件,若要搜索子目录请使用重载方法.\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>\n/// <param name=\"searchPattern\">模式字符串，\"*\"代表0或N个字符，\"?\"代表1个字符。\n/// 范例：\"Log*.xml\"表示搜索所有以Log开头的Xml文件。</param>        \npublic static bool Contains(string directoryPath, string searchPattern)\n    {\n        try\n        {\n            //获取指定的文件列表\n            string[] fileNames = GetFileNames(directoryPath, searchPattern, false);\n            //判断指定文件是否存在\n            if(fileNames.Length == 0)\n            {\n                return false;\n            }\n            else\n            {\n                return true;\n            }\n        }\n        catch(Exception ex)\n        {\n            throw new Exception(ex.Message);\n            //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n        }\n    }\n    /// <summary>\n    /// 检测指定目录中是否存在指定的文件\n    /// </summary>\n    /// <param name=\"directoryPath\">指定目录的绝对路径</param>\n    /// <param name=\"searchPattern\">模式字符串，\"*\"代表0或N个字符，\"?\"代表1个字符。\n    /// 范例：\"Log*.xml\"表示搜索所有以Log开头的Xml文件。</param> \n    /// <param name=\"isSearchChild\">是否搜索子目录</param>\npublic static bool Contains(string directoryPath, string searchPattern, bool isSearchChild)\n{\n    try\n    {\n        //获取指定的文件列表\n        string[] fileNames = GetFileNames(directoryPath, searchPattern, true);\n        //判断指定文件是否存在\n        if(fileNames.Length == 0)\n        {\n            return false;\n        }\n        else\n        {\n            return true;\n        }\n    }\n    catch(Exception ex)\n    {\n        throw new Exception(ex.Message);\n        //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(906,'检测指定目录是否为空','```csharp\n/// <summary>\n/// 检测指定目录是否为空\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>        \npublic static bool IsEmptyDirectory(string directoryPath)\n{\n    try\n    {\n        //判断是否存在文件\n        string[] fileNames = GetFileNames(directoryPath);\n        if(fileNames.Length > 0)\n        {\n            return false;\n        }\n        //判断是否存在文件夹\n        string[] directoryNames = GetDirectories(directoryPath);\n        if(directoryNames.Length > 0)\n        {\n            return false;\n        }\n        return true;\n    }\n    catch\n    {\n        //这里记录日志\n        //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n        return true;\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(907,'获取指定目录及子目录中所有文件列表','```csharp\n/// <summary>\n/// 获取指定目录及子目录中所有文件列表\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>\n/// <param name=\"searchPattern\">模式字符串，\"*\"代表0或N个字符，\"?\"代表1个字符。\n/// 范例：\"Log*.xml\"表示搜索所有以Log开头的Xml文件。</param>\n/// <param name=\"isSearchChild\">是否搜索子目录</param>\npublic static string[] GetFileNames(string directoryPath, string searchPattern, bool isSearchChild)\n{\n    //如果目录不存在，则抛出异常\n    if(!IsExistDirectory(directoryPath))\n    {\n        throw new FileNotFoundException();\n    }\n    try\n    {\n        if(isSearchChild)\n        {\n            return Directory.GetFiles(directoryPath, searchPattern, SearchOption.AllDirectories);\n        }\n        else\n        {\n            return Directory.GetFiles(directoryPath, searchPattern, SearchOption.TopDirectoryOnly);\n        }\n    }\n    catch(IOException ex)\n    {\n        throw ex;\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(908,'复制文件夹及文件','```csharp\n/// <summary>\n/// 复制文件夹及文件\n/// </summary>\n/// <param name=\"sourceFolder\">原文件路径</param>\n/// <param name=\"destFolder\">目标文件路径</param>\n/// <returns>1 || -1</returns>\npublic static int CopyFile(string sourceFolder, string destFolder)\n{\n    try\n    {\n        //如果目标路径不存在,则创建目标路径\n        if(!Directory.Exists(destFolder))\n        {\n            Directory.CreateDirectory(destFolder);\n        }\n        //得到原文件根目录下的所有文件\n        string[] files = Directory.GetFiles(sourceFolder);\n        foreach(string file in files)\n            {\n                string name = Path.GetFileName(file);\n                string dest = Path.Combine(destFolder, name);\n                File.Copy(file, dest, true); //复制文件\n            }\n            //得到原文件根目录下的所有文件夹\n        string[] folders = Directory.GetDirectories(sourceFolder);\n        foreach(string folder in folders)\n        {\n            string name = Path.GetFileName(folder);\n            string dest = Path.Combine(destFolder, name);\n            CopyFile(folder, dest); //构建目标路径,递归复制文件\n        }\n        return 1;\n    }\n    catch(Exception e)\n    {\n        Console.WriteLine(e.Message);\n        return -1;\n    }\n}\n```',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(909,'获取指定目录中所有子目录列表','```csharp\n/// <summary>\n/// 获取指定目录中所有子目录列表\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>        \npublic static string[] GetDirectories(string directoryPath)\n{\n    try\n    {\n        return Directory.GetDirectories(directoryPath);\n    }\n    catch(IOException ex)\n    {\n        throw ex;\n    }\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(910,'获取指定目录中的文件列表','```csharp\n/// <summary>\n/// 获取指定目录中所有文件列表\n/// </summary>\n/// <param name=\"directoryPath\">指定目录的绝对路径</param>        \npublic static string[] GetFileNames(string directoryPath)\n{\n    //如果目录不存在，则抛出异常\n    if(!IsExistDirectory(directoryPath))\n    {\n        throw new FileNotFoundException();\n    }\n    //获取文件列表\n    return Directory.GetFiles(directoryPath);\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(911,'检测指定文件是否存在','```csharp\n/// <summary>\n/// 检测指定文件是否存在\n/// </summary>\n/// <param name=\"filePath\">文件的绝对路径</param>        \npublic static bool IsExistFile(string filePath)\n{\n    return File.Exists(filePath);\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(912,'检测指定目录是否存在','```csharp\n/// <summary>\n/// 检测指定目录是否存在\n/// </summary>\n/// <param name=\"directoryPath\">目录的绝对路径</param>\n/// <returns></returns>\npublic static bool IsExistDirectory(string directoryPath)\n{\n    return Directory.Exists(directoryPath);\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(913,'获取指定目录文件夹','```csharp\n/// <summary>\n/// 获取指定目录文件夹\n/// </summary>\n/// <param name=\"path\">文件路径</param>\n/// <returns>文件名,文件路径</returns>\npublic static List < string > QueryFile(string path)\n{\n    var result = new List < string > ();\n    try\n    {\n        DirectoryInfo theFolder = new DirectoryInfo(path);\n        DirectoryInfo[] dirInfo = theFolder.GetDirectories(); //获取所在目录的文件夹\n        //遍历文件夹\n        foreach(DirectoryInfo NextFolder in dirInfo)\n        {\n            if(!NextFolder.FullName.Contains(\"$RECYCLE\"))\n            {\n                result.Add(NextFolder.Name.ToString() + \",\" + $ \"{path}\\\\{NextFolder.Name}\");\n            }\n        }\n    }\n    catch(Exception)\n    {\n        throw;\n    }\n    return result;\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(914,'浏览文件对话框','```csharp\n/// <summary>\n/// winfrom浏览文件对话框\n/// </summary>\n/// <returns>string</returns>\npublic static string FileDialog()\n{\n    FolderBrowserDialog dialog = new FolderBrowserDialog\n    {\n        //打开的文件夹浏览对话框上的描述\n        Description = \"请选择文件夹\",\n            //是否显示对话框左下角 新建文件夹 按钮，默认为 true\n            ShowNewFolderButton = false\n    };\n    if(dialog.ShowDialog() == DialogResult.OK)\n    {\n        if(!string.IsNullOrEmpty(dialog.SelectedPath))\n        {\n            return dialog.SelectedPath;\n        }\n    }\n    else\n    {\n        return \"false\";\n    }\n    return \"FileDialog false\";\n}\n```\n\n',1,114,364,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(915,'使用系统进程打开程序/文件夹','```csharp\n/// <summary>\n/// 使用本地系统进程打开程序/文件夹\n/// </summary>\n/// <param name=\"path\">路径</param>\npublic static void OpenFile(string path)\n{\n    System.Diagnostics.Process.Start(@path);\n}\n```\n\n',1,114,399,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(916,'将byte[]转换成int','```csharp\n/// <summary>\n/// 将byte[]转换成int\n/// </summary>\n/// <param name=\"data\">需要转换成整数的byte数组</param>\npublic static int BytesToInt32(byte[] data)\n{\n    //如果传入的字节数组长度小于4,则返回0\n    if(data.Length < 4)\n    {\n        return 0;\n    }\n    //定义要返回的整数\n    int num = 0;\n    //如果传入的字节数组长度大于4,需要进行处理\n    if(data.Length >= 4)\n    {\n        //创建一个临时缓冲区\n        byte[] tempBuffer = new byte[4];\n        //将传入的字节数组的前4个字节复制到临时缓冲区\n        Buffer.BlockCopy(data, 0, tempBuffer, 0, 4);\n        //将临时缓冲区的值转换成整数，并赋给num\n        num = BitConverter.ToInt32(tempBuffer, 0);\n    }\n    //返回整数\n    return num;\n}\n```\n\n',1,119,400,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(917,'将byte[]转换成string','```csharp\n/// <summary>\n/// 使用指定字符集将byte[]转换成string\n/// </summary>\n/// <param name=\"bytes\">要转换的字节数组</param>\n/// <param name=\"encoding\">字符编码</param>\npublic static string BytesToString(byte[] bytes, Encoding encoding)\n{\n    return encoding.GetString(bytes);\n}\n```\n\n',1,114,401,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(918,'将string转换成byte[]','```csharp\n/// <summary>\n/// 使用指定字符集将string转换成byte[]\n/// </summary>\n/// <param name=\"text\">要转换的字符串</param>\n/// <param name=\"encoding\">字符编码</param>\npublic static byte[] StringToBytes(string text, Encoding encoding)\n{\n    return encoding.GetBytes(text);\n}\n```\n\n',1,113,401,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(919,'进制数间转换','```csharp\n/// <summary>\n/// 实现各进制数间的转换。ConvertBase(\"15\",10,16)表示将十进制数15转换为16进制的数。\n/// </summary>\n/// <param name=\"value\">要转换的值,即原值</param>\n/// <param name=\"from\">原值的进制,只能是2,8,10,16四个值。</param>\n/// <param name=\"to\">要转换到的目标进制，只能是2,8,10,16四个值。</param>\npublic static string ConvertBase(string value, int from, int to)\n{\n    try\n    {\n        int intValue = Convert.ToInt32(value, from); //先转成10进制\n        string result = Convert.ToString(intValue, to); //再转成目标进制\n        if(to == 2)\n        {\n            int resultLength = result.Length; //获取二进制的长度\n            switch(resultLength)\n            {\n                case 7:\n                    result = \"0\" + result;\n                    break;\n                case 6:\n                    result = \"00\" + result;\n                    break;\n                case 5:\n                    result = \"000\" + result;\n                    break;\n                case 4:\n                    result = \"0000\" + result;\n                    break;\n                case 3:\n                    result = \"00000\" + result;\n                    break;\n            }\n        }\n        return result;\n    }\n    catch\n    {\n        //LogHelper.WriteTraceLog(TraceLogLevel.Error, ex.Message);\n        return \"0\";\n    }\n}\n```\n\n',1,111,403,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(920,'补足字符位数','```csharp\n/// <summary>\n/// 指定字符串的固定长度，如果字符串小于固定长度，\n/// 则在字符串的前面补足零，可设置的固定长度最大为9位\n/// </summary>\n/// <param name=\"text\">原始字符串</param>\n/// <param name=\"limitedLength\">字符串的固定长度</param>\npublic static string RepairZero(string text, int limitedLength)\n{\n    //补足0的字符串\n    string temp = \"\";\n    //补足0\n    for(int i = 0; i < limitedLength - text.Length; i++)\n    {\n        temp += \"0\";\n    }\n    //连接text\n    temp += text;\n    //返回补足0的字符串\n    return temp;\n}\n```\n\n',1,113,404,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(921,'Main','- static：是将Main方法声明为静态， 是应用程序的入口。\n- void：说明main方法不会返回任何内容。 \n- string[]args：这是用来接收命令行传入的参数。string[]是声明args的数据类型，可以存储字符串数组。\n\n​    通过cmd.exe程序来启动上述程序时会弹出命令窗口，你可以在那里输入一些参数，string[] args 指的就是在命令窗口输入的参数， 也就是命令行参数。\n\n​    args是用来接收命令行参数的。它是可选项，不是必须的。\n\n```csharp\nusing System;\n\nnamespace DemoMainArgs\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(\"Hello World！\");\n            Console.ReadLine();\n        }\n    }\n}\n```\n\n#### 方式1\n\n**命令行中启动程序并输入参数**\n\n打开命令行，输入路径+DemoMainArgs，空一格，再输入 a b c d（可以输入任意多个参数，多个之间用空格分隔）\n\n ![image-20230918134225191](http://kai.snblogs.cn/typora/image-20230918134225191.png)\n\n#### 方式2\n\n**编译前输入参数**\n\n右键点击【项目】--》【属性】，弹出配置界面。选择【调试】--》【启动选项】--》【命令行参数】文本框中输入任意的参数，多个之间用空格分隔\n\n ![image-20230918134307706](http://kai.snblogs.cn/typora/image-20230918134307706.png)\n\n#### 方式3\n\n**通过在程序的快捷方式中增加参数【推荐】**\n\n程序编译后，创建快捷方式程序。右键点击【DemoMainArgs.exe】--》【创建快捷方式】\n\n右键点击【DemoMainArgs.exe 快捷方式】--》【属性】--》【快捷方式】--》【目标】，在文本框的最后输入任意参数，\n\n ![image-20230918134408816](http://kai.snblogs.cn/typora/image-20230918134408816.png)\n\n',1,121,407,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(922,'局部类注意事项','### 注意事项\n\n**适用于以下情况：**\n(1) 类型特别大，不宜放在一个文件中实现。\n(2) 一个类型中的一部分代码为自动化工具生成的代码，不宜与我们自己编写的代码混合在一起。\n(3) 需要多人合作编写一个类。\n\n**局部类型的限制**	\n(1) 局部类型只适用于类、接口、结构，不支持委托和枚举。\n(2) 同一个类型的各个部分必须都有修饰符 partial。\n(3) 使用局部类型时，一个类型的各个部分必须位于相同的命名空间中。\n(4) 一个类型的各个部分必须被同时编译。\n\n**局部类型的注意点**\n\n(1) 关键字partial是一个上下文关键字，只有和 class、struct、interface 放在一起时才有关键字的含义。因此partial的引入不会影响现有代码中名称为partial的变量。\n(2) 局部类型的各个部分一般是分开放在几个不同的.cs文件中，但C#编译器允许我们将他们放在同一文件中。\n\n**局部类型的应用特性**\n在局部类型上的特性具有“累加”效应。\n\n```csharp\n[Attribute1, Attribute2(\"Hello\")]\npartial class Class1{}\n\n[Attribute3, Attribute2(\"Exit\")]\npartial class Class1{}\n相当于\n```\n\n```csharp\n[Attribute1, Attribute2(\"Hello\"), Attribute3, Attribute2(\"Exit\")]\nclass Class1 {}\n```\n\n**局部类型上的修饰符**\n\n(1) 一个类型的各个部分上的访问修饰符必须维持一致性。\n(2) 如果一个类型有一个部分使用了abstract修饰符，那么整个类都将被视为抽象类。\n(3) 如果一个类型有一个部分使用了 sealed 修饰符，那么整个类都将被视为密封类。\n(4) 一个类的各个部分不能使用相互矛盾的修饰符，比如不能在一个部分上使用abstract，又在另一个部分上使用sealed。\n\n**局部类型的基类和接口**\n\n(1) 一个类型的各个部分上指定的基类必须一致。某个部分可以不指定基类，但如果指定，则必须相同。\n(2) 局部类型上的接口具有“累加”效应。\n\n```csharp\npartial class Class2: Iinterface1, Iinterface2 {}\npartial class Class2: Iinterface3 {}\npartial class Class2: Iinterface2 {}\n相当于\n```\n\n```csharp\nclass Class2: Iinterface1, Iinterface2, Iinterface3 {}\n```\n\n',1,122,408,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(923,'部分类的使用','#### 部分类的声明\n\n部分类的声明必须使用partial关键字\n\n```csharp\npublic partial class MyClass\n{\n    // class implementation\n}\n```\n\n#### 部分类的使用\n\n部分类可以像普通类一样使用\n\n```csharp\nMyClass myObject = new MyClass();\nmyObject.MyMethod();\n```\n\n#### 代码结构\n\n以下是部分类的示例代码：\n\n```csharp\npartial class MyClass\n{\n    private int myField;\n\n    public void MyMethod()\n    {\n        Console.WriteLine(\"MyMethod called.\");\n    }\n}\n```\n\n在另一个文件中，可以使用相同的类名和partial关键字来声明该类的另一个部分：\n\n```csharp\npartial class MyClass\n{\n    private string myOtherField;\n\n    public void MyOtherMethod()\n    {\n        Console.WriteLine(\"MyOtherMethod called.\");\n    }\n}\n```\n\n这两个部分将组合成一个完整的类。\n\n##### 代码示例\n\n以下是使用部分类的示例代码：\n\n```csharp\nmyObject = new MyClass();\nmyObject.MyMethod();\nmyObject.MyOtherMethod();\n```\n\n输出：\n\n```undefined\nMyMethod called.\nMyOtherMethod called.\n```\n\n#### 结论\n\n部分类是一种有用的技术，可以帮助组织大型类的代码。它允许将类分解为多个文件，使代码更易于维护和理解\n\n',1,122,408,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(924,'变量','[变量](https://en.wikipedia.org/wiki/Variable_(computer_science)) 是数据的“命名存储”。我们可以使用变量来保存商品、访客和其他信息。\n\n在 JavaScript 中创建一个变量，我们需要用到 `let` 关键字。\n\n```js\nlet message;\nmessage = ''Hello''; // 将字符串 ''Hello'' 保存在名为 message 的变量中\nalert(message); // 显示变量内容\n\n//or\nlet message = ''Hello!''; // 定义变量，并且赋值\nalert(message); // Hello!\n```\n\n',6,123,410,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(925,'变量的注意事项','- 一个变量应该只被声明一次\n- 变量名称必须仅包含字母、数字、符号 `$` 和 `_`\n- 首字符必须非数字\n- `let` — 现代的变量声明方式\n- `var` — 老旧的变量声明方式。一般情况下，我们不会再使用它\n- `const`（不变的，不能被改变）\n\n变量是动态类型的，它们可以存储任何值：\n\n```javascript\nlet x = 5;\nx = \"John\";\n```\n\n有 8 种数据类型：\n\n- `number` — 可以是浮点数，也可以是整数，\n- `bigint` — 用于任意长度的整数，\n- `string` — 字符串类型，\n- `boolean` — 逻辑值：`true/false`，\n- `null` — 具有单个值 `null` 的类型，表示“空”或“不存在”，\n- `undefined` — 具有单个值 `undefined` 的类型，表示“未分配（未定义）”，\n- `object` 和 `symbol` — 对于复杂的数据结构和唯一标识符，我们目前还没学习这个类型。\n\n`typeof` 运算符返回值的类型，但有两个例外：\n\n```javascript\ntypeof null == \"object\" // JavaScript 编程语言的设计错误\ntypeof function(){} == \"function\" // 函数被特殊对待\n```\n\n',6,123,410,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(926,'常量','声明一个常数（不变）变量，可以使用 `const` 而非 `let`：\n\n“常量”。它们不能被修改\n\n```js\nconst myBirthday = ''18.04.1982'';\n```\n\n使用大写形式的常量\n\n```js\nconst COLOR_RED = \"#F00\";\nconst COLOR_GREEN = \"#0F0\";\nconst COLOR_BLUE = \"#00F\";\nconst COLOR_ORANGE = \"#FF7F00\";\n\n// ……当我们需要选择一个颜色\nlet color = COLOR_ORANGE;\nalert(color); // #FF7F00\n```\n\n',6,123,241,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(927,'Number','- `Infinity` 代表数学概念中的 [无穷大](https://en.wikipedia.org/wiki/Infinity) ∞。是一个比任何数字都大的特殊值\n\n  ```\n  alert( 1 / 0 ); // Infinity\n  ```\n\n- `NaN` 代表一个计算错误。它是一个不正确的或者一个未定义的数学操作所得到的结\n\n  ```\n  alert( \"not a number\" / 2 ); // NaN，这样的除法是错误的\n  ```\n\n*number* 类型代表整数和浮点数。\n\n数字可以有很多操作，比如，乘法 `*`、除法 `/`、加法 `+`、减法 `-` 等等\n\n```js\nlet n = 123;\nn = 12.345;\n```\n\n',6,124,413,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(928,'BigInt','`BigInt` 类型是最近被添加到 JavaScript 语言中的，用于表示任意长度的整数\n\n可以通过将 `n` 附加到整数字段的末尾来创建 `BigInt` 值。\n\n```javascript\n// 尾部的 \"n\" 表示这是一个 BigInt 类型\nconst bigInt = 1234567890123456789012345678901234567890n;\n```\n\n',6,124,414,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(929,'String','JavaScript 中的字符串必须被括在引号里。\n\n```js\nlet str = \"Hello\";\nlet str2 = ''Single quotes are ok too'';\nlet phrase = `can embed another ${str}`;\n```\n\n',6,124,415,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(930,'String三种包含字符串方式','1. 双引号：`\"Hello\"`.\n2. 单引号：`''Hello''`.\n3. 反引号：``Hello``.\n\n双引号和单引号都是“简单”引用，在 JavaScript 中两者几乎没有什么差别。\n\n反引号是 **功能扩展** 引号。它们允许我们通过将变量和表达式包装在 `${…}` 中，来将它们嵌入到字符串中。例如：\n\n```javascript\nlet name = \"John\";\n\n// 嵌入一个变量\nalert( `Hello, ${name}!` ); // Hello, John!\n\n// 嵌入一个表达式\nalert( `the result is ${1 + 2}` ); // the result is 3\n```\n\n`${…}` 内的表达式会被计算，计算结果会成为字符串的一部分。可以在 `${…}` 内放置任何东西：诸如名为 `name` 的变量，或者诸如 `1 + 2` 的算数表达式，或者其他一些更复杂的。\n\n需要注意的是，这仅仅在反引号内有效，其他引号不允许这种嵌入。\n\n```javascript\nalert( \"the result is ${1 + 2}\" ); // the result is ${1 + 2}（使用双引号则不会计算 ${…} 中的内容）\n```\n\n',6,124,415,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(931,'Boolen','boolean 类型仅包含两个值：`true` 和 `false`。\n\n这种类型通常用于存储表示 yes 或 no 的值：`true` 意味着 “yes，正确”，`false` 意味着 “no，不正确”\n\n```js\nlet nameFieldChecked = true; // yes, name field is checked\nlet ageFieldChecked = false; // no, age field is not checked\n```\n\n可作为比较的结果：\n\n```javascript\nlet isGreater = 4 > 1;\n\nalert( isGreater ); // true（比较的结果是 \"yes\"）\n```\n\n',6,124,417,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(932,'null值','特殊的 `null` 值不属于上述任何一种类型。\n\n它构成了一个独立的类型，只包含 `null` 值\n\n```js\nlet age = null;\n```\n\n',6,124,113,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(933,'undefined值','特殊值 `undefined` 和 `null` 一样自成类型。\n\n`undefined` 的含义是 `未被赋值`。\n\n如果一个变量已被声明，但未被赋值，那么它的值就是 `undefined`：\n\n```javascript\nlet age;\n\nalert(age); // 弹出 \"undefined\"\n```\n\n',6,124,216,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(934,'typeof运算符','`typeof` 运算符返回参数的类型。当我们想要分别处理不同类型值的时候，或者想快速进行数据类型检验时，非常有用。\n\n对 `typeof x` 的调用会以字符串的形式返回数据类型：\n\n```js\ntypeof undefined // \"undefined\"\n\ntypeof 0 // \"number\"\n\ntypeof 10n // \"bigint\"\n\ntypeof true // \"boolean\"\n\ntypeof \"foo\" // \"string\"\n\ntypeof Symbol(\"id\") // \"symbol\"\n```\n\n',6,92,420,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(935,'alert','显示一条信息，并等待用户按下 “OK”\n\n```js\nalert(\"Hello\");\n```\n\n',6,89,421,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(936,'prompt','`prompt` 函数接收两个参数：\n\n```js\nresult = prompt(title, [default]);\n```\n\n浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定/取消按钮。\n\ntitle 显示给用户的文本\n\ndefault 可选的第二个参数，指定 input 框的初始值。\n\n',6,89,422,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(937,'confirm','### \n\n```js\nresult = confirm(question);\n```\n\n`confirm` 函数显示一个带有 `question` 以及确定和取消两个按钮的模态窗口。\n\n点击确定返回 `true`，点击取消返回 `false`。',6,89,423,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(938,'字符串转换','显式地调用 `String(value)` 来将 `value` 转换为字符串类型：\n\n```js\nlet value = true;\nalert(typeof value); // boolean\n\nvalue = String(value); // 现在，值是一个字符串形式的 \"true\"\nalert(typeof value); // string\n```\n\n',6,125,415,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(939,'数字类型转换','在算术函数和表达式中，会自动进行 number 类型转换。\n\n```js\nalert( \"6\" / \"2\" ); // 3, string 类型的值被自动转换成 number 类型后进行计算\n```\n\n使用 `Number(value)` 显式地将这个 `value` 转换为 number 类型\n\n```js\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // 变成 number 类型 123\n\nalert(typeof num); // number\n```\n\n例子：\n\n```javascript\nalert( Number(\"   123   \") ); // 123\nalert( Number(\"123z\") );      // NaN（从字符串“读取”数字，读到 \"z\" 时出现错误）\nalert( Number(true) );        // 1\nalert( Number(false) );       // 0\n```\n\n',6,125,413,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(940,'布尔型转换','转换规则如下：\n\n- 直观上为“空”的值（如 `0`、空字符串、`null`、`undefined` 和 `NaN`）将变为 `false`。\n- 其他值变成 `true`。\n\n```js\nalert( Boolean(1) ); // true\nalert( Boolean(0) ); // false\n\nalert( Boolean(\"hello\") ); // true\nalert( Boolean(\"\") ); // false\n```\n\n\n\n**包含 0 的字符串** `\"0\"` **是** `true`\n\n```js\nalert( Boolean(\"0\") ); // true\nalert( Boolean(\" \") ); // 空格，也是 true（任何非空字符串都是 true）\n```\n\n',6,125,426,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(941,'数学运算','- 加法 `+`,\n- 减法 `-`,\n- 乘法 `*`,\n- 除法 `/`,\n- 取余 `%`,\n- 求幂 `**`.\n\n#### 取余%\n\n`a % b` 的结果是 `a` 整除 `b` 的 余数\n\n```js\nalert( 5 % 2 ); // 1，5 除以 2 的余数\nalert( 8 % 3 ); // 2，8 除以 3 的余数\n```\n\n#### 求幂 **\n\n求幂运算 `a ** b` 将 `a` 提升至 `a` 的 `b` 次幂。\n\n在数学运算中我们将其表示为 ab。\n\n```js\nalert( 2 ** 2 ); // 2² = 4\nalert( 2 ** 3 ); // 2³ = 8\nalert( 2 ** 4 ); // 2⁴ = 16\n```\n\n平方根是指数为 ½ 的幂运算：\n\n```js\nalert( 4 ** (1/2) ); // 2（1/2 次方与平方根相同)\nalert( 8 ** (1/3) ); // 2（1/3 次方与立方根相同)\n```\n\n',6,92,427,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(942,'二元运算符+连接字符串','通常，加号 `+` 用于求和。\n\n但是如果加号 `+` 被应用于字符串，它将合并（连接）\n\n```js\nlet s = \"my\" + \"string\";\nalert(s); // mystring\n```\n\n例子：\n\n```javascript\nalert(2 + 2 + ''1'' ); // \"41\"，不是 \"221\"\n```\n\n在这里，运算符是按顺序工作。第一个 `+` 将两个数字相加，所以返回 `4`，然后下一个 `+` 将字符串 `1` 加入其中，所以就是 `4 + ''1'' = ''41''`。\n\n```javascript\nalert(''1'' + 2 + 2); // \"122\"，不是 \"14\"\n```\n\n这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。`2` 被与 `''1''` 连接到了一起，也就是像 `''1'' + 2 = \"12\"` 然后 `\"12\" + 2 = \"122\"` 这样。',6,92,428,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(943,'数字转化，一元运算符 +','```js\n// 转化非数字\nalert( +true ); // 1\nalert( +\"\" );   // 0\n```\n\n效果和 `Number(...)` 相同，但是更加简短\n\n如果想把它们当做数字对待，需要转化它们，然后再求和：\n\n```javascript\nlet apples = \"2\";\nlet oranges = \"3\";\n\n// 在二元运算符加号起作用之前，所有的值都被转化为了数字\nalert( +apples + +oranges ); // 5\n\n// 更长的写法\n// alert( Number(apples) + Number(oranges) ); // 5\n```\n\n',6,92,430,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(944,'运算符优先级','在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。\n\n这是一个摘抄自 Mozilla 的 [优先级表](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：\n\n| 优先级 | 名称     | 符号 |\n| :----- | :------- | :--- |\n| …      | …        | …    |\n| 15     | 一元加号 | `+`  |\n| 15     | 一元负号 | `-`  |\n| 14     | 求幂     | `**` |\n| 13     | 乘号     | `*`  |\n| 13     | 除号     | `/`  |\n| 12     | 加号     | `+`  |\n| 12     | 减号     | `-`  |\n| …      | …        | …    |\n| 2      | 赋值符   | `=`  |\n| …      | …        | …    |\n\n',6,92,431,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(945,' 赋值运算符','```js\nlet x = 2 * 2 + 1;\n\nalert( x ); // 5\n```\n\n`=` 是一个运算符 , 在 JavaScript 中，所有运算符都会返回一个值。这对于 `+` 和 `-` 来说是显而易见的，但对于 `=` 来说也是如此。\n\n语句 `x = value` 将值 `value` 写入 `x` **然后返回 value**。\n\n#### 链式赋值\n\n```js\nlet a, b, c;\n\na = b = c = 2 + 2;\n\nalert( a ); // 4\nalert( b ); // 4\nalert( c ); // 4\n```\n\n链式赋值从右到左进行计算。首先，对最右边的表达式 `2 + 2` 求值，然后将其赋给左边的变量：`c`、`b` 和 `a`。最后，所有的变量共享一个值。\n\n同样，出于可读性，最好将这种代码分成几行：\n\n```js\nc = 2 + 2;\nb = c;\na = c;\n```\n\n#### 原地修改\n\n如：\n\n```javascript\nlet n = 2;\nn = n + 5;\nn = n * 2;\n```\n\n可以用运算符 `+=` 和 `*=` 来缩写这种表示。\n\n```javascript\nlet n = 2;\nn += 5; // 现在 n = 7（等同于 n = n + 5）\nn *= 2; // 现在 n = 14（等同于 n = n * 2）\n\nalert( n ); // 14\n```\n\n所有算术和位运算符都有简短的“修改并赋值”运算符：`/=` 和 `-=` 等。\n\n这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：\n\n```javascript\nlet n = 2;\n\nn *= 3 + 5;\n\nalert( n ); // 16 （右边部分先被计算，等同于 n *= 8）\n```\n\n\n\n',6,92,432,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(946,'自增自减','- **自增** `++` 将变量与 1 相加：\n\n  ```javascript\n  let counter = 2;\n  counter++;      // 和 counter = counter + 1 效果一样，但是更简洁\n  alert( counter ); // 3\n  ```\n\n- **自减** `--` 将变量与 1 相减：\n\n  ```javascript\n  let counter = 2;\n  counter--;      // 和 counter = counter - 1 效果一样，但是更简洁\n  alert( counter ); // 1\n  ```\n\n自增/自减只能应用于变量。试一下，将其应用于数值（比如 `5++`）则会报错。\n\n- 如果想要对变量进行自增操作，**并且** 需要立刻使用自增后的值，那么我们需要使用前置形式：\n\n  ```javascript\n  let counter = 0;\n  alert( ++counter ); // 1\n  ```\n\n- 如果想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：\n\n  ```javascript\n  let counter = 0;\n  alert( counter++ ); // 0\n  ```\n\n',6,92,433,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(947,' 值的比较','- 大于 / 小于：`a > b`，`a < b`。\n- 大于等于 / 小于等于：`a >= b`，`a <= b`。\n- 检查两个值的相等：`a == b`，请注意双等号 `==` 表示相等性检查，而单等号 `a = b` 表示赋值。\n- 检查两个值不相等：不相等在数学中的符号是 `≠`，但在 JavaScript 中写成 `a != b`。',6,92,434,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(948,'比较结果为Boolean类型','所有比较运算符均返回布尔值：\n\n- `true` —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。\n- `false` —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。\n\n```js\nalert( 2 > 1 );  // true（正确）\nalert( 2 == 1 ); // false（错误）\nalert( 2 != 1 ); // true（正确）\n```\n\n比较的结果可以被赋值给任意变量：\n\n```javascript\nlet result = 5 > 4; // 把比较的结果赋值给 result\nalert( result ); // true\n```\n\n',6,92,426,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(949,'字符串比较','```js\nalert( ''Z'' > ''A'' ); // true\nalert( ''Glow'' > ''Glee'' ); // true\nalert( ''Bee'' > ''Be'' ); // tru\n```\n\n',6,92,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(950,'不同类型的比较','当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。\n\n例如：\n\n```javascript\nalert( ''2'' > 1 ); // true，字符串 ''2'' 会被转化为数字 2\nalert( ''01'' == 1 ); // true，字符串 ''01'' 会被转化为数字 1\n```\n\n对于布尔类型值，`true` 会被转化为 `1`、`false` 转化为 `0`。\n\n例如：\n\n```javascript\nalert( true == 1 ); // true\nalert( false == 0 ); // true\n```\n\n',6,92,175,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(951,'严格相等','普通的相等性检查 `==` 存在一个问题，它不能区分出 `0` 和 `false`：\n\n```javascript\nalert( 0 == false ); // true\n```\n\n也同样无法区分空字符串和 `false`：\n\n```javascript\nalert( '''' == false ); // true\n```\n\n这是因为在比较不同类型的值时，处于相等判断符号 `==` 两侧的值会先被转化为数字。空字符串和 `false` 也是如此，转化后它们都为数字 0。\n\n如果我们需要区分 `0` 和 `false`，该怎么办？\n\n**严格相等运算符 `===` 在进行比较时不会做任何的类型转换。**\n\n换句话说，如果 `a` 和 `b` 属于不同的数据类型，那么 `a === b` 不会做任何的类型转换而立刻返回 `false`。\n\n让我们试试：\n\n```javascript\nalert( 0 === false ); // false，因为被比较值的数据类型不同\n```\n\n同样的，与“不相等”符号 `!=` 类似，“严格不相等”表示为 `!==`。\n\n严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。',6,92,438,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(952,'||或','两个竖线符号表示“或”运算符：\n\n- 从左到右依次计算操作数。\n- 处理每一个操作数时，都将其转化为布尔值。如果结果是 `true`，就停止计算，返回这个操作数的初始值。\n- 如果所有的操作数都被计算过（也就是，转换结果都是 `false`），则返回最后一个操作数。\n\n四种可能的逻辑组合：\n\n```javascript\nalert( true || true );   // true\nalert( false || true );  // true\nalert( true || false );  // true\nalert( false || false ); // false\n```\n\n除了两个操作数都是 `false` 的情况，结果都是 `true`。\n\n如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。\n\n例如，数字 `1` 被作为 `true` 处理，数字 `0` 则被作为 `false`：\n\n```javascript\nif (1 || 0) { // 工作原理相当于 if( true || false )\n  alert( ''truthy!'' );\n}\n```\n\n大多数情况下，逻辑或 `||` 会被用在 `if` 语句中，用来测试是否有 **任何** 给定的条件为 `true`。\n\n例如：\n\n```javascript\nlet hour = 9;\n\nif (hour < 10 || hour > 18) {\n  alert( ''The office is closed.'' );\n}\n```\n\n我们可以传入更多的条件：\n\n```javascript\nlet hour = 12;\nlet isWeekend = true;\n\nif (hour < 10 || hour > 18 || isWeekend) {\n  alert( ''The office is closed.'' ); // 是周末\n}\n```\n\n',6,92,439,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(953,'&&与','两个 & 符号表示 `&&` 与运算符：\n\n- 从左到右依次计算操作数。\n- 在处理每一个操作数时，都将其转化为布尔值。如果结果是 `false`，就停止计算，并返回这个操作数的初始值。\n- 如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。\n\n当两个操作数都是真值时，与运算返回 `true`，否则返回 `false`：\n\n```javascript\nalert( true && true );   // true\nalert( false && true );  // false\nalert( true && false );  // false\nalert( false && false ); // false\n```\n\n',6,92,1,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(954,'!非','感叹符号 `!` 表示布尔非运算符。\n\n语法相当简单：\n\n```javascript\nresult = !value;\n```\n\n1. 将操作数转化为布尔类型：`true/false`。\n2. 返回相反的值。\n\n```js\nalert( !true ); // false\nalert( !0 ); // true\n```\n\n非运算符 `!` 的优先级在所有逻辑运算符里面最高，所以它总是在 `&&` 和 `||` 之前执行。',6,92,441,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(955,'if语句','`if(...)` 语句计算括号里的条件表达式，如果计算结果是 `true`，就会执行对应的代码块。\n\n```js\nlet year = prompt(''In which year was ECMAScript-2015 specification published?'', '''');\n\nif (year == 2015) alert( ''You are right!'' );\n```\n\n如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内：\n\n```javascript\nif (year == 2015) {\n  alert( \"That''s correct!\" );\n  alert( \"You''re so smart!\" );\n}\n```\n\n建议每次使用 if 语句都用大括号 `{}` 来包装代码块，即使只有一条语句。这样可以提高代码可读性。',6,91,228,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(956,'布尔转换','`if (…)` 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。\n\n下面这个条件下的代码永远不会执行：\n\n```javascript\nif (0) { // 0 是假值（falsy）\n  ...\n}\n```\n\n……但下面的条件 —— 始终有效：\n\n```javascript\nif (1) { // 1 是真值（truthy）\n  ...\n}\n```\n\n可以将预先计算的布尔值传入 `if` 语句，像这样：\n\n```javascript\nlet cond = (year == 2015); // 相等运算符的结果是 true 或 false\n\nif (cond) {\n  ...\n}\n```\n\n',6,91,443,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(957,'else语句','`if` 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。\n\n```js\nlet year = prompt(''In which year was ECMAScript-2015 specification published?'', '''');\n\nif (year == 2015) {\n  alert( ''You guessed it right!'' );\n} else {\n  alert( ''How can you be so wrong?'' ); // 2015 以外的任何值\n}\n```\n\n',6,91,444,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(958,'else if语句','有时我们需要测试一个条件的几个变体。我们可以通过使用 `else if` 子句实现。\n\n```js\nlet year = prompt(''In which year was ECMAScript-2015 specification published?'', '''');\n\nif (year < 2015) {\n  alert( ''Too early...'' );\n} else if (year > 2015) {\n  alert( ''Too late'' );\n} else {\n  alert( ''Exactly!'' );\n}\n```\n\nJavaScript 先检查 `year < 2015`。如果条件不符合，就会转到下一个条件 `year > 2015`。如果这个条件也不符合，则会显示最后一个 `alert`。\n\n可以有更多的 `else if` 块。结尾的 `else` 是可选的。',6,91,445,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(959,'条件运算符?','有时我们需要根据一个条件去赋值一个变量。\n\n所谓的“条件”或“问号”运算符让我们可以更简短地达到目的。\n\n这个运算符通过问号 `?` 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。\n\n```javascript\nlet result = condition ? value1 : value2;\n```\n\n计算条件结果，如果结果为真，则返回 `value1`，否则返回 `value2`。\n\n',6,92,433,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(960,'多个?','使用一系列问号 `?` 运算符可以返回一个取决于多个条件的值。\n\n```javascript\nlet age = prompt(''age?'', 18);\n\nlet message = (age < 3) ? ''Hi, baby!'' :\n  (age < 18) ? ''Hello!'' :\n  (age < 100) ? ''Greetings!'' :\n  ''What an unusual age!'';\n\nalert( message );\n```\n\n可能很难一下子看出发生了什么。但经过仔细观察，我们可以看到它只是一个普通的检查序列。\n\n1. 第一个问号检查 `age < 3`。\n2. 如果为真 — 返回 `''Hi, baby!''`。否则，会继续执行冒号 `\":\"` 后的表达式，检查 `age < 18`。\n3. 如果为真 — 返回 `''Hello!''`。否则，会继续执行下一个冒号 `\":\"` 后的表达式，检查 `age < 100`。\n4. 如果为真 — 返回 `''Greetings!''`。否则，会继续执行最后一个冒号 `\":\"` 后面的表达式，返回 `''What an unusual age!''`。',6,91,433,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(961,'switch语句','`switch` 语句可以替代多个 `if` 判断。\n\n`switch` 语句有至少一个 `case` 代码块和一个可选的 `default` 代码块。\n\n```js\nswitch(x) {\n  case ''value1'':  // if (x === ''value1'')\n    ...\n    [break]\n\n  case ''value2'':  // if (x === ''value2'')\n    ...\n    [break]\n\n  default:\n    ...\n    [break]\n}\n```\n\n- 比较 `x` 值与第一个 `case`（也就是 `value1`）是否严格相等，然后比较第二个 `case`（`value2`）以此类推。\n- 如果相等，`switch` 语句就执行相应 `case` 下的代码块，直到遇到最靠近的 `break` 语句（或者直到 `switch` 语句末尾）。\n- 如果没有符合的 case，则执行 `default` 代码块（如果 `default` 存在）。\n\n#### case分组\n\n共享同一段代码的几个 `case` 分支可以被分为一组\n\n```js\n  case 3: // (*) 下面这两个 case 被分在一组\n  case 5:\n    alert(''Wrong!'');\n    alert(\"Why don''t you take a math class?\");\n    break;\n```\n\n',6,91,221,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(962,'while循环','当 `condition` 为真时，执行循环体的 `code`。\n\n```\nwhile (condition) {\n  // 代码\n  // 所谓的“循环体”\n}\n```\n\n以下将循环输出当 `i < 3` 时的 `i` 值：\n\n```javascript\nlet i = 0;\nwhile (i < 3) { // 依次显示 0、1 和 2\n  alert( i );\n  i++;\n}\n```\n\n循环体的单次执行叫作 **一次迭代**。上面示例中的循环进行了三次迭代。\n\n#### 单行循环体不需要大括号\n\n```js\nlet i = 3;\nwhile (i) alert(i--);\n```\n\n',6,90,449,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(963,'do...while循环','使用 `do..while` 语法可以将条件检查移至循环体 \n\n```js\ndo {\n  // 循环体\n} while (condition);\n```\n\n循环首先执行循环体，然后检查条件，当条件为真时，重复执行循环体。\n\n```js\nlet i = 0;\ndo {\n  alert( i );\n  i++;\n} while (i < 3);\n```\n\n这种形式的语法很少使用，除非你希望不管条件是否为真，循环体 **至少执行一次**。通常我们更倾向于使用另一个形式：`while(…) {…}`。',6,90,450,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(964,'for循环','`for` 循环更加复杂，但它是最常使用的循环形式。\n\n| begin          | `let i = 0` | 进入循环时执行一次。                             |\n| -------------- | ----------- | ------------------------------------------------ |\n| condition      | `i < 3`     | 在每次循环迭代之前检查，如果为 false，停止循环。 |\n| body（循环体） | `alert(i)`  | 条件为真时，重复运行。                           |\n| step           | `i++`       | 在每次循环体迭代后执行。                         |\n\n```js\nfor (begin; condition; step) {\n  // ……循环体……\n}\n```\n\n循环从 `i` 等于 `0` 到 `3`（但不包括 `3`）运行 `alert(i)`：\n\n```js\nfor (let i = 0; i < 3; i++) { // 结果为 0、1、2\n  alert(i);\n}\n```\n\n#### 省略语句执行\n\n`for` 循环的任何语句段都可以被省略。\n\n如果我们在循环开始时不需要做任何事，我们就可以省略 `begin` 语句段。\n\n```js\nlet i = 0; // 我们已经声明了 i 并对它进行了赋值\n\nfor (; i < 3; i++) { // 不再需要 \"begin\" 语句段\n  alert( i ); // 0, 1, 2\n}\n```\n\n也可以移除 `step` 语句段：\n\n```javascript\nlet i = 0;\n\nfor (; i < 3;) {\n  alert( i++ );\n}\n```\n\n可以删除所有内容，从而创建一个无限循环：\n\n```javascript\nfor (;;) {\n  // 无限循环\n}\n```\n\n请注意 `for` 的两个 `;` 必须存在，否则会出现语法错误。',6,90,220,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(965,'跳出循环','### 跳出循环\n\n通常条件为假时，循环会终止。\n\n但我们随时都可以使用 `break` 指令强制退出。\n\n```js\nlet sum = 0;\n\nwhile (true) {\n\n  let value = +prompt(\"Enter a number\", '''');\n\n  if (!value) break; // (*)\n\n  sum += value;\n\n}\nalert( ''Sum: '' + sum );\n```\n\n',6,90,452,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(966,'继续下一次循环','`continue` 指令是 `break` 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。\n\n如果我们完成了当前的迭代，并且希望继续执行下一次迭代，我们就可以使用它。\n\n```js\nfor (let i = 0; i < 10; i++) {\n\n  //如果为真，跳过循环体的剩余部分。\n  if (i % 2 == 0) continue;\n\n  alert(i); // 1，然后 3，5，7，9\n}\n```\n\n',6,90,453,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(967,'跳出多个循环','需要一次从多层嵌套的循环中跳出来\n\n**标签** 是在循环之前带有冒号的标识符：\n\n```javascript\nlabelName: for (...) {\n  ...\n}\n```\n\n`break <labelName>` 语句跳出循环至标签处：\n\n```javascript\nouter: for (let i = 0; i < 3; i++) {\n\n  for (let j = 0; j < 3; j++) {\n\n    let input = prompt(`Value at coords (${i},${j})`, '''');\n\n    // 如果是空字符串或被取消，则中断并跳出这两个循环。\n    if (!input) break outer; // (*)\n\n    // 用得到的值做些事……\n  }\n}\n\nalert(''Done!'');\n```\n\n`break outer` 向上寻找名为 `outer` 的标签并跳出当前循环。\n\n因此，控制权直接从 `(*)` 转至 `alert(''Done!'')`。\n\n',6,90,454,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(968,'局部变量','在函数中声明的变量只在该函数内部可见。\n\n```js\nfunction showMessage() {\n  let message = \"Hello, I''m JavaScript!\"; // 局部变量\n\n  alert( message );\n}\n\nshowMessage(); // Hello, I''m JavaScript!\n\nalert( message ); // <-- 错误！变量是函数的局部变量\n```\n\n',6,89,96,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(969,'外部变量','```js\nlet userName = ''John'';\n\nfunction showMessage() {\n  let message = ''Hello, '' + userName;\n  alert(message);\n}\n\nshowMessage(); // Hello, John\n```\n\n',6,89,1,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(970,'参数','通过参数将任意数据传递给函数。\n\n在如下示例中，函数有两个参数：`from` 和 `text`。\n\n```js\nfunction showMessage(from, text) { // 参数：from 和 text\n  alert(from + '': '' + text);\n}\n\nshowMessage(''Ann'', ''Hello!''); // Ann: Hello! (*)\nshowMessage(''Ann'', \"What''s up?\"); // Ann: What''s up? (**)\n```\n\n',6,89,96,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(971,'函数表达式','它允许我们在任何表达式的中间创建一个新函数。\n\n例如：\n\n```javascript\nlet sayHi = function() {\n  alert( \"Hello\" );\n};\n```\n\n',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(972,'箭头函数','\n\n```js\nlet sum = (a, b) => a + b;\n\n/* 这个箭头函数是下面这个函数的更短的版本：\n\nlet sum = function(a, b) {\n  return a + b;\n};\n*/\n\nalert( sum(1, 2) ); // 3\n```\n\n可以看到 `(a, b) => a + b` 表示一个函数接受两个名为 `a` 和 `b` 的参数。在执行时，它将对表达式 `a + b` 求值，并返回计算结果。\n\n- 如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。\n\n  例如：\n\n  ```javascript\n  let double = n => n * 2;\n  // 差不多等同于：let double = function(n) { return n * 2 }\n  \n  alert( double(3) ); // 6\n  ```\n\n- 如果没有参数，括号则是空的（但括号必须保留）：\n\n  ```javascript\n  let sayHi = () => alert(\"Hello!\");\n  \n  sayHi();\n  ```\n\n',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(973,'多行的箭头函数','```js\nlet sum = (a, b) => {  // 花括号表示开始一个多行函数\n  let result = a + b;\n  return result; // 如果我们使用了花括号，那么我们需要一个显式的 “return”\n};\n\nalert( sum(1, 2) ); // 3\n```\n\n',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(974,'debugger','我们也可以使用 `debugger` 命令来暂停代码，像这样：\n\n```javascript\nfunction hello(name) {\n  let phrase = `Hello, ${name}!`;\n\n  debugger;  // <-- 调试器会在这停止\n\n  say(phrase);\n}\n```\n\n这样的命令只有在开发者工具打开时才有效，否则浏览器会忽略它',6,126,1,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(975,'日志记录','要输出一些东西到控制台上？`console.log` 函数可以满足你。\n\n例如：将从 `0` 到 `4` 的值输出到控制台上：\n\n```javascript\n// 打开控制台来查看\nfor (let i = 0; i < 5; i++) {\n  console.log(\"value\", i);\n}\n```\n\n普通用户看不到这个输出，它是在控制台里面的。要想看到它 —— 要么打开开发者工具中的 Console（控制台）选项卡，要么在一个其他的选项卡中按下 Esc：这会在下方打开一个控制台。\n\n如果我们在代码中有足够的日志记录，那么我们可以从记录中看到刚刚发生了什么，而不需要借助调试器。',6,126,460,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(976,'对象','对象则用来存储键值对和更复杂的实体。在 JavaScript 中，对象几乎渗透到了这门编程语言的方方面面。\n\n通过使用带有可选 **属性列表** 的花括号 `{…}` 来创建对象。一个属性就是一个键值对（“key: value”），其中键（`key`）是一个字符串（也叫做属性名），值（`value`）可以是任何值。\n\n把对象想象成一个带有签名文件的文件柜。每一条数据都基于键（`key`）存储在文件中。这样可以很容易根据文件名（也就是“键”）查找文件或添加/删除文件了。\n\n ![image-20230921122342242](http://kai.snblogs.cn/typora/image-20230921122342242.png)\n\n可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：\n\n```javascript\nlet user = new Object(); // “构造函数” 的语法\nlet user = {};  // “字面量” 的语法\n```\n\n用花括号。这种方式我们叫做 **字面量**。',6,87,73,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(977,'对象的文本和属性','创建对象的时候，立即将一些属性以键值对的形式放到 `{...}` 中。\n\n```javascript\nlet user = {     // 一个对象\n  name: \"John\",  // 键 \"name\"，值 \"John\"\n  age: 30        // 键 \"age\"，值 30\n};\n```\n\n属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 `\":\"` 的前面，值在冒号的右边。\n\n在 `user` 对象中，有两个属性：\n\n1. 第一个的键是 `\"name\"`，值是 `\"John\"`。\n2. 第二个的键是 `\"age\"`，值是 `30`。',6,87,73,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(978,'多词属性','```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  \"likes birds\": true  // 多词属性名必须加引号\n};\n```\n\n',6,87,463,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(979,'对象中的方括号','使用方括号，可用于任何字符串：\n\n```javascript\nlet user = {};\n\n// 设置\nuser[\"likes birds\"] = true;\n\n// 读取\nalert(user[\"likes birds\"]); // true\n\n// 删除\ndelete user[\"likes birds\"];\n```\n\n#### 根据输入获取值\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet key = prompt(\"What do you want to know about the user?\", \"name\");\n\n// 访问变量\nalert( user[key] ); // John（如果输入 \"name\"）\n```\n\n',6,87,464,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(980,'对象中使用for..in循环','```js\nfor (key in object) {\n  // 对此对象属性中的每个键执行的代码\n}\n```\n\n列出 `user` 所有的属性\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30,\n  isAdmin: true\n};\n\nfor (let key in user) {\n  // keys\n  alert( key );  // name, age, isAdmin\n  // 属性键的值\n  alert( user[key] ); // John, 30, true\n}\n```\n\n',6,87,465,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(981,'对象结构复制','```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet clone = {}; // 新的空对象\n\n// 将 user 中所有的属性拷贝到其中\nfor (let key in user) {\n  clone[key] = user[key];\n}\n\n// 现在 clone 是带有相同内容的完全独立的对象\nclone.name = \"Pete\"; // 改变了其中的数据\n\nalert( user.name ); // 原来的对象中的 name 属性依然是 John\n```\n\n',1,87,466,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(982,'使用Object.assign复制对象','```javascript\nObject.assign(dest, [src1, src2, src3...])\n```\n\n- 第一个参数 `dest` 是指目标对象。\n- 更后面的参数 `src1, ..., srcN`（可按需传递多个参数）是源对象。\n- 该方法将所有源对象的属性拷贝到目标对象 `dest` 中。换句话说，从第二个开始的所有参数的属性都被拷贝到第一个参数的对象中。\n- 调用结果返回 `dest`。\n\n例如，我们可以用它来合并多个对象：\n\n```javascript\nlet user = { name: \"John\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中\nObject.assign(user, permissions1, permissions2);\n\n// 现在 user = { name: \"John\", canView: true, canEdit: true }\n```\n\n如果被拷贝的属性的属性名已经存在，那么它会被覆盖\n\n也可以用 `Object.assign` 代替 `for..in` 循环来进行简单克隆\n\n```js\nlet user = {\n  name: \"John\",\n  age: 30\n};\n\nlet clone = Object.assign({}, user);\n```\n\n将 `user` 中的所有属性拷贝到了一个空对象中，并返回这个新的对象',6,87,466,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(983,'对象方法','```js\nlet user = {\n  // ...\n};\n\n// 首先，声明函数\nfunction sayHi() {\n  alert(\"Hello!\");\n}\n\n// 然后将其作为一个方法添加\nuser.sayHi = sayHi;\n\nuser.sayHi(); // Hello!\n```\n\n',6,87,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(984,'可选链','如 `value?.prop`：\n\n- 如果 `value` 存在，则结果与 `value.prop` 相同，\n- 否则（当 `value` 为 `undefined/null` 时）则返回 `undefined`。\n\n下面这是一种使用 `?.` 安全地访问 `user.address.street` 的方式：\n\n```javascript\nlet user = {}; // user 没有 address 属性\n\nalert( user?.address?.street ); // undefined（不报错）\n```\n\n',6,87,73,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(985,'symbol类型','根据规范，只有两种原始类型可以用作对象属性键：\n\n- 字符串类型\n- symbol 类型\n\n“symbol” 值表示唯一的标识符。\n\n```js\n// id 是描述为 \"id\" 的 symbol\nlet id = Symbol(\"id\");\n```\n\nsymbol 保证是唯一的。即使创建了许多具有相同描述的 symbol，它们的值也是不同。\n\n有两个描述相同的 symbol —— 它们不相等：\n\n```javascript\nlet id1 = Symbol(\"id\");\nlet id2 = Symbol(\"id\");\n\nalert(id1 == id2); // false\n```\n\n',6,87,470,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(986,'对象字面量中使用symbol','在对象字面量 `{...}` 中使用 symbol，则需要使用方括号把它括起来。\n\n就像这样：\n\n```javascript\nlet id = Symbol(\"id\");\n\nlet user = {\n  name: \"John\",\n  [id]: 123 // 而不是 \"id\"：123\n};\n```\n\n这是因为我们需要变量 `id` 的值作为键，而不是字符串 “id”。',6,87,470,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(987,'全局symbol','应用程序的不同部分想要访问的 symbol `\"id\"` 指的是完全相同的属性\n\n```js\n// 从全局注册表中读取\nlet id = Symbol.for(\"id\"); // 如果该 symbol 不存在，则创建它\n\n// 再次读取（可能是在代码中的另一个位置）\nlet idAgain = Symbol.for(\"id\");\n\n// 相同的 symbol\nalert( id === idAgain ); // true\n```\n\n通过全局 symbol 返回一个名字\n\n```js\n// 通过 name 获取 symbol\nlet sym = Symbol.for(\"name\");\nlet sym2 = Symbol.for(\"id\");\n\n// 通过 symbol 获取 name\nalert( Symbol.keyFor(sym) ); // name\nalert( Symbol.keyFor(sym2) ); // id\n```\n\n',6,87,470,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(988,'编写数字的更多方法','#### 编写数字的更多方法\n\n需要表示 10 亿。显然，我们可以这样写：\n\n```javascript\nlet billion = 1000000000;\n```\n\n我们也可以使用下划线 `_` 作为分隔符：\n\n```javascript\nlet billion = 1_000_000_000;\n```\n\n这里的下划线 `_` 扮演了“[语法糖](https://en.wikipedia.org/wiki/Syntactic_sugar)”的角色，使得数字具有更强的可读性。JavaScript 引擎会直接忽略数字之间的 `_`，所以 上面两个例子其实是一样的。',6,124,473,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(989,'缩短数字','通过在数字后面附加字母 `\"e\"` 并指定零的个数来缩短数字\n\n```js\nlet billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0\n\nalert( 7.3e9 );  // 73 亿（与 7300000000 和 7_300_000_000 相同）\n```\n\n`e` 把数字乘以 `1` 后面跟着给定数量的 0 的数字。\n\n```javascript\n1e3 === 1 * 1000; // e3 表示 *1000\n1.23e6 === 1.23 * 1000000; // e6 表示 *1000000\n```\n\n',6,124,473,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(990,'toString(base)转换','```javascript\nlet num = 255;\n\nalert( num.toString(16) );  // ff\nalert( num.toString(2) );   // 11111111\n```\n\n`base` 的范围可以从 `2` 到 `36`。默认情况下是 `10`。\n\n常见的用例如下：\n\n- **base=16** 用于十六进制颜色，字符编码等，数字可以是 `0..9` 或 `A..F`。\n\n- **base=2** 主要用于调试按位操作，数字可以是 `0` 或 `1`。\n\n- **base=36** 是最大进制，数字可以是 `0..9` 或 `A..Z`。所有拉丁字母都被用于了表示数字。对于 `36` 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 `36` 的数字系统表示：\n\n  ```javascript\n  alert( 123456..toString(36) ); // 2n9c\n  ```\n\n',6,124,473,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(991,'parseInt/parseFloat','经常会有带有单位的值，例如 CSS 中的 `\"100px\"` 或 `\"12pt\"`。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 `\"19€\"`，并希望从中提取出一个数值\n\n它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 `parseInt` 返回一个整数，而 `parseFloat` 返回一个浮点数：\n\n```js\nalert( parseInt(''100px'') ); // 100\nalert( parseFloat(''12.5em'') ); // 12.5\n\nalert( parseInt(''12.3'') ); // 12，只有整数部分被返回了\nalert( parseFloat(''12.3.4'') ); // 12.3，在第二个点出停止了读取\n```\n\n```js\nalert( parseInt(''a123'') ); // NaN，第一个符号停止了读取\n```\n\n',6,124,473,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(992,'使用parseInt解析进制数字','可以解析十六进制数字、二进制数字等的字符串：\n\n```js\nalert( parseInt(''0xff'', 16) ); // 255\nalert( parseInt(''ff'', 16) ); // 255，没有 0x 仍然有效\n\nalert( parseInt(''2n9c'', 36) ); // 123456\n```\n\n',6,124,473,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(993,'使用math返回从0到1的随机数','```js\nalert( Math.random() ); // 0.1234567894322\nalert( Math.random() ); // 0.5435252343232\nalert( Math.random() ); // ... (任何随机数)\n```\n\n',6,124,478,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(994,'使用math返回最大和最小值','```csharp\nalert( Math.max(3, 5, -10, 0, 1) ); // 5\nalert( Math.min(1, 2) ); // 1\n```\n\n',6,124,478,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(995,'特殊字符','换行符写作 `\\n`，用来表示换行：\n\n```js\nlet guestList = \"Guests:\\n * John\\n * Pete\\n * Mary\";\n\nalert(guestList); // 一个多行的客人列表\n```\n\n所有的特殊字符都以反斜杠字符 `\\` 开始。它也被称为“转义字符\n\n| 字符                                    | 描述                                                         |\n| :-------------------------------------- | :----------------------------------------------------------- |\n| `\\n`                                    | 换行                                                         |\n| `\\r`                                    | 在 Windows 文本文件中，两个字符 `\\r\\n` 的组合代表一个换行。而在非 Windows 操作系统上，它就是 `\\n`。这是历史原因造成的，大多数的 Windows 软件也理解 `\\n`。 |\n| `\\''`, `\\\"`                              | 引号                                                         |\n| `\\\\`                                    | 反斜线                                                       |\n| `\\t`                                    | 制表符                                                       |\n| `\\b`, `\\f`, `\\v`                        | 退格，换页，垂直标签 —— 为了兼容性，现在已经不使用了。       |\n| `\\xXX`                                  | 具有给定十六进制 Unicode `XX` 的 Unicode 字符，例如：`''\\x7A''` 和 `''z''` 相同。 |\n| `\\uXXXX`                                | 以 UTF-16 编码的十六进制代码 `XXXX` 的 Unicode 字符，例如 `\\u00A9` —— 是版权符号 `©` 的 Unicode。它必须正好是 4 个十六进制数字。 |\n| `\\u{X…XXXXXX}`（1 到 6 个十六进制字符） | 具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。 |',6,124,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(996,'字符串长度','`length` 属性表示字符串长度：\n\n```javascript\nalert( `My\\n`.length ); // 3\n```\n\n注意 `\\n` 是一个单独的“特殊”字符，所以长度确实是 `3`。',1,124,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(997,'访问字符','使用方括号 `[pos]` 或者调用 [str.charAt(pos)] 方法。第一个字符从零位置开始：\n\n```js\nlet str = `Hello`;\n\n// 第一个字符\nalert( str[0] ); // H\nalert( str.charAt(0) ); // H\n\n// 最后一个字符\nalert( str[str.length - 1] ); // o\n```\n\n也可以使用 `for..of` 遍历字符：\n\n```javascript\nfor (let char of \"Hello\") {\n  alert(char); // H,e,l,l,o（char 变为 \"H\"，然后是 \"e\"，然后是 \"l\" 等）\n}\n```\n\n',6,124,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(998,'改变字符大小写','```javascript\nalert( ''Interface''.toUpperCase() ); // INTERFACE\nalert( ''Interface''.toLowerCase() ); // interface\n```\n\n或者我们想要使一个字符变成小写：\n\n```javascript\nalert( ''Interface''[0].toLowerCase() ); // ''i''\n```\n\n',6,124,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(999,'使用indexOf查找字符','```js\nlet str = ''Widget with id'';\n\nalert( str.indexOf(''Widget'') ); // 0，因为 ''Widget'' 一开始就被找到\nalert( str.indexOf(''widget'') ); // -1，没有找到，检索是大小写敏感的\n\nalert( str.indexOf(\"id\") ); // 1，\"id\" 在位置 1 处（……idget 和 id）\n```\n\n可选的第二个参数允许我们从一个给定的位置开始检索。\n\n例如，`\"id\"` 第一次出现的位置是 `1`。查询下一个存在位置时，我们从 `2` 开始检索：\n\n```javascript\nlet str = ''Widget with id'';\n\nalert( str.indexOf(''id'', 2) ) // 12\n```\n\n',6,124,207,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1000,'使用includes查找字符','```js\nalert( \"Widget with id\".includes(\"Widget\") ); // true\n\nalert( \"Hello\".includes(\"Bye\") ); // false\n```\n\n第二个可选参数是开始搜索的起始位置：\n\n```javascript\nalert( \"Widget\".includes(\"id\") ); // true\nalert( \"Widget\".includes(\"id\", 3) ); // false, 从位置 3 开始没有 \"id\"\n```\n\n',6,92,485,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1001,'使用slice截取','#### 使用slice查找字符\n\n```\nstr.slice(start [, end])\n```\n\n返回字符串从 `start` 到（但不包括）`end` 的部分。\n\n例如：\n\n```javascript\nlet str = \"stringify\";\nalert( str.slice(0, 5) ); // ''strin''，从 0 到 5 的子字符串（不包括 5）\nalert( str.slice(0, 1) ); // ''s''，从 0 到 1，但不包括 1，所以只有在 0 处的字符\n```\n\n如果没有第二个参数，`slice` 会一直运行到字符串末尾：\n\n```javascript\nlet str = \"stringify\";\nalert( str.slice(2) ); // 从第二个位置直到结束\n```\n\n`start/end` 也有可能是负值。它们的意思是起始位置从字符串结尾计算：\n\n```javascript\nlet str = \"stringify\";\n\n// 从右边的第四个位置开始，在右边的第一个位置结束\nalert( str.slice(-4, -1) ); // ''gif''\n```\n\n',6,124,158,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1002,'使用substring截取','这与 `slice` 几乎相同，但它允许 `start` 大于 `end`。\n\n例如：\n\n```javascript\nlet str = \"stringify\";\n\n// 这些对于 substring 是相同的\nalert( str.substring(2, 6) ); // \"ring\"\nalert( str.substring(6, 2) ); // \"ring\"\n\n// ……但对 slice 是不同的：\nalert( str.slice(2, 6) ); // \"ring\"（一样）\nalert( str.slice(6, 2) ); // \"\"（空字符串）\n```\n\n不支持负参数（不像 slice），它们被视为 `0`。',6,124,487,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1003,'使用substr截取','返回字符串从 `start` 开始的给定 `length` 的部分。\n\n与以前的方法相比，这个允许我们指定 `length` 而不是结束位置：\n\n```javascript\nlet str = \"stringify\";\nalert( str.substr(2, 4) ); // ''ring''，从位置 2 开始，获取 4 个字符\n```\n\n第一个参数可能是负数，从结尾算起：\n\n```javascript\nlet str = \"stringify\";\nalert( str.substr(-4, 2) ); // ''gi''，从第 4 位获取 2 个字符\n```\n\n',6,124,71,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1004,'根据字母读取UTF-16编码','```js\n// 不同的字母有不同的代码\nalert( \"z\".codePointAt(0) ); // 122\nalert( \"Z\".codePointAt(0) ); // 90\n```\n\n',6,124,489,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1005,'通过数字code创建字符','```javascript\nalert( String.fromCodePoint(90) ); // Z\n```\n\n我们还可以用 `\\u` 后跟十六进制代码，通过这些代码添加 Unicode 字符：\n\n```javascript\n// 在十六进制系统中 90 为 5a\nalert( ''\\u005a'' ); // Z\n```\n\n',6,124,489,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1006,'声明一个数组','创建一个空数组有两种语法：\n\n```javascript\nlet arr = new Array();\nlet arr = [];\n```\n\n绝大多数情况下使用的都是第二种语法。我们可以在方括号中添加初始元素：\n\n```javascript\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1007,'获取数组元素','数组元素从 0 开始编号。\n\n我们可以通过方括号中的数字获取元素：\n\n```js\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\nalert( fruits[0] ); // Apple\nalert( fruits[1] ); // Orange\nalert( fruits[2] ); // Plum\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1008,'获取数组最后一个元素','```js\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// 与 fruits[fruits.length-1] 相同\nalert( fruits.at(-1) ); // Plum\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1009,'遍历数组','遍历数组最古老的方式就是 `for` 循环：\n\n```javascript\nlet arr = [\"Apple\", \"Orange\", \"Pear\"];\n\nfor (let i = 0; i < arr.length; i++) {\n  alert( arr[i] );\n}\n```\n\n但对于数组来说还有另一种循环方式，`for..of`：\n\n```javascript\nlet fruits = [\"Apple\", \"Orange\", \"Plum\"];\n\n// 遍历数组元素\nfor (let fruit of fruits) {\n  alert( fruit );\n}\n```\n\n`for..of` 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的。而且这样写更短。\n\n技术上来讲，因为数组也是对象，所以使用 `for..in` 也是可以的',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1010,'清空数组','清空数组最简单的方法就是：`arr.length = 0;`。',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1011,'多维数组','数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：\n\n```js\nlet matrix = [\n  [1, 2, 3],\n  [4, 5, 6],\n  [7, 8, 9]\n];\n\nalert( matrix[1][1] ); // 最中间的那个数\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1012,'toString','数组有自己的 `toString` 方法的实现，会返回以逗号隔开的元素列表。\n\n例如：\n\n```javascript\nlet arr = [1, 2, 3];\n\nalert( arr ); // 1,2,3\nalert( String(arr) === ''1,2,3'' ); // true\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1013,'使用splice删除数组元素','```\narr.splice(start[, deleteCount, elem1, ..., elemN])\n```\n\n```js\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\narr.splice(1, 1); // 从索引 1 开始删除 1 个元素\n\nalert( arr ); // [\"I\", \"JavaScript\"]\n```\n\n例子中，我们删除了 3 个元素，并用另外两个元素替换它们：\n\n```javascript\nlet arr = [\"I\", \"study\", \"JavaScript\", \"right\", \"now\"];\n\n// 删除数组的前三项，并使用其他内容代替它们\narr.splice(0, 3, \"Let''s\", \"dance\");\n\nalert( arr ) // 现在 [\"Let''s\", \"dance\", \"right\", \"now\"]\n```\n\n可以将 `deleteCount` 设置为 `0`，`splice` 方法就能够插入元素而不用删除任何元素：\n\n```javascript\nlet arr = [\"I\", \"study\", \"JavaScript\"];\n\n// 从索引 2 开始\n// 删除 0 个元素\n// 然后插入 \"complex\" 和 \"language\"\narr.splice(2, 0, \"complex\", \"language\");\n\nalert( arr ); // \"I\", \"study\", \"complex\", \"language\", \"JavaScript\"\n```\n\n',6,47,97,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1014,'数组中使用slice','返回一个新数组，将所有从索引 `start` 到 `end`（不包括 `end`）的数组项复制到一个新的数组。`start` 和 `end` 都可以是负数，在这种情况下，从末尾计算索引。\n\n它和字符串的 `str.slice` 方法有点像，就是把子字符串替换成子数组。\n\n例如：\n\n```javascript\nlet arr = [\"t\", \"e\", \"s\", \"t\"];\n\nalert( arr.slice(1, 3) ); // e,s（复制从位置 1 到位置 3 的元素）\n\nalert( arr.slice(-2) ); // s,t（复制从位置 -2 到尾端的元素）\n```\n\n我们也可以不带参数地调用它：`arr.slice()` 会创建一个 `arr` 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。',6,47,499,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1015,'使用concat创建新数组','创建一个新数组，其中包含来自于其他数组和其他项的值。\n\n它接受任意数量的参数 —— 数组或值都可以。\n\n结果是一个包含来自于 `arr`，然后是 `arg1`，`arg2` 的元素的新数组。\n\n如果参数 `argN` 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。\n\n例如：\n\n```javascript\nlet arr = [1, 2];\n\n// 从 arr 和 [3,4] 创建一个新数组\nalert( arr.concat([3, 4]) ); // 1,2,3,4\n\n// 从 arr、[3,4] 和 [5,6] 创建一个新数组\nalert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6\n\n// 从 arr、[3,4]、5 和 6 创建一个新数组\nalert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6\n```\n\n通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：\n\n```javascript\nlet arr = [1, 2];\n\nlet arrayLike = {\n  0: \"something\",\n  length: 1\n};\n\nalert( arr.concat(arrayLike) ); // 1,2,[object Object]\n```\n\n',6,47,500,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1016,'使用forEach遍历数组元素','下面这个程序显示了数组的每个元素：\n\n```javascript\n// 对每个元素调用 alert\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach(alert);\n```\n\n而这段代码更详细地介绍了它们在目标数组中的位置：\n\n```javascript\n[\"Bilbo\", \"Gandalf\", \"Nazgul\"].forEach((item, index, array) => {\n  alert(`${item} is at index ${index} in ${array}`);\n});\n```\n\n该函数的结果（如果它有返回）会被抛弃和忽略。\n\n',6,47,501,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1017,'在数组中搜索','- `arr.indexOf(item, from)` —— 从索引 `from` 开始搜索 `item`，如果找到则返回索引，否则返回 `-1`。\n- `arr.includes(item, from)` —— 从索引 `from` 开始搜索 `item`，如果找到则返回 `true`（译注：如果没找到，则返回 `false`）。\n\n通常使用这些方法时只会传入一个参数：传入 `item` 开始搜索。默认情况下，搜索是从头开始的。\n\n例如：\n\n```javascript\nlet arr = [1, 0, false];\n\nalert( arr.indexOf(0) ); // 1\nalert( arr.indexOf(false) ); // 2\nalert( arr.indexOf(null) ); // -1\n\nalert( arr.includes(1) ); // true\n```\n\n请注意，`indexOf` 和 `includes` 使用严格相等 `===` 进行比较。所以，如果我们搜索 `false`，它会准确找到 `false` 而不是数字 `0`。\n\n',6,47,502,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1018,'使用find搜索数组','语法如下：\n\n```javascript\nlet result = arr.find(function(item, index, array) {\n  // 如果返回 true，则返回 item 并停止迭代\n  // 对于假值（falsy）的情况，则返回 undefined\n});\n```\n\n依次对数组中的每个元素调用该函数：\n\n- `item` 是元素。\n- `index` 是它的索引。\n- `array` 是数组本身。\n\n如果它返回 `true`，则搜索停止，并返回 `item`。如果没有搜索到，则返回 `undefined`。\n\n例如，我们有一个存储用户的数组，每个用户都有 `id` 和 `name` 字段。让我们找到 `id == 1` 的那个用户：\n\n```javascript\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\nlet user = users.find(item => item.id == 1);\n\nalert(user.name); // John\n```\n\n在现实生活中，对象数组是很常见的，所以 `find` 方法非常有用。',6,47,503,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1019,'使用filter匹配数组所有元素','`filter` 返回的是所有匹配元素组成的数组\n\n```js\nlet results = arr.filter(function(item, index, array) {\n  // 如果 true item 被 push 到 results，迭代继续\n  // 如果什么都没找到，则返回空数组\n});\n```\n\n```js\nlet users = [\n  {id: 1, name: \"John\"},\n  {id: 2, name: \"Pete\"},\n  {id: 3, name: \"Mary\"}\n];\n\n// 返回前两个用户的数组\nlet someUsers = users.filter(item => item.id < 3);\n\nalert(someUsers.length); // 2\n```\n\n',6,47,504,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1020,'使用reverse颠倒数组元素','```js\nlet arr = [1, 2, 3, 4, 5];\narr.reverse();\n\nalert( arr ); // 5,4,3,2,1\n```\n\n',6,47,505,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1021,'使用isArray判断是否是数组','如果 `value` 是一个数组，则返回 `true`；否则返回 `false`。\n\n```js\nalert(Array.isArray({})); // false\n\nalert(Array.isArray([])); // true\n```\n\n',6,47,506,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1022,'数组总结','数组方法备忘单：\n\n- 添加/删除元素：\n  - `push(...items)` —— 向尾端添加元素，\n  - `pop()` —— 从尾端提取一个元素，\n  - `shift()` —— 从首端提取一个元素，\n  - `unshift(...items)` —— 向首端添加元素，\n  - `splice(pos, deleteCount, ...items)` —— 从 `pos` 开始删除 `deleteCount` 个元素，并插入 `items`。\n  - `slice(start, end)` —— 创建一个新数组，将从索引 `start` 到索引 `end`（但不包括 `end`）的元素复制进去。\n  - `concat(...items)` —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 `items`。如果 `items` 中的任意一项是一个数组，那么就取其元素。\n- 搜索元素：\n  - `indexOf/lastIndexOf(item, pos)` —— 从索引 `pos` 开始搜索 `item`，搜索到则返回该项的索引，否则返回 `-1`。\n  - `includes(value)` —— 如果数组有 `value`，则返回 `true`，否则返回 `false`。\n  - `find/filter(func)` —— 通过 `func` 过滤元素，返回使 `func` 返回 `true` 的第一个值/所有值。\n  - `findIndex` 和 `find` 类似，但返回索引而不是值。\n- 遍历元素：\n  - `forEach(func)` —— 对每个元素都调用 `func`，不返回任何内容。\n- 转换数组：\n  - `map(func)` —— 根据对每个元素调用 `func` 的结果创建一个新数组。\n  - `sort(func)` —— 对数组进行原位（in-place）排序，然后返回它。\n  - `reverse()` —— 原位（in-place）反转数组，然后返回它。\n  - `split/join` —— 将字符串转换为数组并返回。\n  - `reduce/reduceRight(func, initial)` —— 通过对每个元素调用 `func` 计算数组上的单个值，并在调用之间传递中间结果。\n- 其他：\n  - `Array.isArray(value)` 检查 `value` 是否是一个数组，如果是则返回 `true`，否则返回 `false`。\n\n请注意，`sort`，`reverse` 和 `splice` 方法修改的是数组本身。\n\n这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：\n\n- [arr.some(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some)/[arr.every(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every) 检查数组。\n\n  与 `map` 类似，对数组的每个元素调用函数 `fn`。如果任何/所有结果为 `true`，则返回 `true`，否则返回 `false`。\n\n  这两个方法的行为类似于 `||` 和 `&&` 运算符：如果 `fn` 返回一个真值，`arr.some()` 立即返回 `true` 并停止迭代其余数组项；如果 `fn` 返回一个假值，`arr.every()` 立即返回 `false` 并停止对其余数组项的迭代。\n\n  我们可以使用 `every` 来比较数组：\n\n  ```javascript\n  function arraysEqual(arr1, arr2) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n  }\n  \n  alert( arraysEqual([1, 2], [1, 2])); // true\n  ```\n\n- [arr.fill(value, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill) —— 从索引 `start` 到 `end`，用重复的 `value` 填充数组。\n\n- [arr.copyWithin(target, start, end)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin) —— 将从位置 `start` 到 `end` 的所有元素复制到 **自身** 的 `target` 位置（覆盖现有元素）。\n\n- [arr.flat(depth)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)/[arr.flatMap(fn)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap) 从多维数组创建一个新的扁平数组。\n\n- [Array.of(element0[, element1[, …[, elementN\\]]])](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/of) 基于可变数量的参数创建一个新的 `Array` 实例，而不需要考虑参数的数量或类型。\n\n有关完整列表，请参阅 [手册](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array)。\n\n乍看起来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。\n\n浏览这个备忘单，以了解这些方法。然后解决本章中的习题来进行练习，以便让你有数组方法的使用经验。\n\n然后，每当你需要对数组进行某些操作，而又不知道怎么做的时候，请回到这儿，查看这个备忘单，然后找到正确的方法。示例将帮助你正确编写它。用不了多久，你就自然而然地记住这些方法了，根本不需要你死记硬背。',6,47,250,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1023,'遍历字符串','数组和字符串是使用最广泛的内建可迭代对象。\n\n对于一个字符串，`for..of` 遍历它的每个字符：\n\n```javascript\nfor (let char of \"test\") {\n  // 触发 4 次，每个字符一次\n  alert( char ); // t, then e, then s, then t\n}\n```\n\n',6,124,143,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1024,'Map','是一个带键的数据项的集合，就像一个 `Object` 一样。 但是它们最大的差别是 `Map` 允许任何类型的键（key）。\n\n它的方法和属性如下：\n\n- `new Map()` —— 创建 map。\n- `map.set(key, value)` —— 根据键存储值。\n- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。\n- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。\n- `map.delete(key)` —— 删除指定键的值。\n- `map.clear()` —— 清空 map。\n- `map.size` —— 返回当前元素个数。\n\n```js\nlet map = new Map();\n\nmap.set(''1'', ''str1'');   // 字符串键\nmap.set(1, ''num1'');     // 数字键\nmap.set(true, ''bool1''); // 布尔值键\n\n// 还记得普通的 Object 吗? 它会将键转化为字符串\n// Map 则会保留键的类型，所以下面这两个结果不同：\nalert( map.get(1)   ); // ''num1''\nalert( map.get(''1'') ); // ''str1''\n\nalert( map.size ); // 3\n```\n\n',6,128,509,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1025,'使用对象作为map的键','#### 使用对象作为map的键\n\n```javascript\nlet john = { name: \"John\" };\n\n// 存储每个用户的来访次数\nlet visitsCountMap = new Map();\n\n// john 是 Map 中的键\nvisitsCountMap.set(john, 123);\n\nalert( visitsCountMap.get(john) ); // 123\n```\n\n使用对象作为键是 `Map` 最值得注意和重要的功能之一。',6,128,509,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1026,'map的链式调用','#### map的链式调用\n\n每一次 `map.set` 调用都会返回 map 本身，所以我们可以进行“链式”调用：\n\n```javascript\nmap.set(''1'', ''str1'')\n  .set(1, ''num1'')\n  .set(true, ''bool1'');\n```\n\n',6,128,509,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1027,'map迭代','在 `map` 里使用循环，可以使用以下三个方法：\n\n- `map.keys()` —— 遍历并返回一个包含所有键的可迭代对象，\n- `map.values()` —— 遍历并返回一个包含所有值的可迭代对象，\n- `map.entries()` —— 遍历并返回一个包含所有实体 `[key, value]` 的可迭代对象，`for..of` 在默认情况下使用的就是这个。\n\n```javascript\nlet recipeMap = new Map([\n  [''cucumber'', 500],\n  [''tomatoes'', 350],\n  [''onion'',    50]\n]);\n\n// 遍历所有的键（vegetables）\nfor (let vegetable of recipeMap.keys()) {\n  alert(vegetable); // cucumber, tomatoes, onion\n}\n\n// 遍历所有的值（amounts）\nfor (let amount of recipeMap.values()) {\n  alert(amount); // 500, 350, 50\n}\n\n// 遍历所有的实体 [key, value]\nfor (let entry of recipeMap) { // 与 recipeMap.entries() 相同\n  alert(entry); // cucumber,500 (and so on)\n}\n```\n\n`Map` 有内建的 `forEach` 方法，与 `Array` 类似：\n\n```javascript\n// 对每个键值对 (key, value) 运行 forEach 函数\nrecipeMap.forEach( (value, key, map) => {\n  alert(`${key}: ${value}`); // cucumber: 500 etc\n});\n```\n\n',6,128,512,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1028,'从对象创建Map','```javascript\nlet obj = {\n  name: \"John\",\n  age: 30\n};\n\nlet map = new Map(Object.entries(obj));\n\nalert( map.get(''name'') ); // John\n```\n\n这里，`Object.entries` 返回键/值对数组：`[ [\"name\",\"John\"], [\"age\", 30] ]`。这就是 `Map` 所需要的格式。\n\n',6,128,509,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1029,'Set','`Set` 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。\n\n它的主要方法如下：\n\n- `new Set(iterable)` —— 创建一个 `set`，如果提供了一个 `iterable` 对象（通常是数组），将会从数组里面复制值到 `set` 中。\n- `set.add(value)` —— 添加一个值，返回 set 本身\n- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。\n- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。\n- `set.clear()` —— 清空 set。\n- `set.size` —— 返回元素个数。\n\n它的主要特点是，重复使用同一个值调用 `set.add(value)` 并不会发生什么改变。这就是 `Set` 里面的每一个值只出现一次的原因。\n\n例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。\n\n```javascript\nlet set = new Set();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\n// visits，一些访客来访好几次\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set 只保留不重复的值\nalert( set.size ); // 3\n\nfor (let user of set) {\n  alert(user.name); // John（然后 Pete 和 Mary）\n}\n```\n\n`Set` 的替代方法可以是一个用户数组，用 [arr.find](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find) 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。`Set` 内部对唯一性检查进行了更好的优化。',6,128,514,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1030,'Set迭代','使用 `for..of` 或 `forEach` 来遍历 Set：\n\n```javascript\nlet set = new Set([\"oranges\", \"apples\", \"bananas\"]);\n\nfor (let value of set) alert(value);\n\n// 与 forEach 相同：\nset.forEach((value, valueAgain, set) => {\n  alert(value);\n});\n```\n\n`forEach` 的回调函数有三个参数：一个 `value`，然后是 **同一个值** `valueAgain`，最后是目标对象。没错，同一个值在参数里出现了两次。\n\n`forEach` 的回调函数有三个参数，是为了与 `Map` 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 `Set` 代替 `Map` 很有帮助，反之亦然。\n\n`Map` 中用于迭代的方法在 `Set` 中也同样支持：\n\n- `set.keys()` —— 遍历并返回一个包含所有值的可迭代对象，\n- `set.values()` —— 与 `set.keys()` 作用相同，这是为了兼容 `Map`，\n- `set.entries()` —— 遍历并返回一个包含所有的实体 `[value, value]` 的可迭代对象，它的存在也是为了兼容 `Map`。\n\n',6,128,514,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1031,'map/set总结','`Map` —— 是一个带键的数据项的集合。\n\n方法和属性如下：\n\n- `new Map([iterable])` —— 创建 map，可选择带有 `[key,value]` 对的 `iterable`（例如数组）来进行初始化。\n- `map.set(key, value)` —— 根据键存储值，返回 map 自身。\n- `map.get(key)` —— 根据键来返回值，如果 `map` 中不存在对应的 `key`，则返回 `undefined`。\n- `map.has(key)` —— 如果 `key` 存在则返回 `true`，否则返回 `false`。\n- `map.delete(key)` —— 删除指定键对应的值，如果在调用时 `key` 存在，则返回 `true`，否则返回 `false`。\n- `map.clear()` —— 清空 map 。\n- `map.size` —— 返回当前元素个数。\n\n与普通对象 `Object` 的不同点：\n\n- 任何键、对象都可以作为键。\n- 有其他的便捷方法，如 `size` 属性。\n\n`Set` —— 是一组唯一值的集合。\n\n方法和属性：\n\n- `new Set([iterable])` —— 创建 set，可选择带有 `iterable`（例如数组）来进行初始化。\n- `set.add(value)` —— 添加一个值（如果 `value` 存在则不做任何修改），返回 set 本身。\n- `set.delete(value)` —— 删除值，如果 `value` 在这个方法调用的时候存在则返回 `true` ，否则返回 `false`。\n- `set.has(value)` —— 如果 `value` 在 set 中，返回 `true`，否则返回 `false`。\n- `set.clear()` —— 清空 set。\n- `set.size` —— 元素的个数。\n\n在 `Map` 和 `Set` 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。',6,128,516,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1032,'WeakMap','`WeakMap` 和 `Map` 的第一个不同点就是，`WeakMap` 的键必须是对象，不能是原始值：\n\n```javascript\nlet weakMap = new WeakMap();\n\nlet obj = {};\n\nweakMap.set(obj, \"ok\"); // 正常工作（以对象作为键）\n\n// 不能使用字符串作为键\nweakMap.set(\"test\", \"Whoops\"); // Error，因为 \"test\" 不是一个对象\n```\n\n现在，如果我们在 weakMap 中使用一个对象作为键，并且没有其他对这个对象的引用 —— 该对象将会被从内存（和map）中自动清除。\n\n```javascript\nlet john = { name: \"John\" };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, \"...\");\n\njohn = null; // 覆盖引用\n\n// john 被从内存中删除了！\n```\n\n与上面常规的 `Map` 的例子相比，现在如果 `john` 仅仅是作为 `WeakMap` 的键而存在 —— 它将会被从 map（和内存）中自动删除。\n\n`WeakMap` 不支持迭代以及 `keys()`，`values()` 和 `entries()` 方法。所以没有办法获取 `WeakMap` 的所有键或值。\n\n`WeakMap` 只有以下的方法：\n\n- `weakMap.get(key)`\n- `weakMap.set(key, value)`\n- `weakMap.delete(key)`\n- `weakMap.has(key)`\n\n',6,128,517,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1033,'WeakSet','`WeakSet` 的表现类似：\n\n- 与 `Set` 类似，但是我们只能向 `WeakSet` 添加对象（而不能是原始值）。\n- 对象只有在其它某个（些）地方能被访问的时候，才能留在 `WeakSet` 中。\n- 跟 `Set` 一样，`WeakSet` 支持 `add`，`has` 和 `delete` 方法，但不支持 `size` 和 `keys()`，并且不可迭代。\n\n变“弱（weak）”的同时，它也可以作为额外的存储空间。但并非针对任意数据，而是针对“是/否”的事实。`WeakSet` 的元素可能代表着有关该对象的某些信息。\n\n例如，我们可以将用户添加到 `WeakSet` 中，以追踪访问过我们网站的用户：\n\n```javascript\nlet visitedSet = new WeakSet();\n\nlet john = { name: \"John\" };\nlet pete = { name: \"Pete\" };\nlet mary = { name: \"Mary\" };\n\nvisitedSet.add(john); // John 访问了我们\nvisitedSet.add(pete); // 然后是 Pete\nvisitedSet.add(john); // John 再次访问\n\n// visitedSet 现在有两个用户了\n\n// 检查 John 是否来访过？\nalert(visitedSet.has(john)); // true\n\n// 检查 Mary 是否来访过？\nalert(visitedSet.has(mary)); // false\n\njohn = null;\n\n// visitedSet 将被自动清理(即自动清除其中已失效的值 john)\n```\n\n`WeakMap` 和 `WeakSet` 最明显的局限性就是不能迭代，并且无法获取所有当前内容。那样可能会造成不便，但是并不会阻止 `WeakMap/WeakSet` 完成其主要工作 —— 为在其它地方存储/管理的对象数据提供“额外”存储。',6,128,518,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1034,'WeakMap/Set总结','`WeakMap` 是类似于 `Map` 的集合，它仅允许对象作为键，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象与其关联值一同删除。\n\n`WeakSet` 是类似于 `Set` 的集合，它仅存储对象，并且一旦通过其他方式无法访问这些对象，垃圾回收便会将这些对象删除。\n\n它们的主要优点是它们对对象是弱引用，所以被它们引用的对象很容易地被垃圾收集器移除。\n\n这是以不支持 `clear`、`size`、`keys`、`values` 等作为代价换来的……\n\n`WeakMap` 和 `WeakSet` 被用作“主要”对象存储之外的“辅助”数据结构。一旦将对象从主存储器中删除，如果该对象仅被用作 `WeakMap` 或 `WeakSet` 的键，那么该对象将被自动清除。',6,128,517,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1035,'数组结构','将数组解构到变量中的例子：\n\n```javascript\n// 我们有一个存放了名字和姓氏的数组\nlet arr = [\"John\", \"Smith\"]\n\n// 解构赋值\n// 设置 firstName = arr[0]\n// 以及 surname = arr[1]\nlet [firstName, surname] = arr;\n\nalert(firstName); // John\nalert(surname);  // Smith\n```\n\n我们可以使用这些变量而非原来的数组项了。\n\n当与 `split` 函数（或其他返回值为数组的函数）结合使用时，看起来更优雅：\n\n```javascript\nlet [firstName, surname] = \"John Smith\".split('' '');\nalert(firstName); // John\nalert(surname);  // Smith\n```\n\n**“解构”并不意味着“破坏”**\n\n这种语法被叫做“解构赋值”，是因为它“拆开”了数组或对象，将其中的各元素复制给一些变量。原来的数组或对象自身没有被修改。\n\n换句话说，解构赋值只是写起来简洁一点。以下两种写法是等价的：\n\n```javascript\n// let [firstName, surname] = arr;\nlet firstName = arr[0];\nlet surname = arr[1];\n```\n\n',6,47,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1036,'使用逗号丢弃不要的元素进行解构','```javascript\n// 不需要第二个元素\nlet [firstName, , title] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\nalert( title ); // Consul\n```\n\n在上面的代码中，数组的第二个元素被跳过了，第三个元素被赋值给了 `title` 变量。数组中剩下的元素也都被跳过了（因为在这没有对应给它们的变量）。',6,47,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1037,'等号右侧可以是任何可迭代对象','……实际上，我们可以将其与任何可迭代对象一起使用，而不仅限于数组：\n\n```javascript\nlet [a, b, c] = \"abc\"; // [\"a\", \"b\", \"c\"]\nlet [one, two, three] = new Set([1, 2, 3]);\n```\n\n这种情况下解构赋值是通过迭代右侧的值来完成工作的。这是一种用于对在 `=` 右侧的值上调用 `for..of` 并进行赋值的操作的语法糖',6,47,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1038,'通过...获取其余数组项','```javascript\net [name1, name2, ...rest] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n\n// rest 是包含从第三项开始的其余数组项的数组\nalert(rest[0]); // Consul\nalert(rest[1]); // of the Roman Republic\nalert(rest.length); // 2\n```\n\n`rest` 的值就是数组中剩下的元素组成的数组。\n\n不一定要使用变量名 `rest`，我们也可以使用任何其他的变量名。只要确保它前面有三个点，并且在解构赋值的最后一个参数位置上就行了：\n\n```javascript\nlet [name1, name2, ...titles] = [\"Julius\", \"Caesar\", \"Consul\", \"of the Roman Republic\"];\n// 现在 titles = [\"Consul\", \"of the Roman Republic\"]\n```\n\n',1,47,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1039,'对象解构','```js\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\n如果我们想把一个属性赋值给另一个名字的变量，比如把 `options.width` 属性赋值给名为 `w` 的变量，那么我们可以使用冒号来设置变量名称：\n\n```javascript\nlet options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\n// { sourceProperty: targetVariable }\nlet {width: w, height: h, title} = options;\n\n// width -> w\n// height -> h\n// title -> title\n\nalert(title);  // Menu\nalert(w);      // 100\nalert(h);      // 200\n```\n\n对于可能缺失的属性，我们可以使用 `\"=\"` 设置默认值，如下所示：\n\n```javascript\nlet options = {\n  title: \"Menu\"\n};\n\nlet {width = 100, height = 200, title} = options;\n\nalert(title);  // Menu\nalert(width);  // 100\nalert(height); // 200\n```\n\n剩余模式\n\n如果对象拥有的属性数量比我们提供的变量数量还多，该怎么办？我们可以只取其中的某一些属性，然后把“剩余的”赋值到其他地方吗？\n\n```js\nlet options = {\n  title: \"Menu\",\n  height: 200,\n  width: 100\n};\n\n// title = 名为 title 的属性\n// rest = 存有剩余属性的对象\nlet {title, ...rest} = options;\n\n// 现在 title=\"Menu\", rest={height: 200, width: 100}\nalert(rest.height);  // 200\nalert(rest.width);   // 100\n```\n\n',6,87,210,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1040,'创建当前日期时间','```js\nlet now = new Date();\nalert( now ); // 显示当前的日期/时间\n```\n\n',6,124,525,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1041,'JSON.stringify','例如，在这里我们 `JSON.stringify` 一个 `student` 对象：\n\n```js\nlet student = {\n  name: ''John'',\n  age: 30,\n  isAdmin: false,\n  courses: [''html'', ''css'', ''js''],\n  spouse: null\n};\n\nlet json = JSON.stringify(student);\n\nalert(typeof json); // we''ve got a string!\n\nalert(json);\n/* JSON 编码的对象：\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"isAdmin\": false,\n  \"courses\": [\"html\", \"css\", \"js\"],\n  \"spouse\": null\n}\n*/\n```\n\n方法 `JSON.stringify(student)` 接收对象并将其转换为字符串。\n\n得到的 `json` 字符串是一个被称为 **JSON 编码（JSON-encoded）** 或 **序列化（serialized）** 或 **字符串化（stringified）** 或 **编组化（marshalled）** 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。\n\n请注意，JSON 编码的对象与对象字面量有几个重要的区别：\n\n- 字符串使用双引号。JSON 中没有单引号或反引号。所以 `''John''` 被转换为 `\"John\"`。\n- 对象属性名称也是双引号的。这是强制性的。所以 `age:30` 被转换成 `\"age\":30`。\n\n##### 格式化\n\n三个参数是用于优化格式的空格数量\n\n这里的 `space = 2` 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩进 2 个空格\n\n```js\nlet user = {\n  name: \"John\",\n  age: 25,\n  roles: {\n    isAdmin: false,\n    isEditor: true\n  }\n};\n\nalert(JSON.stringify(user, null, 2));\n/* 两个空格的缩进：\n{\n  \"name\": \"John\",\n  \"age\": 25,\n  \"roles\": {\n    \"isAdmin\": false,\n    \"isEditor\": true\n  }\n}\n*/\n\n/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：\n{\n    \"name\": \"John\",\n    \"age\": 25,\n    \"roles\": {\n        \"isAdmin\": false,\n        \"isEditor\": true\n    }\n}\n*/\n```\n\n',6,124,526,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1042,'JSON.parse','解码 JSON 字符串\n\nstr 要解析的 JSON 字符串。\n\nreviver 可选的函数 function(key,value)，该函数将为每个 `(key, value)` 对调用，并可以对值进行转换。\n\n```js\nlet value = JSON.parse(str, [reviver]);\n```\n\n```js\n// 字符串化数组\nlet numbers = \"[0, 1, 2, 3]\";\n\nnumbers = JSON.parse(numbers);\n\nalert( numbers[1] ); // 1\n```\n\n嵌套对象：\n\n```javascript\nlet userData = ''{ \"name\": \"John\", \"age\": 35, \"isAdmin\": false, \"friends\": [0,1,2,3] }'';\n\nlet user = JSON.parse(userData);\n\nalert( user.friends[1] ); // 1\n```\n\nJSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。',6,124,526,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1043,'Rest参数','在 JavaScript 中，无论函数是如何定义的，你都可以在调用它时传入任意数量的参数\n\n```js\nfunction sum(a, b) {\n  return a + b;\n}\n\nalert( sum(1, 2, 3, 4, 5) );\n```\n\n可以在函数定义中声明一个数组来收集参数。语法是这样的：`...变量名`，这将会声明一个数组并指定其名称，其中存有剩余的参数。这三个点的语义就是“收集剩余的参数并存进指定数组中”\n\n```js\nfunction sumAll(...args) { // 数组名为 args\n  let sum = 0;\n\n  for (let arg of args) sum += arg;\n\n  return sum;\n}\n\nalert( sumAll(1) ); // 1\nalert( sumAll(1, 2) ); // 3\nalert( sumAll(1, 2, 3) ); // 6\n```\n\n也可以选择将第一个参数获取为变量，并将剩余的参数收集起来\n\n```js\nfunction showName(firstName, lastName, ...titles) {\n  alert( firstName + '' '' + lastName ); // Julius Caesar\n\n  // 剩余的参数被放入 titles 数组中\n  // i.e. titles = [\"Consul\", \"Imperator\"]\n  alert( titles[0] ); // Consul\n  alert( titles[1] ); // Imperator\n  alert( titles.length ); // 2\n}\n\nshowName(\"Julius\", \"Caesar\", \"Consul\", \"Imperator\");\n```\n\n',6,89,528,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1044,'Spread语法','返回参数中最大的值\n\n```js\nlet arr = [3, 5, 1];\n\nalert( Math.max(...arr) ); // 5（spread 语法把数组转换为参数列表）\n```\n\n还可以通过这种方式传入多个可迭代对象：\n\n```javascript\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(...arr1, ...arr2) ); // 8\n```\n\n还可以将 spread 语法与常规值结合使用：\n\n```javascript\nlet arr1 = [1, -2, 3, 4];\nlet arr2 = [8, 3, -8, 1];\n\nalert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25\n```\n\n可以使用 spread 语法来合并数组：\n\n```javascript\nlet arr = [3, 5, 1];\nlet arr2 = [8, 9, 15];\n\nlet merged = [0, ...arr, 2, ...arr2];\n\nalert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr，然后是 2，然后是 arr2）\n```\n\n上面的示例中，使用数组展示了 spread 语法，其实我们可以用 spread 语法这样操作任何可迭代对象。\n\n例如，使用 spread 语法将字符串转换为字符数组：\n\n```javascript\nlet str = \"Hello\";\n\nalert( [...str] ); // H,e,l,l,o\n```\n\nSpread 语法内部使用了迭代器来收集元素，与 `for..of` 的方式相同。\n\n因此，对于一个字符串，`for..of` 会逐个返回该字符串中的字符，`...str` 也同理会得到 `\"H\",\"e\",\"l\",\"l\",\"o\"` 这样的结果。随后，字符列表被传递给数组初始化器 `[...str]`。\n\n对于这个特定任务，我们还可以使用 `Array.from` 来实现，因为该方法会将一个可迭代对象（如字符串）转换为数组：\n\n```javascript\nlet str = \"Hello\";\n\n// Array.from 将可迭代对象转换为数组\nalert( Array.from(str) ); // H,e,l,l,o\n```\n\n运行结果与 `[...str]` 相同。\n\n不过 `Array.from(obj)` 和 `[...obj]` 存在一个细微的差别：\n\n- `Array.from` 适用于类数组对象也适用于可迭代对象。\n- Spread 语法只适用于可迭代对象。\n\n因此，对于将一些“东西”转换为数组的任务，`Array.from` 往往更通用。',6,89,529,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1045,'嵌套函数','如果一个函数是在另一个函数中创建的，该函数就被称为“嵌套”函数。\n\n```js\nfunction sayHiBye(firstName, lastName) {\n\n  // 辅助嵌套函数使用如下\n  function getFullName() {\n    return firstName + \" \" + lastName;\n  }\n\n  alert( \"Hello, \" + getFullName() );\n  alert( \"Bye, \" + getFullName() );\n\n}\n```\n\n这里创建的 **嵌套** 函数 `getFullName()` 是为了更加方便。它可以访问外部变量，因此可以返回全名\n\n',6,89,222,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1046,'全局对象','在浏览器中，它的名字是 “window”，对 Node.js 而言，它的名字是 “global”，其它环境可能用的是别的名字。\n\n最近，`globalThis` 被作为全局对象的标准名称加入到了 JavaScript 中，所有环境都应该支持该名称。所有主流浏览器都支持它。\n\n全局对象的所有属性都可以被直接访问：\n\n```javascript\nalert(\"Hello\");\n// 等同于\nwindow.alert(\"Hello\");\n```\n\n在浏览器中，使用 `var`（而不是 `let/const`！）声明的全局函数和变量会成为全局对象的属性。\n\n```javascript\nvar gVar = 5;\n\nalert(window.gVar); // 5（成为了全局对象的属性）\n```\n\n',6,87,176,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1047,'MES提示指令错误','**问题点**\n\n ![image-20230907082259012](http://kai.snblogs.cn/typora/image-20230907082259012.png)\n\n**方案**\n\n1. 排查后台API调用字段是否正确\n2. 手动更新模板MES DLL版本',18,102,532,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1048,'通过MES料件配置UID','```\ndllname=MES&method=UID_Master&IsSMT=False&MaterialSpecification=FOR PCBA ASS’Y HDT657 HEADSET\n```\n\n',18,104,533,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1049,'工时计算','计算公式：提案机型日产能*单月天数*12个月*节省时间/3600=节省小时，节省小时*40=年节约金额',18,129,534,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1050,'机型配置','### 机型配置\n\n读取当前机型DLL目录下的Config配置\n\n ![image-20230918141638351](http://kai.snblogs.cn/typora/image-20230918141638351.png)',18,108,535,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1051,'c#使用委托执行带有超时检查的方法.','```csharp\nnamespace TimeOutHelper\n{\n    internal class Program\n    {\n        // 定义一个泛型委托，用于定义带有超时检查的方法的签名\n        public delegate TR TimeOutDelegate<in T, out TR>(T param);\n\n        private static void Main()\n        {\n            Dictionary<Guid, string> result;\n            \n            // 调用TimeoutFunction类的Execute方法执行带有超时检查的方法\n            // Test方法是一个示例方法，它接受一个字符串参数，并返回一个字典\n            // \"Hello, World!\"是传递给Test方法的参数\n            // result是用于接收Test方法的返回值的字典\n            // TimeSpan.FromSeconds(3)表示超时时间为3秒\n            // Execute方法返回一个布尔值，表示是否超时\n            Console.WriteLine(TimeoutFunction.Execute(Test, \"Hello, World!\", out result, TimeSpan.FromSeconds(3)));\n            \n            Console.WriteLine(\"Hello, World!\");\n            Console.ReadKey();\n        }\n\n        // 示例方法，接受一个字符串参数，并返回一个字典\n        public static Dictionary<Guid, string> Test(string sourceString)\n        {\n            // 将字符串转换为字典，每个字符作为键，使用Guid作为值\n            var result = sourceString.ToDictionary(\n                character => Guid.NewGuid(),\n                character => character.ToString(CultureInfo.InvariantCulture));\n            \n            // 模拟耗时操作，暂停4秒\n            Thread.Sleep(4000);\n            \n            return result;\n        }\n\n        public static class TimeoutFunction\n        {\n            /// <summary>\n            /// 执行带有超时检查的方法\n            /// </summary>\n            /// <typeparam name=\"T\">目标方法的参数类型</typeparam>\n            /// <typeparam name=\"TR\">执行结果的类型</typeparam>\n            /// <param name=\"timeoutMethod\">目标方法</param>\n            /// <param name=\"param\">目标方法的参数</param>\n            /// <param name=\"result\">执行结果</param>\n            /// <param name=\"timeout\">超时时间</param>\n            /// <returns>是否超时</returns>\n            public static Boolean Execute<T, TR>(\n                TimeOutDelegate<T, TR> timeoutMethod, T param, out TR result, TimeSpan timeout)\n            {\n                // 使用异步方式执行目标方法\n                var asyncResult = timeoutMethod.BeginInvoke(param, null, null);\n                \n                // 等待指定的超时时间\n                if (!asyncResult.AsyncWaitHandle.WaitOne(timeout, false))\n                {\n                    // 如果超时，则将结果设置为默认值，并返回true\n                    result = default(TR);\n                    return true;\n                }\n                \n                // 如果未超时，则获取执行结果，并返回false\n                result = timeoutMethod.EndInvoke(asyncResult);\n                return false;\n            }\n        }\n    }\n}\n```\n\n',1,111,536,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1052,'c#实现文件压缩的方法','```csharp\n// 实现一个压缩文件的方法\npublic static void CompressFile(string sourceFilePath, string zipFilePath)\n{\n    // 如果文件没有找到，则报错\n    if(!File.Exists(sourceFilePath))\n    {\n        throw new FileNotFoundException(sourceFilePath + \"文件不存在！\");\n    }\n    // 如果压缩文件没有找到，则进行创建\n    if(!Directory.Exists(zipFilePath))\n    {\n        Directory.CreateDirectory(zipFilePath);\n    }\n    // 压缩文件的名称\n    var zipFileName = zipFilePath + \"\\\\\" + Path.GetFileNameWithoutExtension(sourceFilePath) + \".zip\";\n    // 如果压缩文件存在，则进行删除\n    if(File.Exists(zipFileName))\n    {\n        File.Delete(zipFileName);\n    }\n    // 开始压缩文件\n    ZipFile.CreateFromDirectory(sourceFilePath, zipFileName);\n}\n```\n\n方法示例\n\n```csharp\nstring sourceFilePath = \"C:\\\\path\\\\to\\\\source\\\\file.txt\";\nstring zipFilePath = \"C:\\\\path\\\\to\\\\zip\\\\folder\";\n\nCompressFile(sourceFilePath, zipFilePath);\n```\n\n',1,111,537,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1053,'使用c#在指定的时间内等待函数执行结果','在指定的时间内等待某个函数的执行结果的方法。该方法接受三个参数：等待的最大时间、等待的频率和要等待的函数。方法会在指定的时间内每隔一定频率检查函数的执行结果，如果在等待时间内函数返回了true，则表示等待成功，返回true；如果超过等待时间仍未返回true，则表示等待失败，返回false。\n\n```csharp\n/// <summary>\n/// 在指定的时间内等待某个函数的执行结果，并返回一个布尔值表示是否等待成功,\n/// 调用 bool result = WaitSomething(5000, 1000, () =>{})\n/// </summary>\n/// <param name=\"timeout\">表示等待的最大时间，以毫秒为单位</param>\n/// <param name=\"freq\">表示等待的频率，即每隔多少毫秒检查一次函数的执行结果</param>\n/// <param name=\"func\">表示要等待的函数，它是一个返回布尔值的委托</param>\n/// <returns></returns>\npublic static bool WaitSomething(int timeout, int freq, Func < bool > func)\n{\n    for(int index = 0; index < timeout; index += freq)\n    {\n        if(func()) return true;\n        Thread.Sleep(freq);\n    }\n    return false;\n}\n```\n\n使用示例\n\n```csharp\nbool result = WaitSomething(5000, 1000, () =>\n{\n    // 执行一些操作，返回一个布尔值\n    return true;\n});\n```\n\n',1,111,538,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1054,'c#十六进制字符转十进制','- 十六进制字符串：由0-9和A-F组成的字符串，表示十六进制数。\n- 十进制数：由0-9组成的数字，表示十进制数。\n\n```csharp\n /// <summary>\n /// 十六进制字符串转十进制\n /// </summary>\n /// <param name=\"str\">十六进制字符</param>\n /// <returns></returns>\n static int To16Convert10(string str)\n {\n     int res = 0;\n     try\n     {\n         str = str.Trim().Replace(\" \", \"\"); //移除空字符\n         //方法1\n         res = int.Parse(str, System.Globalization.NumberStyles.AllowHexSpecifier);\n         方法2\n         //int r2 = System.Int32.Parse(str, System.Globalization.NumberStyles.HexNumber);\n         //Console.WriteLine(r2);\n         方法3\n         //int r3 = Convert.ToInt32(str, 16);\n         //Console.WriteLine(r3);\n     }\n     catch(Exception e)\n     {\n         res = 0;\n     }\n     return res;\n }\n```\n\n执行步骤\n\n1. 首先，代码中的`To16Convert10`函数接受一个十六进制字符串作为参数，并声明一个整型变量`res`用于存储转换后的十进制数。\n2. 接下来，代码使用`Trim`和`Replace`方法移除字符串中的空字符，以确保字符串的格式正确。\n3. 然后，代码使用`int.Parse`方法将十六进制字符串转换为十进制数，并将结果赋值给`res`变量。`System.Globalization.NumberStyles.AllowHexSpecifier`参数指定了允许解析十六进制数的格式。\n4. 最后，代码使用`try-catch`块来捕获可能发生的异常，并将`res`变量初始化为0，以防止转换失败时返回无效值。\n\n',1,113,403,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1055,'winfrom退出窗体','```csharp\nApplication.Exit();//好像只在主线程可以起作用，而且当有线程，或是阻塞方法的情况下，很容易失灵\nthis.Close();//只是关闭当前窗体。\nApplication.ExitThread();//退出当前线程上的消息循环，并关闭该线程上的所有窗口。 也会失灵\nEnvironment.Exit(0); //前面三种方法都不能很好的退出程序，此方法可以完全退出程序，这个要强制得多。\nProcess.GetCurrentProcess().Kill();//此方法完全奏效，绝对是完全退出。\n```\n\n',1,130,540,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1056,'c#获取Windows当前选文件定路径','在Windows系统中点击文件后获取到文件完整路径\n\n```csharp\n/// <summary>\n/// 获取Windows当前选中的文件或文件夹的完整路径\n/// </summary>\n/// <returns>完整路径</returns>\nprivate static string GetWindowsSelectedPath()\n{  \n    // 获取命令行参数\n    string[] commandLineArgs = Environment.GetCommandLineArgs();\n    // 检查是否有参数传入\n    if(commandLineArgs.Length > 1)\n    {   \n         // 获取传入的路径\n        string path = commandLineArgs[1];\n         // 检查路径是否存在文件或文件夹\n        if(File.Exists(path) || Directory.Exists(path))\n        {\n            // 返回完整路径\n            return path;\n        }\n    }\n    // 如果没有找到有效路径，则返回null\n    return null;\n}\n```\n\n',1,130,541,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1057,'c#后台任务运行','在C#中如果想要执行一段一直运行的程序，如监听网络状态，实时读取PLC数据，遇到这种情况有多种解决方法。\n\n方法一，可以起一个Task任务，在Task任务中写个死循环，这种死循环最好在最后写个 Thread.Sleep，不然程序会占用很高的CPU。\n\n```csharp\n//用于创建并启动任务的方法。它接受一个委托作为参数，该委托定义了任务要执行的代码\nTask.Factory.StartNew(() =>\n{\n    while(true)\n    {\n        Console.WriteLine(\"一直运行的代码\");\n        Thread.Sleep(10);\n    }\n}, TaskCreationOptions.LongRunning);//选项：这是一个用于指定任务类型的选项。使用LongRunning选项可以告诉任务调度器，该任务是一个长时间运行的任务，从而使任务在一个单独的线程上执行。\n```\n\n方法二 **System.Timers.Timer**\n\n```csharp\n//定义Timer\nSystem.Timers.Timer Timers_Timer = new System.Timers.Timer();\n//手动设置Timer，开始执行\nTimers_Timer.Interval = 20;\nTimers_Timer.Enabled = true;\n// AutoReset属性决定计时器是不是要发起一次事件然后停止，还是进入开始/等待的循环。\n Timers_Timer.AutoReset = true;\nTimers_Timer.Elapsed += new System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed); \n//一直运行的循环\nvoid Timers_Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n{ \nThread.Sleep(1000);\n}\n```\n\n',1,131,542,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1058,'c#实现测量代码块执行时间的封装','创建MeasureDuration.cs，并实现 `IDisposable` 接口的\n\n```csharp\nusing System;\nusing System.Diagnostics;\n\nnamespace MechTE_480.Util\n{\n    /// <summary>\n    /// 定义了一个名为MeasureDuration的类，用于测量代码的执行时间。该类实现了IDisposable接口，以便在代码块结束时自动释放资源。\n    /// </summary>\n    public class MeasureDuration : IDisposable\n    {\n        private readonly Stopwatch _stopwatch;\n        private readonly Action<TimeSpan> _callback;\n\n        /// <summary>\n        /// 构造函数接受一个Action&lt;TimeSpan&gt;类型的回调函数作为参数。在构造函数中，我们将回调函数赋值给私有字段_callback，并使用Stopwatch.StartNew()方法启动一个新的计时器。\n        /// </summary>\n        /// <param name=\"callback\"></param>\n        public MeasureDuration(Action<TimeSpan> callback)\n        {\n            _callback = callback;\n            _stopwatch = Stopwatch.StartNew();\n        }\n\n        /// <summary>\n        /// 释放资源\n        /// </summary>\n        public void Dispose()\n        {\n            _stopwatch.Stop();\n            _callback(_stopwatch.Elapsed);\n        }\n    }\n}\n```\n\n在单元测试中使用 `MeasureDuration` 类来测量代码块的执行时间\n\n```csharp\n[Fact]\npublic void Duration()\n{\n    using(new MeasureDuration(duration => _msg.WriteLine($ \"代码执行时间：{duration}\")))\n    {\n        // 在这里编写需要测量执行时间的代码\n        for(int i = 0; i < 10; i++)\n        {\n            // 一些耗时的操作\n            Thread.Sleep(1000);\n        }\n    }\n}\n```\n\n使用了using语句来创建一个MeasureDuration对象，并在代码块结束时自动释放资源。在MeasureDuration的构造函数中，我们传入了一个回调函数，该函数将在代码块结束时被调用，并将代码执行的时间间隔作为参数传递给回调函数。在回调函数中，我们将代码执行的时间间隔输出到控制台。',1,111,543,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1059,'c#获取程序最后修改时间','```c#\n//获取当前系统时间\nDateTime vTime = File.GetLastWriteTime(GetType().Assembly.Location);\n\n//显示在窗口标题栏,时间自定义组合\nthis.Text += $\"_{vTime.Year.ToString().Substring(2, 2)}.{vTime.Month}.{vTime.Day}.{vTime.Hour}.{vTime.Minute}\"; \n```\n\n',1,110,544,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1060,'获取计算机的驱动器','```csharp\nstatic public void Main()\n{\n    // 声明一个字符串数组来存储逻辑驱动器\n    string[] drives = Environment.GetLogicalDrives();\n\n    Console.WriteLine(\"Logical Drives of this computer:\");\n\n    // 显示计算机系统中的所有驱动器\n    foreach (string d in drives)\n    {\n        Console.WriteLine(\"\\t\" + d);\n    }\n}\n\n```\n\n',1,132,330,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1061,'获取主机名和IP地址','```csharp\nstatic void Main(string[] args)\n{\n    // 获取主机名\n    string hostName = Dns.GetHostName();\n    Console.WriteLine(\"主机名：\" + hostName);\n\n    // 根据主机名获取IP地址\n    string IP = Dns.GetHostByName(hostName).AddressList[0].ToString();\n    Console.WriteLine(\"IP地址：\" + IP);\n}\n\n```\n\n',1,132,308,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1062,'命令行中启动程序并输入参数','打开命令行，输入路径+DemoMainArgs，空一格，再输入 a b c d（可以输入任意多个参数，多个之间用空格分隔）\n\n ![image-20230918134225191](http://kai.snblogs.cn/typora/image-20230918134225191.png)',1,112,548,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1063,'通过编译器调试中输入参数','右键点击【项目】--》【属性】，弹出配置界面。选择【调试】--》【启动选项】--》【命令行参数】文本框中输入任意的参数，多个之间用空格分隔\n\n ![image-20230918134307706](http://kai.snblogs.cn/typora/image-20230918134307706.png)',1,112,549,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1064,'通过在程序的快捷方式中增加参数','程序编译后，创建快捷方式程序。右键点击【DemoMainArgs.exe】--》【创建快捷方式】\n\n右键点击【DemoMainArgs.exe 快捷方式】--》【属性】--》【快捷方式】--》【目标】，在文本框的最后输入任意参数，\n\n ![image-20230918134408816](http://kai.snblogs.cn/typora/image-20230918134408816.png)\n\n',1,112,550,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1065,'匿名类使用','```csharp\nvar person = new\n{\n    Name = \"张三\",\n    Age = 25,\n    Occupation = \"工程师\"\n};\n\nConsole.WriteLine($\"姓名：{person.Name}\");\nConsole.WriteLine($\"年龄：{person.Age}\");\nConsole.WriteLine($\"职业：{person.Occupation}\");\n\n```\n\n',1,135,555,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1066,'c#移动控制台的缓冲区','使用C#中的`Console.MoveBufferArea`方法来移动控制台的缓冲区。控制台缓冲区是一个用于存储控制台输出的内存区域。通过移动缓冲区，我们可以在控制台上创建自定义的输出布局\n\n- **控制台缓冲区**：控制台缓冲区是一个二维字符数组，用于存储控制台输出的字符。它的大小由控制台的宽度和高度决定。\n- **Console.MoveBufferArea方法**：控制台类方法，用于移动控制台缓冲区的内容。它接受源区域的左上角坐标、源区域的宽度和高度，以及目标区域的左上角坐标作为参数。\n\n```csharp\nclass Program {\n\n    static void Main(string[] args)\n    {\n        // 在控制台输出字符串 \"GeeksForGeeks\"\n        Console.WriteLine(\"GeeksForGeeks\");\n\n        // 使用Console.MoveBufferArea方法移动控制台缓冲区的内容\n        // 将源区域的左上角坐标设为(0, 0)，宽度和高度设为控制台的宽度和高度\n        // 将目标区域的左上角坐标设为(10, 10)\n        Console.MoveBufferArea(0, 0, Console.BufferWidth,\n                           Console.BufferHeight, 10, 10);\n    }\n}\n```\n\n',1,112,556,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1067,'METest参数化测试方法','```csharp\n[DataTestMethod] //注明这个方法是参数化测试方法；\n[DataRow(\"0508\")] //一组参数，参数可以是任何值；但是一定要和参数的测试方法匹配。\n[DataRow(\"0509\")]\n[DataRow(\"0005\")]\npublic void GetFlag(string name)\n{\n    //act 执行部分 调用具有准备参数的待测方法\n    var r = fun.Flag(\"D\", \"R\", name);\n    //assert 断言部分 验证预期和实际结果是否相同\n    Assert.AreEqual(name, r);\n}\n```\n\n',1,137,562,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1068,'插入字符(Insert)','`Insert`方法用于在字符串中插入另一个字符串。它接受两个参数：插入位置和要插入的字符串。插入位置是指要在哪个索引位置插入字符串。如果插入位置超出了字符串的长度，则会在字符串的末尾插入\n\n```csharp\nstring str = \"GeeksForGeeks\";\nstr.Insert(5, \"GFG\"); //输出：GeeksGFGForGeeks\n```\n\n',1,113,563,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1069,'Null 检查','模式匹配最常见的方案之一是确保值不是 `null`。 使用以下示例进行 `null` 测试时，可以测试可为 null 的值类型并将其转换为其基础类型：\n\n```csharp\n//可空类型使用?符号来声明\nint? maybe = 12;\n\n//使用is关键字来进行类型检查\nif (maybe is int number)\n{\n    Console.WriteLine($\"The nullable int ''maybe'' has the value {number}\");\n}\nelse\n{\n    Console.WriteLine(\"The nullable int ''maybe'' doesn''t hold a value\");\n}\n```\n\n',1,138,113,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1070,'本地函数','本地函数是一种嵌套在另一成员中的类型的方法。 仅能从其包含成员中调用它们不能从外部访问。本地函数可以访问包含它们的函数的局部变量和参数。\n\n```csharp\nvoid Main()\n{\n    int x = 5;\n    int y = 10;\n    int result = AddNumbers(x, y);\n    Console.WriteLine(result);\n    //本地\n    int AddNumbers(int a, int b)\n    {\n        return a + b;\n    }\n}\n\n```\n\n',1,111,565,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1071,'switch常用模式','#### 声明模式\n\n首先检查`value`的类型，然后根据类型输出相应的消息\n\n```csharp\npublic void ShowMessage(object value)\n{\n    switch (value)\n    {\n        case int i: Console.WriteLine($\"value is int:{i}\"); break;\n        case long l: Console.WriteLine($\"value is long:{l}\"); break;\n        case bool b: Console.WriteLine($\"value is bool:{b}\"); break;\n        case string s: Console.WriteLine($\"value is string:{s}\"); break;\n        default: Console.WriteLine($\"value is object\"); break;\n    }\n}\n\n```\n\n#### 类型模式\n\n类型模式可以理解为在声明模式中使用了弃元：　　\n\n```csharp\npublic void ShowMessage(object value)\n{\n    switch (value)\n    {\n        case int: Console.WriteLine($\"value is int\"); break;\n        case long: Console.WriteLine($\"value is long\"); break;\n        case bool: Console.WriteLine($\"value is bool\"); break;\n        case string: Console.WriteLine($\"value is string\"); break;\n        default: Console.WriteLine($\"value is object\"); break;\n    }\n}\n\n```\n\n#### 常量模式\n\n　　常量模式可以理解为原来C#6.0及之前的用法：　　\n\n```csharp\nswitch (score)\n{\n    case 10:\n    case 9:\n        Console.WriteLine(\"优秀\");\n        break;\n    case 8:\n        Console.WriteLine(\"良好\");\n        break;\n    case 7:\n    case 6:\n        Console.WriteLine(\"及格\");\n        break;\n    default:\n        Console.WriteLine(\"不及格\");\n        break;\n}\n```\n\n####  关系模式　　\n\n```csharp\nswitch(score)\n{\n    case >=80:\n        Console.WriteLine(\"excellent\");\n        break;\n    case >=60:\n        Console.WriteLine(\"good\");\n        break;\n    default:\n        Console.WriteLine(\"poor\");\n        break;\n}\n```\n\n#### 逻辑模式　　\n\n```csharp\nswitch(value)\n{\n    case 0:\n        Console.WriteLine(\"value is 0\");\n        break;\n    case not 0 and(100 or - 100):\n        Console.WriteLine(\"abs(value)==100\");\n        break;\n    case not 0 and( > 0 and < 100):\n        Console.WriteLine(\"value is positive and less than 100\");\n        break;\n    case not 0 and > 0:\n        Console.WriteLine(\"value is positive and greater than 100\");\n        break;\n    case <-100 or( < 0 and > -100):\n        Console.WriteLine(\"value is negative and not equals -100\");\n        break;\n}\n```\n\n#### 属性模式\n\n```csharp\nswitch(time)\n{\n    case {\n        Year: 2020 or 2021,\n        Month: <= 6,\n        Day: 1\n    }\n    t:\n        Console.WriteLine($ \"the first day of every month in the first half of 2020 and 2021\");\n        break;\n    case {\n        Year: not 2022\n    }:\n        Console.WriteLine($ \"not 2022\");\n        break;\n    case {\n        DayOfWeek: not DayOfWeek.Sunday and not DayOfWeek.Saturday\n    }:\n        Console.WriteLine($ \"recursion\");\n        break;\n}\n```\n\n#### 位置模式\n\n　　位置模式采用解构的特性来说明指定的模式是否匹配：　　\n\n```csharp\npublic record Point2D(int X, int Y); //记录可以解构\nstatic void Print(Point2D point)\n{\n    switch(point)\n    {\n        case( > 0, > 0):\n            Console.WriteLine(\"first quadrant\");\n            break;\n        case( < 0, > 0):\n            Console.WriteLine(\"second quadrant\");\n            break;\n        case( < 0, < 0):\n            Console.WriteLine(\"third quadrant\");\n            break;\n        case( > 0, < 0):\n            Console.WriteLine(\"fourth quadrant\");\n            break;\n        default:\n            Console.WriteLine(\"coordinate axis\");\n            break;\n    }\n}\n```\n\n#### Var模式\n\n　　Var模式往往和属性模式和位置模式结合，用于提取属性变量值：　　\n\n```csharp\nswitch(point)\n{\n    case(var x,\n        var y,\n            var z):\n        Console.WriteLine($ \"3D point:({x},{y},{z})\");\n        break; //在位置模式中使用\n    case Point2D\n    {\n        X: var x, Y: var y\n    }:\n        Console.WriteLine($ \"2D point:({x},{y})\");\n        break; //在属性模式中使用\n    default:\n        Console.WriteLine(\"others\");\n        break;\n}\n```\n\n#### 弃元模式\n\n　　弃元模式在switch语句中用的不多，但是在switch表达式中使用的多：　　\n\n```csharp\nvar result = score\nswitch\n{ >= 80 => \"excellent\", >= 60 => \"good\",\n        _ => \"poor\" //弃元在switch表达式中就相当于default\n};\n```\n',1,139,221,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1072,'运行多个case语句组合','```csharp\nswitch (dayOfWeek)\n{\n    case DayOfWeek.Friday: Console.WriteLine(\"weekend\"); break;\n    case DayOfWeek.Saturday: // 多个case语句组合\n    case DayOfWeek.Sunday: Console.WriteLine(\"weekend\"); break;\n}\n```\n\n',1,139,221,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1073,'goto语句实现贯穿','注意使用避免死循环\n\n```csharp\nstring color = \"blue\";\nswitch (color)\n{\n    case \"red\": \n        Console.WriteLine(\"red\"); \n        goto default;\n    case \"green\": \n        Console.WriteLine(\"green\"); \n        goto case \"red\";\n    case \"blue\": \n        Console.WriteLine(\"blue\"); \n        goto case \"green\";\n    default: \n        Console.WriteLine(\"default\"); \n        break;\n}\n\n    //输出：\n    //blue\n    //green\n    //red\n    //default\n```\n\n　',1,139,221,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1074,'动态类型dynamic','动态类型是C#中的一个特性，它允许我们在编译时不确定变量的类型，而是在运行时确定。这种灵活性使得我们能够处理一些动态的情况，例如与动态语言的交互或者处理反射\n\n```csharp\n// 与静态类型相反，动态类型允许我们在运行时确定变量的类型。我们可以使用关键字dynamic来声明动态类型的变量\ndynamic value = 10;\nvalue = \"Hello\";\n```\n\n',1,140,569,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1075,'创建目录1','```csharp\nstring path = @\"C:\\MyDirectory\";\n\n// 创建目录\nDirectoryInfo directory = new DirectoryInfo(path);\ndirectory.Create();\n```\n\n',1,141,570,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1076,'创建目录2','```csharp\n// Main方法\nstatic void Main(string[] args)\n{\n    // 提示用户输入新目录的名称\n    Console.WriteLine(\"请输入新目录的名称：\");\n\n    // 读取用户输入的目录名称\n    string DirName = Console.ReadLine();\n\n    // 检查字符串是否为空\n    if (DirName != String.Empty)\n    {\n        // 创建目录\n        Directory.CreateDirectory(DirName);\n\n        // 检查目录是否成功创建\n        if (Directory.Exists(DirName))\n        {\n            // 输出目录创建成功的提示信息\n            Console.WriteLine(\"目录创建成功！\");\n            Console.ReadKey();\n        }\n    }\n}\n\n```\n\n',1,141,374,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1077,'获取目录信息','```csharp\nstring path = @\"C:\\MyDirectory\";\n\n// 获取目录信息\nDirectoryInfo directory = new DirectoryInfo(path);\n\n// 输出目录属性\nConsole.WriteLine(\"目录名称：\" + directory.Name);\nConsole.WriteLine(\"目录路径：\" + directory.FullName);\nConsole.WriteLine(\"创建时间：\" + directory.CreationTime);\nConsole.WriteLine(\"最后修改时间：\" + directory.LastWriteTime);\n```\n\n',1,141,570,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1078,'删除目录1','```csharp\nstring path = @\"C:\\MyDirectory\";\n\n// 删除目录\nDirectoryInfo directory = new DirectoryInfo(path);\ndirectory.Delete();\n```\n\n',1,141,570,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1079,'删除目录2','```csharp\nstatic void Main(string[] args)\n{\n    Console.WriteLine(\"请输入要删除的目录名称：\");\n\n    string DirName = Console.ReadLine();\n\n    // 检查目录是否存在\n    if (Directory.Exists(DirName))\n    {\n        // 删除目录（如果为空）\n        Directory.Delete(DirName);\n\n        // 检查目录是否成功删除\n        if (Directory.Exists(DirName) == false)\n            Console.WriteLine(\"目录删除成功...\");\n    }\n    else\n        Console.WriteLine(\"目录 {0} 不存在！\", DirName);\n\n    Console.ReadKey();\n}\n\n```\n\n',1,141,374,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1080,'重命名目录','使用`Directory.Move`方法将目录重命名为新的名称。\n\n```csharp\nstatic void Main(string[] args)\n{\n    Console.WriteLine(\"请输入要重命名的目录名称：\");\n    string DirName = Console.ReadLine();\n\n    // 检查目录是否存在\n    if (Directory.Exists(DirName))\n    {\n        Console.WriteLine(\"请输入新的目录名称：\");\n        string newDirName = Console.ReadLine();\n\n        if (newDirName != String.Empty) {\n\n            // 重命名目录\n            Directory.Move(DirName, newDirName);\n\n            // 检查目录是否被成功重命名\n            if (Directory.Exists(newDirName))\n            {\n                Console.WriteLine(\"目录已成功重命名为 \" + newDirName);\n                Console.ReadKey();\n            }\n        }\n    }\n}\n\n```\n\n',1,141,374,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1081,'获取目录下的文件和子目录','```csharp\nstring path = @\"C:\\MyDirectory\";\n\n// 获取目录信息\nDirectoryInfo directory = new DirectoryInfo(path);\n\n// 获取目录下的文件\nFileInfo[] files = directory.GetFiles();\nforeach (FileInfo file in files)\n{\n    Console.WriteLine(\"文件名称：\" + file.Name);\n    Console.WriteLine(\"文件路径：\" + file.FullName);\n}\n\n// 获取目录下的子目录\nDirectoryInfo[] subdirectories = directory.GetDirectories();\nforeach (DirectoryInfo subdirectory in subdirectories)\n{\n    Console.WriteLine(\"子目录名称：\" + subdirectory.Name);\n    Console.WriteLine(\"子目录路径：\" + subdirectory.FullName);\n}\n```\n\n',1,141,570,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1082,'获取指定目录下的所有文件','```csharp\nusing System;\nusing System.IO;\n\nclass Program\n{\n    static void Main()\n    {\n        // 获取目录\n        DirectoryInfo place = new DirectoryInfo(@\"C:\\Train\");\n\n        // 使用 GetFiles() 方法获取 Train 目录中的所有文件\n        FileInfo[] Files = place.GetFiles();\n        Console.WriteLine(\"Files are:\");\n        Console.WriteLine();\n\n        // 显示文件名\n        foreach(FileInfo i in Files)\n        {\n            Console.WriteLine(\"File Name - {0}\", i.Name);\n        }\n    }\n}\n```\n\n',1,141,570,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1083,'匿名函数','\n使用匿名函数来创建没有名称的函数。匿名函数是一种特殊类型的函数，它没有函数名，但可以被赋值给委托类型的变量，并且可以像普通函数一样被调用。\n\n- 委托（Delegate）：委托是一种类型，它可以持有对一个或多个方法的引用。通过委托，我们可以将方法作为参数传递给其他方法，或者将方法赋值给委托变量。\n- 匿名函数（Anonymous Function）：匿名函数是一种没有名称的函数，它可以被赋值给委托类型的变量，并且可以像普通函数一样被调用。\n\n```csharp\nusing System;\n\nclass GFG {\n\n    //我们首先定义了一个委托类型 petanim，它接受一个字符串类型的参数\n    public delegate void petanim(string pet);\n\n    // Main方法\n    static public void Main()\n    {\n\n        // 使用一个参数的匿名方法\n        petanim p = delegate(string mypet)\n        {\n            Console.WriteLine(\"我最喜欢的宠物是：{0}\", mypet);\n        };\n        p(\"狗\");\n    }\n}\n\n```\n\n匿名函数在某些情况下非常有用，特别是当我们只需要在特定的上下文中使用一次函数时。',1,111,578,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1084,'插值','数据绑定最常见的形式就是使用“Mustache” (双大括号) 语法的文本插值：\n\n```html\n<span>Message: {{ msg }}</span>\n```\n\n每次 `msg` 属性更改时它也会同步更新',2,3,580,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1085,'传递不同的值类型','```js\n// 定义一个props对象，包含title和likes两个属性\ndefineProps<{\n  title?: string\n  likes?: number\n}>()\n```\n\n```html\n//Number\n<!-- 静态的值，还是需要使用 v-bind -->\n<BlogPost :likes=\"42\" />\n\n<!--的值动态传入 -->\n<BlogPost :likes=\"post.likes\" />\n```\n\n```html\n//Boolean\n<!-- 仅写上 prop 但不传值，会隐式表达为 `true` -->\n<BlogPost is-published />\n\n<!-- 虽然 `false` 是静态的值，我们还是需要使用 v-bind -->\n<BlogPost :is-published=\"false\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :is-published=\"post.isPublished\" />\n```\n\n```html\n//Array\n<!-- 虽然这个数组是静态不变的值，我们还是需要使用 v-bind -->\n<BlogPost :comment-ids=\"[234, 266, 273]\" />\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :comment-ids=\"post.commentIds\" />\n```\n\n```html\n//Object\n<!-- 虽然这个对象字面量是静态不变的值，我们还是需要使用 v-bind -->\n<BlogPost\n  :author=\"{\n    name: ''Veronica'',\n    company: ''Veridian Dynamics''\n  }\"\n/>\n\n<!-- 根据一个变量的值动态传入 -->\n<BlogPost :author=\"post.author\" />\n```\n\n',2,2,42,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1086,'使用对象绑定多个prop','将一个对象的所有属性都当作 prop 传入，可以使用没有参数的 `v-bind`，即只是 `v-bind` 而非 `:prop-name`。\n\n```js\nconst post = {\n  id: 1,\n  title: ''我的 Vue 学习之旅''\n};\n```\n\n以及下面的模板：\n\n```html\n<BlogPost v-bind=\"post\" />\n```\n\n而这实际上等价于：\n\n```html\n<BlogPost :id=\"post.id\" :title=\"post.title\" />\n```\n\n',2,2,42,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1087,'自定义attribute的形式传递','当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：\n\n```js\n<BlogPost title=\"我的 Vue 学习之旅\" />\n<BlogPost title=\"Vue 博客文章总集\" />\n<BlogPost title=\"为什么 Vue 这么有趣\" />\n```\n\n',2,2,42,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1088,'使用v-for传递prop','如下的一个博客文章数组：\n\n```js\nconst posts = ref([\n  { id: 1, title: ''My journey with Vue'' },\n  { id: 2, title: ''Blogging with Vue'' },\n  { id: 3, title: ''Why Vue is so fun'' }\n]);\n```\n\n使用 `v-for` 来渲染：\n\n```js\n<BlogPost\n  v-for=\"post in posts\"\n  :key=\"post.id\"\n  :title=\"post.title\"\n  @click=\"TagSkip(post.id)\"\n />\n```\n\n',2,2,42,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1089,'mitt插件实现同级组件传值','#### 项目中安装mitt\n\n```\nnpm install --save mitt\n```\n\n#### 新建event.js\n\n```js\nimport mitt from ''mitt''\nconst VueEvent = mitt()\nexport default VueEvent\n```\n\n#### 使用\n\n```js\nimport VueEvent from ''@/plugins/event.js'' // 事件总线，同级组件传值\n// 触发\nVueEvent.emit(''collectionPlaylistID'', state.collectionPlaylist[0].id) // 传递给左侧组件，实现默认选中\n\n// 接收\nonMounted(() => {\n    VueEvent.on(''collectionPlaylistID'', data => {\n        state.cur = data // 默认选中\n    })\n})\n```\n\n离开组件时销毁绑定事件，要不当绑定多个事件的时候会有不必要的麻烦\n\n```js\n// 组件销毁完成后执行的函数\nonUnmounted(() => {\n    VueEvent.off(''comments'')\n})\n```\n\n',2,2,632,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1090,'异步组件','子组件的加载一般是按照先后顺序加载的，子组件加载后才会加载父组件。\n\n一个页面的子组件很多，由于会先加载子组件，那么父组件可能会出现比较长的白屏等待时间\n\n在大型项目，可能需要拆分应用为更小的块，并仅在需要时再从服务器加载相关组件Vue 提供`defineAsyncComponent`方法：\n\n```js\nimport { defineAsyncComponent } from ''vue''\n\nconst AsyncComp = defineAsyncComponent(() => {\n  return new Promise((resolve, reject) => {\n    // ...从服务器获取组件\n    resolve(/* 获取到的组件 */)\n  })\n})\n\n// ... 像使用其他一般组件一样使用 `AsyncComp`\n```\n\n',2,2,633,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1091,'使用ES动态导入异步组件','```js\nimport { defineAsyncComponent } from ''vue'';\n\nconst AsyncComp = defineAsyncComponent(() => import(''./components/MyComponent.vue''));\n```\n\n得到的 `AsyncComp` 是一个包裹组件，仅在页面需要它渲染时才调用加载函数。另外，它还会将 props 传给内部的组件，所以你可以使用这个异步的包裹组件无缝地替换原始组件，同时实现延迟加载',2,2,633,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1092,'处理异步组件加载与错误状态','异步操作不可避免地会涉及到加载和错误状态，因此 `defineAsyncComponent()` 也支持在高级选项中处理这些状态：\n\n```js\nconst AsyncComp = defineAsyncComponent({\n  // 加载函数\n  loader: () => import(''./Foo.vue''),\n\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n\n  // 展示加载组件前的延迟时间，默认为 200ms\n  delay: 200,\n\n  // 加载失败后展示的组件\n  errorComponent: ErrorComponent,\n\n  // 如果提供了一个 timeout 时间限制，并超时了\n  // 也会显示这里配置的报错组件，默认值是：Infinity\n  timeout: 3000\n})\n```\n\n如果提供了一个加载组件，它将在内部组件加载时先行显示。在加载组件显示之前有一个默认的 200ms 延迟——这是因为在网络状况较好时，加载完成得很快，加载组件和最终组件之间的替换太快可能产生闪烁，反而影响用户感受。\n\n如果提供了一个报错组件，则它会在加载器函数返回的 Promise 抛错时被渲染。你还可以指定一个超时时间，在请求耗时超过指定时间时也会渲染报错组件。',2,2,633,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1093,'动态加载函数方式导入异步组件','`import`默认导入的模块是静态的，如果我们将`import`用于动态导入模块，那么将放回一个 Promise，也就是说我们可以在`defineAsyncComponent`的加载函数中直接使用`import`来动态导入一个模块。\n\n**若非必要，请不要滥用动态导入**。\n\n```tsx\nimport { defineAsyncComponent } from ''vue'';\nconst VmdContent = defineAsyncComponent(() => {\n  return import(''@/components/editor/VmdContent.vue'');\n});\n```\n\n```html\n<VmdContent :loading=\"state.spinning\" :result=\"state.resultData.text\"></VmdContent>\n```\n\n',2,2,633,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1094,'new Promise导入异步组件','script setup\n\n```tsx\n// app.vue\nimport { onMounted, defineAsyncComponent } from ''vue'';\nimport Child from ''./child.vue'';\nconst AsyncChild = defineAsyncComponent(() => new Promise((resolve, reject) => resolve(Child)));\nonMounted(() => {\n  console.log(''app'');\n});\n```\n\n```html\n<template>\n  <AsyncChild />\n</template>\n```\n\n',2,2,633,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1095,'对象的方式导入异步组件','script setup\n\n```tsx\n// app.vue\nimport {ref, onMounted, defineAsyncComponent } from ''vue''\nimport LoadingComp from ''./LoadingComp.vue'' //加载中\nimport ErrorComp from ''./ErrorComp.vue'' //加载错误\nconst AsyncChild = defineAsyncComponent({\n    loader: () => (new Promise((resolve, reject) => reject())),\n    loadingComponent: LoadingComp,\n    delay: 200,\n    errorComponent: ErrorComp,\n    timeout: 2000\n})\nonMounted(() => {\n    console.log(''app'')\n})\nlet isShowAsyncComp = ref(false)\nconst loader = () => {\n  isShowAsyncComp.value = true\n}\n<template>\n    <button @click=\"loader\">加载异步组件</button>\n    <AsyncChild v-if=\"isShowAsyncComp\" />\n</template>\n```\n\n',2,2,633,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1096,'定义focus焦点指令','自定义 focus 指令，命名 vMyFocus，使用的就是 v-my-focus\n\n```vue\n<script setup lang=\"ts\">\nconst vMyFocus = {\n  onMounted: (el: HTMLInputElement) => {\n    el.focus();\n    // 在元素上做些操作\n  },\n};\n</script>\n<template>\n  <input v-my-focus value=\"111\" />\n</template>\n```\n\n',2,3,639,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1097,'指令的钩子函数','`mounted`其实就是指令的钩子函数，表示组件被挂载后调用；`el`则是指令绑定到的元素\n\n这里主要讲讲钩子函数，除了`mounted`以外，还有其他指令钩子，均为可选\n\n- `created`：在绑定元素的 attribute 或事件监听器被应用之前调用\n- `beforeMount`：当指令第一次绑定到元素并且在挂载父组件之前调用\n- `mounted`：在绑定元素的父组件被挂载后调用\n- `beforeUpdate`：在更新包含组件的 VNode 之前调用\n- `updated`：在包含组件的 VNode及其子组件的 VNode更新后调用\n- `beforeUnmount`：在卸载绑定元素的父组件之前调用\n- `unmounted`：当指令与元素解除绑定且父组件已卸载时，只调用一次\n\n#### 钩子函数的4个参数\n\n钩子函数的4个参数都是可选，分别是\n\n- `el`：用于直接操作 DOM，表示指令绑定到的元素\n- `binding`对象：包含以下6个属性\n\n```bash\ninstance：使用指令的组件实例\nvalue：传递给指令的值\noldValue：先前的值\narg：传递给指令的参数\nmodifiers：传递给指令的修饰符\ndir：一个对象，其实就是注册指令时传递的配置对象\n```\n\n- `vnode`：虚拟DOM，一个真实 DOM 元素的蓝图，对应el\n- `prevNode`：上一个虚拟节点\n\n',2,3,640,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1098,'定义全局指令','新建 directive.ts\n\n```tsx\nimport { App, DirectiveBinding } from ''vue'';\n\n// eslint-disable-next-line no-undef\nlet debounceTimer: NodeJS.Timeout | null, throttleTimer: NodeJS.Timeout | null;\n\nexport default (app: App<Element>) => {\n  //自动聚焦\n  app.directive(''focus'', {\n    mounted(el) {\n      el.focus();\n    }\n  });\n  //新指令从这加\n  app.directive(''指令名'', {\n    mounted(el) {\n      el.focus();\n    }\n  });\n};\n```\n\nmain 全局挂载\n\n```tsx\n// 引入全局自定义指令\nimport directive from ''@/utils/common/directive'';\n\napp.use(directive);\n```\n\n',2,3,641,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1099,'组件内自定义指令','如果是在`<script setup>`定义组件内的指令，有一个语法糖可以使用：任何以`v`开头的驼峰式命名的变量都可以被用作一个自定义指令，然后在模板中使用。举一个简单的例子：在输入框渲染后自动聚焦\n\n```vue\n<script setup>\n// 在模板中启用 v-focus\nconst vFocus = {\n  mounted: (el) => el.focus()\n}\n</script>\n\n<template>\n  <input v-focus />\n</template>\n```\n\n#### mian 中使用\n\n```js\n// main.js\nimport { createApp } from ''vue''\nimport App from ''./App.vue''\n\nconst app = createApp(App)\napp.directive(''focus'', {\n  mounted(el) {\n    el.focus();\n  }\n})\napp.mount(''#app'')\n```\n\n',2,3,642,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1100,'自定义指令生命周期','指令的生命周期和组件的生命周期类似：\n\n```js\nconst myDirective = {\n\n  // 在绑定元素的 attribute 前调用\n  // 或事件监听器应用前调用\n  created(el, binding, vnode, prevVnode) {},\n\n  // 在元素被插入到 DOM 前调用\n  beforeMount(el, binding, vnode, prevVnode) {},\n\n  // 在绑定元素的父组件及他自己的所有子节点都 挂载 完成后调用\n  mounted(el, binding, vnode, prevVnode) {},\n\n  // 绑定元素的父组件更新前调用\n  beforeUpdate(el, binding, vnode, prevVnode) {},\n\n  // 在绑定元素的父组件 及他自己的所有子节点都 更新 完成后调用\n  updated(el, binding, vnode, prevVnode) {},\n\n  // 绑定元素的父组件卸载之前调用\n  beforeUnmount(el, binding, vnode, prevVnode) {},\n\n  // 绑定元素的父组件卸载之后调用\n  unmounted(el, binding, vnode, prevVnode) {}\n  }\n}\n```\n\n',2,3,643,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1101,'声明预处理器','代码块使用 `lang` 这个 attribute 来声明预处理器语言，常见的用例就是在 `<script>` 中使用 TypeScript：\n\n```vue\n<script lang=\"ts\">\n  // use TypeScript\n</script>\n```\n\n`lang` 在任意块上都能使用，可以在 `<style>` 标签中使用 [Sass](https://sass-lang.com/) 或是 `<template>` 中使用Pug\n\n```vue\n<template lang=\"pug\">\np {{ msg }}\n</template>\n\n<style lang=\"scss\">\n  $primary-color: #333;\n  body {\n    color: $primary-color;\n  }\n</style>\n```\n\n',2,2,647,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1102,'组件作用域CSS','当 `<style>` 标签带有 `scoped` attribute 的时候，它的 CSS 只会影响当前组件的元素\n\n```vue\n<style scoped>\n.example {\n  color: red;\n}\n</style>\n\n<template>\n  <div class=\"example\">hi</div>\n</template>\n```\n\n#### 子组件的根元素\n\n使用 `scoped` 后，父组件的样式将不会渗透到子组件中。不过，子组件的根节点会同时被父组件的作用域样式和子组件的作用域样式影响。这样设计是为了让父组件可以从布局的角度出发，调整其子组件根元素的样式\n\n',2,2,648,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1103,'深度选择器','处于 `scoped` 样式中的选择器如果想要做更“深度”的选择，也即：影响到子组件，可以使用 `:deep()` 这个伪类：\n\n```vue\n<style scoped>\n.a :deep(.b) {\n  /* ... */\n}\n</style>\n```\n\n',2,2,346,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1104,'插槽选择器','默认情况下，作用域样式不会影响到 `<slot/>` 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 `:slotted` 伪类以明确地将插槽内容作为选择器的目标：\n\n```vue\n<style scoped>\n:slotted(div) {\n  color: red;\n}\n</style>\n```\n\n',2,2,650,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1105,'全局选择器','如果想让其中一个样式规则应用到全局，比起另外创建一个 `<style>`，可以使用 `:global` 伪类来实现 \n\n```vue\n<style scoped>\n:global(.red) {\n  color: red;\n}\n</style>\n```\n\n',2,2,651,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1106,'混合使用局部与全局样式','你也可以在同一个组件中同时包含作用域样式和非作用域样式：\n\n```vue\n<style>\n/* 全局样式 */\n</style>\n\n<style scoped>\n/* 局部样式 */\n</style>\n```\n\n',2,2,652,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1107,'与组合式API一同使用','```vue\nimport { useCssModule } from ''vue''\n\n// 在 setup() 作用域中...\n// 默认情况下, 返回 <style module> 的 class\nuseCssModule()\n\n// 具名情况下, 返回 <style module=\"classes\"> 的 class\nuseCssModule(''classes'')\n```\n\n',2,2,653,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1108,'窗口改变时获取宽高','实现一个窗口改变时获取宽高的 hook\n\n以export default导出\n\n```ts\n//useWindowResize.ts\nimport { onMounted, onUnmounted, ref } from ''vue'';\n\nfunction useWindowResize() {\n  const width = ref(0);\n  const height = ref(0);\n  //用于处理窗口大小变化的事件\n  function onResize() {\n    //获取当前窗口的宽度和高度，并将它们分别赋值\n    width.value = window.innerWidth;\n    height.value = window.innerHeight;\n  }\n  onMounted(() => {\n    //挂载后立即调用了onResize函数，以获取初始的窗口大小\n    window.addEventListener(''resize'', onResize);\n    onResize();\n  });\n  onUnmounted(() => {\n    //卸载时移除了窗口大小变化的事件监听器\n    window.removeEventListener(''resize'', onResize);\n  });\n  return {\n    width,\n    height\n  };\n}\n\nexport default useWindowResize;\n```\n\n```xml\n<template>\n  <h3>屏幕尺寸</h3>\n  <div>宽度：{{ width }}</div>\n  <div>高度：{{ height }}</div>\n</template>\n\n<script setup lang=\"ts\">\nimport useWindowResize from \"../hooks/useWindowResize.ts\";\nconst { width, height } = useWindowResize();\n</script>\n```\n\n',2,146,656,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1109,'defineComponent','它的存在是完全让传入的整个对象获得对应的类型，它的存在就是完全为了服务 TypeScript 而存在的。\n\n具有组件选项的对象\n\n```js\nimport { defineComponent } from ''vue''\n\nexport default defineComponent({\n  name:''Component'',\n  components: {},\n  emits: {},\n  props: {\n    goback: Boolean,\n    showTitle: {\n      type: Boolean,\n      default: true,\n    },\n    header: {\n      type: Object,\n      default: () => ({}),\n    },\n  },\n  data() {\n    return { count: 1 }\n  },\n  methods: {\n    increment() {\n      this.count++\n    }\n  }\n})\n\n```\n\n',2,4,175,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1110,'defineAsyncComponent','特性可以让我们延迟加载组件。这意味着它们仅在需要时从服务器加载。\n\n这是一个改善初始页面加载的好方法，因为我们的应用程序将以较小的块加载，而不必在页面加载时加载每个组件。\n\n### 简单用法\n\n```js\nimport { defineAsyncComponent } from ''vue''\n\n// 简单用法\nconst ArticleList = defineAsyncComponent(() =>\n  import(''@/components/ArticleList.vue'')\n)\n```\n\n### 配置参数\n\n```js\nconst AsyncPopup = defineAsyncComponent({\n  loader: () => import(''./ArticleList.vue''),\n  // 加载异步组件时使用的组件\n  loadingComponent: LoadingComponent,\n  // 加载失败时使用的组件\n  errorComponent: ErrorComponent\n  // 在显示加载组件之前延迟。默认值：200ms。\n  delay: 1000,\n  // 超过给定时间，则会显示错误组件。默认值：Infinity。\n  timeout: 3000\n})\n```\n\n',2,4,658,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1111,'ref()','- ref接受一个内部值，返回一个ref 对象，这个对象是响应式的、可更改的，且只有一个指向其内部值的属性 .value。\n- 当引用的值发生变化时，相关的组件将自动重新渲染。\n- 当ref的值为对象类型时，会用 reactive() 自动转换它的 .value\n\n类型:\n\n```js\nfunction ref<T>(value: T): Ref<UnwrapRef<T>>\n\ninterface Ref<T> {\n  value: T\n}\n```\n\n',2,147,285,4,2,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1112,'ref类型定义','ref 会根据初始化时的值推导其类型：\n\n```js\nimport { ref } from ''vue'';\n\n//数字\nconst numberRef = ref(0); \n\n//字符串\nconst stringRef = ref('''');\n\n//数组\nconst resUser: any = ref([]); \n\n//接口\ninterface IFoo {\n  bar: string;\n}\nconst fooRef = ref<IFoo>(); // ===> Ref<IFoo | undefined>\n\n//泛型类型\n//指定更复杂的类型\nconst year: Ref<string | number> = ref(''2020'');\nyear.value = 2020; // 成功！\n\n//如果指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 `undefined` 的联合类型\n// 推导得到的类型：Ref<number | undefined>\nconst n = ref<number>();\n\n\n//接口泛型参数\nimport { ref } from ''vue''\ninterface User {\n  name: string\n  age: string | number\n}\nconst user = ref<User>({\n  name:''前端开发爱好者'',\n  age: 20\n})\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1113,'ref类型断言','```js\n//as...类型断言\nexport const resClassify = ref([] as { id: number; name: string }[])\nexport const resClassify = ref([] as ClassifyListItem[])\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1114,'使用Ref接口指定类型','有时我们可能想为 ref 内的值指定一个更复杂的类型，可以通过使用 Ref 这个接口：\n\n```tsx\nimport { ref } from ''vue'';\nimport type { Ref } from ''vue'';\n\nconst year: Ref<string | number> = ref(''2020'');\nyear.value = 2020; // 成功！\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1115,'ref一般对象解构','ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性：\n\n```js\nconst obj = {\n  foo: ref(0),\n  bar: ref(1)\n}\n \n// 该函数接收一个 ref\n// 需要通过 .value 取值\n// 但它会保持响应性\ncallSomeFunction(obj.foo);\n \n// 仍然是响应式的\nconst { foo, bar } = obj;\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1116,'ref响应式替换对象','如果传入 ref 的是一个对象，将调用 `reactive` 方法进行深层响应转换。\n\n```js\nconst objectRef = ref({ count: 0 });\n// 这是响应式的替换\nobjectRef.value = { count: 1 };\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1117,'onMounted','在组件挂载完成后执行\n\n以下情况下被视为已挂载：\n\n- 其所有同步子组件都已经被挂载 (不包含异步组件或 `<Suspense>` 树内的组件)。\n- 其自身的 DOM 树已经创建完成并插入了父容器中。注意仅当根容器在文档中时，才可以保证组件 DOM 树也在文档中。\n\n**这个钩子在服务器端渲染期间不会被调用。**\n\n通过模板引用访问一个元素：\n\n```vue\n<script setup>\nimport { ref, onMounted } from ''vue''\n\nconst el = ref()\n\nonMounted(() => {\n  el.value // <div>\n})\n</script>\n\n<template>\n  <div ref=\"el\"></div>\n</template>\n```\n\n',2,142,132,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1118,'onUpdated','组件更新完成之后(视图发生变化)执行的函数。\n\n在组件的任意 DOM 更新后被调用，这些更新可能是由不同的状态变更导致的，因为多个状态变更可以在同一个渲染周期中批量执行（考虑到性能因素）。如果需要在某个特定的状态更改后访问更新后的 DOM，请使用 [nextTick()](https://cn.vuejs.org/api/general.html#nexttick) 作为替代\n\n**这个钩子在服务器端渲染期间不会被调用**\n\n不要在 updated 钩子中更改组件的状态，这可能会导致无限的更新循环！\n\n访问更新后的 DOM\n\n```vue\n<script setup>\nimport { ref, onUpdated } from ''vue''\n\nconst count = ref(0)\n\nonUpdated(() => {\n  // 文本内容应该与当前的 `count.value` 一致\n  console.log(document.getElementById(''count'').textContent)\n})\n</script>\n\n<template>\n  <button id=\"count\" @click=\"count++\">{{ count }}</button>\n</template>\n```\n\n',2,142,669,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1119,'onUnmounted','组件卸载(销毁)完成后执行的函数\n\n一个组件在以下情况下被视为已卸载：\n\n- 其所有子组件都已经被卸载。\n- 所有相关的响应式作用 (渲染作用以及 `setup()` 时创建的计算属性和侦听器) 都已经停止。\n\n可以在这个钩子中手动清理一些副作用，例如计时器、DOM 事件监听器或者与服务器的连接。\n\n**这个钩子在服务器端渲染期间不会被调用**\n\n```vue\n<script setup>\nimport { onMounted, onUnmounted } from ''vue''\n\nlet intervalId\nonMounted(() => {\n  intervalId = setInterval(() => {\n    // ...\n  })\n})\n\nonUnmounted(() => clearInterval(intervalId))\n</script>\n```\n\n',2,142,670,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1120,'onBeforeMount','组件挂载到节点上之前执行的函数\n\n当这个钩子被调用时，组件已经完成了其响应式状态的设置，但还没有创建 DOM 节点。它即将首次执行 DOM 渲染过程。\n\n**这个钩子在服务器端渲染期间不会被调用。**\n\n',2,142,671,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1121,'onBeforeUpdate','组件更新之前执行的函数\n\n这个钩子可以用来在 Vue 更新 DOM 之前访问 DOM 状态。在这个钩子中更改状态也是安全的。\n\n**这个钩子在服务器端渲染期间不会被调用。**',2,142,672,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1122,'onBeforeUnmount','组件卸载(销毁)之前执行的函数\n\n当这个钩子被调用时，组件实例依然还保有全部的功能。\n\n**这个钩子在服务器端渲染期间不会被调用。**',2,142,673,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1123,'onErrorCaptured','在捕获了后代组件传递的错误时调用\n\n错误可以从以下几个来源中捕获：\n\n- 组件渲染\n- 事件处理器\n- 生命周期钩子\n- `setup()` 函数\n- 侦听器\n- 自定义指令钩子\n- 过渡钩子\n\n',2,142,674,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1124,'onRenderTracked','当组件渲染过程中追踪到响应式依赖时调用\n\n**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ```js\n  function onRenderTracked(callback: DebuggerHook): void\n  \n  type DebuggerHook = (e: DebuggerEvent) => void\n  \n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TrackOpTypes /* ''get'' | ''has'' | ''iterate'' */\n    key: any\n  }\n  ```\n\n',2,142,675,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1125,'onRenderTriggered','当响应式依赖的变更触发了组件渲染时调用\n\n**这个钩子仅在开发模式下可用，且在服务器端渲染期间不会被调用。**\n\n- **类型**\n\n  ts\n\n  ```js\n  function onRenderTriggered(callback: DebuggerHook): void\n  \n  type DebuggerHook = (e: DebuggerEvent) => void\n  \n  type DebuggerEvent = {\n    effect: ReactiveEffect\n    target: object\n    type: TriggerOpTypes /* ''set'' | ''add'' | ''delete'' | ''clear'' */\n    key: any\n    newValue?: any\n    oldValue?: any\n    oldTarget?: Map<any, any> | Set<any>\n  }\n  ```\n\n',2,142,676,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1126,'onActivated','若组件实例是 KeepAlive缓存树的一部分，当组件被插入到 DOM 中时调用。\n\n**这个钩子在服务器端渲染期间不会被调用**',2,142,677,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1127,'onDeactivated','若组件实例是KeepAlive缓存树的一部分，当组件从 DOM 中被移除时调用。\n\n**这个钩子在服务器端渲染期间不会被调用**',2,142,678,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1128,'onServerPrefetch','在组件实例在服务器上被渲染之前调用\n\n- 如果这个钩子返回了一个 Promise，服务端渲染会在渲染该组件前等待该 Promise 完成。\n\n  这个钩子仅会在服务端渲染中执行，可以用于执行一些仅存在于服务端的数据抓取过程。\n\n- **示例**\n\n  vue\n\n  ```js\n  <script setup>\n  import { ref, onServerPrefetch, onMounted } from ''vue''\n  \n  const data = ref(null)\n  \n  onServerPrefetch(async () => {\n    // 组件作为初始请求的一部分被渲染\n    // 在服务器上预抓取数据，因为它比在客户端上更快。\n    data.value = await fetchOnServer(/* ... */)\n  })\n  \n  onMounted(async () => {\n    if (!data.value) {\n      // 如果数据在挂载时为空值，这意味着该组件\n      // 是在客户端动态渲染的。将转而执行\n      // 另一个客户端侧的抓取请求\n      data.value = await fetchOnClient(/* ... */)\n    }\n  })\n  </script>\n  ```\n\n',2,142,679,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1129,'ref在模板中解包','当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value。\n\n仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”\n\n```vue\n<script setup>\nimport { ref } from ''vue'';\nconst a = ref(1);\n</script>\n \n<template>\n  <!-- 无需 .value -->\n  <div>a:{{ a }}</div>\n</template>\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1130,'ref在数组和集合类型的解包','跟响应式对象不同，当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。\n\n```js\nimport { ref, reactive } from ''vue'';\nconst books = reactive([ref(''Vue 3 Guide'')]);\n// 这里需要 .value\nconsole.log(books[0].value);\n \nconst map = reactive(new Map([[''count'', ref(0)]]));\n// 这里需要 .value\nconsole.log(map.get(''count'').value);\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1131,'模板中使用ref','```vue\n<template>\n  <div ref=\"el\"></div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref } from ''vue'';\nconst el = ref<HTMLDivElement | null>(null);\n</script>\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1132,'组件中使用ref','如果子组件使用`<script setup lang=\"ts\">`，默认是全关闭的，子组件需使用defineExpose定义父组件能访问的属性\n\n```vue\n<template>\n  <HelloWorld ref=\"helloworld\" />\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, onMounted } from ''vue'';\nimport HelloWorld from ''@/components/HelloWorld.vue'';\n\nconst helloworld = ref<InstanceType<typeof HelloWorld> | null>(null);\n\nonMounted(() => {\n  //调用子组件的handleClick方法\n  helloworld.value?.handleClick();\n});\n</script>\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1133,'ref拿到dom引用','对 div 元素添加了 ref 属性，声明了一个与 ref 属性名称相同的变量 sectionRef，然后通过 sectionRef.value 的形式即可获取该 div 元素。\n\n```html\n<div ref=\"sectionRef\"></div>\n<button @click=\"higherAction\">变高</button>\n```\n\n```js\nconst sectionRef = ref();\nlet height = 100;\nconst higherAction = () => {\n  height += 50;\n  sectionRef.value.style = `height: ${height}px`;\n};\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1134,'ref将dom引用放到数组中','```vue\n<div class=\"demo2-container\">\n        <div class=\"list-section\">\n            <div :ref=\"setRefAction\" @click=\"higherAction(index)\" class=\"list-item\" v-for=\"(item, index) in state.list\" :key=\"index\">\n                <span>{{item}}</span>\n            </div>\n        </div>\n</div>\n\n<script setup lang=\"ts\">\nimport { reactive } from ''vue''\n\nconst state = reactive({\n    list: [1, 2, 3, 4, 5, 6, 7],\n    refList: [] as Array<any>\n})\n\nconst setRefAction = (el: any) => {\n    state.refList.push(el);\n}\n</script>\n```\n\n',2,147,285,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1135,'reactive()','用于创建一个响应式对象。它接收一个普通对象作为参数，并返回一个响应式的代理对象。当代理对象的属性发生变化时，相关的组件将自动重新渲染。\n\n提示：不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同\n\n- reactive是响应式数据对象\n\n* 作用是定义多个数据的响应式\n\n* 接收一个普通对象然后返回该普通对象的响应式代理器对象\n\n* 响应式转换是“深层的”：会影响对象内部所有嵌套的属性\n\n* 内部基于 ES6 的 `Proxy` 实现，通过代理对象操作源对象内部数据都是响应式的\n\n类型:\n\n```js\nfunction reactive<T extends object>(target: T): UnwrapNestedRefs<T>\n```\n\n',2,147,269,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1136,'reactive类型定义','```js\nimport { reactive } from ''vue'';\n//定义接口\ninterface IFoo {\n    bar: string\n}\n// 第一种\nconst book1 = reactive<IFoo>({ bar: ''bar'' })\n// 第二种\nconst book2: IFoo = reactive({ bar: ''bar'' })\n// 第三种\nconst book3 = reactive({ bar: ''bar'' }) as IFoo\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1137,'reactive解包refs','解包所有深层的 refs，同时维持 ref 的响应性。\n\n```ts\nconst count = ref(1);\nconst obj = reactive({});\nobj.count = count;\nconsole.log(obj.count); // 1\nconsole.log(obj.count === count.value); // true\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1138,'reactive解构对象属性','从响应式对象中解构属性时，我们会失去响应性：\n\n```js\nconst state = reactive({ count: 0 });\n// 函数接受一个纯数字\n// 并不会追踪 state.count 的变化\ncallSomeFunction(state.count);\n// count 已经是一个\n// 与 state 响应性失去连接的纯数字\nlet { count } = state;\n// 不会影响原状态\ncount++;\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1139,'reactive默认隐式推导','`reactive()` 也会隐式地从它的参数中推导类型：\n\n```js\n// 推导得到的类型：{ title: string }\nconst book = reactive({ title: ''Vue 3 指引'' });\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1140,'reactive显式推导','显式地标注一个 `reactive` property 的类型，可以使用接口\n\n```js\ninterface Book {\n  title: string\n  year?: number\n}\nconst book: Book = reactive({ title: ''Vue 3 指引'' })\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1141,'reactive通过接口指定类型','要显式地指定一个 `reactive` 变量的类型，我们可以使用接口：\n\n```ts\nimport { reactive } from ''vue'';\ninterface Book {\n  title: string;\n  year?: number;\n}\nconst book: Book = reactive({ title: ''Vue 3 指引'' });\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1142,'reactive通过泛型参数的形式增加类型','```js\nimport { reactive } from ''vue''\n\ninterface User {\n  name: string\n  age: string | number\n}\n\nconst user = reactive<User>({\n  name:\"前端开发爱好者\",\n  age:''20''\n})\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1143,'computed()','`computed`方法会自动推导出类型,使用**计算属性**来描述依赖响应式状态的复杂逻辑\n\n`computed`函数有两种用法，都是用来监听数据的变化。\n\n\n```js\nimport { computed, ref } from ''vue'';\n\nconst count = ref(1);\n\n// // 一个计算属性 ref\nconst doubleCount = computed(() => {\n  return count.value * 2;\n});\n```\n\n计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`\n\n```html\n<template>\n  <span>{{ doubleCount }}</span>\n</template>\n```\n\n',2,147,694,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1144,'computed隐式类型推导','```js\nimport { ref, computed } from ''vue'';\n\nlet count = ref(0);\n\n// 推导得到的类型：ComputedRef<number>\nconst double = computed(() => count.value * 2);\n\n// => TS Error: Property ''split'' does not exist on type ''number''\nconst result = double.value.split('''');\n```\n\n',2,147,694,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1145,'computed显示指定类型','```js\nconst double =\n  computed <\n  number >\n  (() => {\n    // 若返回值不是 number 类型则会报错\n  });\n```\n\n',2,147,694,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1146,'computed可写属性','计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：\n\n```js\nimport { ref, computed } from ''vue'';\n\nconst firstName = ref(''John'');\nconst lastName = ref(''Doe'');\n\nconst fullName = computed({\n  // getter\n  get() {\n    return firstName.value + '' '' + lastName.value;\n  },\n  // setter\n  set(newValue) {\n    // 注意：我们这里使用的是解构赋值语法\n    [firstName.value, lastName.value] = newValue.split('' '');\n  }\n});\n```\n\n现在当你再运行 `fullName.value = ''John Doe''` 时，setter 会被调用而 `firstName` 和 `lastName` 会随之更新。\n\n',2,147,694,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1147,'依赖注入示例','顶级组件：\n\n```vue\n<template>\n    <son />\n</template>\n\n<script setup>\nimport son from \"./son.vue\";\nimport { provide } from \"vue\";\nprovide(\"abc\", \"123\");\n</script>\n```\n\n子组件：\n\n```vue\n<template>\n    <grandson />\n</template>\n\n<script setup>\nimport grandson from \"./grandson.vue\";\n</script>\n```\n\n孙组件：\n\n```vue\n<template>\n  <div>我是孙子</div>\n</template>\n\n<script setup>\nimport { inject } from \"vue\";\nconst abc = inject(\"abc\");\nconsole.log(abc);\n</script>\n```\n\n',2,148,705,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1148,'isRef()','用于检查值是否为一个 ref 对象。\n\n```js\n  const num = ref(10)\n  const num1 = 20\n  const num2 = reactive({ data: 30 })\n  \n  console.log(isRef(num)) //true\n  console.log(isRef(num1)) //false\n  console.log(isRef(num2)) //false\n```\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1149,'unref()','如果参数是`ref`，则返回内部值，否则返回参数本身。 这是 `val = isRef(val) ? val.value : val` 计算的一个语法糖。\n\n```vue\n<script>\nimport { ref, unref } from ''vue''\nexport default {\n  setup() {\n    const name = ref(''test'');\n    const age = 18;\n    console.log(unref(name)); // test\n    console.log(unref(age)); // 18\n  }\n}\n</script>\n```\n\n可以认为 name.value === unref(name)\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1150,'toRef()','toRef 是函数，转换**响应式对象**中**某个**属性为单独响应式数据，并且**值是关联的**\n\n把 `reactive` 创建的响应对象中的某个属性变成一个单独的 `ref` ，但这个新 `ref` 与原对象是保持响应式连接的。\n\n响应式变量 = toRef(响应式对象, \"属性名\")- 值是相关联的\n\n```js\nimport { reactive, toRef } from ''vue'';\nconst person = reactive({\n  name: ''test'',\n  age: 18\n});\nconst newAge = toRef(person, ''age'');\n\nfunction update() {\n  newAge.value = 20;\n}\n```\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1151,'toRefs()   ','解构响应式对象\n\n`toRef` 的批量操作，它的主要作用:\n\n- 将 `reactive` 创建的响应对象中每个属性变成单独的 `ref`。\n- 结合 `ES6` 的解构，可以使 `reactive` 对象的属性在模板中直接被使用，再也不需要通过 `xx.属性` 的形式。\n\n> 需要注意的是，若直接对 `reactive` 创建的对象解构，会失去响应式！\n\n```html\n<script>\n  import { reactive, toRef, toRefs } from ''vue'';\n  const person1 = reactive({\n    name: ''test''\n  });\n  const person2 = reactive({\n    age: 18\n  });\n\n  function update() {\n    person1.name = ''YDYDYDQ'';\n    person2.age = 20;\n  }\n\n  return {\n    ...toRefs(person1),\n    ...person2, // 直接解构, 会失去响应式\n    add\n  };\n</script>\n```\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1152,'isReactive()','检查一个对象是否是由 `reactive` 或 shallowReactive 创建的代理。\n\n```html\n<script>\n  import { ref, reactive, isReactive } from ''vue'';\n  export default {\n    setup() {\n      const name = ref(''test'');\n      const person = reactive({});\n      console.log(isReactive(name)); // false\n      console.log(isReactive(person)); // true\n    }\n  };\n</script>\n```\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1153,'isProxy()','检查一个对象是否是由 `reactive`、`readonly`、`shallowReactive` 或 `shallowReadonly` 创建的代理。\n\n```html\n<script>\n  import { ref, reactive, isProxy } from ''vue'';\n  export default {\n    setup() {\n      const name = ref(''test'');\n      const person = reactive({});\n      const age = 18;\n\n      console.log(isProxy(name)); // false\n      console.log(isProxy(person)); // true\n      console.log(isProxy(age)); // false\n    }\n  };\n</script>\n```\n\n',2,147,285,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1154,'Transition','- `<Transition>` 会在一个元素或组件进入和离开 DOM 时应用动画。\n- `<TransitionGroup>` 会在一个元素或组件被插入到 `v-for` 列表中，或是被移动或从其中移除时应用动画。\n\n除了这两个组件，也可以通过其他技术手段来应用动画，如切换 CSS 类或用状态绑定样式来驱动动画。\n\n',2,2,720,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1155,'透传attribute','透传 attribute指的是传递给一个组件，却没有被该组件声明为 **props**或**emits** 的 attribute 或者 v-on 事件监听器。常见的有 `class` `style` `id`.\n\n简单的理解就是：传递给子组件的属性，但是被没有在子组件声明，就是**透传 attributes**。',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1156,'Attribute的继承','当一个组件以单个元素为根作渲染时，透传的 attribute 会自动添加到根元素的 attribute 中。\n\n下面这个组件有这样的模板：\n\n```html\n<!-- <MyButton> 的模板 -->\n<button>click me</button>\n```\n\n父组件使用这个组件：\n\n```html\n<MyButton class=\"large\" />\n```\n\n渲染出 DOM 结果是：\n\n```html\n<button class=\"large\">click me</button>\n```\n\n',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1157,'class和style的值合并','一个子组件的根元素已经有了 `class` 或 `style` attribute，它会和从父组件上继承的值合并。\n\n**子组件有多个根节点**\n\n如果没有手动处理的话，是会存在警告的。\n\n将之前的组件的模板改成这样：\n\n存在自身的类名 `btn`\n\n```html\n//子组件只有一个根节点\n<!--MyButton子组件-->\n<template>\n<button class=\"btn\">click me</button>\n</template>\n```\n\n父组件使用子组件：\n\n```html\n<MyButton class=\"large\" />\n```\n\n渲染出的 DOM 结果是：\n\n```html\n<button class=\"btn large\">click me</button>\n```\n\n就会主动的绑定到根节点上去，与原来的 class 进行组合',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1158,'v-on透传事件绑定','同样的规则也适用于 `v-on` 事件监听器：\n\n表现形式跟样式绑定是基本一样的\n\n```html\n <!--子组件Son-->\n <script setup lang=\"ts\">\n const btn1 = () => {\n   console.log(\"子组件的点击事件\");\n };\n </script>\n <template>\n   <button @click=\"btn1\">点击</button>\n </template>\n\n```\n\n子组件的根节点是一个 button 标签，并且上面绑定了一个点击事件\n\n```vue\n <!--父组件使用-->\n <script setup lang=\"ts\">\n import Son from \"./Son.vue\";\n const btn = () => {\n   console.log(\"父组件的点击事件\");\n };\n </script>\n\n <template>\n   <Son @click=\"btn\" />\n </template>\n\n```\n\n父组件调用，也传递了一个透传的事件过来。当点击按钮\n\n子组件的事件被触发了，父组件传递过来的事件也被触发了，顺序为**先子后父**',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1159,'组件嵌套中的透传','有些情况下一个组件会在根节点上渲染另一个组件。那么透传 attributes 也会继续传递下去\n\n```html\n <!--baseChild-->\n <template>\n   <div></div>\n </template>\n   \n <!--child-->\n <template>\n   <base-child />\n </template>\n \n <!--father-->\n <Child class=''abc''/>\n```\n\n那么最后渲染的结果：\n\n```ini\n <div class=''abc''></div>\n```\n\n',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1160,'禁用Attribute','如果不想要一个组件自动地继承 attribute，可以在组件选项中设置 `inheritAttrs: false`。\n\n如果你使用了 `<script setup>`，你需要一个额外的 `<script>` 块来书写这个选项声明：\n\n```html\n <!--如果是setup写法，就需要单独添加一个script标签，暴露一个配置对象-->\n <script lang=\"ts\">\n export default {\n   inheritAttrs: false, // 禁用\n };\n </script>\n \n <script setup lang=\"ts\">\n const btn1 = () => {\n   console.log(\"子组件的点击事件\");\n };\n </script>\n \n <template>\n   <button @click=\"btn1\">点击</button>\n </template>\n```\n\n注意的是：\n\n- 和 props 有所不同，透传 attributes 在 JavaScript 中**保留了它们原始的大小写**，所以像 foo-bar 这样的一个 attribute 需要通过 `$attrs[''foo-bar'']` 来访问。\n- 像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 `$attrs.onClick`',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1161,'多根节点Attribute继承','和单根节点组件有所不同，有着多个根节点的组件没有自动 attribute 透传行为。\n\n```html\n<CustomLayout id=\"custom-layout\" @click=\"changeValue\" />\n```\n\n如果 `<CustomLayout>` 有下面这样的多根节点模板，由于 Vue 不知道要将 attribute 透传到哪里，所以会抛出一个警告。\n\n```html\n<header>...</header>\n<main>...</main>\n<footer>...</footer>\n```\n\n如果 `$attrs` 被显式绑定，则不会有警告：\n\n```html\n<header>...</header>\n<main v-bind=\"$attrs\">...</main>\n<footer>...</footer>\n```\n\n',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1162,'JavaScript中访问Attributes','可以在 `<script setup>` 中使用 `useAttrs()` API 来访问一个组件的所有透传 attribute：\n\n```html\n<script setup>\n  import { useAttrs } from ''vue'';\n\n  const attrs = useAttrs();\n</script>\n```\n\n如果没有使用 `<script setup>`，`attrs` 会作为 `setup()` 上下文对象的一个属性暴露：\n\n```vue\nexport default { setup(props, ctx) { // 透传 attribute 被暴露为 ctx.attrs console.log(ctx.attrs) } }\n```\n\n需要注意的是，虽然这里的 `attrs` 对象总是反映为最新的透传 attribute，但它并不是响应式的 (考虑到性能因素)。你不能通过侦听器去监听它的变化。如果你需要响应性，可以使用 prop。或者你也可以使用 `onUpdated()` 以在每次更新时结合最新的 `attrs` 执行副作用。',2,150,723,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1163,'单文件组件定义','将组件定义在一个单独的`.vue`文件中，这被叫做单文件组件（Single-File Component，简称 SFC）\n\n```html\n<script setup>\nimport { ref } from ''vue''\n\nconst count = ref(0)\n</script>\n\n<template>\n  <button @click=\"count++\">点击了 {{ count }} 次</button>\n</template>\n```',2,2,645,4,4,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1164,'单文件组件','Vue 的单文件组件会将一个组件的逻辑（JavaScript），模板（HTML）和样式（CSS）封装在同一个文件里。下面我们将用单文件组件的格式重写上面的计数器示例：\n\n```vue\n<script>\nexport default {\n  data() {\n    return {\n      count: 0\n    }\n  }\n}\n</script>\n\n<template>\n  <button @click=\"count++\"> Count is: {{ count }} </button>\n</templat>\n\n<style scoped>\nbutton {\n  font-weight: bold;\n}\n</style>\n```\n\n单文件组件是 Vue 的标志性功能。如果你的用例需要进行构建，我们推荐用它来编写 Vue 组件。\n\n',2,2,732,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1165,'DOM更新时机','更改响应式状态后，DOM会自动更新。然而要注意 DOM 的更新并**不是同步的**。相反，Vue 将缓冲它们直到更新周期的“next tick”执行，以确保无论你进行了多少次状态更改，每个**组件**都只需要**更新一次**。\n简单的理解是：**当数据更新了，在dom中渲染后，自动执行该函数**\n\n若要等待一个状态改变后的 DOM 更新完成，你可以使用`nextTick()`这个全局 API：\n\n```js\nimport { nextTick } from ''vue''\n\nfunction increment() {\n  count.value++\n  nextTick(() => {\n    // 访问更新后的 DOM\n  })\n}\n```\n\n\n\n',2,147,646,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1166,'跨组件传值','#### 1. key是Symbol\n\n新建src/constant/index.ts\n\n```vue\nimport type { InjectionKey } from ''vue'';\n\nexport const key = Symbol() as InjectionKey<string>;\n<!-- 父组件使用provide提供值 -->\n<script setup lang=\"ts\">\nimport { provide } from ''vue'';\nimport { key } from ''@/constant/index'';\nprovide(key, ''123''); //提供改变响应式对象的方法\n</script>\n\n<!-- 子组件使用inject取值 -->\n<script setup lang=\"ts\">\nimport { inject } from ''vue'';\nimport { key } from ''@/constant/index'';\n\nconst string = inject(key);\n</script>\n```\n\n#### 2. key是字符串\n\ninject返回的类型是 unknown，需要通过泛型参数显式声明\n\n```vue\n<!-- 父组件提供provide -->\n<script setup lang=\"ts\">\nimport { ref, provide } from ''vue'';\nconst state = ref(0);\nconst handlerState = () => {\n  state.value = 1;\n};\nprovide(''info'', state); //提供响应式对象\nprovide(''func'', handlerState); //提供改变响应式对象的方法\n</script>\n\n<!-- 子组件使用inject取值 -->\n<script setup lang=\"ts\">\nimport { inject } from ''vue'';\n\n//通过泛型参数显式声明\nconst state = inject<number>(''info'');\nconst func = inject<() => void>(''func'');\n</script>\n```\n\n#### 3. undefined问题\n\n由于无法保证provide会提供这个值，因此inject通过泛型参数显示声明了类型，还会多个undefined类型\n\n1. 提供默认值，可消除undefined\n\n```js\nconst state = inject<number>(''info'', 20);\n```\n\n1. 使用类型断言，告诉编辑器这个值一定会提供\n\n```js\nconst state = inject(''info'') as number;\n```\n\n',2,148,734,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1167,'reactive局限性','`reactive()` API 有两条限制：\n\n- 仅对**对象**类型有效（对象、数组和Map、Set这样的`集合类型`），对string、number和boolean这样的`基础类型`无效。\n-  Vue 的响应式系统是通过**对象的属性**（property）访问进行追踪的，因此必须始终**保持对该响应式对象的\\*相同引用\\***。意味着不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的响应性连接丢失。更新响应式对象属性的值，不会丧失响应性。\n\n```js\nlet state = reactive({ count: 0 })\n\n// 把已经创建的具备响应式的变量 state ，重新赋值，state 会失去响应性。\nstate = reactive({ count: 1 })\n```\n\n将响应式对象的属性赋值给一个新变量时，此新变量失去响应性。\n\n```js\nconst state = reactive({ count: 0 })\n\n//把具备响应性 state.count 赋值给变量 n，那么 n 不具备响应性\nlet n = state.count\n\n// 变量 n 自增加，并不影响 state.count 状态\nn++\n```\n\n解构响应式对象，至本地变量时，解构出来的变量失去响应性。\n\n```js\nconst state = reactive({ count: 0 })\n// count 也和 state.count 失去了响应性连接\nlet { count } = state\n\n// 不会影响原状态\ncount++\n```\n\n**将响应式对象的任何属性传入一个函数时，此对象将会失去响应性**。\n\n```js\nconst state = reactive({ count: 0 })\n// 更换响应式对象的属性的值，其对象的响应性不会丢失。\nstate.count = 10\n\n// 对响应式对象传入一个函数后，state 对象会丧失响应性，并且将无法跟踪 state.count 的变化\ncallSomeFunction(state.count)\n```\n\n',2,147,269,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1168,'watch侦听来源类型','`watch`的第一个参数，可以是不同形式的“数据源”：它可以是一个ref（包括计算属性）、一个响应式对象、一个getter函数、或多个来源组成的数组：\n\n```js\nconst x = ref(0)\nconst y = ref(0)\n\n// 单个 ref\nwatch(x, (newX) => {\n  console.log(`x is ${newX}`)\n})\n\n// getter 函数\nwatch(\n  () => x.value + y.value,\n  (sum) => {\n    console.log(`sum of x + y is: ${sum}`)\n  }\n)\n\n// 多个来源组成的数组\nwatch([x, () => y.value], ([newX, newY]) => {\n  console.log(`x is ${newX} and y is ${newY}`)\n})\n```\n\n**不能直接**侦听响应式对象的属性值，例如:\n\n```js\nconst obj = reactive({ count: 0 })\n\n// 这不会正常工作，因为你是向 watch() 传入了一个 number\nwatch(obj.count, (count) => {\n  console.log(`count is: ${count}`)\n})\n```\n\n若需要侦听响应式对象的属性值，而是**用getter函数**：\n\n```js\n// 提供一个 getter 函数\nwatch(\n  () => obj.count,\n  (count) => {\n    console.log(`count is: ${count}`)\n  }\n)\n```\n\n',2,151,736,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1169,'侦听回调的刷新时机','更改响应式状态，可能会同时触发 Vue 组件更新和侦听器回调。\n\n默认情况下，用户创建的**侦听器**回调，都会**在 Vue 组件更新之前**被调用。这意味着，你在侦听器回调中，访问的 DOM 将是被 Vue 更新之前的状态。如果想在侦听器回调中，能访问被 Vue 更新*之后*的DOM，你需要指明`flush:''post''`选项：\n\n```js\nwatch(source, callback, {\n  flush: ''post''\n})\n\nwatchEffect(callback, {\n  flush: ''post''\n})\n```\n\n后置刷新的`watchEffect()`有个更方便的别名`watchPostEffect()`：\n\n```js\nimport { watchPostEffect } from ''vue''\n\nwatchPostEffect(() => {\n   /* 在 Vue 更新后执行 */\n})\n```\n\n',2,151,64,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1170,'停止侦听器.','在`setup()`或`<script setup>`中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。因此，在大多数情况下，你无需关心怎么停止一个侦听器。\n\n一个关键点是，侦听器必须用**同步**语句创建：如果用**异步**回调创建一个侦听器，那么它不会绑定到当前组件上，必须手动停止，以防内存泄漏。\n\n```vue\n<script setup>\nimport { watchEffect } from ''vue''\n\n// 它会自动停止\nwatchEffect(() => {})\n\n// ...这个则不会！\nsetTimeout(() => {\n   watchEffect(() => {})\n}, 100)\n</script>\n```\n\n要手动停止一个侦听器，请调用`watch`或`watchEffect`返回的函数：\n\n```js\nconst unwatch = watchEffect(() => {})\n\n// ...当该侦听器不再需要时\nonBeforeUnmount(() =>unwatch())\n```\n\n注意，需要异步创建侦听器的情况很少，请尽可能选择同步创建。如果需要等待一些异步数据，你可以使用条件式的侦听逻辑：\n\n```js\n// 需要异步请求得到的数据\nconst data = ref(null)\n\nwatchEffect(() => {\n  if (data.value) {\n    // 得到数据后要做的事...\n  }\n})\n```\n\n',2,151,64,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1171,'v-for遍历整数','直接传给`v-for`一个**整数值**。在这种用例中，将会将该模板基于`1...n`的取值范围重复多次。\n\n```html\n<span v-for=\"n in 5\">{{ n }}</span>\n```\n\n​	渲染结果：\n\n```html\n<span>1</span>\n<span>2</span>\n<span>3</span>\n<span>4</span>\n<span>5</span>\n```\n\n注意此处n的初值是从*1*开始而非*0*。',2,3,597,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1172,'template中使用v-for','与模板上的`v-if`类似，也可以在`<template>`标签上使用`v-for`来渲染包含多个元素的一个块。例如：\n\n```html\n<ul>\n  <template v-for=\"item in items\">\n    <li>{{ item.msg }}</li>\n    <li class=\"divider\" role=\"presentation\"></li>\n  </template>\n</ul>\n```\n\n',2,3,597,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1173,'单选框(radio)使用v-model','```js\nconst picked = ref('''')\n```\n\n```html\n<div>Picked: {{ picked }}</div>\n<input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\" />\n<label for=\"one\">One</label>\n\n<input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\" />\n<label for=\"two\">Two</label>\n```\n\n',2,3,621,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1174,'注册周期钩子','`onMounted`钩子，可以用来在组件完成初始渲染并创建 DOM 节点后运行代码。\n\n```vue\n<script setup>\nimport { onMounted } from ''vue''\n\nonMounted(() => {\n  console.log(`the component is now mounted.`)\n})\n</script>\n```\n\n',2,142,743,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1175,'组件触发与监听事件.','组件的模板表达式中，可以直接使用*$emit()*函数**触发**自定义事件(例如：在`v-on`的处理函数中)：\n\n```html\n<!-- MyComponent -->\n<button @click=\"$emit(''someEvent'')\">click me</button>\n```\n\n父组件可以通过`v-on`（缩写为`@`）来**监听**事件：\n\n```html\n<MyComponent @some-event=\"callback\" />\n```\n\n同样，组件的事件监听器也支持`.once`修饰符：\n\n```html\n<MyComponent @some-event.once=\"callback\" />\n```\n\n组件与 prop 一样，事件的名字也提供了**自动转换**。请注意，我们触发了一个以*camelCase*形式命名的事件，但在父组件中可以使用*kebab-case*形式来监听。与 prop 大小写格式一样，**在模板中推荐使用kebab-case形式来编写监听器**。\n\nTIP：和原生 DOM 事件不太一样，组件触发的事件**不会冒泡**。你只能监听直接子组件触发的事件。',2,2,61,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1176,'组件事件参数','需要在触发事件时附带一个特定的值。举个例子，我们想要`<BlogPost>`组件来管理文本会缩放得多大。在这个场景下，我们可以给`$emit`提供一个值作为额外的参数：\n\n```html\n<button @click=\"$emit(''increaseBy'', 1)\">\n  Increase by 1\n</button>		\n```\n\n然后在父组件中监听事件，我们可以先简单写一个内联的箭头函数作为监听器，此时可以访问到事件附带的参数：\n\n```vue\n<MyButton @increase-by=\"(n) => count += n\" />\n```\n\n或用一个方法函数来作为事件处理函数：\n\n```vue\n<MyButton @increase-by=\"increaseCount\" />\n```\n\n然后，可以从方法的第一个参数上取到这个值：\n\n```js\n//js\nfunction increaseCount(n) {\n  count.value += n\n}\n```\n\n传入*$emit()*的**所有参数**都会被直接传向监听器。\n\n```vue\ntemplate\n<MyButton @foo=\"increase\" />\n\njs\nfunction increase(n1,n2,n3) {\n  //......\n}\n\nMyButton.vue\n监听器 foo，将会收到这三个参数值\n<button @click=\"$emit(''foo'', 1, 2, 3)\">\n  Increase by 1\n</button> \n```\n\n> *emit()*中传值的参数类型，是*任意类型*，可以是字符串、数字、布尔值、数组、对象等等。\n\n',2,2,61,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1177,'依赖注入响应性','当使用响应式`provide/inject`值时，建议尽可能将任何对响应式状态的变更都保持在*provider*内部。这样可以确保`provide`的状态和变更操作都在同一个组件内，使其更容易维护。\n\n有时候，可能需要在*injector*组件中更改数据。这种情况下，推荐provider组件内，提供一个更改数据方法：\n\n### provider组件内\n\n```vue\n<!-- 在 provider 组件内 -->\n<script setup>\nimport { provide, ref } from ''vue''\n\nconst location = ref(''North Pole'')\n\nfunction updateLocation() {\n  location.value = ''South Pole''\n}\n\nprovide(''location'', {\n  location,\n  updateLocation\n})\n    \n```\n\n### injector组件\n\n```vue\n</script>\n<!-- 在 injector 组件 -->\n<script setup>\nimport { inject } from ''vue''\n\nconst { location, updateLocation } = inject(''location'')\n</script>\n\n<template>\n  <button @click=\"updateLocation\">{{ location }}</button>\n</template>\n```\n\n\n\n如果你想确保从*provider*传过来的数据不能被*injector*的组件更改，你可以使用*readonly()*来包装提供的值。\n\n```vue\n<script setup>\nimport { ref, provide, readonly } from ''vue''\n\nconst count = ref(0)\nprovide(''read-only-count'', readonly(count))\n</script>\n```\n\n',2,148,705,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1178,'使用Symbol作注入名','我们已经了解了如何使用字符串作为注入名。但如果你正在构建大型的应用程序，包含非常多的依赖提供，或者你正在编写提提供其他开发者使用的组件库，建议最好使用`Symbol`来作为注入名，以避免潜在的冲突。\n\n建议在一个单独的文件中导出这些注入名 Symbol：\n\n```js\n// keys.js\nexport const myInjectionKey = Symbol()\n// 在提供方组件中\nimport { provide } from ''vue''\nimport { myInjectionKey } from ''./keys.js''\n\nprovide(myInjectionKey, { /* 要提供的数据 */ });\n// 注入方组件\nimport { inject } from ''vue''\nimport { myInjectionKey } from ''./keys.js''\n\nconst injected = inject(myInjectionKey)\n```\n\n',2,148,747,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1179,'如何使用插槽','- 定义插槽slot：\n\n- - 插槽的使用过程其实是抽取共性、预留不同；\n  - 将共同的元素、内容依然在组件内进行封装；\n  - 同时会将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素；\n\n- 如何使用slot呢？\n\n- - Vue中将 slot 元素作为承载分发内容的出口；\n  - 在封装组件中，使用特殊的元素slot就可以为封装组件开启一个插槽；\n  - 该插槽插入什么内容取决于父组件如何使用；\n\n\n\n在某些情况下，我们可能希望**把模板片段传递给子组件，并让子组件在其自己的模板中渲染该片段**\n\n我们可能有一个支持这样使用的`<FancyButton>`组件：\n\n```html\n<-- 父组件 -->\n<FancyButton>\n  Click me! <!-- slot 内容 -->\n</FancyButton>\n```\n\n`<FancyButton>`模板，如下所示：\n\n```html\n<-- 子组件 -->\n<button class=\"fancy-btn\">\n  <slot></slot> <!-- slot 出口 -->\n</button>\n```\n\n该`<slot>`元素是一个插槽出口，指示应在何处呈现父级提供的插槽内容\n\n ![image-20231123164325387](http://kai.snblogs.cn/typora/image-20231123164325387.png)\n\n渲染结果:\n\n```html\n<button class=\"fancy-btn\">\n  Click me!\n</button>\n```\n\n通过使用*slot*，`<FancyButton>`可以灵活和可重用。我们可以在不同的地方使用它，具有不同的内部内容，但都具有相同的精美样式\n\n',2,117,367,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1180,'全局注册异步组件','与普通组件一样，异步组件可以使用`app.component()`**全局注册**\n\n```js\napp.component(''MyComponent'', defineAsyncComponent(() => import(''./components/MyComponent.vue'')))\n```\n\n',2,2,347,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1181,'组件自定义实现绑定','`<CustomInput>`组件内部需要做两件事：\n\n1. 将内部原生`<input>`元素的`value` attribute 绑定到`modelValue` prop\n2. 当原生的`input`事件触发时，触发一个携带了新值的`update:modelValue`自定义事件\n\n```vue\n<!-- CustomInput.vue -->\n<script setup>\ndefineProps([''modelValue''])\ndefineEmits([''update:modelValue''])\n</script>\n\n<template>\n  <input\n    :value=\"modelValue\"\n    @input=\"$emit(''update:modelValue'', $event.target.value)\"\n  />\n</template>\n```\n\n`v-model`可以在这个组件上正常工作了：\n\n```html\n<CustomInput v-model=\"searchText\" />\n```\n\n',2,3,621,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1182,'组件计算属性实现绑定','```vue\n<!-- CustomInput.vue -->\n<script setup>\nimport { computed } from ''vue''\n\nconst props = defineProps([''modelValue''])\nconst emit = defineEmits([''update:modelValue''])\n\nconst value = computed({\n  get() {\n    return props.modelValue\n  },\n  set(value) {\n    emit(''update:modelValue'', value)\n  }\n})\n</script>\n\n<template>\n  <input v-model=\"value\" />\n</template>\n```\n\n```html\nemit(''update:modelValue'',value)中参数value，数据类型是任意类型：字符串、数字、布尔值、以及数组、对象等。\n```\n\n',2,3,621,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1183,'组件中更新参数','默认情况下，`v-model`在组件上都是使用`modelValue`作为 prop，并以`update:modelValue`作为对应的事件。我们可以通过给`v-model`指定一个参数来更改这些名字：\n\n```html\n<MyComponent v-model:title=\"bookTitle\" />\n```\n\n在这个例子中，子组件应声明一个`title` prop，并通过触发`update:title`事件更新父组件值：\n\n```vue\n<!-- MyComponent.vue -->\n<script setup>\ndefineProps([''title''])\ndefineEmits([''update:title''])\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"title\"\n    @input=\"$emit(''update:title'', $event.target.value)\"\n  />\n</template>\n```\n\n',2,3,621,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1187,'创建自定义修饰符','它会自动将`v-model`绑定输入的字符串值第一个字母转为大写:\n\n```html\n<MyComponent v-model.capitalize=\"myText\" />\n```\n\n组件的`v-model`上所添加的修饰符，可以通过`modelModifiers` prop 在组件内访问到。在下面的组件中，我们声明了`modelModifiers`这个 prop，它的默认值是一个空对象：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\ndefineEmits([''update:modelValue''])\n\nconsole.log(props.modelModifiers) // { capitalize: true }\n</script>\n\n<template>\n  <input\n    type=\"text\"\n    :value=\"modelValue\"\n    @input=\"$emit(''update:modelValue'', $event.target.value)\"\n  />\n</template>\n```\n\n这里组件的`modelModifiers` prop 包含了`capitalize`且其值为`true`，因为它在模板中的`v-model`绑定`v-model.capitalize=\"myText\"`上被使用了。\n\n\n\n有了这个 prop，就可以检查`modelModifiers`对象的键，并编写一个处理函数来改变抛出的值。\n\n下面的代码里，每次`<input />`元素触发`input`事件时将值的首字母大写：\n\n```vue\n<script setup>\nconst props = defineProps({\n  modelValue: String,\n  modelModifiers: { default: () => ({}) }\n})\n\nconst emit = defineEmits([''update:modelValue''])\n\nfunction emitValue(e) {\n  let value = e.target.value\n  if (props.modelModifiers.capitalize) {\n    value = value.charAt(0).toUpperCase() + value.slice(1)\n  }\n  emit(''update:modelValue'', value)\n}\n</script>\n\n<template>\n  <input type=\"text\" :value=\"modelValue\" @input=\"emitValue\" />\n</template>\n```\n\n\n\n对于又有参数又有修饰符的`v-model`绑定，生成的 prop 名将是`arg +\"Modifiers\"`。举例来说：\n\n```html\n<MyComponent v-model:title.capitalize=\"myText\">\n```\n\n相应的声明应该是：\n\n```js\nconst props = defineProps([''title'', ''titleModifiers''])\ndefineEmits([''update:title''])\n\nconsole.log(props.titleModifiers) // { capitalize: true }\n```\n\n',2,3,621,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1188,'hooks基本用例','封装一个useMouse\n\n```js\n// mouse.js\nimport { ref, onMounted, onUnmounted } from ''vue''\n\n// 按照惯例，组合式函数名以“use”开头\nexport function useMouse() {\n  // 被组合式函数封装和管理的状态\n  const x = ref(0)\n  const y = ref(0)\n\n  // 组合式函数可以随时更改其状态。\n  function update(event) {\n    x.value = event.pageX\n    y.value = event.pageY\n  }\n\n  // 一个组合式函数也可以挂靠在所属组件的生命周期上\n  // 来启动和卸载副作用\n  onMounted(() => window.addEventListener(''mousemove'', update))\n  onUnmounted(() => window.removeEventListener(''mousemove'', update))\n\n  // 通过返回值暴露所管理的状态\n  return { x, y }\n}\n```\n\n它在组件中使用的方式：\n\n```vue\n<script setup>\nimport { useMouse } from ''./mouse.js''\n\nconst { x, y } = useMouse()\n</script>\n\n<template>Mouse position is at: {{ x }}, {{ y }}</template>\n```\n\n',2,146,761,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1189,'选项式中使用组合式函数','如果你正在使用选项式 API，组合式函数必须在`setup()`中调用。且其返回的绑定必须在`setup()`中返回，以便暴露给`this`及其模板：\n\n```vue\n<script>\nimport { useMouse } from ''./mouse.js''\nimport { useFetch } from ''./fetch.js''\n\nexport default {\n  setup() {\n    const { x, y } = useMouse()\n    const { data, error } = useFetch(''...'')\n    return { x, y, data, error }\n  },\n  mounted() {\n    // setup() 暴露的 property 可以在通过 `this` 访问到\n    console.log(this.x)\n  }\n  // ...其他选项\n}\n</script>\n```\n\n',2,146,762,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1190,'基于CSS过渡流程','有 6 个应用于进入与离开过渡效果的 CSS 类。\n\n1. `v-enter-from`：进入动画的起始状态。这个 CSS 类在元素插入之前添加，在元素插入完成后的下一帧移除。\n2. `v-enter-active`：进入动画的生效状态，应用于整个进入动画阶段。这个 CSS 类在元素被插入之前被添加，在过渡/动画完成之后移除。这个类可以用来定义进入动画的持续时间、延迟与速度曲线类型。\n3. `v-enter-to`：进入动画的结束状态。这个 CSS 类在元素插入完成后的下一帧被添加 (也就是 `v-enter-from` 被移除的同时)，在过渡/动画完成之后移除。\n4. `v-leave-from`：离开动画的起始状态，在离开过渡效果被触发时立即添加，在一帧后被移除。\n5. `v-leave-active`：离开动画的生效状态，应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡/动画完成之后移除。这个类可以用来定义离开动画的持续时间、延迟与速度曲线类型。\n6. `v-leave-to`：离开动画的结束状态。这个 CSS 类在一个离开动画被触发后的下一帧被添加 (也就是 `v-leave-from` 被移除的同时)，在过渡/动画完成之后移除。\n\n`v-enter-active` 和 `v-leave-active` 给了我们为进入和离开动画指定不同速度曲线的能力。',1,2,358,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1191,'为组件的prop标注类型','当使用`<script setup>`时，这个`defineProps()`宏函数支持从它的参数中**推导类型**：\n\n```vue\n<script setup lang=\"ts\">\nconst props = defineProps({\n  foo: { type: String, required: true },\n  bar: Number\n})\n\nprops.foo // string\nprops.bar // number | undefined\n</script>\n```\n\n这被称之为“**运行时声明**”，因为传递给`defineProps()`的参数会作为运行时的`props`选项使用。\n\n通过**泛型**参数来定义 prop 的类型通常更直接：\n\n```vue\n<script setup lang=\"ts\">\nconst props = defineProps<{\n    foo: string\n    bar?: number\n}>()\n</script>\n```\n\n也可以将 prop 的类型移入一个单独的**接口**中：\n\n```vue\n<script setup lang=\"ts\">\ninterface Props {\n  foo: string\n  bar?: number\n}\n\nconst props = defineProps<Props>()\n</script>\n```\n\n',2,2,764,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1192,'事件处理器标注类型','在处理原生 DOM 事件时，应该为我们传递给事件处理器的参数正确地标注类型。\n\n```vue\n<script setup lang=\"ts\">\nfunction handleChange(event) {\n  // `event` 隐式地标注为 `any` 类型\n  console.log(event.target.value)\n}\n</script>\n\n<template>\n  <input type=\"text\" @change=\"handleChange\" />\n</template>\n```\n\n没有类型标注时，这个event参数会隐式地标注为*any*类型。这也会在*tsconfig.json*中配置了`\"strict\": true`或`\"noImplicitAny\": true`时报出一个 TS 错误。因此，建议显式地为事件处理器的参数标注类型。此外，你可能需要显式地**强制类型转换**event上的 property：\n\n```js\nfunction handleChange(event: Event) {\n  console.log((event.target as HTMLInputElement).value)\n}\n```\n\n',2,2,175,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1193,'模板ref标注类型','模板`ref`需要通过一个显式指定的**泛型**参数和一个初始值`null`来创建：\n\n```vue\n<script setup lang=\"ts\">\nimport { ref, onMounted } from ''vue''\n\nconst el = ref<HTMLInputElement | null>(null)\n\nonMounted(() => {\n  el.value?.focus()\n})\n</script>\n\n<template>\n  <input ref=\"el\" />\n</template>\n```\n\n注意：为了严格的类型安全，有必要在访问el.value时使用**可选链**或**类型守卫**。这是因为直到组件被挂载前，这个 ref 的值都是初始的`null`，并且在由于`v-if`的行为将引用的元素卸载时，也可以被设置为`null`。\n\n',2,147,766,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1194,'图片压缩','安装 **vite-plugin-imagemin**\n\n```\nnpm i vite-plugin-imagemin -D\n```\n\n修改 vite.config.js 配置\n\n```js\nimport viteImagemin from \"vite-plugin-imagemin\"\n\nplugins: [vue(), viteImagemin()]\n```\n\n打包后会生成压缩的图片，但是每次打包都会重新压缩一遍，比较浪费时间，如果不介意的话采用此方案也很简单，网上查了一下有使用本地压缩的方案，不过配置比较繁琐，就自己写了个插件，后续会有文章单独介绍，敬请关注',9,152,768,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1195,'readonly()','接受一个对象（反应式或普通）或一个 ref 并返回一个只读代理到原来的。\n\n```js\nconst original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // works for reactivity tracking\n  console.log(copy.count)\n})\n\n// mutating original will trigger watchers relying on the copy\noriginal.count++\n\n// mutating the copy will fail and result in a warning\ncopy.count++ // warning!\n```\n\n',2,147,769,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1196,'控制台按键检测','1. 设置`Console.TreatControlCAsInput`为`true`，以防止按下Ctrl+C时程序终止。\n2. 输出提示信息，告诉用户按下组合键或按下Esc键退出。\n3. 使用`do-while`循环来等待用户按下键，并输出按下的键。\n4. 循环条件为按下的键不是Esc键。\n\n```csharp\npublic static void Main()\n{\n    ConsoleKeyInfo c;\n\n    // 防止按下Ctrl+C时程序终止\n    Console.TreatControlCAsInput = true;\n\n    Console.WriteLine(\"按下任意键与CTL、ALT和SHIFT的组合键，或按下Esc键退出：\\n\");\n\n    do {\n        c = Console.ReadKey();\n        Console.Write(\" - 按下的键是 \");\n\n        // 只输出按下的键\n        Console.WriteLine(c.Key.ToString());\n\n        // 退出条件\n    } while (c.Key != ConsoleKey.Escape);\n}\n```\n\n',1,112,28,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1197,'设置控制台光标X(水平)位置','`Console.CursorLeft`属性用于获取或设置控制台光标的水平位置。光标的位置是从控制台窗口的左上角开始计算的，水平位置从左到右递增。\n\n```csharp\nnamespace GFG {\n    class Program {\n        static void Main(string[] args) {\n            // 获取光标的水平位置\n            Console.WriteLine(\"当前光标的水平位置: {0}\", Console.CursorLeft);\n\n            // 设置光标的水平位置\n            Console.CursorLeft = 25;\n\n            // 获取光标的水平位置\n            Console.Write(\"当前光标的水平位置: {0};\", Console.CursorLeft);\n        }\n    }\n}\n\n```\n\n',1,112,771,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1198,'更改控制台缓冲区宽度','```csharp\nnamespace GFG {\n    class Program {\n        static void Main(string[] args) {\n            // 显示当前缓冲区宽度\n            Console.WriteLine(\"默认缓冲区宽度: {0}\", Console.BufferWidth);\n\n            // 将缓冲区宽度设置为100\n            Console.BufferWidth = 100;\n\n            // 显示更改后的缓冲区宽度\n            Console.WriteLine(\"更改后的缓冲区宽度: {0}\", Console.BufferWidth);\n        }\n    }\n}\n\n```\n\n',1,112,556,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1199,'更改控制台缓冲区高度','```csharp\nnamespace GFG {\n    class Program {\n        static void Main(string[] args) {\n            // 显示当前缓冲区高度\n            Console.WriteLine(\"默认缓冲区高度: {0}\", Console.BufferHeight);\n\n            // 将缓冲区高度设置为100\n            Console.BufferHeight = 100;\n\n            // 显示更改后的缓冲区高度\n            Console.WriteLine(\"更改后的缓冲区高度: {0}\", Console.BufferHeight);\n        }\n    }\n}\n\n```\n\n',1,112,556,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1200,'更改控制台背景颜色','```csharp\nnamespace GFG {\n    class Program {\n        static void Main(string[] args) {\n\n            // 显示当前的背景颜色\n            Console.WriteLine(\"默认背景颜色: {0}\",\n                              Console.BackgroundColor);\n\n            // 将背景颜色设置为蓝色\n            Console.BackgroundColor\n                = ConsoleColor.Blue;\n\n            // 显示当前的背景颜色\n            Console.WriteLine(\"更改后的背景颜色: {0}\",\n                              Console.BackgroundColor);\n        }\n    }\n}\n\n```\n\n',1,121,556,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1201,'更改光标大小','使用`Console.CursorSize`属性来获取和设置光标的大小。\n\n```csharp\nclass Program {\n\n    // Main方法\n    static void Main(string[] args)\n    {\n\n        // 获取光标大小\n        Console.WriteLine(\"当前光标大小: {0}\",\n                                Console.CursorSize);\n\n        // 设置光标大小\n        Console.CursorSize = 100;\n\n        // 获取光标大小\n        Console.Write(\"当前光标大小: {0}\",\n                            Console.CursorSize);\n    }\n}\n\n```\n\n',1,112,771,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1202,'更改控制台字体颜色','`Console.ForegroundColor`：控制台前景色属性，用于设置文本的颜色\n\n```csharp\n// 显示当前的前景色\nConsole.WriteLine(\"默认前景色: {0}\", Console.ForegroundColor);\n\n// 将前景色设置为蓝色\nConsole.ForegroundColor = ConsoleColor.Blue;\n\n// 显示当前的前景色\nConsole.WriteLine(\"更改后的前景色: {0}\", Console.ForegroundColor);\n```\n\n',1,112,776,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1203,'设置控制台光标TOP位置','`Console.CursorTop`属性用于获取或设置光标在控制台窗口中的垂直位置。默认情况下，光标的初始位置为0，即控制台窗口的顶部。\n\n```csharp\nclass Program {\n    static void Main(string[] args) {\n        // 获取光标的当前垂直位置\n        Console.WriteLine(\"当前光标的垂直位置: {0}\", Console.CursorTop);\n\n        // 设置光标的垂直位置为10\n        Console.CursorTop = 10;\n\n        // 获取光标的当前垂直位置\n        Console.Write(\"当前光标的垂直位置: {0};\", Console.CursorTop);\n    }\n}\n```\n\n',1,112,771,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1204,'控制台光标可见性','将`Console.CursorVisible`属性设置为`false`，以将光标设置为不可见\n\n```csharp\nclass Program {\n    static void Main(string[] args) {\n        // 获取当前光标可见性\n        Console.WriteLine(\"当前光标可见性: {0}\", Console.CursorVisible);\n\n        // 设置光标不可见\n        Console.CursorVisible = false;\n\n        // 获取当前光标可见性\n        Console.Write(\"当前光标可见性: {0}\", Console.CursorVisible);\n    }\n}\n\n```\n\n',1,112,771,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1205,'设置窗口高度值','使用`Console.WindowHeight`属性来获取和设置控制台窗口的高度\n\n```csharp\nclass Program {\n\n    static void Main(string[] args)\n    {\n\n        // 获取当前窗口高度\n        Console.WriteLine(\"当前窗口高度: {0}\",\n                                Console.WindowHeight);\n\n        // 设置窗口高度为50\n        Console.WindowHeight = 50;\n\n        // 获取当前窗口高度\n        Console.Write(\"当前窗口高度: {0}\",\n                            Console.WindowHeight);\n    }\n}\n\n```\n\n',1,112,779,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1206,'设置窗口宽度的值','使用`Console.WindowWidth`属性，我们可以获取当前控制台窗口的宽度，并且还可以通过设置该属性来更改窗口的宽度。\n\n```csharp\nclass Program {\n\n    static void Main(string[] args)\n    {\n\n        // 获取当前窗口宽度\n        Console.WriteLine(\"当前窗口宽度: {0}\",\n                                Console.WindowWidth);\n\n        // 设置窗口宽度为150\n        Console.WindowWidth = 150;\n\n        // 获取当前窗口宽度\n        Console.Write(\"当前窗口宽度: {0}\",\n                            Console.WindowWidth);\n    }\n}\n\n```\n\n',1,121,780,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1207,'设置控制台吧标题','```csharp\nConsole.Title = \"GeeksForGeeks\";\n```\n\n',1,112,781,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1208,'SortedSet','存储唯一元素的集合\n\n```csharp\nclass test {\n\n    // Driver code\n    public static void Main()\n    {\n        // 创建一个整数类型的SortedSet对象\n        SortedSet<int> mySortedSet1 = new SortedSet<int>();\n\n        // 向mySortedSet1中添加元素\n        mySortedSet1.Add(2);\n        mySortedSet1.Add(4);\n        mySortedSet1.Add(6);\n        mySortedSet1.Add(8);\n        mySortedSet1.Add(10);\n\n        // 创建一个整数类型的SortedSet对象\n        SortedSet<int> mySortedSet2 = new SortedSet<int>();\n\n        // 向mySortedSet2中添加元素\n        mySortedSet2.Add(4);\n        mySortedSet2.Add(5);\n        mySortedSet2.Add(7);\n        mySortedSet2.Add(8);\n        mySortedSet2.Add(9);\n\n        Console.WriteLine(\"mySortedSet1和mySortedSet2的交集:\");\n\n        // 计算mySortedSet1和mySortedSet2的交集\n        mySortedSet1.IntersectWith(mySortedSet2);\n\n        // 遍历交集并打印结果\n        foreach(int i in mySortedSet1)\n        {\n            Console.WriteLine(i);\n        }\n    }\n}\n\n```\n\n\n\n',1,134,782,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1209,'StringCollection','StringCollection类是一个可变大小的字符串集合，它可以动态地添加、删除和访问字符串。它是一个有序的集合，可以通过索引访问其中的元素。StringCollection类提供了一些常用的方法，如Add、Remove、Clear等，用于操作集合中的字符串\n\n- StringCollection 接受 `null` 作为有效值，并允许重复元素。\n- 字符串比较区分大小写\n- 可以使用整数索引访问此集合中的元素。 此集合中的索引从零开始\n\n```csharp\nusing System;\nusing System.Collections.Specialized;\n\nnamespace MyNamespace\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            // 创建一个StringCollection对象\n            StringCollection stringCollection = new StringCollection();\n\n            // 添加字符串到集合中\n            stringCollection.Add(\"Hello\");\n            stringCollection.Add(\"World\");\n\n            // 遍历集合中的字符串并打印\n            foreach (string str in stringCollection)\n            {\n                Console.WriteLine(str);\n            }\n        }\n    }\n}\n```\n\n',1,134,783,4,1,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1210,'StringDictionary','用于存储字符串键和字符串值的集合。可以认为是类似于 Dictionary<string, string> 的键值对集合\n\n- 键不能为 `null` ，但值可以为null。\n- 键不区分大小写 , 键不能重复【\"ABC\"和\"abc\"认为是同一个键】\n- 通过键key来访问\n\n```csharp\n// Driver code\npublic static void Main()\n{\n\n    // 创建一个名为myDict的StringDictionary对象\n    StringDictionary myDict = new StringDictionary();\n\n    // 向StringDictionary对象中添加键值对\n    myDict.Add(\"A\", \"Apple\"); // 添加键值对\"A\"和\"Apple\"\n    myDict.Add(\"B\", \"Banana\"); // 添加键值对\"B\"和\"Banana\"\n    myDict.Add(\"C\", \"Cat\"); // 添加键值对\"C\"和\"Cat\"\n    myDict.Add(\"D\", \"Dog\"); // 添加键值对\"D\"和\"Dog\"\n\n    // 将StringDictionary对象的键复制到一个字符串数组中\n    String[] myKeys = new String[myDict.Count];\n    myDict.Keys.CopyTo(myKeys, 0);\n\n    // 遍历StringDictionary对象，输出键和对应的值\n    for (int i = 0; i < myDict.Count; i++) {\n        Console.WriteLine(myKeys[i] + \" \" + myDict[myKeys[i]]);\n    }\n}\n\n```\n\n',1,134,784,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1211,'OrderedDictionary','有序字典（OrderedDictionary）：有序字典是一种特殊的字典，它可以按照插入顺序来迭代元素。与普通字典不同，有序字典可以保持元素的插入顺序。\n\n```csharp\nusing System;\nusing System.Collections;\n\nclass Program\n{\n    static void Main()\n    {\n        // 创建一个有序字典\n        OrderedDictionary orderedDictionary = new OrderedDictionary();\n\n        // 向有序字典中添加元素\n        orderedDictionary.Add(\"key1\", \"value1\");\n        orderedDictionary.Add(\"key2\", \"value2\");\n        orderedDictionary.Add(\"key3\", \"value3\");\n\n        // 遍历有序字典并输出键值对\n        foreach (DictionaryEntry entry in orderedDictionary)\n        {\n            Console.WriteLine(\"Key: \" + entry.Key + \", Value: \" + entry.Value);\n        }\n    }\n}\n```\n\n',1,154,785,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1212,'Dictionary','字典是一种键值对的集合，其中每个键都是唯一的。通过键可以快速查找对应的值\n\n- Dictionary里面的每一个元素都是一个键值对（由二个元素组成：键和值）\n- 键必须是唯一的,而值不需要唯一的\n- 键和值都可以是任何类型(比如：string, int, 自定义类型等等)\n- 字典是线程不安全的，如果需要线程安全，需要自己加锁。\n\n```csharp\nstatic void Main(string[] args)\n{\n	// 1.定义\n 	// Key和Value可以是任意类型\n 	Dictionary<int, string> _testDic = new Dictionary<int, string>();\n\n 	// 2.添加元素\n	 _testDic.Add(24, \"Canon\");\n 	// 注意相同相同Key值只能Add一次\n 	 _testDic.Add(24, \"Jason\");// 报错：System.ArgumentException:“已添加了具有相同键的项。”\n 	// 可以使用ContainsKey判断字典中是否已经存在\n 	if (!_testDic.ContainsKey(24))  _testDic.Add(24, \"Canon\");\n\n 	// 3.删除元素\n 	// Remove 删除不存在的值不会报错\n 	_testDic.Remove(24);\n\n 	// 4.取值\n 	// 索引器取值，若字典中没有Key会报错\n 	string str = _testDic[24];\n	// TryGetValue 取值成功返回true,内部对str赋值，否则返回false\n 	bool isExist = _testDic.TryGetValue(24, out str);\n\n 	// 5.改值\n 	// 要确保字典中确实存在该值\n 	if (_testDic.ContainsKey(1))  _testDic[1] = \"\";\n\n 	// 6.遍历\n 	// Key\n 	foreach (var key in _testDic.Keys) Console.WriteLine(\"Key = {0}\", key);\n 	// Value\n 	foreach (var value in _testDic.Values) Console.WriteLine(\"value = {0}\", value);\n 	// foreach遍历\n 	foreach (var kvp in _testDic) Console.WriteLine(\"Key = {0}, Value = {1}\", kvp.Key, kvp.Value);\n 	// 迭代器遍历\n 	var enumerator = _testDic.GetEnumerator();\n 	while (enumerator.MoveNext())\n 	{\n 		var kvp = enumerator.Current;\n 		Console.WriteLine(\"Key = {0}\", kvp.Key);\n 		Console.WriteLine(\"Key = {0}\", kvp.Value);\n 	}\n            \n 	// 7.清空\n 	_testDic.Clear();\n}\n```\n\n',1,154,786,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1213,'接口参数校验','入参出参校验是程序员必备的基本素养。设计的接口，必须先校验参数。比如入参是否允许为空，入参长度是否符合你的预期长度。日常开发中，很多低级bug都是不校验参数导致的。\n\n出参也是，比如你定义的接口报文，参数是不为空的，但是你的接口返回参数，没有做校验，因为程序某些原因，直接返回别人一个`null`值。。。',1,156,811,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1214,'修改老接口注意接口的兼容性','很多bug都是因为修改了对外旧接口，但是却**不做兼容**导致的。关键这个问题多数是比较严重的，可能直接导致系统发版失败的。\n\n```csharp\n//老接口\nvoid oldService(A,B){\n  //兼容新接口，传个null代替C\n  newService(A,B,null);\n}\n\n//新接口，暂时不能删掉老接口，需要做兼容。\nvoid newService(A,B,C){\n  ...\n}\n```\n\n',1,156,812,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1215,'使用委托监听方法','监听按键测试的方法`ButtonTest`。该方法接受一个方法参数和一个字符串参数，并执行按键测试操作\n\n```csharp\n/// <summary>\n/// 下指令按键测试\n/// </summary>\n/// <param name=\"func\">传入方法, _button.ButtonTest(() =&gt; BtnTest(\"0x01\"), \"请按Teams键\")) </param>\n/// <param name=\"name\">按键操作对应窗口名</param>\n/// <returns></returns>\npublic bool ButtonTest(Func < bool > func, string name)\n{\n    var flag = true;\n    //用于监控按键操作\n    var buttonMonitor = Task.Run(() =>\n    {\n        Thread.Sleep(50);\n        while(flag)\n        {\n            if(func.Invoke())\n            {   \n                // 如果返回值为true，则设置msgbox的DialogResult为OK\n                msgbox.DialogResult = DialogResult.OK;\n            }\n            Thread.Sleep(100);\n        }\n    });\n    var result = ProgressBarsBox(name);\n    flag = false;\n    return result;\n}\n```\n\n```csharp\n_button.ButtonTest(() =&gt; BtnTest(\"0x01\")\n```',1,157,813,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1216,'FormClosing','当窗口关闭时，它会引发两个事件：Closing 和 Closed。\n\nClosing 在窗口关闭之前引发， 系统会向Closing 事件处理程序传递一个 FormClosingEventArgs e，该参数实现 Boolean Cancel 属性，将该属性设置为 true 可以阻止窗口关闭。\n\n在事件中提示并关闭资源\n\n```csharp\nif(MessageBox.Show(\"是否关闭？\", \"关闭\", MessageBoxButtons.OKCancel, MessageBoxIcon.Question) == DialogResult.OK)\n{\n    // 关闭所有的线程\n    this.Dispose();\n    this.Close();\n    Application.Exit();\n}\nelse\n{\n    e.Cancel = true; ////不关闭窗口\n}\n```\n\n取消退出\n\n```csharp\ne.Cancel = true;\n```',1,130,814,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20'),
(1217,'FormClosed','FormClosed事件 是在 关闭窗体后发生，可以在该事件中处理保存窗口的一些信息等操作，不能取消窗口关闭。\n\n在窗口真正关闭之前，会引发 Closed，这时无法阻止窗口关闭。\n\n```csharp\nprivate void Form2_FormClosed(object sender, FormClosingEventArgs e)\n{\n  Application.Exit();\n}\n```\n\n',1,130,814,4,0,'2021-11-13 03:18:20','2021-11-13 03:18:20');
/*!40000 ALTER TABLE `snippet` ENABLE KEYS */;

-- 
-- Definition of user
-- 

DROP TABLE IF EXISTS `user`;
CREATE TABLE IF NOT EXISTS `user` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `ip` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT 'ip地址',
  `name` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '账号',
  `email` varchar(30) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '邮箱',
  `pwd` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '密码',
  `photo` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '头像',
  `time_create` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
  `time_modified` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `nickname` varchar(20) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '称呼',
  `brief` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '简介',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=19 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table user
-- 

/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user`(`id`,`ip`,`name`,`email`,`pwd`,`photo`,`nickname`,`brief`) VALUES
(1,'','1','81929392@qq.con','1','','测试号','哈哈'),
(4,'','kai','851039536@qq.com','woshishui','..','少年','人生有梦,各自精彩'),
(18,'','admin123','admin12','admin123','131232','测试角色','213123');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;

-- 
-- Definition of user_talk
-- 

DROP TABLE IF EXISTS `user_talk`;
CREATE TABLE IF NOT EXISTS `user_talk` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_id` int DEFAULT NULL,
  `text` text CHARACTER SET utf8mb4 COLLATE utf8mb4_bin COMMENT '说说内容',
  `time_create` datetime DEFAULT NULL COMMENT '发表时间',
  `read` int DEFAULT NULL,
  `give` int DEFAULT NULL,
  `comment_id` int DEFAULT NULL COMMENT '评论id',
  PRIMARY KEY (`id`) USING BTREE,
  KEY `sn_user_talk_userId` (`user_id`) USING BTREE,
  CONSTRAINT `user_talk_userId` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=45 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table user_talk
-- 

/*!40000 ALTER TABLE `user_talk` DISABLE KEYS */;
INSERT INTO `user_talk`(`id`,`user_id`,`text`,`time_create`,`read`,`give`,`comment_id`) VALUES
(12,4,'omorrow is always fresh, with no mistakes in it. 明天始终崭新，无错可言。','2020-10-19 00:00:00',0,0,0),
(13,4,'人生有梦,各自精彩','2020-10-19 00:00:00',0,0,0),
(15,4,'Sometimes you have to sacrifice to do the right thing. 有时候，为了做成正确的事，你必须付出代价。','2020-10-20 00:00:00',0,0,0),
(16,4,'我就是这样,就是和你不一样','2020-10-23 00:00:00',0,0,0),
(17,4,'A brave man never surrenders. 勇者永不屈服。','2020-10-27 00:00:00',0,0,0),
(18,4,'The strongest person is the person who isn''t scared to be alone. 强大的人不会惧怕孤独。','2020-11-11 00:00:00',0,0,0),
(19,4,'Real love is always worth waiting for. 真爱永远值得等待。','2020-11-24 00:00:00',0,0,0),
(20,4,'“嗨，同志！您知道列宁格勒和斯大林格勒在哪吗？我在地图上找不到它。” “没有了，再也没有了，我们失败了，白匪和资本家再一次骑到了我们的头上，如果你要追随那颗红星，去东方吧，穿越第聂伯河，翻过乌拉尔山脉，西伯利亚平原的尽头，那里还燃烧着星星之火。”','2020-12-26 00:00:00',0,0,0),
(33,4,'失眠了,那就熬夜吧','2023-08-02 11:12:45',0,0,0),
(34,4,'测试','2023-08-02 11:38:47',0,0,0),
(35,4,'呃呃是二手厄尔','2023-08-02 11:39:00',0,0,0),
(36,4,'报错了吗!','2023-08-02 11:39:10',0,0,0),
(37,4,'12345678908765432134567897654321','2023-08-02 11:39:18',0,0,0),
(38,4,'测试一下','2023-08-02 11:43:49',0,0,0),
(39,4,'改数据库,人都要改麻了!','2023-08-07 12:12:53',0,0,0),
(40,4,'这个地方,没有希望','2023-08-09 08:35:54',0,0,0),
(41,4,'少说少错','2023-08-10 14:37:38',0,0,0),
(42,4,'劳动者并不反感加班，而是反感，无偿，无意义，无收获的加班','2023-08-11 09:10:08',0,0,0),
(43,4,'缓慢进步!','2023-08-16 14:24:04',0,0,0),
(44,4,'躁躁躁躁！','2024-05-30 16:27:54',0,0,0);
/*!40000 ALTER TABLE `user_talk` ENABLE KEYS */;

-- 
-- Definition of video
-- 

DROP TABLE IF EXISTS `video`;
CREATE TABLE IF NOT EXISTS `video` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '标题',
  `img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '图片',
  `url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL COMMENT '链接路径',
  `type_id` int NOT NULL COMMENT '分类',
  `user_id` int NOT NULL,
  `time_create` datetime NOT NULL COMMENT '时间',
  `time_modified` datetime NOT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  KEY `video_type_id` (`type_id`) USING BTREE,
  KEY `video_user_id` (`user_id`) USING BTREE,
  CONSTRAINT `video_type_id` FOREIGN KEY (`type_id`) REFERENCES `sn_video_type` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `video_user_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE=InnoDB AUTO_INCREMENT=39 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin ROW_FORMAT=DYNAMIC;

-- 
-- Dumping data for table video
-- 

/*!40000 ALTER TABLE `video` DISABLE KEYS */;
INSERT INTO `video`(`id`,`name`,`img`,`url`,`type_id`,`user_id`,`time_create`,`time_modified`) VALUES
(25,'我们的故事，英雄联盟！','https://s1.ax1x.com/2020/11/11/BX2acT.png','//player.bilibili.com/player.html?aid=45028887&bvid=BV1zb411b7JK&cid=78863318&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(26,'故事开始的地方——为你的本命献上弹幕吧！','https://s1.ax1x.com/2020/11/11/BX2N90.jpg','//player.bilibili.com/player.html?aid=25180028&bvid=BV18s411j7CL&cid=42677566&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(27,'用战斗来祭奠这个世界 ！！','https://s1.ax1x.com/2020/11/11/BX2BB4.jpg','//player.bilibili.com/player.html?aid=1328701&bvid=BV1px411N7Yd&cid=2015358&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(28,'前方高能！让世界感受这场视觉盛宴吧！','https://s1.ax1x.com/2020/11/11/BX20uF.jpg','//player.bilibili.com/player.html?aid=50331935&bvid=BV1x441187u5&cid=92865323&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(29,'这才是忍者世界的巅峰战力！','https://s1.ax1x.com/2020/11/11/BX2U3V.jpg','//player.bilibili.com/player.html?aid=71840112&bvid=BV1HE41167kR&cid=124483833&page=1',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(30,'这个故事 还没有完结','https://s1.ax1x.com/2020/11/11/BX2JNn.jpg','//player.bilibili.com/player.html?aid=66382748&bvid=BV1J441117u7&cid=115130259&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(31,'感受国服配音的魅力吧！ 你的热血从未结霜！！','https://s1.ax1x.com/2020/11/11/BX2Yhq.jpg','//player.bilibili.com/player.html?aid=18767799&bvid=BV1WW411e7wq&cid=30610512&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(32,'敌人虽众，一击皆斩！','https://s1.ax1x.com/2020/11/11/BX2JNn.jpg','//player.bilibili.com/player.html?aid=22446917&bvid=BV1SW41157WM&cid=37190046&page=1',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(33,'【英雄联盟/CG/燃向】 召唤师 如果没有你们 何为英雄 何为联盟','https://s3.ax1x.com/2020/11/13/Dpmoee.jpg','//player.bilibili.com/player.html?aid=78147108&bvid=BV1fJ411v7Q6&cid=133666781&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(34,'【超燃巨作/视听盛宴】我...已被这优雅蒙蔽了双眼... 「英雄联盟系列混剪」','https://s3.ax1x.com/2020/11/13/DpnyX8.jpg','//player.bilibili.com/player.html?aid=49445129&bvid=BV1gb411j7r4&cid=86578090&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(35,'那不屈的嘶吼和永不低头的信念使我们迎难而上','https://s3.ax1x.com/2020/11/13/Dputg0.png','//player.bilibili.com/player.html?aid=49661297&bvid=BV1ib41157zQ&cid=86951456&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(36,'这就是英雄联盟的魅力！','https://s3.ax1x.com/2020/11/13/DpKDL8.jpg','//player.bilibili.com/player.html?aid=47199816&bvid=BV1nb41147HD&cid=82660090&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',2,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(37,'【火影忍者百万填词】一袋米要扛几楼','https://s3.ax1x.com/2020/11/13/DpQAN4.jpg','//player.bilibili.com/player.html?aid=56970467&bvid=BV1Px411d7em&cid=99503508&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00'),
(38,'『忍び的时代真的结束了吗？』让鸡皮疙瘩和肾上腺素','https://s3.ax1x.com/2020/11/13/DpQxaD.png','//player.bilibili.com/player.html?aid=81848177&bvid=BV1HJ411j771&cid=140045131&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"',1,4,'2020-07-28 00:00:00','2020-07-28 00:00:00');
/*!40000 ALTER TABLE `video` ENABLE KEYS */;


/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;


-- Dump completed on 2024-05-31 19:06:35
-- Total time: 0:0:0:0:283 (d:h:m:s:ms)
